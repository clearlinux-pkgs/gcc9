Alex Coplan (1):
      arm: Fix ICEs with compare-and-swap and -march=armv8-m.base [PR99977]

Andrew Pinski (1):
      [GCC 10 branch] tree-optimization: [PR102622]: wrong code due to signed one bit integer and "a?-1:0"

Bill Schmidt (3):
      rs6000: Don't let swaps pass break multiply low-part (PR101129)
      rs6000: Add int128 target check to pr101129.c (PR101531)
      rs6000: Fix vec_cpsgn parameter order (PR101985)

Christophe Lyon (1):
      arm: Fix pr69245.c testcase for reorder assembler architecture directives [PR101723]

Diane Meirowitz (1):
      doc: improve -fsanitize=undefined description

Eric Botcazou (6):
      Fix internal error on pointer-to-pointer binding in LTO mode
      Fix inaccurate bounds in debug info for vector array types
      Fix PR rtl-optimization/102306
      Update documentation of %X spec
      Properly enable -freorder-blocks-and-partition on 64-bit Windows
      Fix internal error with vectorization on SPARC

Fritz Reese (1):
      fortran: Fix conv of UNION constructors [PR105310]

GCC Administrator (341):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

H.J. Lu (2):
      x86: Document -fcf-protection requires i686 or newer
      libsanitizer: Cherry-pick LLVM release/13.x commit d96358a28193

Harald Anlauf (18):
      Fortran - ICE in inline_matmul_assign
      Fortran - ICE in gfc_conv_expr_present initializing non-dummy class variable
      Fortran - fix handling of optional allocatable DT arguments with INTENT(OUT)
      Fortran - fix handling of substring start and end indices
      Fortran - ensure simplification of bounds of array-valued named constants
      Fortran - out of bounds in array constructor with implied do loop
      Fortran - improve error recovery determining array element from constructor
      Fortran: do not attempt simplification of [LU]BOUND for pointer/allocatable
      Fortran: perform array subscript checks only for valid INTEGER bounds
      Fortran: prevent NULL pointer dereference in check of passed do-loop variable
      Fortran: fix checking of elemental functions of type CLASS
      Fortran: dimensions of an array have to be non-negative
      Fortran: catch failed simplification of bad stride expression
      Fortran: PACK intrinsic should not try to read from zero-sized array
      Fortran: fix ICE overloading elemental intrinsics
      Fortran: MOLD argument to TRANSFER intrinsic having storage size zero
      Fortran: fix simplification of TRANSFER for zero-sized character array result
      Fortran: reject simplifying TRANSFER for MOLD with storage size 0

Hongyu Wang (1):
      AVX512F: Add missing macro for mask(z?)_scalf_s[sd] [PR 105339]

Iain Buclaw (18):
      d: Fix ICE in gimplify_var_or_parm_decl, at gimplify.c:2755 (PR100882)
      d: Respect explicit align(N) type alignment (PR100935)
      d: TypeInfo error when using slice copy on Structs (PR100964)
      PR d/90651 (ICE in FuncDeclaration::semantic3, at d/dmd/func.c:1524)
      d: Fix ICE in TypeInfoDeclaration, at dmd/declaration.c (PR100967)
      d: Compile-time reflection for supported built-ins (PR101127)
      d: __FUNCTION__ doesn't work in core.stdc.stdio functions without cast (PR101441)
      d: fix ICE at convert_expr(tree_node*, Type*, Type*) (PR101490)
      d: Wrong evaluation order of binary expressions (PR101640)
      d: Ensure casting from bool results in either 0 or 1 (PR96435)
      d: gdc driver ignores -static-libstdc++ when automatically linking libstdc++ library
      d: Use HOST_WIDE_INT for type size temporaries.
      libphobos: Don't call __gthread_key_delete in the emutls destroy function.
      libphobos: Increase size of defaultStackPages on OSX X86_64 targets.
      d: Align methods to MINIMUM_METHOD_BOUNDARY.
      libphobos: Fix definition of stat_t for MIPS64 (PR103604)
      libphobos: Don't call free on the TLS array in the emutls destroy function.
      libphobos: Give _Unwind_Exception an alignment that best resembles __attribute__((aligned))

Jakub Jelinek (84):
      openmp: Fix up taskloop reduction ICE if taskloop has no iterations [PR100471]
      expand: Don't reuse DEBUG_EXPRs with vector type if they have different modes [PR100508]
      testsuite: Add testcase for already fixed PR
      c++: Avoid -Wunused-value false positives on nullptr passed to ellipsis [PR100666]
      x86: Fix ix86_expand_vector_init for V*TImode [PR100887]
      tree-inline: Fix up __builtin_va_arg_pack handling [PR100898]
      expr: Fix up VEC_PACK_TRUNC_EXPR expansion [PR101046]
      libffi: Fix up x86_64 classify_argument
      testsuite: Use noipa attribute instead of noinline, noclone
      stor-layout: Create DECL_BIT_FIELD_REPRESENTATIVE even for bitfields in unions [PR101062]
      stor-layout: Don't create DECL_BIT_FIELD_REPRESENTATIVE for QUAL_UNION_TYPE [PR101062]
      inline-asm: Fix ICE with bitfields in "m" operands [PR100785]
      openmp: Fix up *_reduction clause handling with UDRs on PARM_DECLs [PR101167]
      c: Fix C cast error-recovery [PR101171]
      c: Fix up c_parser_has_attribute_expression [PR101176]
      match.pd: Avoid (intptr_t)x eq/ne CST to x eq/ne (typeof x) CST opt in GENERIC when sanitizing [PR101210]
      dwarf2out: Handle COMPOUND_LITERAL_EXPR in loc_list_from_tree_1 [PR101266]
      libgomp: Don't include limits.h instead of hidden visibility block
      godump: Fix -fdump-go-spec= reproduceability issue [PR101407]
      c++: Optimize away NULLPTR_TYPE comparisons [PR101443]
      openmp - Fix up && and || reductions [PR94366]
      rs6000: Fix up easy_vector_constant_msb handling [PR101384]
      c++: Ensure OpenMP reduction with reference type references complete type [PR101516]
      openmp: Fix up omp_check_private [PR101535]
      expmed: Fix store_integral_bit_field [PR101562]
      ubsan: Fix ICEs with DECL_REGISTER tests [PR101624]
      dwarf2out: Emit DW_AT_location for global register vars during early dwarf [PR101905]
      i386: Fix up @xorsign<mode>3_1 [PR102224]
      c++: Fix __is_*constructible/assignable for templates [PR102305]
      c++: Update DECL_*SIZE for objects with flexible array members with initializers [PR102295]
      c++: Fix handling of decls with flexible array members initialized with side-effects [PR88578]
      i386: Don't emit fldpi etc. if -frounding-math [PR102498]
      ubsan: Use -fno{,-}sanitize=float-divide-by-zero for float division by zero recovery [PR102515]
      c++: Fix apply_identity_attributes [PR102548]
      openmp: Fix up handling of OMP_PLACES=threads(1)
      c++: Don't reject calls through PMF during constant evaluation [PR102786]
      openmp: For default(none) ignore variables created by ubsan_create_data [PR64888]
      dwarf2out: Fix up field_byte_offset [PR101378]
      i386: Fix up x86 atomic_bit_test* expanders for !TARGET_HIMODE_MATH [PR103205]
      lim: Reset flow sensitive info even for pointers [PR103192]
      c++: Fix up -fstrong-eval-order handling of call arguments [PR70796]
      fortran, debug: Fix up DW_AT_rank [PR103315]
      bswap: Fix UB in find_bswap_or_nop_finalize [PR103435]
      loop-invariant: Fix -fcompare-debug failure [PR103837]
      shrink-wrapping: Fix up prologue block discovery [PR103860]
      libcpp: Fix up ##__VA_OPT__ handling [PR89971]
      ifcvt: Check for asm goto at the end of then_bb/else_bb in ifcvt [PR103908]
      match.pd, optabs: Avoid vectorization of {FLOOR,CEIL,ROUND}_{DIV,MOD}_EXPR [PR102860]
      optabs: Don't create pseudos in prepare_cmp_insn when not allowed [PR102478]
      libcpp: Avoid PREV_WHITE and other random content on CPP_PADDING tokens
      libcpp: Fix up padding handling in funlike_invocation_p [PR104147]
      libgomp: Fix segfault with posthumous orphan tasks [PR104385]
      rs6000: Fix up vspltis_shifted [PR102140]
      combine: Fix ICE with substitution of CONST_INT into PRE_DEC argument [PR104446]
      c++: Fix up constant expression __builtin_convertvector folding [PR104472]
      i386: Fix up cvtsd2ss splitter [PR104502]
      asan: Fix up address sanitizer instrumentation of __builtin_alloca* if it can throw [PR104449]
      c++: Don't reject GOTO_EXPRs to cdtor_label in potential_constant_expression_1 [PR104513]
      openmp: Make finalize_task_copyfn order reproduceable [PR104517]
      sanitizer: Use glibc _thread_db_sizeof_pthread symbol if present
      c-family: Fix up shorten_compare for decimal vs. non-decimal float comparison [PR104510]
      valtrack: Avoid creating raw SUBREGs with VOIDmode argument [PR104557]
      libiberty: Fix up debug.temp.o creation if *.o has 64K+ sections [PR104617]
      match.pd: Don't create BIT_NOT_EXPRs for COMPLEX_TYPE [PR104675]
      rs6000: Use rs6000_emit_move in movmisalign<mode> expander [PR104681]
      match.pd: Further complex simplification fixes [PR104675]
      s390: Fix up *cmp_and_trap_unsigned_int<mode> constraints [PR104775]
      c++: Don't suggest cdtor or conversion op identifiers in spelling hints [PR104806]
      c, c++, c-family: -Wshift-negative-value and -Wshift-overflow* tweaks for -fwrapv and C++20+ [PR104711]
      i386: Don't emit pushf;pop for __builtin_ia32_readeflags_u* with unused lhs [PR104971]
      c++: extern thread_local declarations in constexpr [PR104994]
      c++: Fix up __builtin_convertvector parsing
      ubsan: Fix ICE due to -fsanitize=object-size [PR105093]
      i386: Fix up ix86_expand_vector_init_general [PR105123]
      combine: Don't record for UNDO_MODE pointers into regno_reg_rtx array [PR104985]
      fold-const: Fix up make_range_step [PR105189]
      c-family: Initialize ridpointers for __int128 etc. [PR105186]
      builtins: Fix up expand_builtin_int_roundingfn_2 [PR105211]
      i386: Fix ICE caused by ix86_emit_i387_log1p [PR105214]
      c++: Fix up CONSTRUCTOR_PLACEHOLDER_BOUNDARY handling [PR105256]
      sparc: Preserve ORIGINAL_REGNO in epilogue_renumber [PR105257]
      asan: Fix up asan_redzone_buffer::emit_redzone_byte [PR105396]
      testsuite: Fix up pr102860.f90 for gcc 9 [PR105570]
      re PR c++/67184 (Missed optimization with C++11 final specifier)

Jan Hubicka (1):
      Fix looping flag discovery in ipa-pure-const

Jason Merrill (20):
      c++: fix testcases
      c++: alias template equivalence and cv-quals [PR100032]
      c++: constexpr, inheritance, and local class [PR91933]
      c++: access checking in aggregate initialization [PR96673]
      c++: -Wunused, constant, and generic lambda [PR96311]
      c++: lambda in DMI in class template [PR95870]
      c++: PMF template parm and noexcept [PR90664]
      c++: nested generic lambda in DMI [PR101717]
      c++: C++17 constexpr static data member linkage [PR99901]
      c++: assignment to temporary [PR59950]
      c++: constexpr trivial -fno-elide-ctors [PR104646]
      c++: operator new lookup [PR98249]
      c++: NRV and ref-extended temps [PR101442]
      c++: template conversion op [PR101698]
      c++: alignment of local typedef in template [PR65211]
      c++: array new initialized from a call [PR99643]
      c++: NRV in lambda in template [PR91217]
      c++: missing dtor with -fno-elide-constructors [PR100838]
      c++: extern template and static data member [PR99066]
      c++: static memfn from non-dependent base [PR101078]

John David Anglin (5):
      Add support for 32-bit hppa targets in muldi3 expander
      Fix TARGET_SOFT_FLOAT patterns in pa.md
      Consistently use "rG" constraint for copy instruction in move patterns
      Don't use 'G' constraint in integer move patterns
      Fix warnings building linux-atomic.c and fptr.c on hppa64-linux

Jonathan Wakely (44):
      libstdc++: Fix find_type helper to work consistently
      libstdc++: Simplify constexpr checks in std::char_traits [PR 91488]
      libstdc++: Reject std::make_shared<T[]> [PR 99006]
      libstdc++: Do not use deduced return type for std::visit [PR 100384]
      libstdc++: Fix filesystem::path constraints for volatile [PR 100630]
      libstdc++: Replace incorrect static assertion in std::reduce [PR95833]
      libstdc++: Fix constraint on std::optional assignment [PR 100982]
      libstdc++: Fix constructor constraints for std::any  (PR 90415)
      libstdc++: Fix std::any constraints [PR101034]
      libstdc++: Move atomic functions to libsupc++ [PR 96657]
      libstdc++: Fix test failure in C++20 mode
      libstdc++: Re-enable workaround for _wstat64 bug [PR 88881]
      libstdc++: Re-enable workaround for _wstat64 bug, again [PR 88881]
      libstdc++: Add more tests for filesystem::create_directory [PR101510]
      libstdc++: Fix create_directories to resolve symlinks [PR101510]
      libstdc++: Fix test that fails randomly [PR101866]
      c++: Fix docs on assignment of virtual bases [PR60318]
      libstdc++: Fix std::match_results::end() for failed matches [PR102667]
      libstdc++: Clear up directories created by tests
      libstdc++: Install GDB pretty printers for debug library
      libstdc++: Add pretty printer for std::error_code and std::error_condition
      libstdc++: std::system_category should know meaning of zero [PR102425]
      libstdc++: Remove non-deducible parameter for std::advance overload
      libstdc++: Rename tests with incorrect extension
      libstdc++: Rename file with the wrong extension
      libstdc++: Fix range access for empty std::valarray [PR103022]
      libstdc++: Fix circular dependency for bitmap_allocator [PR103381]
      aarch64: Fix mismatched extern "C" block [PR100985]
      libstdc++: Deprecate __gnu_cxx::rope::erase(size_type) [PR102048]
      libstdc++: Fix incorrect IS number in doc comment
      libstdc++: Fix mismatched noexcept-specifiers in Filesystem TS
      libstdc++: Rename non-reserved macros in config header [PR103650]
      libstdc++: Fix example preprocessor command in FAQ [PR103877]
      libstdc++: Initialize member in std::match_results [PR103549]
      libstdc++: Add missing header to test
      libstdc++: Do not allocate a zero-size vector<bool> [PR 100153]
      libstdc++: Add additional overload of std::lerp [PR101870]
      libstdc++: Fix undefined behaviour in std::string
      libstdc++: Test errno macros directly, not via autoconf [PR 93151]
      libstdc++: Test errno macros directly for all targets [PR 93151]
      libstdc++: Fix std::exception_ptr regressions [PR103630]
      libstdc++: Remove un-implementable noexcept from Filesystem TS operations
      libstdc++: Fix test that fails for C++98 mode
      libstdc++: Fix deserialization for std::normal_distribution [PR105502]

Kewen Lin (3):
      ipa-fnsummary: Remove inconsistent bp_pack_value
      vect: Don't update inits for simd_lane_access DRs [PR102789]
      rs6000: Remove builtin mask check from builtin_decl [PR102347]

Marius Hillenbrand (1):
      IBM Z: Fix vector intrinsics vec_double and vec_floate

Martin Jambor (2):
      ipa-sra: Check also ECF_LOOPING_CONST_OR_PURE when evaluating calls
      cplxlower: Avoid a transform when looking at a default definition

Martin Liska (8):
      contrib: add git-commit-mklog wrapper
      Add mklog.py.
      sanitizer: cherry pick 414482751452e54710f16bae58458c66298aaf69
      gcc-changelog: sync from master
      jit: Initialize function::m_blocks in ctor
      git-backport: support renamed .cc files in commit message.
      git scripts: sync from master.
      gcc-changelog: sync from master.

Martin Storsjö (1):
      mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags variables

Mikael Morin (1):
      fortran: Backport associate character length fixes [PR104228]

Patrick Palka (3):
      c++: Fix deduction with reference NTTP [PR83476]
      c++: deleted fn and noexcept inst [PR101532, PR104225]
      c++: ICE when building builtin operator->* set [PR103455]

Paul Thomas (9):
      Fortran: Allow pointer deferred length associate selectors. [PR93794]
      Fortran: Fix ICE due to elemental procedure pointers [PR93924/5].
      Fortran: Fix for class defined operators [PR99125].
      Fortran: Assumed and explicit size class arrays [PR46691/99819].
      Fortran: Fix host associated PDT entity initialization
      Fortran: Fix ICE due to elemental procedure pointers [PR98472].
      Fortran: Improve resolution of associate variables. [PR93701].
      Fortran: Fix for class functions as associated target [PR98565].
      Fortran: Correct missing structure constructor comps. [PR97612].

Pavel I. Kryukov (1):
      libstdc++: Add self-merge check to std::forward_list::merge [PR103853]

Piotr Kubaj (1):
      gcc/configure: Check for powerpc64le*-*-freebsd*

Richard Biener (20):
      Bump BASE-VER to 9.4.1
      middle-end/100509 - avoid folding constant to aggregate type
      tree-optimization/100934 - properly mark irreducible regions for DOM
      tree-optimization/101105 - fix runtime alias test optimization
      tree-optimization/101394 - fix PRE full redundancy wrt abnormals
      tree-optimization/101173 - fix interchange dependence checking
      middle-end/101824 - properly handle volatiles in nested fn lowering
      tree-optimization/101868 - avoid PRE of trapping mems across calls
      middle-end/100672 - fix bogus right shift folding
      tree-optimization/97953 - fix bougs range recorded by EVRP
      tree-optimization/103237 - avoid vectorizing unhandled double reductions
      middle-end/103181 - fix operation_could_trap_p for vector division
      tree-optimization/102798 - avoid copying PTA info to old SSA names
      tree-optimization/96522 - transfer of flow-sensitive info in copy_ref_info
      tree-optimization/97043 - fix latent wrong-code with SLP vectorization
      target/104453 - guard call folding with NULL LHS
      middle-end/100786 - constant folding from incompatible alias
      tree-optimization/103361 - fix unroll-and-jam direction vector handling
      middle-end/104786 - ICE with asm and VLA
      tree-optimization/105070 - annotate bit cluster tests with locations

Richard Earnshaw (5):
      arm: Remove use of opts_set in arm_configure_build_target [PR100767]
      arm: Fix an incorrect warning when -mcpu=cortex-a55 is used with -mfloat-abi=soft
      arm: ensure the arch_name is always set for the build target
      arm: Don't reconfigure globals in arm_configure_build_target
      arm: reorder assembler architecture directives [PR101723]

Richard Sandiford (2):
      aarch64: Add -mtune=neoverse-512tvb
      libgcc: Add missing runtime exception notices

Segher Boessenkool (1):
      combine: Don't create REG_UNUSED notes if the reg already died (PR99927)

Stefan Schulze Frielinghaus (1):
      IBM Z: Fix load-and-test peephole2 condition

Thomas Koenig (1):
      Do not replace variable op variable in I/O implied DO loop replacement.

Thomas Schwinge (3):
      Restore 'gcc.dg/pr78213.c' testing
      Fix up 'gcc.dg/pr78213.c' for '--enable-checking=release' etc.
      Fix 'OMP_CLAUSE_TILE' operands handling in 'gcc/tree.c:walk_tree_1'

Tobias Burnus (2):
      OpenMP: Support complex/float in && and || reduction
      g++.dg/gomp/clause-3.C: Fix - missing in r12-438-g1580fc7 [PR100422]

Tom de Vries (1):
      debug: fix switch lowering debug info

Uros Bizjak (3):
      i386: Prevent unwanted combine from LZCNT to BSR [PR101175]
      i386: Remove atomic_storedi_fpu and atomic_loaddi_fpu peepholes [PR100182]
      i386: Fix vec_unpacks_float_lo_v4si operand constraint [PR104469]

Xi Ruoyao (1):
      mips: Fix up mips_atomic_assign_expand_fenv [PR94780]

konglin1 (1):
      i386: Fix _mm512_fpclass_ps_mask in O0 [PR 101471]

liuhongt (1):
      ICE: QImode(not SImode) operand should be passed to gen_vec_initv16qiqi in ashlv16qi3.

diff --git a/config/ChangeLog b/config/ChangeLog
index debc7381143..07d1a887900 100644
--- a/config/ChangeLog
+++ b/config/ChangeLog
@@ -1,3 +1,11 @@
+2021-12-16  Martin Storsjö  <martin@martin.st>
+
+	Backported from master:
+	2021-04-13  Martin Storsjö  <martin@martin.st>
+
+	* mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags
+	variables
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/config/mh-mingw b/config/mh-mingw
index a795096f038..e91367a7112 100644
--- a/config/mh-mingw
+++ b/config/mh-mingw
@@ -1,7 +1,9 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
 BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
+BOOT_CXXFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
 CFLAGS += -D__USE_MINGW_ACCESS
+CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE1_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE2_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE3_CXXFLAGS += -D__USE_MINGW_ACCESS
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 7ab95a2466e..de6bd24866c 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,40 @@
+2022-01-24  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Sync from master.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2022-01-19  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: Sync from master.
+	* git-commit-mklog.py: Likewise.
+	* git-fix-changelog.py: New file.
+
+2022-01-17  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-01-17  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: Support renaming of .cc files.
+
+2021-11-08  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_check_commit.py: Sync from master.
+	* gcc-changelog/git_commit.py: Likewise.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* mklog.py: New file.
+	* test_mklog.py: New file.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* git-commit-mklog.py: New file.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/contrib/gcc-changelog/git_check_commit.py b/contrib/gcc-changelog/git_check_commit.py
index 9a4c5d448fb..d6aff3cef91 100755
--- a/contrib/gcc-changelog/git_check_commit.py
+++ b/contrib/gcc-changelog/git_check_commit.py
@@ -29,6 +29,8 @@ parser.add_argument('-g', '--git-path', default='.',
                     help='Path to git repository')
 parser.add_argument('-p', '--print-changelog', action='store_true',
                     help='Print final changelog entires')
+parser.add_argument('-v', '--verbose', action='store_true',
+                    help='Print verbose information')
 args = parser.parse_args()
 
 retval = 0
@@ -41,6 +43,8 @@ for git_commit in parse_git_revisions(args.git_path, args.revisions):
     else:
         for error in git_commit.errors:
             print('ERR: %s' % error)
+            if args.verbose and error.details:
+                print(error.details)
         retval = 1
 
 exit(retval)
diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py
index 4958ab9c159..95dc49e5d48 100755
--- a/contrib/gcc-changelog/git_commit.py
+++ b/contrib/gcc-changelog/git_commit.py
@@ -134,6 +134,7 @@ ignored_prefixes = {
     'gcc/go/gofrontend/',
     'gcc/testsuite/gdc.test/',
     'gcc/testsuite/go.test/test/',
+    'libffi/',
     'libgo/',
     'libphobos/libdruntime/',
     'libphobos/src/',
@@ -156,7 +157,9 @@ author_line_regex = \
         re.compile(r'^(?P<datetime>\d{4}-\d{2}-\d{2})\ {2}(?P<name>.*  <.*>)')
 additional_author_regex = re.compile(r'^\t(?P<spaces>\ *)?(?P<name>.*  <.*>)')
 changelog_regex = re.compile(r'^(?:[fF]or +)?([a-z0-9+-/]*)ChangeLog:?')
-pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?([0-9]+)$')
+subject_pr_regex = re.compile(r'(^|\W)PR\s+(?P<component>[a-zA-Z+-]+)/(?P<pr>\d{4,7})')
+subject_pr2_regex = re.compile(r'[(\[]PR\s*(?P<pr>\d{4,7})[)\]]')
+pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?(?P<pr>[0-9]+)$')
 dr_regex = re.compile(r'\tDR ([0-9]+)$')
 star_prefix_regex = re.compile(r'\t\*(?P<spaces>\ *)(?P<content>.*)')
 end_of_location_regex = re.compile(r'[\[<(:]')
@@ -194,9 +197,10 @@ def decode_path(path):
 
 
 class Error:
-    def __init__(self, message, line=None):
+    def __init__(self, message, line=None, details=None):
         self.message = message
         self.line = line
+        self.details = details
 
     def __repr__(self):
         s = self.message
@@ -215,7 +219,7 @@ class ChangeLogEntry:
         self.lines = []
         self.files = []
         self.file_patterns = []
-        self.opened_parentheses = 0
+        self.parentheses_stack = []
 
     def parse_file_names(self):
         # Whether the content currently processed is between a star prefix the
@@ -298,6 +302,7 @@ class GitCommit:
         self.top_level_authors = []
         self.co_authors = []
         self.top_level_prs = []
+        self.subject_prs = set()
         self.cherry_pick_commit = None
         self.revert_commit = None
         self.commit_to_info_hook = commit_to_info_hook
@@ -307,6 +312,9 @@ class GitCommit:
         if self.info.lines and self.info.lines[0] == 'Update copyright years.':
             return
 
+        if self.info.lines and len(self.info.lines) > 1 and self.info.lines[1]:
+            self.errors.append(Error('Expected empty second line in commit message', info.lines[0]))
+
         # Identify first if the commit is a Revert commit
         for line in self.info.lines:
             m = revert_regex.match(line)
@@ -316,6 +324,21 @@ class GitCommit:
         if self.revert_commit:
             self.info = self.commit_to_info_hook(self.revert_commit)
 
+        # The following happens for get_email.py:
+        if not self.info:
+            return
+
+        self.check_commit_email()
+
+        # Extract PR numbers form the subject line
+        # Match either [PRnnnn] / (PRnnnn) or PR component/nnnn
+        if self.info.lines and not self.revert_commit:
+            self.subject_prs = {m.group('pr') for m in subject_pr2_regex.finditer(info.lines[0])}
+            for m in subject_pr_regex.finditer(info.lines[0]):
+                if not m.group('component') in bug_components:
+                    self.errors.append(Error('invalid PR component in subject', info.lines[0]))
+                self.subject_prs.add(m.group('pr'))
+
         # Allow complete deletion of ChangeLog files in a commit
         project_files = [f for f in self.info.modified_files
                          if (self.is_changelog_filename(f[0], allow_suffix=True) and f[1] != 'D')
@@ -326,9 +349,11 @@ class GitCommit:
             # All modified files are only MISC files
             return
         elif project_files:
-            self.errors.append(Error('ChangeLog, DATESTAMP, BASE-VER and '
-                                     'DEV-PHASE updates should be done '
-                                     'separately from normal commits'))
+            err = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates ' \
+                  'should be done separately from normal commits\n' \
+                  '(note: ChangeLog entries will be automatically ' \
+                  'added by a cron job)'
+            self.errors.append(Error(err))
             return
 
         all_are_ignored = (len(project_files) + len(ignored_files)
@@ -344,6 +369,9 @@ class GitCommit:
             if not self.errors:
                 self.check_mentioned_files()
                 self.check_for_correct_changelog()
+        if self.subject_prs:
+            self.errors.append(Error('PR %s in subject but not in changelog' %
+                                     ', '.join(self.subject_prs), self.info.lines[0]))
 
     @property
     def success(self):
@@ -458,7 +486,9 @@ class GitCommit:
                     else:
                         author_tuple = (m.group('name'), None)
                 elif pr_regex.match(line):
-                    component = pr_regex.match(line).group('component')
+                    m = pr_regex.match(line)
+                    component = m.group('component')
+                    pr = m.group('pr')
                     if not component:
                         self.errors.append(Error('missing PR component', line))
                         continue
@@ -467,6 +497,8 @@ class GitCommit:
                         continue
                     else:
                         pr_line = line.lstrip()
+                    if pr in self.subject_prs:
+                        self.subject_prs.remove(pr)
                 elif dr_regex.match(line):
                     pr_line = line.lstrip()
 
@@ -521,7 +553,7 @@ class GitCommit:
                     m = star_prefix_regex.match(line)
                     if m:
                         if (len(m.group('spaces')) != 1 and
-                                last_entry.opened_parentheses == 0):
+                                not last_entry.parentheses_stack):
                             msg = 'one space should follow asterisk'
                             self.errors.append(Error(msg, line))
                         else:
@@ -546,13 +578,13 @@ class GitCommit:
     def process_parentheses(self, last_entry, line):
         for c in line:
             if c == '(':
-                last_entry.opened_parentheses += 1
+                last_entry.parentheses_stack.append(line)
             elif c == ')':
-                if last_entry.opened_parentheses == 0:
+                if not last_entry.parentheses_stack:
                     msg = 'bad wrapping of parenthesis'
                     self.errors.append(Error(msg, line))
                 else:
-                    last_entry.opened_parentheses -= 1
+                    del last_entry.parentheses_stack[-1]
 
     def parse_file_names(self):
         for entry in self.changelog_entries:
@@ -578,9 +610,9 @@ class GitCommit:
 
     def check_for_broken_parentheses(self):
         for entry in self.changelog_entries:
-            if entry.opened_parentheses != 0:
+            if entry.parentheses_stack:
                 msg = 'bad parentheses wrapping'
-                self.errors.append(Error(msg, entry.lines[0]))
+                self.errors.append(Error(msg, entry.parentheses_stack[-1]))
 
     def get_file_changelog_location(self, changelog_file):
         for file in self.info.modified_files:
@@ -656,9 +688,11 @@ class GitCommit:
         for file in sorted(mentioned_files - changed_files):
             msg = 'unchanged file mentioned in a ChangeLog'
             candidates = difflib.get_close_matches(file, changed_files, 1)
+            details = None
             if candidates:
                 msg += f' (did you mean "{candidates[0]}"?)'
-            self.errors.append(Error(msg, file))
+                details = '\n'.join(difflib.Differ().compare([file], [candidates[0]])).rstrip()
+            self.errors.append(Error(msg, file, details))
         for file in sorted(changed_files - mentioned_files):
             if not self.in_ignored_location(file):
                 if file in self.new_files:
@@ -684,9 +718,15 @@ class GitCommit:
                         self.changelog_entries.append(entry)
                     # strip prefix of the file
                     assert file.startswith(entry.folder)
-                    file = file[len(entry.folder):].lstrip('/')
-                    entry.lines.append('\t* %s: New file.' % file)
-                    entry.files.append(file)
+                    # do not allow auto-addition of New files
+                    # for the top-level folder
+                    if entry.folder:
+                        file = file[len(entry.folder):].lstrip('/')
+                        entry.lines.append('\t* %s: New file.' % file)
+                        entry.files.append(file)
+                    else:
+                        msg = 'new file in the top-level folder not mentioned in a ChangeLog'
+                        self.errors.append(Error(msg, file))
                 else:
                     used_pattern = [p for p in mentioned_patterns
                                     if file.startswith(p)]
@@ -775,3 +815,12 @@ class GitCommit:
         print('Errors:')
         for error in self.errors:
             print(error)
+
+    def check_commit_email(self):
+        # Parse 'Martin Liska  <mliska@suse.cz>'
+        email = self.info.author.split(' ')[-1].strip('<>')
+
+        # Verify that all characters are ASCII
+        # TODO: Python 3.7 provides a nicer function: isascii
+        if len(email) != len(email.encode()):
+            self.errors.append(Error(f'non-ASCII characters in git commit email address ({email})'))
diff --git a/contrib/gcc-changelog/git_email.py b/contrib/gcc-changelog/git_email.py
index fa62e3ad2f7..87b419cae5d 100755
--- a/contrib/gcc-changelog/git_email.py
+++ b/contrib/gcc-changelog/git_email.py
@@ -17,6 +17,7 @@
 # <http://www.gnu.org/licenses/>.  */
 
 import os
+import re
 import sys
 from itertools import takewhile
 
@@ -28,6 +29,8 @@ from unidiff import PatchSet, PatchedFile
 
 DATE_PREFIX = 'Date: '
 FROM_PREFIX = 'From: '
+SUBJECT_PREFIX = 'Subject: '
+subject_patch_regex = re.compile(r'^\[PATCH( \d+/\d+)?\] ')
 unidiff_supports_renaming = hasattr(PatchedFile(), 'is_rename')
 
 
@@ -37,7 +40,9 @@ class GitEmail(GitCommit):
         diff = PatchSet.from_filename(filename)
         date = None
         author = None
+        subject = ''
 
+        subject_last = False
         with open(self.filename, 'r') as f:
             lines = f.read().splitlines()
         lines = list(takewhile(lambda line: line != '---', lines))
@@ -46,8 +51,21 @@ class GitEmail(GitCommit):
                 date = parse(line[len(DATE_PREFIX):])
             elif line.startswith(FROM_PREFIX):
                 author = GitCommit.format_git_author(line[len(FROM_PREFIX):])
+            elif line.startswith(SUBJECT_PREFIX):
+                subject = line[len(SUBJECT_PREFIX):]
+                subject_last = True
+            elif subject_last and line.startswith(' '):
+                subject += line
+            elif line == '':
+                break
+            else:
+                subject_last = False
+
+        if subject:
+            subject = subject_patch_regex.sub('', subject)
         header = list(takewhile(lambda line: line != '', lines))
-        body = lines[len(header) + 1:]
+        # Note: commit message consists of email subject, empty line, email body
+        message = [subject] + lines[len(header):]
 
         modified_files = []
         for f in diff:
@@ -67,7 +85,7 @@ class GitEmail(GitCommit):
             else:
                 t = 'M'
             modified_files.append((target if t != 'D' else source, t))
-        git_info = GitInfo(None, date, author, body, modified_files)
+        git_info = GitInfo(None, date, author, message, modified_files)
         super().__init__(git_info,
                          commit_to_info_hook=lambda x: None)
 
diff --git a/contrib/gcc-changelog/git_update_version.py b/contrib/gcc-changelog/git_update_version.py
index 0508f194084..1837c1a8d7f 100755
--- a/contrib/gcc-changelog/git_update_version.py
+++ b/contrib/gcc-changelog/git_update_version.py
@@ -27,7 +27,10 @@ from git_repository import parse_git_revisions
 current_timestamp = datetime.datetime.now().strftime('%Y%m%d\n')
 
 # Skip the following commits, they cannot be correctly processed
-IGNORED_COMMITS = ('c2be82058fb40f3ae891c68d185ff53e07f14f45')
+IGNORED_COMMITS = (
+        'c2be82058fb40f3ae891c68d185ff53e07f14f45',
+        '04a040d907a83af54e0a98bdba5bfabc0ef4f700',
+        '2e96b5f14e4025691b57d2301d71aa6092ed44bc')
 
 
 def read_timestamp(path):
diff --git a/contrib/gcc-changelog/test_email.py b/contrib/gcc-changelog/test_email.py
index 7472762e66d..c56f6da513a 100755
--- a/contrib/gcc-changelog/test_email.py
+++ b/contrib/gcc-changelog/test_email.py
@@ -258,7 +258,7 @@ class TestGccChangelog(unittest.TestCase):
         email = self.from_patch_glob('0001-Add-patch_are')
         msg = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates should ' \
               'be done separately from normal commits'
-        assert email.errors[0].message == msg
+        assert email.errors[0].message.startswith(msg)
 
     def test_strict_mode_normal_patch(self):
         email = self.get_git_email('0001-Just-test-it.patch')
@@ -415,6 +415,7 @@ class TestGccChangelog(unittest.TestCase):
     def test_multiline_bad_parentheses(self):
         email = self.from_patch_glob('0002-Wrong-macro-changelog.patch')
         assert email.errors[0].message == 'bad parentheses wrapping'
+        assert email.errors[0].line == '	* config/i386/i386.md (*fix_trunc<mode>_i387_1,'
 
     def test_changelog_removal(self):
         email = self.from_patch_glob('0001-ChangeLog-removal.patch')
@@ -427,3 +428,26 @@ class TestGccChangelog(unittest.TestCase):
     def test_multi_same_file(self):
         email = self.from_patch_glob('0001-OpenMP-Fix-SIMT')
         assert email.errors[0].message == 'same file specified multiple times'
+
+    def test_pr_only_in_subject(self):
+        email = self.from_patch_glob('0001-rs6000-Support-doubleword')
+        assert (email.errors[0].message ==
+                'PR 100085 in subject but not in changelog')
+
+    def test_wrong_pr_comp_in_subject(self):
+        email = self.from_patch_glob('pr-wrong-comp.patch')
+        assert email.errors[0].message == 'invalid PR component in subject'
+
+    def test_copyright_years(self):
+        email = self.from_patch_glob('copyright-years.patch')
+        assert not email.errors
+
+    def test_non_ascii_email(self):
+        email = self.from_patch_glob('non-ascii-email.patch')
+        assert (email.errors[0].message ==
+                'non-ASCII characters in git commit email address (jbglaw@ług-owl.de)')
+
+    def test_new_file_in_root_folder(self):
+        email = self.from_patch_glob('toplev-new-file.patch')
+        assert (email.errors[0].message ==
+                'new file in the top-level folder not mentioned in a ChangeLog')
diff --git a/contrib/gcc-changelog/test_patches.txt b/contrib/gcc-changelog/test_patches.txt
index 39d40b88618..95ad961f2d3 100644
--- a/contrib/gcc-changelog/test_patches.txt
+++ b/contrib/gcc-changelog/test_patches.txt
@@ -1461,6 +1461,7 @@ Subject: [PATCH 0030/2034] 	PR c++/92746 - ICE with noexcept of function
 Another place that needs to specially handle Concepts TS function-style
 concepts.
 
+	PR c++/92746
 	* except.c (check_noexcept_r): Handle concept-check.
 ---
  gcc/cp/ChangeLog                            | 3 +++
@@ -1977,7 +1978,7 @@ index aac31d02b6c..56c470f6ecf 100644
 From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
 From: Jason Merrill <jason@redhat.com>
 Date: Thu, 16 Jan 2020 16:55:39 -0500
-Subject: [PATCH 0121/2034] PR c++/93286 - ICE with __is_constructible and
+Subject: [PATCH 0121/2034] PR c++/12345 - ICE with __is_constructible and
  variadic template.
 
 Here we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST
@@ -3406,3 +3407,167 @@ index 00000000000..21540512e23
 +
 -- 
 2.25.1
+=== 0001-rs6000-Support-doubleword ===
+From f700e4b0ee3ef53b48975cf89be26b9177e3a3f3 Mon Sep 17 00:00:00 2001
+From: Xionghu Luo <luoxhu@linux.ibm.com>
+Date: Tue, 8 Jun 2021 21:48:12 -0500
+Subject: [PATCH] rs6000: Support doubleword swaps removal in rot64 load store
+ [PR100085]
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+=== pr-wrong-comp.patch ===
+From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Thu, 16 Jan 2020 16:55:39 -0500
+Subject: [PATCH 0121/2034] PR some/93286 - ICE with __is_constructible and
+ variadic template.
+
+gcc/testsuite/ChangeLog:
+
+	PR c++/93286
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+==== copyright-years.patch ===
+From 99dee82307f1e163e150c9c810452979994047ce Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Mon, 4 Jan 2021 10:26:59 +0100
+Subject: [PATCH] Update copyright years.
+
+---
+diff --git a/lto-plugin/lto-plugin.c b/lto-plugin/lto-plugin.c
+new file mode 100644
+index 6f67552d075..32478f070e8 100644
+--- a/lto-plugin/lto-plugin.c
++++ b/lto-plugin/lto-plugin.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+
+=== non-ascii-email.patch ===
+From f42e95a830ab48e59389065ce79a013a519646f1 Mon Sep 17 00:00:00 2001
+From: Jan-Benedict Glaw <jbglaw@ług-owl.de>
+Date: Mon, 13 Sep 2021 12:08:25 +0200
+Subject: [PATCH] Fix multi-statment macro
+
+INIT_CUMULATIVE_ARGS() expands to multiple statements, which will break right
+after an `if` statement. Wrap it into a block.
+
+gcc/ChangeLog:
+
+	* config/alpha/vms.h (INIT_CUMULATIVE_ARGS): Wrap multi-statment
+	define into a block.
+---
+ gcc/config/alpha/vms.h | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/gcc/config/alpha/vms.h b/gcc/config/alpha/vms.h
+index 2a9917cde62..0033b0004b3 100644
+--- a/gcc/config/alpha/vms.h
++++ b/gcc/config/alpha/vms.h
+@@ -0,0 +1,1 @@
++
+-- 
+
+=== toplev-new-file.patch ===
+From 05e37b6e65027188f08e6374c7d356d75b54738e Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 24 Jan 2022 12:46:27 +0100
+Subject: [PATCH] New file.
+
+ChangeLog:
+
+	* Makefile.in: Update.
+
+gcc/ChangeLog:
+
+	* ipa-icf.cc: Update.
+---
+ Makefile.am     | 1 +
+ Makefile.in     | 1 +
+ gcc/ipa-icf.cc  | 1 +
+ gcc/ipa-icf2.cc | 1 +
+ 4 files changed, 4 insertions(+)
+ create mode 100644 Makefile.am
+ create mode 100644 gcc/ipa-icf2.cc
+
+diff --git a/Makefile.am b/Makefile.am
+new file mode 100644
+index 00000000000..f0129caae3d
+--- /dev/null
++++ b/Makefile.am
+@@ -0,0 +1 @@
++new file.
+diff --git a/Makefile.in b/Makefile.in
+index 79c77fccf0f..7a090030119 100644
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -1,4 +1,5 @@
+ 
++
+ # Makefile.in is generated from Makefile.tpl by 'autogen Makefile.def'.
+ #
+ # Makefile for directory with subdirs to build.
+diff --git a/gcc/ipa-icf.cc b/gcc/ipa-icf.cc
+index 765ae746745..15735b6684f 100644
+--- a/gcc/ipa-icf.cc
++++ b/gcc/ipa-icf.cc
+@@ -1,3 +1,4 @@
++
+ /* Interprocedural Identical Code Folding pass
+    Copyright (C) 2014-2022 Free Software Foundation, Inc.
+ 
+diff --git a/gcc/ipa-icf2.cc b/gcc/ipa-icf2.cc
+new file mode 100644
+index 00000000000..c49c556e0e4
+--- /dev/null
++++ b/gcc/ipa-icf2.cc
+@@ -0,0 +1 @@
++tt
+-- 
+2.34.1
+
+From 80c9d63af350b280bfccb82adb3867c25a25e6d0 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 24 Jan 2022 12:17:09 +0100
+Subject: [PATCH] Add Makefile.am file.
+
+Foo bar.
+
+ChangeLog:
+
+---
+ Makefile.am | 0
+ 1 file changed, 0 insertions(+), 0 deletions(-)
+ create mode 100644 Makefile.am
+
+diff --git a/Makefile.am b/Makefile.am
+new file mode 100644
+index 00000000000..d6459e00543
+--- /dev/null
++++ b/Makefile.am
+@@ -0,0 +1 @@
++xxx
+-- 
+2.34.1
diff --git a/contrib/git-backport.py b/contrib/git-backport.py
index 2b8e4686719..fc369d97754 100755
--- a/contrib/git-backport.py
+++ b/contrib/git-backport.py
@@ -20,46 +20,16 @@
 # Boston, MA 02110-1301, USA.
 
 import argparse
+import os
 import subprocess
 
+script_folder = os.path.dirname(os.path.abspath(__file__))
+fixup_script = os.path.join(script_folder, 'git-fix-changelog.py')
+
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Backport a git revision and '
-                                     'stash all ChangeLog files.')
+    parser = argparse.ArgumentParser(description='Backport a git revision.')
     parser.add_argument('revision', help='Revision')
     args = parser.parse_args()
 
-    r = subprocess.run('git cherry-pick -x %s' % args.revision, shell=True)
-    if r.returncode == 0:
-        cmd = 'git show --name-only --pretty="" -- "*ChangeLog"'
-        changelogs = subprocess.check_output(cmd, shell=True, encoding='utf8')
-        changelogs = changelogs.strip()
-        if changelogs:
-            for changelog in changelogs.split('\n'):
-                subprocess.check_output('git checkout HEAD~ %s' % changelog,
-                                        shell=True)
-        subprocess.check_output('git commit --amend --no-edit', shell=True)
-    else:
-        # 1) remove all ChangeLog files from conflicts
-        out = subprocess.check_output('git diff --name-only --diff-filter=U',
-                                      shell=True,
-                                      encoding='utf8')
-        conflicts = out.strip().split('\n')
-        changelogs = [c for c in conflicts if c.endswith('ChangeLog')]
-        if changelogs:
-            cmd = 'git checkout --theirs %s' % ' '.join(changelogs)
-            subprocess.check_output(cmd, shell=True)
-        # 2) remove all ChangeLog files from index
-        cmd = 'git diff --name-only --diff-filter=M HEAD'
-        out = subprocess.check_output(cmd, shell=True, encoding='utf8')
-        out = out.strip().split('\n')
-        modified = [c for c in out if c.endswith('ChangeLog')]
-        for m in modified:
-            subprocess.check_output('git reset %s' % m, shell=True)
-            subprocess.check_output('git checkout %s' % m, shell=True)
-
-        # try to continue
-        if len(conflicts) == len(changelogs):
-            cmd = 'git -c core.editor=true cherry-pick --continue'
-            subprocess.check_output(cmd, shell=True)
-        else:
-            print('Please resolve all remaining file conflicts.')
+    subprocess.run('git cherry-pick -x %s' % args.revision, shell=True)
+    subprocess.run(fixup_script, shell=True)
diff --git a/contrib/git-commit-mklog.py b/contrib/git-commit-mklog.py
new file mode 100755
index 00000000000..eda3fc4a892
--- /dev/null
+++ b/contrib/git-commit-mklog.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script is wrapper for git commit-mklog alias where it parses
+# -b/--pr-numbers argument and passes it via environment variable
+# to mklog.py script.
+
+import argparse
+import os
+import subprocess
+
+if __name__ == '__main__':
+    children_args = []
+    myenv = os.environ.copy()
+
+    parser = argparse.ArgumentParser(description='git-commit-mklog wrapped')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('--co',
+                        help='Add Co-Authored-By trailer (comma separated)')
+    args, unknown_args = parser.parse_known_args()
+
+    myenv['GCC_FORCE_MKLOG'] = '1'
+    mklog_args = []
+    if args.pr_numbers:
+        mklog_args.append(f'-b {",".join(args.pr_numbers)}')
+    if args.fill_up_bug_titles:
+        mklog_args.append('-p')
+
+    if mklog_args:
+        myenv['GCC_MKLOG_ARGS'] = ' '.join(mklog_args)
+
+    if args.co:
+        for author in args.co.split(','):
+            unknown_args.append(f'--trailer "Co-Authored-By: {author}"')
+
+    commit_args = ' '.join(unknown_args)
+    subprocess.run(f'git commit {commit_args}', shell=True, env=myenv)
diff --git a/contrib/git-fix-changelog.py b/contrib/git-fix-changelog.py
new file mode 100755
index 00000000000..c15e45c11fa
--- /dev/null
+++ b/contrib/git-fix-changelog.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script tries to fix commit message where ChangeLog entries
+# can point to .cc renamed files.
+
+import argparse
+import os
+import subprocess
+import tempfile
+
+DESCRIPTION = 'Fix up ChangeLog of the current commit.'
+
+script_folder = os.path.dirname(os.path.abspath(__file__))
+verify_script = os.path.join(script_folder,
+                             'gcc-changelog/git_check_commit.py')
+
+
+def replace_file_in_changelog(lines, filename, fixed):
+    # consider all componenets of a path: gcc/ipa-icf.cc
+    while filename:
+        for i, line in enumerate(lines):
+            if filename in line:
+                lines[i] = line.replace(filename, fixed)
+                return
+
+        parts = filename.split('/')
+        if len(parts) == 1:
+            return
+        filename = '/'.join(parts[1:])
+        fixed = '/'.join(fixed.split('/')[1:])
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=DESCRIPTION)
+    args = parser.parse_args()
+
+    # Update commit message if change for a .cc file was taken
+    r = subprocess.run(f'{verify_script} HEAD', shell=True, encoding='utf8',
+                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    if r.returncode != 0:
+        lines = r.stdout.splitlines()
+        cmd = 'git show -s --format=%B'
+        commit_message = subprocess.check_output(cmd, shell=True,
+                                                 encoding='utf8').strip()
+        commit_message = commit_message.splitlines()
+
+        # Parse the following lines:
+        # ERR: unchanged file mentioned in a ChangeLog \
+        # (did you mean "gcc/ipa-icf.cc"?): "gcc/ipa-icf.c"
+        replaced = 0
+        for line in lines:
+            if ('unchanged file mentioned' in line and
+                    'did you mean' in line):
+                filename = line.split()[-1].strip('"')
+                fixed = line[line.index('did you mean'):]
+                fixed = fixed[fixed.index('"') + 1:]
+                fixed = fixed[:fixed.index('"')]
+
+                if filename.count('/') == fixed.count('/'):
+                    replace_file_in_changelog(commit_message, filename, fixed)
+                    replaced += 1
+
+        if replaced:
+            with tempfile.NamedTemporaryFile('w', encoding='utf8',
+                                             delete=False) as w:
+                w.write('\n'.join(commit_message))
+                w.close()
+                subprocess.check_output(f'git commit --amend -F {w.name}',
+                                        shell=True, encoding='utf8')
+                os.unlink(w.name)
+                print(f'Commit message updated: {replaced} file(s) renamed.')
+        else:
+            print('Commit message has not been updated.')
diff --git a/contrib/mklog.py b/contrib/mklog.py
new file mode 100755
index 00000000000..674c1dcd78b
--- /dev/null
+++ b/contrib/mklog.py
@@ -0,0 +1,356 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import argparse
+import datetime
+import os
+import re
+import subprocess
+import sys
+from itertools import takewhile
+
+import requests
+
+from unidiff import PatchSet
+
+pr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<pr>PR [a-z+-]+\/[0-9]+)')
+prnum_regex = re.compile(r'PR (?P<comp>[a-z+-]+)/(?P<num>[0-9]+)')
+dr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<dr>DR [0-9]+)')
+dg_regex = re.compile(r'{\s+dg-(error|warning)')
+pr_filename_regex = re.compile(r'(^|[\W_])[Pp][Rr](?P<pr>\d{4,})')
+identifier_regex = re.compile(r'^([a-zA-Z0-9_#].*)')
+comment_regex = re.compile(r'^\/\*')
+struct_regex = re.compile(r'^(class|struct|union|enum)\s+'
+                          r'(GTY\(.*\)\s+)?([a-zA-Z0-9_]+)')
+macro_regex = re.compile(r'#\s*(define|undef)\s+([a-zA-Z0-9_]+)')
+super_macro_regex = re.compile(r'^DEF[A-Z0-9_]+\s*\(([a-zA-Z0-9_]+)')
+fn_regex = re.compile(r'([a-zA-Z_][^()\s]*)\s*\([^*]')
+template_and_param_regex = re.compile(r'<[^<>]*>')
+md_def_regex = re.compile(r'\(define.*\s+"(.*)"')
+bugzilla_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/bug?id=%s&' \
+               'include_fields=summary,component'
+
+function_extensions = {'.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def', '.md'}
+
+# NB: Makefile.in isn't listed as it's not always generated.
+generated_files = {'aclocal.m4', 'config.h.in', 'configure'}
+
+help_message = """\
+Generate ChangeLog template for PATCH.
+PATCH must be generated using diff(1)'s -up or -cp options
+(or their equivalent in git).
+"""
+
+script_folder = os.path.realpath(__file__)
+root = os.path.dirname(os.path.dirname(script_folder))
+
+firstpr = ''
+
+
+def find_changelog(path):
+    folder = os.path.split(path)[0]
+    while True:
+        if os.path.exists(os.path.join(root, folder, 'ChangeLog')):
+            return folder
+        folder = os.path.dirname(folder)
+        if folder == '':
+            return folder
+    raise AssertionError()
+
+
+def extract_function_name(line):
+    if comment_regex.match(line):
+        return None
+    m = struct_regex.search(line)
+    if m:
+        # Struct declaration
+        return m.group(1) + ' ' + m.group(3)
+    m = macro_regex.search(line)
+    if m:
+        # Macro definition
+        return m.group(2)
+    m = super_macro_regex.search(line)
+    if m:
+        # Supermacro
+        return m.group(1)
+    m = fn_regex.search(line)
+    if m:
+        # Discard template and function parameters.
+        fn = m.group(1)
+        fn = re.sub(template_and_param_regex, '', fn)
+        return fn.rstrip()
+    return None
+
+
+def try_add_function(functions, line):
+    fn = extract_function_name(line)
+    if fn and fn not in functions:
+        functions.append(fn)
+    return bool(fn)
+
+
+def sort_changelog_files(changed_file):
+    return (changed_file.is_added_file, changed_file.is_removed_file)
+
+
+def get_pr_titles(prs):
+    output = []
+    for idx, pr in enumerate(prs):
+        pr_id = pr.split('/')[-1]
+        r = requests.get(bugzilla_url % pr_id)
+        bugs = r.json()['bugs']
+        if len(bugs) == 1:
+            prs[idx] = 'PR %s/%s' % (bugs[0]['component'], pr_id)
+            out = '%s - %s\n' % (prs[idx], bugs[0]['summary'])
+            if out not in output:
+                output.append(out)
+    if output:
+        output.append('')
+    return '\n'.join(output)
+
+
+def generate_changelog(data, no_functions=False, fill_pr_titles=False,
+                       additional_prs=None):
+    changelogs = {}
+    changelog_list = []
+    prs = []
+    out = ''
+    diff = PatchSet(data)
+    global firstpr
+
+    if additional_prs:
+        prs = [pr for pr in additional_prs if pr not in prs]
+    for file in diff:
+        # skip files that can't be parsed
+        if file.path == '/dev/null':
+            continue
+        changelog = find_changelog(file.path)
+        if changelog not in changelogs:
+            changelogs[changelog] = []
+            changelog_list.append(changelog)
+        changelogs[changelog].append(file)
+
+        # Extract PR entries from newly added tests
+        if 'testsuite' in file.path and file.is_added_file:
+            # Only search first ten lines as later lines may
+            # contains commented code which a note that it
+            # has not been tested due to a certain PR or DR.
+            this_file_prs = []
+            for line in list(file)[0][0:10]:
+                m = pr_regex.search(line.value)
+                if m:
+                    pr = m.group('pr')
+                    if pr not in prs:
+                        prs.append(pr)
+                        this_file_prs.append(pr.split('/')[-1])
+                else:
+                    m = dr_regex.search(line.value)
+                    if m:
+                        dr = m.group('dr')
+                        if dr not in prs:
+                            prs.append(dr)
+                            this_file_prs.append(dr.split('/')[-1])
+                    elif dg_regex.search(line.value):
+                        # Found dg-warning/dg-error line
+                        break
+            # PR number in the file name
+            fname = os.path.basename(file.path)
+            m = pr_filename_regex.search(fname)
+            if m:
+                pr = m.group('pr')
+                pr2 = 'PR ' + pr
+                if pr not in this_file_prs and pr2 not in prs:
+                    prs.append(pr2)
+
+    if prs:
+        firstpr = prs[0]
+
+    if fill_pr_titles:
+        out += get_pr_titles(prs)
+
+    # print list of PR entries before ChangeLog entries
+    if prs:
+        if not out:
+            out += '\n'
+        for pr in prs:
+            out += '\t%s\n' % pr
+        out += '\n'
+
+    # sort ChangeLog so that 'testsuite' is at the end
+    for changelog in sorted(changelog_list, key=lambda x: 'testsuite' in x):
+        files = changelogs[changelog]
+        out += '%s:\n' % os.path.join(changelog, 'ChangeLog')
+        out += '\n'
+        # new and deleted files should be at the end
+        for file in sorted(files, key=sort_changelog_files):
+            assert file.path.startswith(changelog)
+            in_tests = 'testsuite' in changelog or 'testsuite' in file.path
+            relative_path = file.path[len(changelog):].lstrip('/')
+            functions = []
+            if file.is_added_file:
+                msg = 'New test' if in_tests else 'New file'
+                out += '\t* %s: %s.\n' % (relative_path, msg)
+            elif file.is_removed_file:
+                out += '\t* %s: Removed.\n' % (relative_path)
+            elif hasattr(file, 'is_rename') and file.is_rename:
+                out += '\t* %s: Moved to...\n' % (relative_path)
+                new_path = file.target_file[2:]
+                # A file can be theoretically moved to a location that
+                # belongs to a different ChangeLog.  Let user fix it.
+                if new_path.startswith(changelog):
+                    new_path = new_path[len(changelog):].lstrip('/')
+                out += '\t* %s: ...here.\n' % (new_path)
+            elif os.path.basename(file.path) in generated_files:
+                out += '\t* %s: Regenerate.\n' % (relative_path)
+            else:
+                if not no_functions:
+                    for hunk in file:
+                        # Do not add function names for testsuite files
+                        extension = os.path.splitext(relative_path)[1]
+                        if not in_tests and extension in function_extensions:
+                            last_fn = None
+                            modified_visited = False
+                            success = False
+                            for line in hunk:
+                                m = identifier_regex.match(line.value)
+                                if line.is_added or line.is_removed:
+                                    # special-case definition in .md files
+                                    m2 = md_def_regex.match(line.value)
+                                    if extension == '.md' and m2:
+                                        fn = m2.group(1)
+                                        if fn not in functions:
+                                            functions.append(fn)
+                                            last_fn = None
+                                            success = True
+
+                                    if not line.value.strip():
+                                        continue
+                                    modified_visited = True
+                                    if m and try_add_function(functions,
+                                                              m.group(1)):
+                                        last_fn = None
+                                        success = True
+                                elif line.is_context:
+                                    if last_fn and modified_visited:
+                                        try_add_function(functions, last_fn)
+                                        last_fn = None
+                                        modified_visited = False
+                                        success = True
+                                    elif m:
+                                        last_fn = m.group(1)
+                                        modified_visited = False
+                            if not success:
+                                try_add_function(functions,
+                                                 hunk.section_header)
+                if functions:
+                    out += '\t* %s (%s):\n' % (relative_path, functions[0])
+                    for fn in functions[1:]:
+                        out += '\t(%s):\n' % fn
+                else:
+                    out += '\t* %s:\n' % relative_path
+        out += '\n'
+    return out
+
+
+def update_copyright(data):
+    current_timestamp = datetime.datetime.now().strftime('%Y-%m-%d')
+    username = subprocess.check_output('git config user.name', shell=True,
+                                       encoding='utf8').strip()
+    email = subprocess.check_output('git config user.email', shell=True,
+                                    encoding='utf8').strip()
+
+    changelogs = set()
+    diff = PatchSet(data)
+
+    for file in diff:
+        changelog = os.path.join(find_changelog(file.path), 'ChangeLog')
+        if changelog not in changelogs:
+            changelogs.add(changelog)
+            with open(changelog) as f:
+                content = f.read()
+            with open(changelog, 'w+') as f:
+                f.write(f'{current_timestamp}  {username}  <{email}>\n\n')
+                f.write('\tUpdate copyright years.\n\n')
+                f.write(content)
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=help_message)
+    parser.add_argument('input', nargs='?',
+                        help='Patch file (or missing, read standard input)')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-s', '--no-functions', action='store_true',
+                        help='Do not generate function names in ChangeLogs')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('-d', '--directory',
+                        help='Root directory where to search for ChangeLog '
+                        'files')
+    parser.add_argument('-c', '--changelog',
+                        help='Append the ChangeLog to a git commit message '
+                             'file')
+    parser.add_argument('--update-copyright', action='store_true',
+                        help='Update copyright in ChangeLog files')
+    args = parser.parse_args()
+    if args.input == '-':
+        args.input = None
+    if args.directory:
+        root = args.directory
+
+    data = open(args.input) if args.input else sys.stdin
+    if args.update_copyright:
+        update_copyright(data)
+    else:
+        output = generate_changelog(data, args.no_functions,
+                                    args.fill_up_bug_titles, args.pr_numbers)
+        if args.changelog:
+            lines = open(args.changelog).read().split('\n')
+            start = list(takewhile(lambda l: not l.startswith('#'), lines))
+            end = lines[len(start):]
+            with open(args.changelog, 'w') as f:
+                if not start or not start[0]:
+                    # initial commit subject line 'component: [PRnnnnn]'
+                    m = prnum_regex.match(firstpr)
+                    if m:
+                        title = f'{m.group("comp")}: [PR{m.group("num")}]'
+                        start.insert(0, title)
+                if start:
+                    # append empty line
+                    if start[-1] != '':
+                        start.append('')
+                else:
+                    # append 2 empty lines
+                    start = 2 * ['']
+                f.write('\n'.join(start))
+                f.write('\n')
+                f.write(output)
+                f.write('\n'.join(end))
+        else:
+            print(output, end='')
diff --git a/contrib/test_mklog.py b/contrib/test_mklog.py
new file mode 100755
index 00000000000..f5e9ecd577c
--- /dev/null
+++ b/contrib/test_mklog.py
@@ -0,0 +1,487 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import unittest
+
+from mklog import generate_changelog
+
+import unidiff
+
+unidiff_supports_renaming = hasattr(unidiff.PatchedFile(), 'is_rename')
+
+
+PATCH1 = '''\
+diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
+index 567c23380fe..e6209ede9d6 100644
+--- a/gcc/config/riscv/riscv.h
++++ b/gcc/config/riscv/riscv.h
+@@ -920,6 +920,7 @@ extern unsigned riscv_stack_boundary;
+ #define SHIFT_RS1 15
+ #define SHIFT_IMM 20
+ #define IMM_BITS 12
++#define C_S_BITS 5
+ #define C_SxSP_BITS 6
+ 
+ #define IMM_REACH (1LL << IMM_BITS)
+@@ -929,6 +930,10 @@ extern unsigned riscv_stack_boundary;
+ #define SWSP_REACH (4LL << C_SxSP_BITS)
+ #define SDSP_REACH (8LL << C_SxSP_BITS)
+ 
++/* This is the maximum value that can be represented in a compressed load/store
++   offset (an unsigned 5-bit value scaled by 4).  */
++#define CSW_MAX_OFFSET ((4LL << C_S_BITS) - 1) & ~3
++
+ /* Called from RISCV_REORG, this is defined in riscv-sr.c.  */
+ 
+ extern void riscv_remove_unneeded_save_restore_calls (void);
+
+'''
+
+EXPECTED1 = '''\
+gcc/ChangeLog:
+
+	* config/riscv/riscv.h (C_S_BITS):
+	(CSW_MAX_OFFSET):
+
+'''
+
+PATCH2 = '''\
+diff --git a/gcc/targhooks.h b/gcc/targhooks.h
+index 9704d23f1db..b572a36e8cf 100644
+--- a/gcc/targhooks.h
++++ b/gcc/targhooks.h
+@@ -120,7 +120,7 @@ extern bool default_empty_mask_is_expensive (unsigned);
+ extern void *default_init_cost (class loop *);
+ extern unsigned default_add_stmt_cost (class vec_info *, void *, int,
+ 				       enum vect_cost_for_stmt,
+-				       class _stmt_vec_info *, int,
++				       class _stmt_vec_info *, tree, int,
+ 				       enum vect_cost_model_location);
+ extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);
+ extern void default_destroy_cost_data (void *);
+@@ -186,6 +186,7 @@ extern tree default_emutls_var_init (tree, tree, tree);
+ extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);
+ extern bool default_hard_regno_scratch_ok (unsigned int);
+ extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);
++extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);
+ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);
+ extern bool default_target_option_pragma_parse (tree, tree);
+ extern bool default_target_can_inline_p (tree, tree);
+
+'''
+
+EXPECTED2 = '''\
+gcc/ChangeLog:
+
+	* targhooks.h (default_add_stmt_cost):
+	(default_new_address_profitable_p):
+
+'''
+
+PATCH3 = '''\
+diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
+index 2b1e33f94ae..7f47402f9b9 100644
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -173,7 +173,7 @@ enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_GNUC11, CLK_GNUC17, CLK_GNUC2X,
+ 	     CLK_STDC2X,
+ 	     CLK_GNUCXX, CLK_CXX98, CLK_GNUCXX11, CLK_CXX11,
+ 	     CLK_GNUCXX14, CLK_CXX14, CLK_GNUCXX17, CLK_CXX17,
+-	     CLK_GNUCXX2A, CLK_CXX2A, CLK_ASM};
++	     CLK_GNUCXX20, CLK_CXX20, CLK_ASM};
+ 
+ /* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */
+ struct GTY(()) cpp_string {
+@@ -484,7 +484,7 @@ struct cpp_options
+   /* Nonzero for C2X decimal floating-point constants.  */
+   unsigned char dfp_constants;
+ 
+-  /* Nonzero for C++2a __VA_OPT__ feature.  */
++  /* Nonzero for C++20 __VA_OPT__ feature.  */
+   unsigned char va_opt;
+ 
+   /* Nonzero for the '::' token.  */
+
+'''
+
+EXPECTED3 = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h (enum c_lang):
+	(struct cpp_options):
+
+'''
+
+EXPECTED3B = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h:
+
+'''
+
+PATCH4 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index aab79492357..f0df1002488 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -1,5 +1,7 @@
+ 
+ 
++
++
+ /* Interprocedural Identical Code Folding pass
+    Copyright (C) 2014-2020 Free Software Foundation, Inc.
+ 
+diff --git a/gcc/testsuite/gcc.dg/pr32374.c b/gcc/testsuite/gcc.dg/pr32374.c
+deleted file mode 100644
+index de15d559f5b..00000000000
+--- a/gcc/testsuite/gcc.dg/pr32374.c
++++ /dev/null
+@@ -1,20 +0,0 @@
+-/* { dg-do compile } */
+-/* { dg-options "-O2" } */
+-
+-extern int *stderr;
+-
+-void f (int *, const char *, ...);
+-
+-void g (const char *conf_name)
+-{
+-  typedef struct
+-  {
+-    const char *label;
+-    const int value;
+-  } Section;
+-
+-  const Section sections[2] = { {"", 0}, {"", 1} };
+-
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-}
+diff --git a/gcc/testsuite/gcc.dg/pr40209.c b/gcc/testsuite/gcc.dg/pr40209.c
+index 4e77df5c2e6..c23d69d1f1b 100644
+--- a/gcc/testsuite/gcc.dg/pr40209.c
++++ b/gcc/testsuite/gcc.dg/pr40209.c
+@@ -1,6 +1,8 @@
+ /* { dg-do compile } */
+ /* { dg-options "-O2 -fprofile-use -fopt-info -Wno-missing-profile" } */
+ 
++
++
+ void process(const char *s);
+ 
+ struct BaseHolder {
+diff --git a/gcc/testsuite/gcc.dg/pr50209.c b/gcc/testsuite/gcc.dg/pr50209.c
+new file mode 100644
+index 00000000000..b28b04f6431
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/pr50209.c
+@@ -0,0 +1,3 @@
++
++
++
+diff --git a/gcc/testsuite/gcc.dg/pr63567-1.c b/gcc/testsuite/gcc.dg/pr63567-1.c
+index 97da171563e..00c5ecc11fa 100644
+--- a/gcc/testsuite/gcc.dg/pr63567-1.c
++++ b/gcc/testsuite/gcc.dg/pr63567-1.c
+@@ -1,3 +1,4 @@
++
+ /* PR c/63567 */
+ /* { dg-do compile } */
+ /* { dg-options "" } */
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index f062e48071f..fd3c7ca8cf3 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1,3 +1,5 @@
++
++
+ /* Output variables, constants and external declarations, for GNU compiler.
+    Copyright (C) 1987-2020 Free Software Foundation, Inc.
+ 
+diff --git a/libssp/gets-chk.c b/libssp/gets-chk.c
+index 4ad78c1f77b..6687b368038 100644
+--- a/libssp/gets-chk.c
++++ b/libssp/gets-chk.c
+@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ 
++
++
+ #include "config.h"
+ #include <ssp/ssp.h>
+ #include <stdarg.h>
+'''
+
+EXPECTED4 = '''\
+
+	PR 50209
+
+gcc/ChangeLog:
+
+	* ipa-icf.c:
+	* varasm.c:
+
+libssp/ChangeLog:
+
+	* gets-chk.c:
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.dg/pr40209.c:
+	* gcc.dg/pr63567-1.c:
+	* gcc.dg/pr32374.c: Removed.
+	* gcc.dg/pr50209.c: New test.
+
+'''
+
+PATCH5 = '''\
+diff --git a/gcc/testsuite/gcc.target/i386/pr95046-6.c b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+new file mode 100644
+index 00000000000..dcc8999c446
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+@@ -0,0 +1,44 @@
++/* PR target/95046 */
++/* { dg-do compile { target { ! ia32 } } } */
++/* { dg-options "-O3 -mavx512vl" } */
++
++
++double r[2];
++int s[2];
++unsigned int u[2];
++
++void
++test_float (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = s[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtdq2pd" } } */
++
++void
++test_ufloat (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = u[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtudq2pd" } } */
++
++void
++test_fix (void)
++{
++  for (int i = 0; i < 2; i++)
++    s[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2dqx" } } */
++
++void
++test_ufix (void)
++{
++  for (int i = 0; i < 2; i++)
++    u[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2udqx" } } */
+-- 
+2.26.2
+
+'''
+
+EXPECTED5 = '''\
+PR target/95046 - Vectorize V2SFmode operations
+
+	PR target/95046
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/i386/pr95046-6.c: New test.
+
+'''
+
+PATCH6 = '''\
+diff --git a/gcc/cgraph.h b/gcc/cgraph.h
+index 5ddeb65269b..cfae6e91da9 100644
+--- a/gcc/cgraph.h
++++ b/gcc/cgraph.h
+@@ -937,7 +937,8 @@ struct GTY((tag ("SYMTAB_FUNCTION"))) cgraph_node : public symtab_node
+       split_part (false), indirect_call_target (false), local (false),
+       versionable (false), can_change_signature (false),
+       redefined_extern_inline (false), tm_may_enter_irr (false),
+-      ipcp_clone (false), m_uid (uid), m_summary_id (-1)
++      ipcp_clone (false), declare_variant_alt (false),
++      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)
+   {}
+ 
+   /* Remove the node from cgraph and all inline clones inlined into it.
+
+'''
+
+EXPECTED6 = '''\
+gcc/ChangeLog:
+
+	* cgraph.h (struct cgraph_node):
+
+'''
+
+PATCH7 = '''\
+diff --git a/gcc/testsuite/g++.dg/DRs/dr2237.C b/gcc/testsuite/g++.dg/DRs/dr2237.C
+new file mode 100644
+index 00000000000..f3d6d11e61e
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/DRs/dr2237.C
+@@ -0,0 +1,18 @@
++// DR 2237 - Can a template-id name a constructor?
++
++template<class T>
++struct X {
++  X<T>(); // { dg-error "expected" "" { target c++20 } }
++  X(int); // OK, injected-class-name used
++  ~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
++
++// ill-formed since DR1435
++template<typename T> X<T>::X<T>() {} // { dg-error "names the constructor|as no template constructors" }
++template<typename T> X<T>::~X<T>() {} // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++
++struct Q {
++  // ill-formed since DR1435
++  template<typename T> friend X<T>::X<T>(); // { dg-error "names the constructor|as no template constructors" }
++  template<typename T> friend X<T>::~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
+'''
+
+EXPECTED7 = '''\
+
+	DR 2237
+
+gcc/testsuite/ChangeLog:
+
+	* g++.dg/DRs/dr2237.C: New test.
+
+'''
+
+PATCH8 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf2.c
+similarity index 100%
+rename from gcc/ipa-icf.c
+rename to gcc/ipa-icf2.c
+'''
+
+EXPECTED8 = '''\
+gcc/ChangeLog:
+
+	* ipa-icf.c: Moved to...
+	* ipa-icf2.c: ...here.
+
+'''
+
+PATCH9 = '''\
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 2a260c1cfbd..7f03fc491c3 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -17611,6 +17611,23 @@ (define_insn "avx2_<code>v16qiv16hi2<mask_name>"
+    (set_attr "prefix" "maybe_evex")
+    (set_attr "mode" "OI")])
+ 
++(define_insn_and_split "*avx2_zero_extendv16qiv16hi2_1"
++  [(set (match_operand:V32QI 0 "register_operand" "=v")
++	(vec_select:V32QI
++	  (vec_concat:V64QI
++	    (match_operand:V32QI 1 "nonimmediate_operand" "vm")
++	    (match_operand:V32QI 2 "const0_operand" "C"))
++	  (match_parallel 3 "pmovzx_parallel"
++	    [(match_operand 4 "const_int_operand" "n")])))]
++  "TARGET_AVX2"
++  "#"
++  "&& reload_completed"
++  [(set (match_dup 0) (zero_extend:V16HI (match_dup 1)))]
++{
++  operands[0] = lowpart_subreg (V16HImode, operands[0], V32QImode);
++  operands[1] = lowpart_subreg (V16QImode, operands[1], V32QImode);
++})
++
+ (define_expand "<insn>v16qiv16hi2"
+   [(set (match_operand:V16HI 0 "register_operand")
+ 	(any_extend:V16HI
+'''
+
+EXPECTED9 = '''\
+gcc/ChangeLog:
+
+	* config/i386/sse.md (*avx2_zero_extendv16qiv16hi2_1):
+
+'''
+
+class TestMklog(unittest.TestCase):
+    def test_macro_definition(self):
+        changelog = generate_changelog(PATCH1)
+        assert changelog == EXPECTED1
+
+    def test_changed_argument(self):
+        changelog = generate_changelog(PATCH2)
+        assert changelog == EXPECTED2
+
+    def test_enum_and_struct(self):
+        changelog = generate_changelog(PATCH3)
+        assert changelog == EXPECTED3
+
+    def test_no_function(self):
+        changelog = generate_changelog(PATCH3, True)
+        assert changelog == EXPECTED3B
+
+    def test_sorting(self):
+        changelog = generate_changelog(PATCH4)
+        assert changelog == EXPECTED4
+
+    def test_pr_bugzilla_download(self):
+        changelog = generate_changelog(PATCH5, fill_pr_titles=True)
+        assert changelog == EXPECTED5
+
+    def test_gty_in_struct(self):
+        changelog = generate_changelog(PATCH6, fill_pr_titles=True)
+        assert changelog == EXPECTED6
+
+    def test_dr_detection_in_test_case(self):
+        changelog = generate_changelog(PATCH7)
+        assert changelog == EXPECTED7
+
+    @unittest.skipIf(not unidiff_supports_renaming,
+                     'Newer version of unidiff is needed (0.6.0+)')
+    def test_renaming(self):
+        changelog = generate_changelog(PATCH8)
+        assert changelog == EXPECTED8
+
+    def test_define_macro_parsing(self):
+        changelog = generate_changelog(PATCH9)
+        assert changelog == EXPECTED9
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 8148c559489..ccfb75e5120 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.4.0
+9.4.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 7558c0a369e..daf4de3bc47 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,1076 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* asan.c (asan_redzone_buffer::emit_redzone_byte): Handle the case
+	where offset is bigger than off but smaller than m_prev_offset + 32
+	bits by pushing one or more 0 bytes.  Sink the
+	m_shadow_bytes.safe_push (value); flush_if_full (); statements from
+	all cases to the end of the function.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* config/sparc/sparc.c (epilogue_renumber): If ORIGINAL_REGNO,
+	use gen_raw_REG instead of gen_rtx_REG and copy over also
+	ORIGINAL_REGNO.  Use return 0; instead of /* fallthrough */.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105214
+	* config/i386/i386.c (ix86_emit_i387_log1p): Call
+	do_pending_stack_adjust.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105211
+	* builtins.c (expand_builtin_int_roundingfn_2): If mathfn_built_in_1
+	fails for TREE_TYPE (arg), retry it with
+	TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl))) and if even that
+	fails, emit call normally.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105189
+	* fold-const.c (make_range_step): Fix up handling of
+	(unsigned) x +[low, -] ranges for signed x if low fits into
+	typeof (x).
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/104985
+	* combine.c (struct undo): Add where.regno member.
+	(do_SUBST_MODE): Rename to ...
+	(subst_mode): ... this.  Change first argument from rtx * into int,
+	operate on regno_reg_rtx[regno] and save regno into where.regno.
+	(SUBST_MODE): Remove.
+	(try_combine): Use subst_mode instead of SUBST_MODE, change first
+	argument from regno_reg_rtx[whatever] to whatever.  For UNDO_MODE, use
+	regno_reg_rtx[undo->where.regno] instead of *undo->where.r.
+	(undo_to_marker): For UNDO_MODE, use regno_reg_rtx[undo->where.regno]
+	instead of *undo->where.r.
+	(simplify_set): Use subst_mode instead of SUBST_MODE, change first
+	argument from regno_reg_rtx[whatever] to whatever.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105123
+	* config/i386/i386.c (ix86_expand_vector_init_general): Avoid
+	using word as target for expand_simple_binop when doing ASHIFT and
+	IOR.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105093
+	* ubsan.c (instrument_object_size): If t is equal to inner and
+	is a decl other than global var, punt.  When emitting call to
+	UBSAN_OBJECT_SIZE ifn, make sure base is addressable.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/104971
+	* config/i386/i386.c
+	(ix86_expand_builtin) <case IX86_BUILTIN_READ_FLAGS>: If ignore,
+	don't push/pop anything and just return const0_rtx.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104711
+	* doc/invoke.texi (-Wextra): Document that -Wshift-negative-value
+	is enabled by it only for C++11 to C++17 rather than for C++03 or
+	later.
+	(-Wshift-negative-value): Similarly (except here we stated
+	that it is enabled for C++11 or later).
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104775
+	* config/s390/s390.md (*cmp_and_trap_unsigned_int<mode>): Use
+	S constraint instead of T in the last alternative.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+		    Marc Glisse  <marc.glisse@inria.fr>
+
+	PR tree-optimization/104675
+	* match.pd (t * 2U / 2 -> t & (~0 / 2), t / 2U * 2 -> t & ~1):
+	Restrict simplifications to INTEGRAL_TYPE_P.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104681
+	* config/rs6000/vector.md (movmisalign<mode>): Use rs6000_emit_move.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/104675
+	* match.pd (-A - 1 -> ~A, -1 - A -> ~A): Don't simplify for
+	COMPLEX_TYPE.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/104557
+	* valtrack.c (debug_lowpart_subreg): Don't call gen_rtx_raw_SUBREG
+	if expr has VOIDmode.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/104517
+	* omp-low.c (task_cpyfns): New variable.
+	(delete_omp_context): Don't call finalize_task_copyfn from here.
+	(create_task_copyfn): Push task_stmt into task_cpyfns.
+	(execute_lower_omp): Call finalize_task_copyfn here on entries from
+	task_cpyfns vector and release the vector.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/104449
+	* asan.c: Include tree-eh.h.
+	(handle_builtin_alloca): Handle the case when __builtin_alloca or
+	__builtin_alloca_with_align can throw.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104502
+	* config/i386/i386.md (cvtsd2ss splitter): If operands[1] is xmm16+
+	and AVX512VL isn't available, move operands[1] to operands[0] first.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/104446
+	* combine.c (subst): Don't substitute CONST_INTs into RTX_AUTOINC
+	operands.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102140
+	* config/rs6000/rs6000.c (vspltis_shifted): Return false also if
+	split1 pass has finished already.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/102478
+	* optabs.c (prepare_cmp_insn): If !can_create_pseudo_p (), don't
+	force_reg constants and for -fnon-call-exceptions fail if copy_to_reg
+	would be needed.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/102860
+	* match.pd (x %[fl] y -> x % y): New simplification for
+	unsigned integral types.
+	* optabs-tree.c (optab_for_tree_code): Return unknown_optab
+	for {CEIL,FLOOR,ROUND}_{DIV,MOD}_EXPR with VECTOR_TYPE.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103908
+	* ifcvt.c (bb_valid_for_noce_process_p): Punt on bbs ending with
+	asm goto.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103860
+	* shrink-wrap.c (try_shrink_wrapping): Make sure can_get_prologue is
+	called on pro even if nothing further is pushed into vec.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103837
+	* loop-invariant.c (can_move_invariant_reg): Ignore DEBUG_INSNs in
+	the decisions whether to return false or continue and right before
+	returning true reset those debug insns that previously caused
+	returning false.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/103435
+	* gimple-ssa-store-merging.c (find_bswap_or_nop_finalize): Avoid UB if
+	n->range - rsize == 8, just clear both *cmpnop and *cmpxchg in that
+	case.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/103192
+	* tree-ssa-loop-im.c (move_computations_worker): Use
+	reset_flow_sensitive_info instead of manually clearing
+	SSA_NAME_RANGE_INFO and do it for all SSA_NAMEs, not just ones
+	with integral types.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/103205
+	* config/i386/sync.md (atomic_bit_test_and_set<mode>,
+	atomic_bit_test_and_complement<mode>,
+	atomic_bit_test_and_reset<mode>): Use OPTAB_WIDEN instead of
+	OPTAB_DIRECT.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101378
+	* dwarf2out.c (field_byte_offset): Do the PCC_BITFIELD_TYPE_MATTERS
+	handling only for DECL_BIT_FIELD_TYPE decls.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102498
+	* config/i386/i386.c (standard_80387_constant_p): Don't recognize
+	special 80387 instruction XFmode constants if flag_rounding_math.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88578
+	PR c++/102295
+	* varasm.c (output_constructor_regular_field): Instead of assertion
+	that array_size_for_constructor result is equal to size of
+	TREE_TYPE (local->val) in bytes, assert that the type size is greater
+	or equal to array_size_for_constructor result and use type size as
+	fieldsize.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102224
+	* config/i386/i386.md (xorsign<mode>3): If operands[1] is equal to
+	operands[2], emit abs<mode>2 instead.
+	(@xorsign<mode>3_1): Add early-clobber for output operand.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-08-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101905
+	* dwarf2out.c (gen_variable_die): Add DW_AT_location for global
+	register variables already during early_dwarf if possible.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101624
+	* ubsan.c (maybe_instrument_pointer_overflow,
+	instrument_object_size): Only test DECL_REGISTER on VAR_DECLs,
+	PARM_DECLs or RESULT_DECLs.
+	* sanopt.c (maybe_optimize_ubsan_ptr_ifn): Likewise.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/101562
+	* expmed.c (store_integral_bit_field): Only use movstrict_optab
+	if the operand isn't paradoxical.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101535
+	* gimplify.c (omp_check_private): Properly skip ORT_TARGET_DATA
+	contexts in which decl isn't privatized and for ORT_TARGET return
+	false if decl is mapped.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/101384
+	* config/rs6000/rs6000.c (vspltis_constant): Accept EASY_VECTOR_MSB
+	only if step and copies are equal to 1.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94366
+	* omp-low.c (lower_rec_input_clauses): Rename is_fp_and_or to
+	is_truth_op, set it for TRUTH_*IF_EXPR regardless of new_var's type,
+	use boolean_type_node instead of integer_type_node as NE_EXPR type.
+	(lower_reduction_clauses): Likewise.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* omp-low.c (lower_rec_input_clauses, lower_reduction_clauses): Handle
+	&& and || with floating-point and complex arguments.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR go/101407
+	* godump.c (godump_str_hash): New type.
+	(godump_container::pot_dummy_types): Use string_hash instead of
+	ptr_hash in the hash_set.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101266
+	* dwarf2out.c (loc_list_from_tree_1): Handle COMPOUND_LITERAL_EXPR.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101210
+	* match.pd ((intptr_t)x eq/ne CST to x eq/ne (typeof x) CST): Don't
+	perform the optimization in GENERIC when sanitizing and x has a
+	reference type.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101167
+	* omp-low.c (lower_omp_regimplify_p): Regimplify also PARM_DECLs
+	and RESULT_DECLs that have DECL_HAS_VALUE_EXPR_P set.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/100785
+	* cfgexpand.c (expand_asm_stmt): If errors are emitted,
+	remove all inputs, outputs and clobbers from the asm and
+	set template to "".
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101062
+	* stor-layout.c (finish_bitfield_layout): Don't add bitfield
+	representatives in QUAL_UNION_TYPE.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101062
+	* stor-layout.c (finish_bitfield_representative): For fields in unions
+	assume nextf is always NULL.
+	(finish_bitfield_layout): Compute bit field representatives also in
+	unions, but handle it as if each bitfield was the only field in the
+	aggregate.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/101046
+	* expr.c (expand_expr_real_2) <case VEC_PACK_FIX_TRUNC_EXPR,
+	case VEC_PACK_TRUNC_EXPR>: Clear subtarget when changing mode.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100898
+	* tree-inline.c (copy_bb): Only use gimple_call_arg_ptr if memcpy
+	should copy any arguments.  Don't call gimple_call_num_args
+	on id->call_stmt or call_stmt more than once.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/100887
+	* config/i386/i386.c (ix86_expand_vector_init): Handle
+	concatenation from half-sized modes with TImode elements.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100508
+	* cfgexpand.c (expand_debug_expr): For DEBUG_EXPR_DECL with vector
+	type, don't reuse DECL_RTL if it has different mode, instead force
+	creation of a new DEBUG_EXPR.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100471
+	* omp-low.c (lower_omp_task_reductions): For OMP_TASKLOOP, if data
+	is 0, bypass the reduction loop including
+	GOMP_taskgroup_reduction_unregister call.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/105292
+	* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): Return
+	true only for 8-byte vector modes.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105070
+	* tree-switch-conversion.h
+	(bit_test_cluster::hoist_edge_and_branch_if_true): Add location
+	argument.
+	* tree-switch-conversion.c
+	(bit_test_cluster::hoist_edge_and_branch_if_true): Annotate
+	cond with location.
+	(bit_test_cluster::emit): Annotate all generated expressions
+	with location.
+
+2022-05-06  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2021-02-05  Tom de Vries  <tdevries@suse.de>
+
+	PR debug/98656
+	* tree-switch-conversion.c (jump_table_cluster::emit): Add loc
+	argument.
+	(bit_test_cluster::emit): Reuse location_t for newly created
+	gswitch statement.
+	(switch_decision_tree::try_switch_expansion): Preserve
+	location_t.
+	* tree-switch-conversion.h: Change function signatures.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-03-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104786
+	* cfgexpand.c (expand_asm_stmt): Do not generate a copy
+	for VLAs without an upper size bound.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103361
+	* gimple-loop-jam.c (adjust_unroll_factor): Use lambda_int
+	for the dependence distance.
+	* tree-data-ref.c (print_lambda_vector): Properly print a lambda_int.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-01-20  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100786
+	* gimple-fold.c (get_symbol_constant_value): Only return
+	values of compatible type to the symbol.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* config/i386/avx512fintrin.h (_mm512_scalef_round_pd):
+	Add parentheses for parameters and djust format.
+	(_mm512_mask_scalef_round_pd): Ditto.
+	(_mm512_maskz_scalef_round_pd): Ditto.
+	(_mm512_scalef_round_ps): Ditto.
+	(_mm512_mask_scalef_round_ps): Ditto.
+	(_mm512_maskz_scalef_round_ps): Ditto.
+	(_mm_scalef_round_sd): Use _mm_undefined_pd.
+	(_mm_scalef_round_ss): Use _mm_undefined_ps.
+	(_mm_mask_scalef_round_sd): New macro.
+	(_mm_mask_scalef_round_ss): Ditto.
+	(_mm_maskz_scalef_round_sd): Ditto.
+	(_mm_maskz_scalef_round_ss): Ditto.
+
+2022-04-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99977
+	* config/arm/arm.c (arm_split_compare_and_swap): Fix up codegen
+	with negative immediates: ensure we expand cbranchsi4_scratch
+	correctly and ensure we satisfy its constraints.
+	* config/arm/sync.md
+	(@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1): Don't
+	attempt to tie two output operands together with constraints;
+	collapse two alternatives.
+	(@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1): Likewise.
+	* config/arm/thumb1.md (cbranchsi4_neg_late): New.
+
+2022-03-30  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2020-10-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/97456
+	PR middle-end/105071
+	* tree-complex.c (set_component_ssa_name): Do not replace ignored decl
+	default definitions with new component vars.  Reorder if conditions.
+
+2022-03-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR target/104453
+	* config/i386/i386.c (ix86_gimple_fold_builtin): Guard shift
+	folding for NULL LHS.
+
+2022-02-18  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-09-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97043
+	* tree-vect-slp.c (vect_analyze_slp_instance): Do not
+	elide a load permutation if the current vectorization
+	factor is one.
+
+2022-02-18  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96522
+	* tree-ssa-address.c (copy_ref_info): Reset flow-sensitive
+	info of the copied points-to.  Transfer bigger alignment
+	via the access type.
+	* tree-ssa-sccvn.c (eliminate_dom_walker::eliminate_stmt):
+	Reset all flow-sensitive info.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/102798
+	* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):
+	Only copy points-to info to newly generated SSA names.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/103181
+	PR middle-end/103248
+	* tree-eh.c (operation_could_trap_helper_p): Properly
+	check vector constants for a zero element for integer
+	division.  Separate floating point and integer division code.
+	Properly handle fixed-point RDIV_EXPR.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103237
+	* tree-vect-loop.c (vect_is_simple_reduction): Fail for
+	double reductions with multiple inner loop LC PHI nodes.
+
+2022-02-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-02-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/104469
+	* config/i386/sse.md (vec_unpacks_float_lo_v4si):
+	Change operand 1 constraint to register_operand.
+
+2022-02-09  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/104451
+	* config/i386/sse.md (<insn><mode>3): lowpart_subreg
+	operands[2] from SImode to QImode.
+
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gimple-ssa-evrp-analyze.c
+	(evrp_range_analyzer::record_ranges_from_incoming_edge): Make
+	sure the condition post-dominates the SSA definition before
+	recording into SSA_NAME_RANGE_INFO.
+
+2022-01-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/103465
+	* coretypes.h (unwind_info_type): Swap UI_SEH and UI_TARGET.
+
+2022-01-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (%X): Remove obsolete reference to -Wl.
+
+2021-12-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR target/100985
+	* config/aarch64/arm_acle.h: Remove unclosed extern "C" block.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* config/rs6000/rs6000.c (rs6000_builtin_decl): Remove builtin mask
+	check.
+
+2021-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/103267
+	* tree-sra.c (scan_function): Also check ECF_LOOPING_CONST_OR_PURE
+	flag.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* ipa-pure-const.c (propagate_pure_const): Fix merging of loping flag.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* config/rs6000/altivec.h (vec_cpsgn): Swap operand order.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config/s390/s390.md (define_peephole2): Variable insn points
+	to the first matched insn.  Use peep2_next_insn(1) to refer to
+	the second matched insn.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* fold-const.c (fold_negate_expr_1): Use element_precision.
+	(negate_expr_p): Likewise.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* tree-ssa-pre.c (prune_clobbered_mems): Also prune trapping
+	references when the BB may not return.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* tree-nested.c (get_frame_field): Mark the COMPONENT_REF as
+	volatile in case the variable was.
+
+2021-11-08  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-10-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR tree-optimization/102789
+	* tree-vect-loop-manip.c (vect_update_inits_of_drs): Do not
+	update inits of simd_lane_access.
+
+2021-10-26  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	Backported from master:
+	2021-10-16  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	* configure.ac: Treat powerpc64*-*-freebsd* the same as
+	powerpc64-*-freebsd*.
+	* configure: Regenerate.
+
+2021-10-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Don't use 'G' constraint in integer move patterns.
+
+2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/98667
+	* doc/invoke.texi: Document -fcf-protection requires i686 or
+	new.
+
+2021-10-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Consistently use "rG" constraint for copy
+	instruction in move patterns.
+
+2021-10-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (cbranchsf4): Disable if TARGET_SOFT_FLOAT.
+	(cbranchdf4): Likewise.
+	Add missing move patterns for TARGET_SOFT_FLOAT.
+
+2021-10-13  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (muldi3): Add support for inlining 64-bit
+	multiplication on 32-bit PA 1.1 and 2.0 targets.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gimple-loop-interchange.cc
+	(tree_loop_interchange::valid_data_dependences): Properly
+	guard all dependence checks with DDR_REVERSED_P or its
+	inverse.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* tree-ssa-pre.c (do_pre_regular_insertion): Avoid inserting
+	copies from abnormals for a full redundancy.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Only ignore steps when they are equal or scalar order is preserved.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* tree-ssa-dom.c (pass_dominator::execute): Properly
+	mark irreducible regions.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gimple-fold.c (fold_gimple_assign): Only call
+	get_symbol_constant_value on register type symbols.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* tree-ssa-phiopt.c (conditional_replacement): Set neg
+	to false for one bit signed types.
+
+2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	Backported from master:
+	2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	* doc/invoke.texi: Add link to UndefinedBehaviorSanitizer
+	documentation, mention UBSAN_OPTIONS, similar to what is done
+	for AddressSanitizer.
+
+2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	* ipa-fnsummary.c (inline_read_section): Unpack a dummy bit
+	to keep consistent with the side of streaming out.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/102306
+	* combine.c (try_combine): Abort the combination if we are about to
+	duplicate volatile references.
+
+2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/60318
+	* doc/trouble.texi (Copy Assignment): Fix description of
+	behaviour and fix code in example.
+
+2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* tree.c (walk_tree_1) <OMP_CLAUSE_TILE>: Handle three operands.
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* config/i386/avx512dqintrin.h (_mm512_fpclass_ps_mask): Fix
+	macro define in O0.
+	(_mm512_mask_fpclass_ps_mask): Ditto.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* config/arm/arm-cpus.in (quirk_no_asmcpu): New feature bit.
+	(ALL_QUIRKS): Add it.
+	(generic-armv7-a): Add quirk to suppress writing .cpu directive in
+	asm output.
+	* config/arm/arm.c (arm_identify_fpu_from_isa): New variable.
+	(arm_last_printed_arch_string): Delete.
+	(arm_last-printed_fpu_string): Delete.
+	(arm_configure_build_target): If use of floating-point/SIMD is
+	disabled, remove all fp/simd related features from the target ISA.
+	(last_arm_targ_options): New variable.
+	(arm_print_asm_arch_directives): Add new parameters.  Change order
+	of emitted directives and handle all cases here.
+	(arm_file_start): Always call arm_print_asm_arch_directives, move
+	all generation of .arch/.arch_extension here.
+	(arm_file_end): Call arm_print_asm_arch.
+	(arm_declare_function_name): Call arm_print_asm_arch_directives
+	instead of printing .arch/.fpu directives directly.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Don't call
+	arm_option_reconfigure_globals.
+	(arm_option_restore): Call arm_option_reconfigure_globals after
+	reconfiguring the target.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Ensure the target's
+	arch_name is always set.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2019-12-11  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm-cpus.in (ALL_SIMD_EXTERNAL): New fgroup.
+	(ALL_SIMD): Use it.
+	(ALL_FPU_EXTERNAL): New fgroup.
+	(ALL_FP): Use it.
+	(cortex-a55, cortex-a75, cortex-a76): Remove redundant
+	+simd from architecture specification.
+	(neoverse-n1, cortex-a75.cortex-a55): Likewise.
+	* config/arm/arm.c (isa_all_fpubits, fpu_bitlist): Rename to ...
+	(isa_all_fpubits_internal, fpu_bitlist_internal): ... these.
+	(isa_all_fpbits): New bitmap.
+	(arm_option_override): Initialize it.
+	(arm_configure_build_target): If the target isa does not have any
+	FP enabled, do not warn about mismatches in FP-related feature bits.
+
+2021-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-05-27  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/100767
+	* config/arm/arm.c (arm_configure_build_target): Remove parameter
+	opts_set, directly check opts parameters for being non-null.
+	(arm_option_restore): Update call to arm_configure_build_target.
+	(arm_option_override): Likewise.
+	(arm_can_inline_p): Likewise.
+	(arm_valid_target_attribute_tree): Likewise.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+	* config/arm/arm-protos.h (arm_configure_build_target): Adjust
+	prototype.
+
+2021-08-17  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-03  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* doc/invoke.texi: Document -mtune=neoverse-512tvb and
+	-mcpu=neoverse-512tvb.
+	* config/aarch64/aarch64-cores.def (neoverse-512tvb): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+
+2021-07-31  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	Backported from master:
+	2021-07-30  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	PR target/94780
+	* config/mips/mips.c (mips_atomic_assign_expand_fenv): Use
+	  TARGET_EXPR instead of MODIFY_EXPR.
+
+2021-07-20  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* config/i386/sync.md (define_peephole2 atomic_storedi_fpu):
+	Remove.
+	(define_peephole2 atomic_loaddi_fpu): Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* config/rs6000/rs6000-p8swap.c (has_part_mult): New.
+	(rs6000_analyze_swaps): Insns containing a subreg of a mult are
+	not swappable.
+
+2021-07-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2021-04-18  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/99927
+	* combine.c (distribute_notes) [REG_UNUSED]: If the register already
+	is dead, just drop it.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* config/i386/i386.md (bsr_rex64): Add zero-flag setting RTX.
+	(bsr): Ditto.
+	(*bsrhi): Remove.
+	(clz<mode>2): Update RTX pattern for additions.
+
+2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	Backported from master:
+	2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	PR target/100871
+	* config/s390/vecintrin.h (vec_doublee): Fix to use
+	  __builtin_s390_vflls.
+	(vec_floate): Fix to use __builtin_s390_vflrd.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 75713e9bfba..9c6ac5447f5 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,13 @@
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): For vector types, make
+	the representative array the debug type.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (update_pointer_to): Set TYPE_CANONICAL on
+	pointer and reference types.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index de43c66b77c..0af1c7112ed 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -4646,6 +4646,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
       else
 	gnu_decl = create_type_decl (gnu_entity_name, gnu_type, artificial_p,
 				     debug_info_p, gnat_entity);
+
+      /* For vector types, make the representative array the debug type.  */
+      if (VECTOR_TYPE_P (gnu_type))
+	{
+	  tree rep = TYPE_REPRESENTATIVE_ARRAY (gnu_type);
+	  TYPE_NAME (rep) = DECL_NAME (gnu_decl);
+	  SET_TYPE_DEBUG_TYPE (gnu_type, rep);
+	}
     }
 
   /* Otherwise, for a type reusing an existing DECL, back-annotate values.  */
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
index 882802a19e4..acfb60c3e37 100644
--- a/gcc/ada/gcc-interface/utils.c
+++ b/gcc/ada/gcc-interface/utils.c
@@ -4144,6 +4144,7 @@ update_pointer_to (tree old_type, tree new_type)
 	    TREE_TYPE (t) = new_type;
 	    if (TYPE_NULL_BOUNDS (t))
 	      TREE_TYPE (TREE_OPERAND (TYPE_NULL_BOUNDS (t), 0)) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_POINTER_TO (new_type));
 	  }
 
       /* Chain REF and its variants at the end.  */
@@ -4160,7 +4161,10 @@ update_pointer_to (tree old_type, tree new_type)
       /* Now adjust them.  */
       for (; ref; ref = TYPE_NEXT_REF_TO (ref))
 	for (t = TYPE_MAIN_VARIANT (ref); t; t = TYPE_NEXT_VARIANT (t))
-	  TREE_TYPE (t) = new_type;
+	  {
+	    TREE_TYPE (t) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_REFERENCE_TO (new_type));
+	  }
 
       TYPE_POINTER_TO (old_type) = NULL_TREE;
       TYPE_REFERENCE_TO (old_type) = NULL_TREE;
diff --git a/gcc/asan.c b/gcc/asan.c
index 7c392547c0e..91c70c6325d 100644
--- a/gcc/asan.c
+++ b/gcc/asan.c
@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "builtins.h"
 #include "fnmatch.h"
 #include "tree-inline.h"
+#include "tree-eh.h"
 
 /* AddressSanitizer finds out-of-bounds and use-after-free bugs
    with <2x slowdown on average.
@@ -623,14 +624,24 @@ handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)
 
   tree last_alloca = get_last_alloca_addr ();
   tree callee = gimple_call_fndecl (call);
+  tree lhs = gimple_call_lhs (call);
   tree old_size = gimple_call_arg (call, 0);
-  tree ptr_type = gimple_call_lhs (call) ? TREE_TYPE (gimple_call_lhs (call))
-					 : ptr_type_node;
+  tree ptr_type = lhs ? TREE_TYPE (lhs) : ptr_type_node;
   tree partial_size = NULL_TREE;
   unsigned int align
     = DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA
       ? 0 : tree_to_uhwi (gimple_call_arg (call, 1));
 
+  bool throws = false;
+  edge e = NULL;
+  if (stmt_can_throw_internal (cfun, call))
+    {
+      if (!lhs)
+	return;
+      throws = true;
+      e = find_fallthru_edge (gsi_bb (*iter)->succs);
+    }
+
   /* If ALIGN > ASAN_RED_ZONE_SIZE, we embed left redzone into first ALIGN
      bytes of allocated space.  Otherwise, align alloca to ASAN_RED_ZONE_SIZE
      manually.  */
@@ -687,29 +698,54 @@ handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)
 			  build_int_cst (size_type_node, align));
   tree new_alloca_with_rz = make_ssa_name (ptr_type, gg);
   gimple_call_set_lhs (gg, new_alloca_with_rz);
-  gsi_insert_before (iter, gg, GSI_SAME_STMT);
+  if (throws)
+    {
+      gimple_call_set_lhs (call, NULL);
+      gsi_replace (iter, gg, true);
+    }
+  else
+    gsi_insert_before (iter, gg, GSI_SAME_STMT);
 
   /* new_alloca = new_alloca_with_rz + align.  */
   g = gimple_build_assign (make_ssa_name (ptr_type), POINTER_PLUS_EXPR,
 			   new_alloca_with_rz,
 			   build_int_cst (size_type_node,
 					  align / BITS_PER_UNIT));
-  gsi_insert_before (iter, g, GSI_SAME_STMT);
+  gimple_stmt_iterator gsi = gsi_none ();
+  if (throws)
+    {
+      gsi_insert_on_edge_immediate (e, g);
+      gsi = gsi_for_stmt (g);
+    }
+  else
+    gsi_insert_before (iter, g, GSI_SAME_STMT);
   tree new_alloca = gimple_assign_lhs (g);
 
   /* Poison newly created alloca redzones:
       __asan_alloca_poison (new_alloca, old_size).  */
   fn = builtin_decl_implicit (BUILT_IN_ASAN_ALLOCA_POISON);
   gg = gimple_build_call (fn, 2, new_alloca, old_size);
-  gsi_insert_before (iter, gg, GSI_SAME_STMT);
+  if (throws)
+    gsi_insert_after (&gsi, gg, GSI_NEW_STMT);
+  else
+    gsi_insert_before (iter, gg, GSI_SAME_STMT);
 
   /* Save new_alloca_with_rz value into last_alloca to use it during
      allocas unpoisoning.  */
   g = gimple_build_assign (last_alloca, new_alloca_with_rz);
-  gsi_insert_before (iter, g, GSI_SAME_STMT);
+  if (throws)
+    gsi_insert_after (&gsi, g, GSI_NEW_STMT);
+  else
+    gsi_insert_before (iter, g, GSI_SAME_STMT);
 
   /* Finally, replace old alloca ptr with NEW_ALLOCA.  */
-  replace_call_with_value (iter, new_alloca);
+  if (throws)
+    {
+      g = gimple_build_assign (lhs, new_alloca);
+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);
+    }
+  else
+    replace_call_with_value (iter, new_alloca);
 }
 
 /* Return the memory references contained in a gimple statement
@@ -1270,10 +1306,14 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
   HOST_WIDE_INT off
     = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();
   if (off == offset)
+    /* Consecutive shadow memory byte.  */;
+  else if (offset < m_prev_offset + (HOST_WIDE_INT) (ASAN_SHADOW_GRANULARITY
+						     * RZ_BUFFER_SIZE)
+	   && !m_shadow_bytes.is_empty ())
     {
-      /* Consecutive shadow memory byte.  */
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
+      /* Shadow memory byte with a small gap.  */
+      for (; off < offset; off += ASAN_SHADOW_GRANULARITY)
+	m_shadow_bytes.safe_push (0);
     }
   else
     {
@@ -1294,9 +1334,9 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
       m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,
 				     diff >> ASAN_SHADOW_SHIFT);
       m_prev_offset = offset;
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
     }
+  m_shadow_bytes.safe_push (value);
+  flush_if_full ();
 }
 
 /* Emit RTX emission of the content of the buffer.  */
diff --git a/gcc/builtins.c b/gcc/builtins.c
index 39ba87a6759..697729de692 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -2897,16 +2897,28 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)
 	 BUILT_IN_IROUND and if __builtin_iround is called directly, emit
 	 a call to lround in the hope that the target provides at least some
 	 C99 functions.  This should result in the best user experience for
-	 not full C99 targets.  */
-      tree fallback_fndecl = mathfn_built_in_1
-	(TREE_TYPE (arg), as_combined_fn (fallback_fn), 0);
-
-      exp = build_call_nofold_loc (EXPR_LOCATION (exp),
-				   fallback_fndecl, 1, arg);
+	 not full C99 targets.
+	 As scalar float conversions with same mode are useless in GIMPLE,
+	 we can end up e.g. with _Float32 argument passed to float builtin,
+	 try to get the type from the builtin prototype first.  */
+      tree fallback_fndecl = NULL_TREE;
+      if (tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl)))
+        fallback_fndecl
+          = mathfn_built_in_1 (TREE_VALUE (argtypes),
+			       as_combined_fn (fallback_fn), 0);
+      if (fallback_fndecl == NULL_TREE)
+	fallback_fndecl
+	  = mathfn_built_in_1 (TREE_TYPE (arg),
+			       as_combined_fn (fallback_fn), 0);
+      if (fallback_fndecl)
+	{
+	  exp = build_call_nofold_loc (EXPR_LOCATION (exp),
+				       fallback_fndecl, 1, arg);
 
-      target = expand_call (exp, NULL_RTX, target == const0_rtx);
-      target = maybe_emit_group_store (target, TREE_TYPE (exp));
-      return convert_to_mode (mode, target, 0);
+	  target = expand_call (exp, NULL_RTX, target == const0_rtx);
+	  target = maybe_emit_group_store (target, TREE_TYPE (exp));
+	  return convert_to_mode (mode, target, 0);
+	}
     }
 
   return expand_call (exp, target, target == const0_rtx);
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index faa228f91c6..582bf176684 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,54 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105186
+	* c-common.c (c_common_nodes_and_builtins): After registering __int%d
+	and __int%d__ builtin types, initialize corresponding ridpointers
+	entry.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104711
+	* c-opts.c (c_common_post_options): Don't enable
+	-Wshift-negative-value from -Wextra for C++20 or later.
+	* c-ubsan.c (ubsan_instrument_shift): Adjust comments.
+	* c-warn.c (maybe_warn_shift_overflow): Use TYPE_OVERFLOW_WRAPS
+	instead of TYPE_UNSIGNED.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104510
+	* c-common.c (shorten_compare): Convert original arguments to
+	the original *restype_ptr when mixing binary and decimal float.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64888
+	* c-omp.c (c_omp_predefined_variable): Return true also for
+	ubsan_create_data created artificial variables.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR sanitizer/102515
+	* c-ubsan.c (ubsan_instrument_division): Check the right
+	flag_sanitize_recover bit, depending on which sanitization
+	is done.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 910407374d2..330f6074de4 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -2993,7 +2993,11 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,
   else if (real1 && real2
 	   && (DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (primop0)))
 	       || DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (primop1)))))
-    return NULL_TREE;
+    {
+      type = *restype_ptr;
+      primop0 = op0;
+      primop1 = op1;
+    }
 
   else if (real1 && real2
 	   && (TYPE_PRECISION (TREE_TYPE (primop0))
@@ -4022,6 +4026,9 @@ c_common_nodes_and_builtins (void)
       sprintf (name, "__int%d", int_n_data[i].bitsize);
       record_builtin_type ((enum rid)(RID_FIRST_INT_N + i), name,
 			   int_n_trees[i].signed_type);
+      ridpointers[RID_FIRST_INT_N + i]
+	= DECL_NAME (TYPE_NAME (int_n_trees[i].signed_type));
+
       sprintf (name, "__int%d unsigned", int_n_data[i].bitsize);
       record_builtin_type (RID_MAX, name, int_n_trees[i].unsigned_type);
     }
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index ebe0b4e8155..d2db5b4b20d 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -2032,13 +2032,44 @@ c_omp_predefined_variable (tree decl)
 {
   if (VAR_P (decl)
       && DECL_ARTIFICIAL (decl)
-      && TREE_READONLY (decl)
       && TREE_STATIC (decl)
-      && DECL_NAME (decl)
-      && (DECL_NAME (decl) == ridpointers[RID_C99_FUNCTION_NAME]
-	  || DECL_NAME (decl) == ridpointers[RID_FUNCTION_NAME]
-	  || DECL_NAME (decl) == ridpointers[RID_PRETTY_FUNCTION_NAME]))
-    return true;
+      && DECL_NAME (decl))
+    {
+      if (TREE_READONLY (decl)
+	  && (DECL_NAME (decl) == ridpointers[RID_C99_FUNCTION_NAME]
+	      || DECL_NAME (decl) == ridpointers[RID_FUNCTION_NAME]
+	      || DECL_NAME (decl) == ridpointers[RID_PRETTY_FUNCTION_NAME]))
+	return true;
+      /* For UBSan handle the same also ubsan_create_data created
+	 variables.  There is no magic flag for those, but user variables
+	 shouldn't be DECL_ARTIFICIAL or have TYPE_ARTIFICIAL type with
+	 such names.  */
+      if ((flag_sanitize & (SANITIZE_UNDEFINED
+			    | SANITIZE_UNDEFINED_NONDEFAULT)) != 0
+	  && DECL_IGNORED_P (decl)
+	  && !TREE_READONLY (decl)
+	  && TREE_CODE (DECL_NAME (decl)) == IDENTIFIER_NODE
+	  && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE
+	  && TYPE_ARTIFICIAL (TREE_TYPE (decl))
+	  && TYPE_NAME (TREE_TYPE (decl))
+	  && TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) == TYPE_DECL
+	  && DECL_NAME (TYPE_NAME (TREE_TYPE (decl)))
+	  && (TREE_CODE (DECL_NAME (TYPE_NAME (TREE_TYPE (decl))))
+	      == IDENTIFIER_NODE))
+	{
+	  tree id1 = DECL_NAME (decl);
+	  tree id2 = DECL_NAME (TYPE_NAME (TREE_TYPE (decl)));
+	  if (IDENTIFIER_LENGTH (id1) >= sizeof ("ubsan_data") - 1
+	      && IDENTIFIER_LENGTH (id2) >= sizeof ("__ubsan__data")
+	      && !memcmp (IDENTIFIER_POINTER (id2), "__ubsan_",
+			  sizeof ("__ubsan_") - 1)
+	      && !memcmp (IDENTIFIER_POINTER (id2) + IDENTIFIER_LENGTH (id2)
+			  - sizeof ("_data") + 1, "_data",
+			  sizeof ("_data") - 1)
+	      && strstr (IDENTIFIER_POINTER (id1), "ubsan_data"))
+	    return true;
+	}
+    }
   return false;
 }
 
diff --git a/gcc/c-family/c-opts.c b/gcc/c-family/c-opts.c
index 51ac3916fe6..2e2a9411158 100644
--- a/gcc/c-family/c-opts.c
+++ b/gcc/c-family/c-opts.c
@@ -907,10 +907,12 @@ c_common_post_options (const char **pfilename)
   if (warn_shift_overflow == -1)
     warn_shift_overflow = cxx_dialect >= cxx11 || flag_isoc99;
 
-  /* -Wshift-negative-value is enabled by -Wextra in C99 and C++11 modes.  */
+  /* -Wshift-negative-value is enabled by -Wextra in C99 and C++11 to C++17
+     modes.  */
   if (warn_shift_negative_value == -1)
     warn_shift_negative_value = (extra_warnings
-				 && (cxx_dialect >= cxx11 || flag_isoc99));
+				 && (cxx_dialect >= cxx11 || flag_isoc99)
+				 && cxx_dialect < cxx2a);
 
   /* -Wregister is enabled by default in C++17.  */
   if (!global_options_set.x_warn_register)
diff --git a/gcc/c-family/c-ubsan.c b/gcc/c-family/c-ubsan.c
index e4e2c7a1ce8..c523d11f3f6 100644
--- a/gcc/c-family/c-ubsan.c
+++ b/gcc/c-family/c-ubsan.c
@@ -41,6 +41,7 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)
 {
   tree t, tt;
   tree type = TREE_TYPE (op0);
+  enum sanitize_code flag = SANITIZE_DIVIDE;
 
   /* At this point both operands should have the same type,
      because they are already converted to RESULT_TYPE.
@@ -58,8 +59,11 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)
 		     op1, build_int_cst (type, 0));
   else if (TREE_CODE (type) == REAL_TYPE
 	   && sanitize_flags_p (SANITIZE_FLOAT_DIVIDE))
-    t = fold_build2 (EQ_EXPR, boolean_type_node,
-		     op1, build_real (type, dconst0));
+    {
+      t = fold_build2 (EQ_EXPR, boolean_type_node,
+		       op1, build_real (type, dconst0));
+      flag = SANITIZE_FLOAT_DIVIDE;
+    }
   else
     return NULL_TREE;
 
@@ -95,7 +99,7 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)
 				     NULL_TREE);
       data = build_fold_addr_expr_loc (loc, data);
       enum built_in_function bcode
-	= (flag_sanitize_recover & SANITIZE_DIVIDE)
+	= (flag_sanitize_recover & flag)
 	  ? BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW
 	  : BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT;
       tt = builtin_decl_explicit (bcode);
@@ -142,7 +146,7 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,
       || cxx_dialect >= cxx2a)
     ;
 
-  /* For signed x << y, in C99/C11, the following:
+  /* For signed x << y, in C99 and later, the following:
      (unsigned) x >> (uprecm1 - y)
      if non-zero, is undefined.  */
   else if (code == LSHIFT_EXPR && flag_isoc99 && cxx_dialect < cxx11)
@@ -155,7 +159,7 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,
 			build_int_cst (TREE_TYPE (tt), 0));
     }
 
-  /* For signed x << y, in C++11 and later, the following:
+  /* For signed x << y, in C++11 to C++17, the following:
      x < 0 || ((unsigned) x >> (uprecm1 - y))
      if > 1, is undefined.  */
   else if (code == LSHIFT_EXPR && cxx_dialect >= cxx11)
diff --git a/gcc/c-family/c-warn.c b/gcc/c-family/c-warn.c
index 67dce9e125a..7c8157e0b51 100644
--- a/gcc/c-family/c-warn.c
+++ b/gcc/c-family/c-warn.c
@@ -2464,7 +2464,7 @@ maybe_warn_shift_overflow (location_t loc, tree op0, tree op1)
   unsigned int prec0 = TYPE_PRECISION (type0);
 
   /* Left-hand operand must be signed.  */
-  if (TYPE_UNSIGNED (type0) || cxx_dialect >= cxx2a)
+  if (TYPE_OVERFLOW_WRAPS (type0) || cxx_dialect >= cxx2a)
     return false;
 
   unsigned int min_prec = (wi::min_precision (wi::to_wide (op0), SIGNED)
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 0ab66fb192b..7aa714fc9e7 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,48 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104711
+	* c-fold.c (c_fully_fold_internal): Don't emit
+	-Wshift-negative-value warning if TYPE_OVERFLOW_WRAPS.
+	* c-typeck.c (build_binary_op): Likewise.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* c-typeck.c (c_finish_omp_clauses): Accept float + complex
+	for || and && reductions.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/101176
+	* c-parser.c (c_parser_has_attribute_expression): Set source range for
+	the result.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/101171
+	* c-typeck.c (build_c_cast): Don't call note_integer_operands on
+	error_mark_node.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/100785
+	* c-typeck.c (c_mark_addressable): Diagnose trying to make
+	bit-fields addressable.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/c/c-fold.c b/gcc/c/c-fold.c
index a4ece88fe6b..b5066f01e6b 100644
--- a/gcc/c/c-fold.c
+++ b/gcc/c/c-fold.c
@@ -380,6 +380,7 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,
 	  && TREE_CODE (TREE_TYPE (orig_op0)) == INTEGER_TYPE
 	  && TREE_CODE (op0) == INTEGER_CST
 	  && c_inhibit_evaluation_warnings == 0
+	  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (orig_op0))
 	  && tree_int_cst_sgn (op0) < 0)
 	warning_at (loc, OPT_Wshift_negative_value,
 		    "left shift of negative value");
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index bfeacaa0a45..61fd12e2ec1 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -7590,6 +7590,7 @@ c_parser_has_attribute_expression (c_parser *parser)
 {
   gcc_assert (c_parser_next_token_is_keyword (parser,
 					      RID_BUILTIN_HAS_ATTRIBUTE));
+  location_t start = c_parser_peek_token (parser)->location;
   c_parser_consume_token (parser);
 
   c_inhibit_evaluation_warnings++;
@@ -7668,6 +7669,7 @@ c_parser_has_attribute_expression (c_parser *parser)
 
   parser->lex_untranslated_string = false;
 
+  location_t finish = c_parser_peek_token (parser)->location;
   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
     c_parser_consume_token (parser);
   else
@@ -7696,6 +7698,7 @@ c_parser_has_attribute_expression (c_parser *parser)
   else
     result.value =  boolean_false_node;
 
+  set_c_expr_source_range (&result, start, finish);
   return result;
 }
 
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index d97363428d4..6438941888f 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -4989,8 +4989,17 @@ c_mark_addressable (tree exp, bool array_ref_p)
 	    && TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE
 	    && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))))
 	  return true;
-	/* FALLTHRU */
+	x = TREE_OPERAND (x, 0);
+	break;
+
       case COMPONENT_REF:
+	if (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))
+	  {
+	    error ("cannot take address of bit-field %qD",
+		   TREE_OPERAND (x, 1));
+	    return false;
+	  }
+	/* FALLTHRU */
       case ADDR_EXPR:
       case ARRAY_REF:
       case REALPART_EXPR:
@@ -5999,6 +6008,7 @@ build_c_cast (location_t loc, tree type, tree expr)
      return value reflects this.  */
   if (int_operands
       && INTEGRAL_TYPE_P (type)
+      && value != error_mark_node
       && !EXPR_INT_CONST_OPERANDS (value))
     value = note_integer_operands (value);
 
@@ -11901,7 +11911,8 @@ build_binary_op (location_t location, enum tree_code code,
 	{
 	  doing_shift = true;
 	  if (TREE_CODE (op0) == INTEGER_CST
-	      && tree_int_cst_sgn (op0) < 0)
+	      && tree_int_cst_sgn (op0) < 0
+	      && !TYPE_OVERFLOW_WRAPS (type0))
 	    {
 	      /* Don't reject a left shift of a negative value in a context
 		 where a constant expression is needed in C90.  */
@@ -13875,6 +13886,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 		case PLUS_EXPR:
 		case MULT_EXPR:
 		case MINUS_EXPR:
+		case TRUTH_ANDIF_EXPR:
+		case TRUTH_ORIF_EXPR:
 		  break;
 		case MIN_EXPR:
 		  if (TREE_CODE (type) == COMPLEX_TYPE)
@@ -13893,14 +13906,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 		case BIT_IOR_EXPR:
 		  r_name = "|";
 		  break;
-		case TRUTH_ANDIF_EXPR:
-		  if (FLOAT_TYPE_P (type))
-		    r_name = "&&";
-		  break;
-		case TRUTH_ORIF_EXPR:
-		  if (FLOAT_TYPE_P (type))
-		    r_name = "||";
-		  break;
 		default:
 		  gcc_unreachable ();
 		}
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 26b6bf3e6c6..9e0d4584704 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -2950,6 +2950,7 @@ expand_asm_stmt (gasm *stmt)
   unsigned ninputs = gimple_asm_ninputs (stmt);
   unsigned nlabels = gimple_asm_nlabels (stmt);
   unsigned i;
+  bool error_seen = false;
 
   /* ??? Diagnose during gimplification?  */
   if (ninputs + noutputs + nlabels > MAX_RECOG_OPERANDS)
@@ -3008,6 +3009,7 @@ expand_asm_stmt (gasm *stmt)
 		{
 		  /* ??? Diagnose during gimplification?  */
 		  error ("unknown register name %qs in %<asm%>", regname);
+		  error_seen = true;
 		}
 	      else if (j == -4)
 		{
@@ -3071,7 +3073,10 @@ expand_asm_stmt (gasm *stmt)
 		&& REG_P (DECL_RTL (output_tvec[j]))
 		&& HARD_REGISTER_P (DECL_RTL (output_tvec[j]))
 		&& output_hregno == REGNO (DECL_RTL (output_tvec[j])))
-	      error ("invalid hard register usage between output operands");
+	      {
+		error ("invalid hard register usage between output operands");
+		error_seen = true;
+	      }
 
 	  /* Verify matching constraint operands use the same hard register
 	     and that the non-matching constraint operands do not use the same
@@ -3094,13 +3099,19 @@ expand_asm_stmt (gasm *stmt)
 		  }
 		if (i == match
 		    && output_hregno != input_hregno)
-		  error ("invalid hard register usage between output operand "
-			 "and matching constraint operand");
+		  {
+		    error ("invalid hard register usage between output "
+			   "operand and matching constraint operand");
+		    error_seen = true;
+		  }
 		else if (early_clobber_p
 			 && i != match
 			 && output_hregno == input_hregno)
-		  error ("invalid hard register usage between earlyclobber "
-			 "operand and input operand");
+		  {
+		    error ("invalid hard register usage between "
+			   "earlyclobber operand and input operand");
+		    error_seen = true;
+		  }
 	      }
 	}
 
@@ -3168,7 +3179,9 @@ expand_asm_stmt (gasm *stmt)
 		    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))
 	  || ! allows_reg
 	  || is_inout
-	  || TREE_ADDRESSABLE (type))
+	  || TREE_ADDRESSABLE (type)
+	  || (!tree_fits_poly_int64_p (TYPE_SIZE (type))
+	      && !known_size_p (max_int_size_in_bytes (type))))
 	{
 	  op = expand_expr (val, NULL_RTX, VOIDmode,
 			    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);
@@ -3176,7 +3189,10 @@ expand_asm_stmt (gasm *stmt)
 	    op = validize_mem (op);
 
 	  if (! allows_reg && !MEM_P (op))
-	    error ("output number %d not directly addressable", i);
+	    {
+	      error ("output number %d not directly addressable", i);
+	      error_seen = true;
+	    }
 	  if ((! allows_mem && MEM_P (op) && GET_MODE (op) != BLKmode)
 	      || GET_CODE (op) == CONCAT)
 	    {
@@ -3216,6 +3232,19 @@ expand_asm_stmt (gasm *stmt)
 	inout_opnum.safe_push (i);
     }
 
+  const char *str = gimple_asm_string (stmt);
+  if (error_seen)
+    {
+      ninputs = 0;
+      noutputs = 0;
+      inout_opnum.truncate (0);
+      output_rvec.truncate (0);
+      clobber_rvec.truncate (0);
+      constraints.truncate (0);
+      CLEAR_HARD_REG_SET (clobbered_regs);
+      str = "";
+    }
+
   auto_vec<rtx, MAX_RECOG_OPERANDS> input_rvec;
   auto_vec<machine_mode, MAX_RECOG_OPERANDS> input_mode;
 
@@ -3273,7 +3302,7 @@ expand_asm_stmt (gasm *stmt)
     }
 
   /* For in-out operands, copy output rtx to input rtx.  */
-  unsigned ninout = inout_opnum.length();
+  unsigned ninout = inout_opnum.length ();
   for (i = 0; i < ninout; i++)
     {
       int j = inout_opnum[i];
@@ -3327,7 +3356,7 @@ expand_asm_stmt (gasm *stmt)
 
   rtx body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode
 				    : GET_MODE (output_rvec[0])),
-				   ggc_strdup (gimple_asm_string (stmt)),
+				   ggc_strdup (str),
 				   "", 0, argvec, constraintvec,
 				   labelvec, locus);
   MEM_VOLATILE_P (body) = gimple_asm_volatile_p (stmt);
@@ -4356,7 +4385,12 @@ expand_debug_expr (tree exp)
       op0 = DECL_RTL_IF_SET (exp);
 
       if (op0)
-	return op0;
+	{
+	  if (GET_MODE (op0) != mode)
+	    gcc_assert (VECTOR_TYPE_P (TREE_TYPE (exp)));
+	  else
+	    return op0;
+	}
 
       op0 = gen_rtx_DEBUG_EXPR (mode);
       DEBUG_EXPR_TREE_DECL (op0) = exp;
diff --git a/gcc/combine.c b/gcc/combine.c
index d82161e5161..10c643797b9 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -396,7 +396,7 @@ struct undo
   struct undo *next;
   enum undo_kind kind;
   union { rtx r; int i; machine_mode m; struct insn_link *l; } old_contents;
-  union { rtx *r; int *i; struct insn_link **l; } where;
+  union { rtx *r; int *i; int regno; struct insn_link **l; } where;
 };
 
 /* Record a bunch of changes to be undone, up to MAX_UNDO of them.
@@ -793,10 +793,11 @@ do_SUBST_INT (int *into, int newval)
    well.  */
 
 static void
-do_SUBST_MODE (rtx *into, machine_mode newval)
+subst_mode (int regno, machine_mode newval)
 {
   struct undo *buf;
-  machine_mode oldval = GET_MODE (*into);
+  rtx reg = regno_reg_rtx[regno];
+  machine_mode oldval = GET_MODE (reg);
 
   if (oldval == newval)
     return;
@@ -807,15 +808,13 @@ do_SUBST_MODE (rtx *into, machine_mode newval)
     buf = XNEW (struct undo);
 
   buf->kind = UNDO_MODE;
-  buf->where.r = into;
+  buf->where.regno = regno;
   buf->old_contents.m = oldval;
-  adjust_reg_mode (*into, newval);
+  adjust_reg_mode (reg, newval);
 
   buf->next = undobuf.undos, undobuf.undos = buf;
 }
 
-#define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE (&(INTO), (NEWVAL))
-
 /* Similar to SUBST, but NEWVAL is a LOG_LINKS expression.  */
 
 static void
@@ -3222,6 +3221,16 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
       return 0;
     }
 
+  /* We cannot safely duplicate volatile references in any case.  */
+
+  if ((added_sets_2 && volatile_refs_p (PATTERN (i2)))
+      || (added_sets_1 && volatile_refs_p (PATTERN (i1)))
+      || (added_sets_0 && volatile_refs_p (PATTERN (i0))))
+    {
+      undo_all ();
+      return 0;
+    }
+
   /* Count how many auto_inc expressions there were in the original insns;
      we need to have the same number in the resulting patterns.  */
 
@@ -3334,7 +3343,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
 		    newpat_dest = gen_rtx_REG (compare_mode, regno);
 		  else
 		    {
-		      SUBST_MODE (regno_reg_rtx[regno], compare_mode);
+		      subst_mode (regno, compare_mode);
 		      newpat_dest = regno_reg_rtx[regno];
 		    }
 		}
@@ -3724,7 +3733,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
 		ni2dest = gen_rtx_REG (new_mode, REGNO (i2dest));
 	      else
 		{
-		  SUBST_MODE (regno_reg_rtx[REGNO (i2dest)], new_mode);
+		  subst_mode (REGNO (i2dest), new_mode);
 		  ni2dest = regno_reg_rtx[REGNO (i2dest)];
 		}
 
@@ -3861,7 +3870,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
 		newdest = gen_rtx_REG (split_mode, REGNO (i2dest));
 	      else
 		{
-		  SUBST_MODE (regno_reg_rtx[REGNO (i2dest)], split_mode);
+		  subst_mode (REGNO (i2dest), split_mode);
 		  newdest = regno_reg_rtx[REGNO (i2dest)];
 		}
 	    }
@@ -4229,7 +4238,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
       for (undo = undobuf.undos; undo; undo = undo->next)
 	if (undo->kind == UNDO_MODE)
 	  {
-	    rtx reg = *undo->where.r;
+	    rtx reg = regno_reg_rtx[undo->where.regno];
 	    machine_mode new_mode = GET_MODE (reg);
 	    machine_mode old_mode = undo->old_contents.m;
 
@@ -4896,7 +4905,8 @@ undo_to_marker (void *marker)
 	  *undo->where.i = undo->old_contents.i;
 	  break;
 	case UNDO_MODE:
-	  adjust_reg_mode (*undo->where.r, undo->old_contents.m);
+	  adjust_reg_mode (regno_reg_rtx[undo->where.regno],
+			   undo->old_contents.m);
 	  break;
 	case UNDO_LINKS:
 	  *undo->where.l = undo->old_contents.l;
@@ -5697,6 +5707,12 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)
 		  if (!x)
 		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 		}
+	      /* CONST_INTs shouldn't be substituted into PRE_DEC, PRE_MODIFY
+		 etc. arguments, otherwise we can ICE before trying to recog
+		 it.  See PR104446.  */
+	      else if (CONST_SCALAR_INT_P (new_rtx)
+		       && GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)
+		return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 	      else
 		SUBST (XEXP (x, i), new_rtx);
 	    }
@@ -6970,7 +6986,7 @@ simplify_set (rtx x)
 		new_dest = gen_rtx_REG (compare_mode, regno);
 	      else
 		{
-		  SUBST_MODE (regno_reg_rtx[regno], compare_mode);
+		  subst_mode (regno, compare_mode);
 		  new_dest = regno_reg_rtx[regno];
 		}
 
@@ -14392,6 +14408,11 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,
 	     we keep notes from i2 or i1 if they will turn into REG_DEAD
 	     notes.  */
 
+	  /* If this register is set or clobbered between FROM_INSN and I3,
+	     we should not create a note for it.  */
+	  if (reg_set_between_p (XEXP (note, 0), from_insn, i3))
+	    break;
+
 	  /* If this register is set or clobbered in I3, put the note there
 	     unless there is one already.  */
 	  if (reg_set_p (XEXP (note, 0), PATTERN (i3)))
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 3cd7db88b77..fb2faa44e06 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -115,7 +115,7 @@ AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_
 /* ARM ('A') cores. */
 AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
 AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
-
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
 AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 0a73e105e08..e4ae7d9b16b 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,a64fx,tsv110,zeus,neoversev1,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
+	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,a64fx,tsv110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/arm_acle.h b/gcc/config/aarch64/arm_acle.h
index 56147352c23..8c622a3985b 100644
--- a/gcc/config/aarch64/arm_acle.h
+++ b/gcc/config/aarch64/arm_acle.h
@@ -98,10 +98,6 @@ __rint64x (double __a)
 
 #pragma GCC target ("+nothing+crc")
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
 {
diff --git a/gcc/config/arm/arm-c.c b/gcc/config/arm/arm-c.c
index 6e256ee0a12..8cb08646ce5 100644
--- a/gcc/config/arm/arm-c.c
+++ b/gcc/config/arm/arm-c.c
@@ -266,8 +266,8 @@ arm_pragma_target_parse (tree args, tree pop_target)
        target_option_current_node, but not handle_pragma_target.  */
       target_option_current_node = cur_tree;
       arm_configure_build_target (&arm_active_target,
-				  TREE_TARGET_OPTION (cur_tree),
-				  &global_options_set, false);
+				  TREE_TARGET_OPTION (cur_tree), false);
+      arm_option_reconfigure_globals ();
     }
 
   /* Update macros if target_node changes. The global state will be restored
diff --git a/gcc/config/arm/arm-cpus.in b/gcc/config/arm/arm-cpus.in
index f87044fd25c..de2caec5497 100644
--- a/gcc/config/arm/arm-cpus.in
+++ b/gcc/config/arm/arm-cpus.in
@@ -180,6 +180,9 @@ define feature quirk_armv6kz
 # Cortex-M3 LDRD quirk.
 define feature quirk_cm3_ldrd
 
+# Don't use .cpu assembly directive
+define feature quirk_no_asmcpu
+
 # (Very) slow multiply operations.  Should probably be a tuning bit.
 define feature smallmul
 
@@ -213,15 +216,18 @@ define fgroup ALL_CRYPTO	crypto
 # strip off 32 D-registers, but does not remove support for
 # double-precision FP.
 define fgroup ALL_SIMD_INTERNAL	fp_d32 neon ALL_CRYPTO
-define fgroup ALL_SIMD	ALL_SIMD_INTERNAL dotprod fp16fml
+define fgroup ALL_SIMD_EXTERNAL dotprod fp16fml
+define fgroup ALL_SIMD	ALL_SIMD_INTERNAL ALL_SIMD_EXTERNAL
 
 # List of all FPU bits to strip out if -mfpu is used to override the
 # default.  fp16 is deliberately missing from this list.
 define fgroup ALL_FPU_INTERNAL	vfpv2 vfpv3 vfpv4 fpv5 fp16conv fp_dbl ALL_SIMD_INTERNAL
-
 # Similarly, but including fp16 and other extensions that aren't part of
 # -mfpu support.
-define fgroup ALL_FP	fp16 ALL_FPU_INTERNAL
+define fgroup ALL_FPU_EXTERNAL fp16
+
+# Everything related to the FPU extensions (FP or SIMD).
+define fgroup ALL_FP	ALL_FPU_EXTERNAL ALL_FPU_INTERNAL ALL_SIMD
 
 define fgroup ARMv4       armv4 notm
 define fgroup ARMv4t      ARMv4 thumb
@@ -274,7 +280,7 @@ define fgroup DOTPROD	NEON dotprod
 # architectures.
 # xscale isn't really a 'quirk', but it isn't an architecture either and we
 # need to ignore it for matching purposes.
-define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd xscale
+define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd xscale quirk_no_asmcpu
 
 # Architecture entries
 # format:
@@ -976,6 +982,7 @@ begin cpu generic-armv7-a
  cname genericv7a
  tune flags LDSCHED
  architecture armv7-a+fp
+ isa quirk_no_asmcpu
  option mp add mp
  option sec add sec
  option vfpv3-d16 add VFPv3 FP_DBL
@@ -1301,7 +1308,7 @@ begin cpu cortex-a55
  cname cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  option nofp remove ALL_FP
  costs cortex_a53
@@ -1313,7 +1320,7 @@ begin cpu cortex-a75
  cname cortexa75
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a73
  vendor 41
@@ -1324,7 +1331,7 @@ begin cpu cortex-a76
  cname cortexa76
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
  vendor 41
@@ -1336,7 +1343,7 @@ begin cpu neoverse-n1
  alias !ares
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
  vendor 41
@@ -1348,7 +1355,7 @@ begin cpu cortex-a75.cortex-a55
  cname cortexa75cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a73
 end cpu cortex-a75.cortex-a55
@@ -1357,7 +1364,7 @@ begin cpu cortex-a76.cortex-a55
  cname cortexa76cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
 end cpu cortex-a76.cortex-a55
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 3e8bba5caea..cd16c3c35f9 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -229,8 +229,7 @@ extern bool arm_change_mode_p (tree);
 extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,
 					     struct gcc_options *);
 extern void arm_configure_build_target (struct arm_build_target *,
-					struct cl_target_option *,
-					struct gcc_options *, bool);
+					struct cl_target_option *, bool);
 extern void arm_option_reconfigure_globals (void);
 extern void arm_options_perform_arch_sanity_checks (void);
 extern void arm_pr_long_calls (struct cpp_reader *);
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 4679da75dd8..8cbdb9a44e5 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -78,10 +78,6 @@
 typedef struct minipool_node    Mnode;
 typedef struct minipool_fixup   Mfix;
 
-/* The last .arch and .fpu assembly strings that we printed.  */
-static std::string arm_last_printed_arch_string;
-static std::string arm_last_printed_fpu_string;
-
 void (*arm_lang_output_object_attributes_hook)(void);
 
 struct four_ints
@@ -325,6 +321,7 @@ static unsigned int arm_hard_regno_nregs (unsigned int, machine_mode);
 static bool arm_hard_regno_mode_ok (unsigned int, machine_mode);
 static bool arm_modes_tieable_p (machine_mode, machine_mode);
 static HOST_WIDE_INT arm_constant_alignment (const_tree, HOST_WIDE_INT);
+static const char *arm_identify_fpu_from_isa (sbitmap);
 
 /* Table of machine attributes.  */
 static const struct attribute_spec arm_attribute_table[] =
@@ -2985,7 +2982,7 @@ arm_override_options_after_change (void)
 {
   arm_configure_build_target (&arm_active_target,
 			      TREE_TARGET_OPTION (target_option_default_node),
-			      &global_options_set, false);
+			      false);
 
   arm_override_options_after_change_1 (&global_options);
 }
@@ -3006,8 +3003,8 @@ arm_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)
   opts->x_arm_arch_string = ptr->x_arm_arch_string;
   opts->x_arm_cpu_string = ptr->x_arm_cpu_string;
   opts->x_arm_tune_string = ptr->x_arm_tune_string;
-  arm_configure_build_target (&arm_active_target, ptr, &global_options_set,
-			      false);
+  arm_configure_build_target (&arm_active_target, ptr, false);
+  arm_option_reconfigure_globals ();
 }
 
 /* Reset options between modes that the user has specified.  */
@@ -3115,7 +3112,8 @@ arm_option_override_internal (struct gcc_options *opts,
 #endif
 }
 
-static sbitmap isa_all_fpubits;
+static sbitmap isa_all_fpubits_internal;
+static sbitmap isa_all_fpbits;
 static sbitmap isa_quirkbits;
 
 /* Configure a build target TARGET from the user-specified options OPTS and
@@ -3124,7 +3122,6 @@ static sbitmap isa_quirkbits;
 void
 arm_configure_build_target (struct arm_build_target *target,
 			    struct cl_target_option *opts,
-			    struct gcc_options *opts_set,
 			    bool warn_compatible)
 {
   const cpu_option *arm_selected_tune = NULL;
@@ -3139,7 +3136,7 @@ arm_configure_build_target (struct arm_build_target *target,
   target->core_name = NULL;
   target->arch_name = NULL;
 
-  if (opts_set->x_arm_arch_string)
+  if (opts->x_arm_arch_string)
     {
       arm_selected_arch = arm_parse_arch_option_name (all_architectures,
 						      "-march",
@@ -3147,7 +3144,7 @@ arm_configure_build_target (struct arm_build_target *target,
       arch_opts = strchr (opts->x_arm_arch_string, '+');
     }
 
-  if (opts_set->x_arm_cpu_string)
+  if (opts->x_arm_cpu_string)
     {
       arm_selected_cpu = arm_parse_cpu_option_name (all_cores, "-mcpu",
 						    opts->x_arm_cpu_string);
@@ -3157,7 +3154,7 @@ arm_configure_build_target (struct arm_build_target *target,
 	 options for tuning.  */
     }
 
-  if (opts_set->x_arm_tune_string)
+  if (opts->x_arm_tune_string)
     {
       arm_selected_tune = arm_parse_cpu_option_name (all_cores, "-mtune",
 						     opts->x_arm_tune_string);
@@ -3182,7 +3179,12 @@ arm_configure_build_target (struct arm_build_target *target,
 	  /* Ignore any bits that are quirk bits.  */
 	  bitmap_and_compl (isa_delta, isa_delta, isa_quirkbits);
 	  /* Ignore (for now) any bits that might be set by -mfpu.  */
-	  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits);
+	  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits_internal);
+
+	  /* And if the target ISA lacks floating point, ignore any
+	     extensions that depend on that.  */
+	  if (!bitmap_bit_p (target->isa, isa_bit_vfpv2))
+	    bitmap_and_compl (isa_delta, isa_delta, isa_all_fpbits);
 
 	  if (!bitmap_empty_p (isa_delta))
 	    {
@@ -3341,10 +3343,15 @@ arm_configure_build_target (struct arm_build_target *target,
       auto_sbitmap fpu_bits (isa_num_bits);
 
       arm_initialize_isa (fpu_bits, arm_selected_fpu->isa_bits);
-      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits);
+      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits_internal);
       bitmap_ior (target->isa, target->isa, fpu_bits);
     }
 
+  /* If we have the soft-float ABI, clear any feature bits relating to use of
+     floating-point operations.  They'll just confuse things later on.  */
+  if (arm_float_abi == ARM_FLOAT_ABI_SOFT)
+    bitmap_and_compl (target->isa, target->isa, isa_all_fpbits);
+
   if (!arm_selected_tune)
     arm_selected_tune = arm_selected_cpu;
   else /* Validate the features passed to -mtune.  */
@@ -3353,6 +3360,8 @@ arm_configure_build_target (struct arm_build_target *target,
   const cpu_tune *tune_data = &all_tunes[arm_selected_tune - all_cores];
 
   /* Finish initializing the target structure.  */
+  if (!target->arch_name)
+    target->arch_name = arm_selected_arch->common.name;
   target->arch_pp_name = arm_selected_arch->arch;
   target->base_arch = arm_selected_arch->base_arch;
   target->profile = arm_selected_arch->profile;
@@ -3360,23 +3369,26 @@ arm_configure_build_target (struct arm_build_target *target,
   target->tune_flags = tune_data->tune_flags;
   target->tune = tune_data->tune;
   target->tune_core = tune_data->scheduler;
-  arm_option_reconfigure_globals ();
 }
 
 /* Fix up any incompatible options that the user has specified.  */
 static void
 arm_option_override (void)
 {
-  static const enum isa_feature fpu_bitlist[]
+  static const enum isa_feature fpu_bitlist_internal[]
     = { ISA_ALL_FPU_INTERNAL, isa_nobit };
+  static const enum isa_feature fp_bitlist[]
+    = { ISA_ALL_FP, isa_nobit };
   static const enum isa_feature quirk_bitlist[] = { ISA_ALL_QUIRKS, isa_nobit};
   cl_target_option opts;
 
   isa_quirkbits = sbitmap_alloc (isa_num_bits);
   arm_initialize_isa (isa_quirkbits, quirk_bitlist);
 
-  isa_all_fpubits = sbitmap_alloc (isa_num_bits);
-  arm_initialize_isa (isa_all_fpubits, fpu_bitlist);
+  isa_all_fpubits_internal = sbitmap_alloc (isa_num_bits);
+  isa_all_fpbits = sbitmap_alloc (isa_num_bits);
+  arm_initialize_isa (isa_all_fpubits_internal, fpu_bitlist_internal);
+  arm_initialize_isa (isa_all_fpbits, fp_bitlist);
 
   arm_active_target.isa = sbitmap_alloc (isa_num_bits);
 
@@ -3392,8 +3404,7 @@ arm_option_override (void)
     }
 
   cl_target_option_save (&opts, &global_options);
-  arm_configure_build_target (&arm_active_target, &opts, &global_options_set,
-			      true);
+  arm_configure_build_target (&arm_active_target, &opts, true);
 
 #ifdef SUBTARGET_OVERRIDE_OPTIONS
   SUBTARGET_OVERRIDE_OPTIONS;
@@ -26654,20 +26665,65 @@ arm_print_tune_info (void)
 	       (int) current_tune->sched_autopref);
 }
 
+/* The last set of target options used to emit .arch directives, etc.  This
+   could be a function-local static if it were not required to expose it as a
+   root to the garbage collector.  */
+static GTY(()) cl_target_option *last_asm_targ_options = NULL;
+
 /* Print .arch and .arch_extension directives corresponding to the
    current architecture configuration.  */
 static void
-arm_print_asm_arch_directives ()
+arm_print_asm_arch_directives (FILE *stream, cl_target_option *targ_options)
 {
+  arm_build_target build_target;
+  /* If the target options haven't changed since the last time we were called
+     there is nothing to do.  This should be sufficient to suppress the
+     majority of redundant work.  */
+  if (last_asm_targ_options == targ_options)
+    return;
+
+  last_asm_targ_options = targ_options;
+
+  build_target.isa = sbitmap_alloc (isa_num_bits);
+  arm_configure_build_target (&build_target, targ_options, false);
+
+  if (build_target.core_name
+      && !bitmap_bit_p (build_target.isa, isa_bit_quirk_no_asmcpu))
+    {
+      const char* truncated_name
+	= arm_rewrite_selected_cpu (build_target.core_name);
+      asm_fprintf (stream, "\t.cpu %s\n", truncated_name);
+    }
+
   const arch_option *arch
     = arm_parse_arch_option_name (all_architectures, "-march",
-				  arm_active_target.arch_name);
+				  build_target.arch_name);
   auto_sbitmap opt_bits (isa_num_bits);
 
   gcc_assert (arch);
 
-  asm_fprintf (asm_out_file, "\t.arch %s\n", arm_active_target.arch_name);
-  arm_last_printed_arch_string = arm_active_target.arch_name;
+  if (strcmp (build_target.arch_name, "armv7ve") == 0)
+    {
+      /* Keep backward compatability for assemblers which don't support
+	 armv7ve.  Fortunately, none of the following extensions are reset
+	 by a .fpu directive.  */
+      asm_fprintf (stream, "\t.arch armv7-a\n");
+      asm_fprintf (stream, "\t.arch_extension virt\n");
+      asm_fprintf (stream, "\t.arch_extension idiv\n");
+      asm_fprintf (stream, "\t.arch_extension sec\n");
+      asm_fprintf (stream, "\t.arch_extension mp\n");
+    }
+  else
+    asm_fprintf (stream, "\t.arch %s\n", build_target.arch_name);
+
+  /* The .fpu directive will reset any architecture extensions from the
+     assembler that relate to the fp/vector extensions.  So put this out before
+     any .arch_extension directives.  */
+  const char *fpu_name = (TARGET_SOFT_FLOAT
+			  ? "softvfp"
+			  : arm_identify_fpu_from_isa (build_target.isa));
+  asm_fprintf (stream, "\t.fpu %s\n", fpu_name);
+
   if (!arch->common.extensions)
     return;
 
@@ -26679,13 +26735,12 @@ arm_print_asm_arch_directives ()
 	{
 	  arm_initialize_isa (opt_bits, opt->isa_bits);
 
-	  /* If every feature bit of this option is set in the target
-	     ISA specification, print out the option name.  However,
-	     don't print anything if all the bits are part of the
-	     FPU specification.  */
-	  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
-	      && !bitmap_subset_p (opt_bits, isa_all_fpubits))
-	    asm_fprintf (asm_out_file, "\t.arch_extension %s\n", opt->name);
+	  /* If every feature bit of this option is set in the target ISA
+	     specification, print out the option name.  However, don't print
+	     anything if all the bits are part of the FPU specification.  */
+	  if (bitmap_subset_p (opt_bits, build_target.isa)
+	      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))
+	    asm_fprintf (stream, "\t.arch_extension %s\n", opt->name);
 	}
     }
 }
@@ -26695,42 +26750,23 @@ arm_file_start (void)
 {
   int val;
 
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (TARGET_BPABI)
     {
-      /* We don't have a specified CPU.  Use the architecture to
-	 generate the tags.
-
-	 Note: it might be better to do this unconditionally, then the
-	 assembler would not need to know about all new CPU names as
-	 they are added.  */
-      if (!arm_active_target.core_name)
-	{
-	  /* armv7ve doesn't support any extensions.  */
-	  if (strcmp (arm_active_target.arch_name, "armv7ve") == 0)
-	    {
-	      /* Keep backward compatability for assemblers
-		 which don't support armv7ve.  */
-	      asm_fprintf (asm_out_file, "\t.arch armv7-a\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension virt\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension idiv\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension sec\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension mp\n");
-	      arm_last_printed_arch_string = "armv7ve";
-	    }
-	  else
-	    arm_print_asm_arch_directives ();
-	}
-      else if (strncmp (arm_active_target.core_name, "generic", 7) == 0)
-	{
-	  asm_fprintf (asm_out_file, "\t.arch %s\n",
-		       arm_active_target.core_name + 8);
-	  arm_last_printed_arch_string = arm_active_target.core_name + 8;
-	}
-      else
+      /* If we have a named cpu, but we the assembler does not support that
+	 name via .cpu, put out a cpu name attribute; but don't do this if the
+	 name starts with the fictitious prefix, 'generic'.  */
+      if (arm_active_target.core_name
+	  && bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu)
+	  && strncmp (arm_active_target.core_name, "generic", 7) != 0)
 	{
 	  const char* truncated_name
 	    = arm_rewrite_selected_cpu (arm_active_target.core_name);
-	  asm_fprintf (asm_out_file, "\t.cpu %s\n", truncated_name);
+	  if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu))
+	    asm_fprintf (asm_out_file, "\t.eabi_attribute 5, \"%s\"\n",
+			 truncated_name);
 	}
 
       if (print_tune_info)
@@ -26798,6 +26834,13 @@ arm_file_end (void)
 {
   int regno;
 
+  /* Just in case the last function output in the assembler had non-default
+     architecture directives, we force the assembler state back to the default
+     set, so that any 'calculated' build attributes are based on the default
+     options rather than the special options for that function.  */
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (NEED_INDICATE_EXEC_STACK)
     /* Add .note.GNU-stack.  */
     file_end_indicate_exec_stack ();
@@ -29010,13 +29053,31 @@ arm_split_compare_and_swap (rtx operands[])
     }
   else
     {
-      emit_move_insn (neg_bval, const1_rtx);
       cond = gen_rtx_NE (VOIDmode, rval, oldval);
       if (thumb1_cmpneg_operand (oldval, SImode))
-	emit_unlikely_jump (gen_cbranchsi4_scratch (neg_bval, rval, oldval,
-						    label2, cond));
+	{
+	  rtx src = rval;
+	  if (!satisfies_constraint_L (oldval))
+	    {
+	      gcc_assert (satisfies_constraint_J (oldval));
+
+	      /* For such immediates, ADDS needs the source and destination regs
+		 to be the same.
+
+		 Normally this would be handled by RA, but this is all happening
+		 after RA.  */
+	      emit_move_insn (neg_bval, rval);
+	      src = neg_bval;
+	    }
+
+	  emit_unlikely_jump (gen_cbranchsi4_neg_late (neg_bval, src, oldval,
+						       label2, cond));
+	}
       else
-	emit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));
+	{
+	  emit_move_insn (neg_bval, const1_rtx);
+	  emit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));
+	}
     }
 
   arm_emit_store_exclusive (mode, neg_bval, mem, newval, use_release);
@@ -30938,10 +30999,8 @@ arm_can_inline_p (tree caller, tree callee)
   caller_target.isa = sbitmap_alloc (isa_num_bits);
   callee_target.isa = sbitmap_alloc (isa_num_bits);
 
-  arm_configure_build_target (&caller_target, caller_opts, &global_options_set,
-			      false);
-  arm_configure_build_target (&callee_target, callee_opts, &global_options_set,
-			      false);
+  arm_configure_build_target (&caller_target, caller_opts, false);
+  arm_configure_build_target (&callee_target, callee_opts, false);
   if (!bitmap_subset_p (callee_target.isa, caller_target.isa))
     can_inline = false;
 
@@ -31073,7 +31132,7 @@ arm_valid_target_attribute_tree (tree args, struct gcc_options *opts,
     return NULL_TREE;
 
   cl_target_option_save (&cl_opts, opts);
-  arm_configure_build_target (&arm_active_target, &cl_opts, opts_set, false);
+  arm_configure_build_target (&arm_active_target, &cl_opts, false);
   arm_option_check_internal (opts);
   /* Do any overrides, such as global options arch=xxx.
      We do this since arm_active_target was overridden.  */
@@ -31188,7 +31247,7 @@ arm_identify_fpu_from_isa (sbitmap isa)
   auto_sbitmap fpubits (isa_num_bits);
   auto_sbitmap cand_fpubits (isa_num_bits);
 
-  bitmap_and (fpubits, isa, isa_all_fpubits);
+  bitmap_and (fpubits, isa, isa_all_fpubits_internal);
 
   /* If there are no ISA feature bits relating to the FPU, we must be
      doing soft-float.  */
@@ -31219,44 +31278,7 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
     targ_options = TREE_TARGET_OPTION (target_option_current_node);
   gcc_assert (targ_options);
 
-  /* Only update the assembler .arch string if it is distinct from the last
-     such string we printed. arch_to_print is set conditionally in case
-     targ_options->x_arm_arch_string is NULL which can be the case
-     when cc1 is invoked directly without passing -march option.  */
-  std::string arch_to_print;
-  if (targ_options->x_arm_arch_string)
-    arch_to_print = targ_options->x_arm_arch_string;
-
-  if (arch_to_print != arm_last_printed_arch_string)
-    {
-      std::string arch_name
-	= arch_to_print.substr (0, arch_to_print.find ("+"));
-      asm_fprintf (asm_out_file, "\t.arch %s\n", arch_name.c_str ());
-      const arch_option *arch
-	= arm_parse_arch_option_name (all_architectures, "-march",
-				      targ_options->x_arm_arch_string);
-      auto_sbitmap opt_bits (isa_num_bits);
-
-      gcc_assert (arch);
-      if (arch->common.extensions)
-	{
-	  for (const struct cpu_arch_extension *opt = arch->common.extensions;
-	       opt->name != NULL;
-	       opt++)
-	    {
-	      if (!opt->remove)
-		{
-		  arm_initialize_isa (opt_bits, opt->isa_bits);
-		  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
-		      && !bitmap_subset_p (opt_bits, isa_all_fpubits))
-		    asm_fprintf (asm_out_file, "\t.arch_extension %s\n",
-				 opt->name);
-		}
-	     }
-	}
-
-      arm_last_printed_arch_string = arch_to_print;
-    }
+  arm_print_asm_arch_directives (stream, targ_options);
 
   fprintf (stream, "\t.syntax unified\n");
 
@@ -31274,16 +31296,6 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
   else
     fprintf (stream, "\t.arm\n");
 
-  std::string fpu_to_print
-    = TARGET_SOFT_FLOAT
-	? "softvfp" : arm_identify_fpu_from_isa (arm_active_target.isa);
-
-  if (fpu_to_print != arm_last_printed_arch_string)
-    {
-      asm_fprintf (asm_out_file, "\t.fpu %s\n", fpu_to_print.c_str ());
-      arm_last_printed_fpu_string = fpu_to_print;
-    }
-
   if (TARGET_POKE_FUNCTION_NAME)
     arm_poke_function_name (stream, (const char *) name);
 }
@@ -31934,28 +31946,28 @@ arm_test_cpu_arch_data (void)
 static void
 arm_test_fpu_data (void)
 {
-  auto_sbitmap isa_all_fpubits (isa_num_bits);
+  auto_sbitmap isa_all_fpubits_internal (isa_num_bits);
   auto_sbitmap fpubits (isa_num_bits);
   auto_sbitmap tmpset (isa_num_bits);
 
-  static const enum isa_feature fpu_bitlist[]
+  static const enum isa_feature fpu_bitlist_internal[]
     = { ISA_ALL_FPU_INTERNAL, isa_nobit };
-  arm_initialize_isa (isa_all_fpubits, fpu_bitlist);
+  arm_initialize_isa (isa_all_fpubits_internal, fpu_bitlist_internal);
 
   for (unsigned int i = 0; i < TARGET_FPU_auto; i++)
   {
     arm_initialize_isa (fpubits, all_fpus[i].isa_bits);
-    bitmap_and_compl (tmpset, isa_all_fpubits, fpubits);
-    bitmap_clear (isa_all_fpubits);
-    bitmap_copy (isa_all_fpubits, tmpset);
+    bitmap_and_compl (tmpset, isa_all_fpubits_internal, fpubits);
+    bitmap_clear (isa_all_fpubits_internal);
+    bitmap_copy (isa_all_fpubits_internal, tmpset);
   }
 
-  if (!bitmap_empty_p (isa_all_fpubits))
+  if (!bitmap_empty_p (isa_all_fpubits_internal))
     {
 	fprintf (stderr, "Error: found feature bits in the ALL_FPU_INTERAL"
 			 " group that are not defined by any FPU.\n"
 			 "       Check your arm-cpus.in.\n");
-	ASSERT_TRUE (bitmap_empty_p (isa_all_fpubits));
+	ASSERT_TRUE (bitmap_empty_p (isa_all_fpubits_internal));
     }
 }
 
diff --git a/gcc/config/arm/sync.md b/gcc/config/arm/sync.md
index 0e777a92bb4..693a802c292 100644
--- a/gcc/config/arm/sync.md
+++ b/gcc/config/arm/sync.md
@@ -187,20 +187,20 @@
 ;; Constraints of this pattern must be at least as strict as those of the
 ;; cbranchsi operations in thumb1.md and aim to be as permissive.
 (define_insn_and_split "@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1"
-  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l,&l")	;; bool out
+  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l")	;; bool out
 	(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))
-   (set (match_operand:SI 1 "s_register_operand" "=&r,&l,&0,&l*h")	;; val out
+   (set (match_operand:SI 1 "s_register_operand" "=&r,&l,&l*h")	;; val out
 	(zero_extend:SI
-	  (match_operand:NARROW 2 "mem_noofs_operand" "+Ua,Ua,Ua,Ua")))	;; memory
+	  (match_operand:NARROW 2 "mem_noofs_operand" "+Ua,Ua,Ua")))	;; memory
    (set (match_dup 2)
 	(unspec_volatile:NARROW
-	  [(match_operand:SI 3 "arm_add_operand" "rIL,lIL*h,J,*r")	;; expected
-	   (match_operand:NARROW 4 "s_register_operand" "r,r,r,r")	;; desired
+	  [(match_operand:SI 3 "arm_add_operand" "rIL,lILJ*h,*r")	;; expected
+	   (match_operand:NARROW 4 "s_register_operand" "r,r,r")	;; desired
 	   (match_operand:SI 5 "const_int_operand")		;; is_weak
 	   (match_operand:SI 6 "const_int_operand")		;; mod_s
 	   (match_operand:SI 7 "const_int_operand")]		;; mod_f
 	  VUNSPEC_ATOMIC_CAS))
-   (clobber (match_scratch:SI 8 "=&r,X,X,X"))]
+   (clobber (match_scratch:SI 8 "=&r,X,X"))]
   "<sync_predtab>"
   "#"
   "&& reload_completed"
@@ -209,7 +209,7 @@
     arm_split_compare_and_swap (operands);
     DONE;
   }
-  [(set_attr "arch" "32,v8mb,v8mb,v8mb")])
+  [(set_attr "arch" "32,v8mb,v8mb")])
 
 (define_mode_attr cas_cmp_operand
   [(SI "arm_add_operand") (DI "cmpdi_operand")])
@@ -219,19 +219,19 @@
 ;; Constraints of this pattern must be at least as strict as those of the
 ;; cbranchsi operations in thumb1.md and aim to be as permissive.
 (define_insn_and_split "@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1"
-  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l,&l")	;; bool out
+  [(set (match_operand:CCSI 0 "cc_register_operand" "=&c,&l,&l")	;; bool out
 	(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))
-   (set (match_operand:SIDI 1 "s_register_operand" "=&r,&l,&0,&l*h")	;; val out
-	(match_operand:SIDI 2 "mem_noofs_operand" "+Ua,Ua,Ua,Ua"))	;; memory
+   (set (match_operand:SIDI 1 "s_register_operand" "=&r,&l,&l*h")	;; val out
+	(match_operand:SIDI 2 "mem_noofs_operand" "+Ua,Ua,Ua"))	;; memory
    (set (match_dup 2)
 	(unspec_volatile:SIDI
-	  [(match_operand:SIDI 3 "<cas_cmp_operand>" "<cas_cmp_str>,lIL*h,J,*r") ;; expect
-	   (match_operand:SIDI 4 "s_register_operand" "r,r,r,r")	;; desired
+	  [(match_operand:SIDI 3 "<cas_cmp_operand>" "<cas_cmp_str>,lILJ*h,*r") ;; expect
+	   (match_operand:SIDI 4 "s_register_operand" "r,r,r")	;; desired
 	   (match_operand:SI 5 "const_int_operand")		;; is_weak
 	   (match_operand:SI 6 "const_int_operand")		;; mod_s
 	   (match_operand:SI 7 "const_int_operand")]		;; mod_f
 	  VUNSPEC_ATOMIC_CAS))
-   (clobber (match_scratch:SI 8 "=&r,X,X,X"))]
+   (clobber (match_scratch:SI 8 "=&r,X,X"))]
   "<sync_predtab>"
   "#"
   "&& reload_completed"
@@ -240,7 +240,7 @@
     arm_split_compare_and_swap (operands);
     DONE;
   }
-  [(set_attr "arch" "32,v8mb,v8mb,v8mb")])
+  [(set_attr "arch" "32,v8mb,v8mb")])
 
 (define_insn_and_split "atomic_exchange<mode>"
   [(set (match_operand:QHSD 0 "s_register_operand" "=&r,&r")	;; output
diff --git a/gcc/config/arm/thumb1.md b/gcc/config/arm/thumb1.md
index 8f051f87c0f..edbeb7340d4 100644
--- a/gcc/config/arm/thumb1.md
+++ b/gcc/config/arm/thumb1.md
@@ -1242,6 +1242,21 @@
    (set_attr "type" "multiple")]
 )
 
+;; An expander which makes use of the cbranchsi4_scratch insn, but can
+;; be used safely after RA.
+(define_expand "cbranchsi4_neg_late"
+  [(parallel [
+     (set (pc) (if_then_else
+		(match_operator 4 "arm_comparison_operator"
+		 [(match_operand:SI 1 "s_register_operand")
+		  (match_operand:SI 2 "thumb1_cmpneg_operand")])
+		(label_ref (match_operand 3 "" ""))
+		(pc)))
+     (clobber (match_operand:SI 0 "s_register_operand"))
+  ])]
+  "TARGET_THUMB1"
+)
+
 ;; Changes to the constraints of this pattern must be propagated to those of
 ;; atomic compare_and_swap splitters in sync.md.  These must be at least as
 ;; strict as the constraints here and aim to be as permissive.
diff --git a/gcc/config/i386/avx512dqintrin.h b/gcc/config/i386/avx512dqintrin.h
index f0c18fb45fb..c080c2041fa 100644
--- a/gcc/config/i386/avx512dqintrin.h
+++ b/gcc/config/i386/avx512dqintrin.h
@@ -2629,7 +2629,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_mask_fpclass_ps_mask(u, x, c)				\
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)(u)))
+						 (int) (c),(__mmask16)(u)))
 
 #define _mm512_fpclass_pd_mask(X, C)                                    \
   ((__mmask8) __builtin_ia32_fpclasspd512_mask ((__v8df) (__m512d) (X), \
@@ -2637,7 +2637,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_fpclass_ps_mask(x, c)                                    \
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)-1))
+						 (int) (c),(__mmask16)-1))
 
 #define _mm_reduce_sd(A, B, C)						\
   ((__m128d) __builtin_ia32_reducesd_mask ((__v2df)(__m128d)(A),	\
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index 6ca90d344e9..5e3b888282c 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3237,31 +3237,67 @@ _mm_maskz_scalef_round_ss (__mmask8 __U, __m128 __A, __m128 __B, const int __R)
 						      (__mmask8) __U, __R);
 }
 #else
-#define _mm512_scalef_round_pd(A, B, C)            \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_undefined_pd(), -1, C)
-
-#define _mm512_mask_scalef_round_pd(W, U, A, B, C) \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, W, U, C)
-
-#define _mm512_maskz_scalef_round_pd(U, A, B, C)   \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_setzero_pd(), U, C)
-
-#define _mm512_scalef_round_ps(A, B, C)            \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_undefined_ps(), -1, C)
-
-#define _mm512_mask_scalef_round_ps(W, U, A, B, C) \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, W, U, C)
-
-#define _mm512_maskz_scalef_round_ps(U, A, B, C)   \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_setzero_ps(), U, C)
-
-#define _mm_scalef_round_sd(A, B, C)            \
-    (__m128d)__builtin_ia32_scalefsd_mask_round (A, B, \
-	(__v2df)_mm_setzero_pd (), -1, C)
-
-#define _mm_scalef_round_ss(A, B, C)            \
-    (__m128)__builtin_ia32_scalefss_mask_round (A, B, \
-	(__v4sf)_mm_setzero_ps (), -1, C)
+#define _mm512_scalef_round_pd(A, B, C)					\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_undefined_pd(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_pd(W, U, A, B, C)			\
+  ((__m512d) __builtin_ia32_scalefpd512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_pd(U, A, B, C)			\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_setzero_pd(),	\
+				   (U), (C)))
+
+#define _mm512_scalef_round_ps(A, B, C)					\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_undefined_ps(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_ps(W, U, A, B, C)			\
+  ((__m512) __builtin_ia32_scalefps512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_ps(U, A, B, C)			\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_setzero_ps(),	\
+				   (U), (C)))
+
+#define _mm_scalef_round_sd(A, B, C)					\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_undefined_pd (),	\
+				       -1, (C)))
+
+#define _mm_scalef_round_ss(A, B, C)					\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_undefined_ps (),	\
+				       -1, (C)))
+
+#define _mm_mask_scalef_round_sd(W, U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B), (W), (U), (C)))
+
+#define _mm_mask_scalef_round_ss(W, U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B), (W), (U), (C)))
+
+#define _mm_maskz_scalef_round_sd(U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_setzero_pd (),	\
+				       (U), (C)))
+
+#define _mm_maskz_scalef_round_ss(U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_setzero_ps (),	\
+				       (U), (C)))
 #endif
 
 #ifdef __OPTIMIZE__
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index b079985e9e2..7821034931a 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -10222,7 +10222,8 @@ standard_80387_constant_p (rtx x)
   /* For XFmode constants, try to find a special 80387 instruction when
      optimizing for size or on those CPUs that benefit from them.  */
   if (mode == XFmode
-      && (optimize_function_for_size_p (cfun) || TARGET_EXT_80387_CONSTANTS))
+      && (optimize_function_for_size_p (cfun) || TARGET_EXT_80387_CONSTANTS)
+      && !flag_rounding_math)
     {
       int i;
 
@@ -33801,6 +33802,8 @@ ix86_gimple_fold_builtin (gimple_stmt_iterator *gsi)
 
     do_shift:
       gcc_assert (n_args >= 2);
+      if (!gimple_call_lhs (stmt))
+	break;
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       if (n_args > 2)
@@ -37592,6 +37595,9 @@ rdseed_step:
       return target;
 
     case IX86_BUILTIN_READ_FLAGS:
+      if (ignore)
+	return const0_rtx;
+
       emit_insn (gen_push (gen_rtx_REG (word_mode, FLAGS_REG)));
 
       if (optimize
@@ -43370,9 +43376,9 @@ quarter:
 	      else
 		{
 		  word = expand_simple_binop (word_mode, ASHIFT, word, shift,
-					      word, 1, OPTAB_LIB_WIDEN);
+					      NULL_RTX, 1, OPTAB_LIB_WIDEN);
 		  word = expand_simple_binop (word_mode, IOR, word, elt,
-					      word, 1, OPTAB_LIB_WIDEN);
+					      NULL_RTX, 1, OPTAB_LIB_WIDEN);
 		}
 	    }
 
@@ -43425,11 +43431,15 @@ ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)
       if (GET_MODE_NUNITS (GET_MODE (x)) * 2 == n_elts)
 	{
 	  rtx ops[2] = { XVECEXP (vals, 0, 0), XVECEXP (vals, 0, 1) };
-	  if (inner_mode == QImode || inner_mode == HImode)
+	  if (inner_mode == QImode
+	      || inner_mode == HImode
+	      || inner_mode == TImode)
 	    {
 	      unsigned int n_bits = n_elts * GET_MODE_SIZE (inner_mode);
-	      mode = mode_for_vector (SImode, n_bits / 4).require ();
-	      inner_mode = mode_for_vector (SImode, n_bits / 8).require ();
+	      scalar_mode elt_mode = inner_mode == TImode ? DImode : SImode;
+	      n_bits /= GET_MODE_SIZE (elt_mode);
+	      mode = mode_for_vector (elt_mode, n_bits).require ();
+	      inner_mode = mode_for_vector (elt_mode, n_bits / 2).require ();
 	      ops[0] = gen_lowpart (inner_mode, ops[0]);
 	      ops[1] = gen_lowpart (inner_mode, ops[1]);
 	      subtarget = gen_reg_rtx (mode);
@@ -44830,6 +44840,11 @@ void ix86_emit_i387_log1p (rtx op0, rtx op1)
   rtx cst, cstln2, cst1;
   rtx_insn *insn;
 
+  /* The emit_jump call emits pending stack adjust, make sure it is emitted
+     before the conditional jump, otherwise the stack adjustment will be
+     only conditional.  */
+  do_pending_stack_adjust ();
+
   cst = const_double_from_real_value
     (REAL_VALUE_ATOF ("0.29289321881345247561810596348408353", XFmode), XFmode);
   cstln2 = force_reg (XFmode, standard_80387_constant_rtx (4)); /* fldln2 */
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 8ae7ea68c16..00a1db3ec0c 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -4613,8 +4613,8 @@
      movddup is available.  */
   if (REG_P (operands[1]))
     {
-      if (!TARGET_SSE3
-	  && REGNO (operands[0]) != REGNO (operands[1]))
+      if ((!TARGET_SSE3 && REGNO (operands[0]) != REGNO (operands[1]))
+	  || (EXT_REX_SSE_REG_P (operands[1]) && !TARGET_AVX512VL))
 	{
 	  rtx tmp = lowpart_subreg (DFmode, operands[0], SFmode);
 	  emit_move_insn (tmp, operands[1]);
@@ -9823,10 +9823,16 @@
    (match_operand:MODEF 1 "register_operand")
    (match_operand:MODEF 2 "register_operand")]
   "SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH"
-  "ix86_expand_xorsign (operands); DONE;")
+{
+  if (rtx_equal_p (operands[1], operands[2]))
+    emit_insn (gen_abs<mode>2 (operands[0], operands[1]));
+  else
+    ix86_expand_xorsign (operands);
+  DONE;
+})
 
 (define_insn_and_split "xorsign<mode>3_1"
-  [(set (match_operand:MODEF 0 "register_operand" "=Yv")
+  [(set (match_operand:MODEF 0 "register_operand" "=&Yv")
 	(unspec:MODEF
 	  [(match_operand:MODEF 1 "register_operand" "Yv")
 	   (match_operand:MODEF 2 "register_operand" "0")
@@ -13451,10 +13457,12 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "bsr_rex64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:DI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:DI 0 "register_operand" "=r")
 	(minus:DI (const_int 63)
-		  (clz:DI (match_operand:DI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:DI (match_dup 1))))]
   "TARGET_64BIT"
   "bsr{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13463,10 +13471,12 @@
    (set_attr "mode" "DI")])
 
 (define_insn "bsr"
-  [(set (match_operand:SI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
 	(minus:SI (const_int 31)
-		  (clz:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:SI (match_dup 1))))]
   ""
   "bsr{l}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13474,25 +13484,15 @@
    (set_attr "znver1_decode" "vector")
    (set_attr "mode" "SI")])
 
-(define_insn "*bsrhi"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(minus:HI (const_int 15)
-		  (clz:HI (match_operand:HI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
-  ""
-  "bsr{w}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")
-   (set_attr "prefix_0f" "1")
-   (set_attr "znver1_decode" "vector")
-   (set_attr "mode" "HI")])
-
 (define_expand "clz<mode>2"
   [(parallel
-     [(set (match_operand:SWI48 0 "register_operand")
+     [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SWI48 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+      (set (match_operand:SWI48 0 "register_operand")
 	   (minus:SWI48
 	     (match_dup 2)
-	     (clz:SWI48 (match_operand:SWI48 1 "nonimmediate_operand"))))
-      (clobber (reg:CC FLAGS_REG))])
+	     (clz:SWI48 (match_dup 1))))])
    (parallel
      [(set (match_dup 0) (xor:SWI48 (match_dup 0) (match_dup 2)))
       (clobber (reg:CC FLAGS_REG))])]
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 3b51fef56f2..7de1b23eb60 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -6393,7 +6393,7 @@
 (define_expand "vec_unpacks_float_hi_v8si"
   [(set (match_dup 2)
 	(vec_select:V4SI
-	  (match_operand:V8SI 1 "vector_operand")
+	  (match_operand:V8SI 1 "register_operand")
 	  (parallel [(const_int 4) (const_int 5)
 		     (const_int 6) (const_int 7)])))
    (set (match_operand:V4DF 0 "register_operand")
@@ -18713,8 +18713,9 @@
 	    negate = true;
 	}
       par = gen_rtx_PARALLEL (V16QImode, rtvec_alloc (16));
+      tmp = lowpart_subreg (QImode, operands[2], SImode);
       for (i = 0; i < 16; i++)
-        XVECEXP (par, 0, i) = operands[2];
+	XVECEXP (par, 0, i) = tmp;
 
       tmp = gen_reg_rtx (V16QImode);
       emit_insn (gen_vec_initv16qiqi (tmp, par));
diff --git a/gcc/config/i386/sync.md b/gcc/config/i386/sync.md
index 08149006876..9e9617357fd 100644
--- a/gcc/config/i386/sync.md
+++ b/gcc/config/i386/sync.md
@@ -212,82 +212,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))
-   (set (match_dup 4) (match_dup 3))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_move_insn (operands[4], operands[3]);
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))
-   (set (match_dup 4) (match_dup 3))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_move_insn (operands[4], operands[3]);
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
 (define_expand "atomic_store<mode>"
   [(set (match_operand:ATOMIC 0 "memory_operand")
 	(unspec:ATOMIC [(match_operand:ATOMIC 1 "nonimmediate_operand")
@@ -375,82 +299,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 0) (match_dup 1))
-   (set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[0], operands[1]);
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 0) (match_dup 1))
-   (set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[0], operands[1]);
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
 ;; ??? You'd think that we'd be able to perform this via FLOAT + FIX_TRUNC
 ;; operations.  But the fix_trunc patterns want way more setup than we want
 ;; to provide.  Note that the scratch is DFmode instead of XFmode in order
@@ -800,7 +648,7 @@
   rtx result = convert_modes (<MODE>mode, QImode, tem, 1);
   if (operands[4] == const0_rtx)
     result = expand_simple_binop (<MODE>mode, ASHIFT, result,
-				  operands[2], operands[0], 0, OPTAB_DIRECT);
+				  operands[2], operands[0], 0, OPTAB_WIDEN);
   if (result != operands[0])
     emit_move_insn (operands[0], result);
   DONE;
@@ -837,7 +685,7 @@
   rtx result = convert_modes (<MODE>mode, QImode, tem, 1);
   if (operands[4] == const0_rtx)
     result = expand_simple_binop (<MODE>mode, ASHIFT, result,
-				  operands[2], operands[0], 0, OPTAB_DIRECT);
+				  operands[2], operands[0], 0, OPTAB_WIDEN);
   if (result != operands[0])
     emit_move_insn (operands[0], result);
   DONE;
@@ -875,7 +723,7 @@
   rtx result = convert_modes (<MODE>mode, QImode, tem, 1);
   if (operands[4] == const0_rtx)
     result = expand_simple_binop (<MODE>mode, ASHIFT, result,
-				  operands[2], operands[0], 0, OPTAB_DIRECT);
+				  operands[2], operands[0], 0, OPTAB_WIDEN);
   if (result != operands[0])
     emit_move_insn (operands[0], result);
   DONE;
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index d758fbf1be6..1e3ea6b5f43 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -22370,12 +22370,12 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   tree get_fcsr = mips_builtin_decls[MIPS_GET_FCSR];
   tree set_fcsr = mips_builtin_decls[MIPS_SET_FCSR];
   tree get_fcsr_hold_call = build_call_expr (get_fcsr, 0);
-  tree hold_assign_orig = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				  fcsr_orig_var, get_fcsr_hold_call);
+  tree hold_assign_orig = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				  fcsr_orig_var, get_fcsr_hold_call, NULL, NULL);
   tree hold_mod_val = build2 (BIT_AND_EXPR, MIPS_ATYPE_USI, fcsr_orig_var,
 			      build_int_cst (MIPS_ATYPE_USI, 0xfffff003));
-  tree hold_assign_mod = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				 fcsr_mod_var, hold_mod_val);
+  tree hold_assign_mod = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				 fcsr_mod_var, hold_mod_val, NULL, NULL);
   tree set_fcsr_hold_call = build_call_expr (set_fcsr, 1, fcsr_mod_var);
   tree hold_all = build2 (COMPOUND_EXPR, MIPS_ATYPE_USI,
 			  hold_assign_orig, hold_assign_mod);
@@ -22385,8 +22385,8 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   *clear = build_call_expr (set_fcsr, 1, fcsr_mod_var);
 
   tree get_fcsr_update_call = build_call_expr (get_fcsr, 0);
-  *update = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-		    exceptions_var, get_fcsr_update_call);
+  *update = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+		    exceptions_var, get_fcsr_update_call, NULL, NULL);
   tree set_fcsr_update_call = build_call_expr (set_fcsr, 1, fcsr_orig_var);
   *update = build2 (COMPOUND_EXPR, void_type_node, *update,
 		    set_fcsr_update_call);
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 18f8e127d3d..e0ed18c73fc 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -1383,7 +1383,7 @@
                         (match_operand:SF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -1398,7 +1398,7 @@
                         (match_operand:DF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -2236,6 +2236,29 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:SI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], SImode)
+    || reg_or_0_operand (operands[1], SImode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   ldw RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   {zdepi|depwi,z} %Z1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SI 0 "indexed_memory_operand" "=R")
 	(match_operand:SI 1 "register_operand" "f"))]
@@ -4024,12 +4047,12 @@
   [(set (match_operand:DF 0 "move_dest_operand"
 			  "=!*r,*r,*r,*r,*r,Q,f,f,T")
 	(match_operand:DF 1 "move_src_operand"
-			  "!*r,J,N,K,RQ,*rG,fG,RT,f"))]
+			  "!*rG,J,N,K,RQ,*rG,fG,RT,f"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !TARGET_SOFT_FLOAT && TARGET_64BIT"
   "@
-   copy %1,%0
+   copy %r1,%0
    ldi %1,%0
    ldil L'%1,%0
    depdi,z %z1,%0
@@ -4042,6 +4065,25 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "move_dest_operand"
+			  "=!*r,*r,*r,*r,*r,Q")
+	(match_operand:DF 1 "move_src_operand"
+			  "!*rG,J,N,K,RQ,*rG"))]
+  "(register_operand (operands[0], DFmode)
+    || reg_or_0_operand (operands[1], DFmode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0"
+  [(set_attr "type" "move,move,move,shift,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4")])
+
 
 (define_expand "movdi"
   [(set (match_operand:DI 0 "general_operand" "")
@@ -4200,6 +4242,28 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:DI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], DImode)
+    || reg_or_0_operand (operands[1], DImode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   ldd RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:DI 0 "indexed_memory_operand" "=R")
 	(match_operand:DI 1 "register_operand" "f"))]
@@ -4405,6 +4469,23 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "move_dest_operand"
+			  "=!*r,*r,Q")
+	(match_operand:SF 1 "reg_or_0_or_nonsymb_mem_operand"
+			  "!*rG,RQ,*rG"))]
+  "(register_operand (operands[0], SFmode)
+    || reg_or_0_operand (operands[1], SFmode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0"
+  [(set_attr "type" "move,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "indexed_memory_operand" "=R")
 	(match_operand:SF 1 "register_operand" "f"))]
@@ -5374,32 +5455,38 @@
   [(set (match_operand:DI 0 "register_operand" "")
         (mult:DI (match_operand:DI 1 "register_operand" "")
 		 (match_operand:DI 2 "register_operand" "")))]
-  "TARGET_64BIT && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
+  "! optimize_size
+   && TARGET_PA_11
+   && ! TARGET_DISABLE_FPREGS
+   && ! TARGET_SOFT_FLOAT"
   "
 {
   rtx low_product = gen_reg_rtx (DImode);
   rtx cross_product1 = gen_reg_rtx (DImode);
   rtx cross_product2 = gen_reg_rtx (DImode);
-  rtx cross_scratch = gen_reg_rtx (DImode);
-  rtx cross_product = gen_reg_rtx (DImode);
   rtx op1l, op1r, op2l, op2r;
-  rtx op1shifted, op2shifted;
-
-  op1shifted = gen_reg_rtx (DImode);
-  op2shifted = gen_reg_rtx (DImode);
-  op1l = gen_reg_rtx (SImode);
-  op1r = gen_reg_rtx (SImode);
-  op2l = gen_reg_rtx (SImode);
-  op2r = gen_reg_rtx (SImode);
-
-  emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
-						GEN_INT (32)));
-  emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
-						GEN_INT (32)));
-  op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
-  op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
-  op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
-  op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+
+  if (TARGET_64BIT)
+    {
+      rtx op1shifted = gen_reg_rtx (DImode);
+      rtx op2shifted = gen_reg_rtx (DImode);
+
+      emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
+						    GEN_INT (32)));
+      emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
+						    GEN_INT (32)));
+      op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
+      op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
+      op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
+      op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+    }
+  else
+    {
+      op1r = force_reg (SImode, gen_lowpart (SImode, operands[1]));
+      op2r = force_reg (SImode, gen_lowpart (SImode, operands[2]));
+      op1l = force_reg (SImode, gen_highpart (SImode, operands[1]));
+      op2l = force_reg (SImode, gen_highpart (SImode, operands[2]));
+    }
 
   /* Emit multiplies for the cross products.  */
   emit_insn (gen_umulsidi3 (cross_product1, op2r, op1l));
@@ -5408,13 +5495,35 @@
   /* Emit a multiply for the low sub-word.  */
   emit_insn (gen_umulsidi3 (low_product, copy_rtx (op2r), copy_rtx (op1r)));
 
-  /* Sum the cross products and shift them into proper position.  */
-  emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
-  emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+  if (TARGET_64BIT)
+    {
+      rtx cross_scratch = gen_reg_rtx (DImode);
+      rtx cross_product = gen_reg_rtx (DImode);
 
-  /* Add the cross product to the low product and store the result
-     into the output operand .  */
-  emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+      /* Sum the cross products and shift them into proper position.  */
+      emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
+      emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+
+      /* Add the cross product to the low product and store the result
+	 into the output operand .  */
+      emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+    }
+  else
+    {
+      rtx cross_scratch = gen_reg_rtx (SImode);
+
+      /* Sum cross products.  */
+      emit_move_insn (cross_scratch,
+		      gen_rtx_PLUS (SImode,
+				    gen_lowpart (SImode, cross_product1),
+				    gen_lowpart (SImode, cross_product2)));
+      emit_move_insn (gen_lowpart (SImode, operands[0]),
+		      gen_lowpart (SImode, low_product));
+      emit_move_insn (gen_highpart (SImode, operands[0]),
+		      gen_rtx_PLUS (SImode,
+				    gen_highpart (SImode, low_product),
+				    cross_scratch));
+    }
   DONE;
 }")
 
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index cb887eba521..beb3f0d0952 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -127,7 +127,7 @@
 #define vec_vcfux __builtin_vec_vcfux
 #define vec_cts __builtin_vec_cts
 #define vec_ctu __builtin_vec_ctu
-#define vec_cpsgn __builtin_vec_copysign
+#define vec_cpsgn(x,y) __builtin_vec_copysign(y,x)
 #define vec_double __builtin_vec_double
 #define vec_doublee __builtin_vec_doublee
 #define vec_doubleo __builtin_vec_doubleo
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index d30e5dec980..d8fc8a74e77 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -1501,6 +1501,22 @@ replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)
   insn->set_deleted ();
 }
 
+/* INSN is known to contain a SUBREG, which we can normally handle,
+   but if the SUBREG itself contains a MULT then we need to leave it alone
+   to avoid turning a mult_hipart into a mult_lopart, for example.  */
+static bool
+has_part_mult (rtx_insn *insn)
+{
+  rtx body = PATTERN (insn);
+  if (GET_CODE (body) != SET)
+    return false;
+  rtx src = SET_SRC (body);
+  if (GET_CODE (src) != SUBREG)
+    return false;
+  rtx inner = XEXP (src, 0);
+  return (GET_CODE (inner) == MULT);
+}
+
 /* Make NEW_MEM_EXP's attributes and flags resemble those of
    ORIGINAL_MEM_EXP.  */
 static void
@@ -2437,6 +2453,9 @@ rs6000_analyze_swaps (function *fun)
 		    insn_entry[uid].is_swappable = 0;
 		  else if (special != SH_NONE)
 		    insn_entry[uid].special_handling = special;
+		  else if (insn_entry[uid].contains_subreg
+			   && has_part_mult (insn))
+		    insn_entry[uid].is_swappable = 0;
 		  else if (insn_entry[uid].contains_subreg)
 		    insn_entry[uid].special_handling = SH_SUBREG;
 		}
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 62250433c16..991dcca18ef 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -6081,7 +6081,7 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)
 
   /* Also check if are loading up the most significant bit which can be done by
      loading up -1 and shifting the value left by -1.  */
-  else if (EASY_VECTOR_MSB (splat_val, inner))
+  else if (EASY_VECTOR_MSB (splat_val, inner) && step == 1 && copies == 1)
     ;
 
   else
@@ -6130,8 +6130,11 @@ vspltis_shifted (rtx op)
     return false;
 
   /* We need to create pseudo registers to do the shift, so don't recognize
-     shift vector constants after reload.  */
-  if (!can_create_pseudo_p ())
+     shift vector constants after reload.  Don't match it even before RA
+     after split1 is done, because there won't be further splitting pass
+     before RA to do the splitting.  */
+  if (!can_create_pseudo_p ()
+      || (cfun->curr_properties & PROP_rtl_split_insns))
     return false;
 
   nunits = GET_MODE_NUNITS (mode);
@@ -17110,23 +17113,17 @@ rs6000_init_builtins (void)
 #endif
 }
 
-/* Returns the rs6000 builtin decl for CODE.  */
+/* Returns the rs6000 builtin decl for CODE.  Note that we don't check
+   the builtin mask here since there could be some #pragma/attribute
+   target functions and the rs6000_builtin_mask could be wrong when
+   this checking happens, though it will be updated properly later.  */
 
 static tree
 rs6000_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)
 {
-  HOST_WIDE_INT fnmask;
-
   if (code >= RS6000_BUILTIN_COUNT)
     return error_mark_node;
 
-  fnmask = rs6000_builtin_info[code].mask;
-  if ((fnmask & rs6000_builtin_mask) != fnmask)
-    {
-      rs6000_invalid_builtin ((enum rs6000_builtins)code);
-      return error_mark_node;
-    }
-
   return rs6000_builtin_decls[code];
 }
 
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index f90489c0203..de5523e590f 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -1290,7 +1290,10 @@
  [(set (match_operand:VEC_N 0 "nonimmediate_operand")
        (match_operand:VEC_N 1 "any_operand"))]
  "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_ALLOW_MOVMISALIGN"
- "")
+{
+  rs6000_emit_move (operands[0], operands[1], <MODE>mode);
+  DONE;
+})
 
 ;; Vector shift right in bits. Currently supported ony for shift
 ;; amounts that can be expressed as byte shifts (divisible by 8).
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 5a3496ac92e..3dba0ac6c1c 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -973,7 +973,7 @@
 	(match_operand:GPR 2 "memory_operand"))
    (set (reg CC_REGNUM)
 	(compare (match_dup 0) (match_operand:GPR 1 "const0_operand")))]
-  "s390_match_ccmode(insn, CCSmode) && TARGET_EXTIMM
+  "s390_match_ccmode (peep2_next_insn (1), CCSmode) && TARGET_EXTIMM
    && GENERAL_REG_P (operands[0])
    && satisfies_constraint_T (operands[2])
    && !contains_constant_pool_address_p (operands[2])"
@@ -9268,7 +9268,7 @@
 (define_insn "*cmp_and_trap_unsigned_int<mode>"
   [(trap_if (match_operator 0 "s390_unsigned_integer_comparison"
 	       [(match_operand:GPR 1 "register_operand" "d,d,d")
-		(match_operand:GPR 2 "general_operand"  "d,D,T")])
+		(match_operand:GPR 2 "general_operand"  "d,D,S")])
 	    (const_int 0))]
   "TARGET_Z10"
   "@
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index d7a4ae64c36..788175e1543 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -109,8 +109,8 @@ __lcbb(const void *ptr, int bndry)
 #define vec_rint(X)   __builtin_s390_vfi((X), 0, 0)
 #define vec_roundc(X) __builtin_s390_vfi((X), 4, 0)
 #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)
-#define vec_doublee(X) __builtin_s390_vfll((X))
-#define vec_floate(X) __builtin_s390_vflr((X), 0, 0)
+#define vec_doublee(X) __builtin_s390_vflls((X))
+#define vec_floate(X) __builtin_s390_vflrd((X), 0, 0)
 #define vec_load_len_r(X,L)				\
   (__vector unsigned char)__builtin_s390_vlrlr((L),(X))
 #define vec_store_len_r(X,Y,L) \
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 0553dc501e6..69ac39e2fb4 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -8883,8 +8883,20 @@ epilogue_renumber (register rtx *where, int test)
       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */
 	return 1;
       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)
-	*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));
-      /* fallthrough */
+	{
+	  if (ORIGINAL_REGNO (*where))
+	    {
+	      rtx n = gen_raw_REG (GET_MODE (*where),
+				   OUTGOING_REGNO (REGNO (*where)));
+	      ORIGINAL_REGNO (n) = ORIGINAL_REGNO (*where);
+	      *where = n;
+	    }
+	  else
+	    *where = gen_rtx_REG (GET_MODE (*where),
+				  OUTGOING_REGNO (REGNO (*where)));
+	}
+      return 0;
+
     case SCRATCH:
     case CC0:
     case PC:
@@ -12941,9 +12953,9 @@ sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
   if (!TARGET_VIS2)
     return false;
 
-  /* All permutes are supported.  */
+  /* All 8-byte permutes are supported.  */
   if (!target)
-    return true;
+    return GET_MODE_SIZE (vmode) == 8;
 
   /* Force target-independent code to convert constant permutations on other
      modes down to V8QI.  Rely on this to avoid the complexity of the byte
diff --git a/gcc/configure b/gcc/configure
index 9e4c8693966..8c25a18fa08 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -28944,7 +28944,7 @@ $as_echo "#define HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE 1" >>confdefs.h
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/configure.ac b/gcc/configure.ac
index ec10dbeb3e9..d67f72df8a2 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5671,7 +5671,7 @@ EOF
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index 2f6b8599d7c..eb0bda3a835 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -202,15 +202,17 @@ enum profile_update {
   PROFILE_UPDATE_PREFER_ATOMIC
 };
 
-/* Types of unwind/exception handling info that can be generated.  */
+/* Types of unwind/exception handling info that can be generated.
+   Note that a UI_TARGET (or larger) setting is considered to be
+   incompatible with -freorder-blocks-and-partition.  */
 
 enum unwind_info_type
 {
   UI_NONE,
   UI_SJLJ,
   UI_DWARF2,
-  UI_TARGET,
-  UI_SEH
+  UI_SEH,
+  UI_TARGET
 };
 
 /* Callgraph node profile representation.  */
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index c6877864cab..fe9d5a153f3 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,321 @@
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101078
+	* pt.c (tsubst_baselink): Update binfos in non-dependent case.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99066
+	* pt.c (mark_decl_instantiated): Set DECL_EXTERNAL.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100838
+	PR c++/105265
+	* call.c (convert_like_internal): Clear tf_no_cleanup when
+	recursing.
+	(build_user_type_conversion_1): Only add ck_rvalue if
+	LOOKUP_ONLYCONVERTING.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91217
+	* pt.c (tsubst_lambda_expr): Skip the body block from
+	DECL_SAVED_TREE.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99643
+	* typeck2.c (massage_init_elt): Don't strip TARGET_EXPR.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* pt.c (tsubst_decl) [TYPE_DECL]: Copy TYPE_ALIGN.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* pt.c (tsubst_baselink): Also check dependent optype.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* decl.c (cp_finish_decl): Don't pass decl to push_cleanup.
+	* init.c (perform_member_init): Likewise.
+	* semantics.c (push_cleanup): Adjust comment.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/98249
+	* call.c (build_operator_new_call): Just look in ::.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* constexpr.c (maybe_save_constexpr_fundef): Don't do extra
+	checks for defaulted ctors.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/59950
+	* call.c (build_over_call): Use cp_build_indirect_ref.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99901
+	* decl.c (cp_finish_decl): mark_needed an implicitly inline
+	static data member with an out-of-class redeclaration.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101717
+	* lambda.c (lambda_expr_this_capture): Check all enclosing
+	lambdas for completeness.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90664
+	* cvt.c (can_convert_qual): Check fnptr_conv_p.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95870
+	* pt.c (enclosing_instantiation_of): Compare DECL_SOURCE_LOCATION if
+	there is no enclosing non-lambda function.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96311
+	* typeck.c (check_return_expr): Call mark_exp_read in dependent
+	case.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96673
+	* init.c (get_nsdmi): Don't defer access checking.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91933
+	* class.c (build_base_path): Shortcut simple non-pointer case.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100032
+	* pt.c (get_underlying_template): Compare TYPE_QUALS.
+
+2022-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/67184
+	PR c++/69445
+	* call.c (build_new_method_call_1): Remove set but not used variable
+	binfo.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/103455
+	* call.c (add_builtin_candidate) <case MEMBER_REF>: Test
+	CLASS_TYPE_P instead of MAYBE_CLASS_TYPE_P.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-01-25  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/101532
+	PR c++/104225
+	* decl2.c (mark_used): Don't consider maybe_instantiate_noexcept
+	on a deleted function.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* pt.c (deducible_expression): Look through implicit
+	INDIRECT_REFs as well.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105256
+	* typeck2.c (process_init_constructor_array,
+	process_init_constructor_record, process_init_constructor_union): Move
+	CONSTRUCTOR_PLACEHOLDER_BOUNDARY flag from CONSTRUCTOR elements to the
+	containing CONSTRUCTOR.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* parser.c (cp_parser_postfix_expression)
+	<case RID_BILTIN_CONVERTVECTOR>: Don't
+	return cp_build_vec_convert result right away, instead
+	set postfix_expression to it and break.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104994
+	* constexpr.c (potential_constant_expression_1): Don't diagnose extern
+	thread_local declarations.
+	* decl.c (start_decl): Likewise.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104711
+	* constexpr.c (cxx_eval_check_shift_p): Use TYPE_OVERFLOW_WRAPS
+	instead of TYPE_UNSIGNED.
+	* typeck.c (cp_build_binary_op): Don't emit
+	-Wshift-negative-value warning if TYPE_OVERFLOW_WRAPS.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104806
+	* search.c (lookup_field_fuzzy_info::fuzzy_lookup_field): Ignore
+	identifiers with space at the end.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104513
+	* constexpr.c (potential_constant_expression_1) <case GOTO_EXPR>:
+	Don't punt if returns (target).
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104472
+	* constexpr.c (cxx_eval_internal_function) <case IFN_VEC_CONVERT>:
+	Only return fold_const_call result if it is non-NULL.  Otherwise
+	fall through into the default: case to return t, set *non_constant_p
+	and emit diagnostics if needed.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/70796
+	* cp-gimplify.c (cp_gimplify_arg): New function.
+	(cp_gimplify_expr): Use cp_gimplify_arg instead of gimplify_arg,
+	pass true as last argument to it if there are any following
+	arguments in strong evaluation order with side-effects.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102786
+	* constexpr.c (cxx_eval_constant_expression): Don't reject
+	INTEGER_CSTs with type POINTER_TYPE to METHOD_TYPE.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102548
+	* tree.c (apply_identity_attributes): Fix handling of the
+	case where an attribute in the list doesn't affect type
+	identity but some attribute before it does.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88578
+	PR c++/102295
+	* typeck2.c (split_nonconstant_init_1): Don't throw away empty
+	initializers of flexible array members if they have non-zero type
+	size.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102295
+	* decl.c (layout_var_decl): For aggregates ending with a flexible
+	array member, add the size of the initializer for that member to
+	DECL_SIZE and DECL_SIZE_UNIT.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102305
+	* method.c (is_xible_helper): Call complete_type on to.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101516
+	* semantics.c (finish_omp_reduction_clause): Also call
+	complete_type_or_else and return true if it fails.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* semantics.c (finish_omp_reduction_clause): Accept float + complex
+	for || and && reductions.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101443
+	* cp-gimplify.c (cp_fold): For comparisons with NULLPTR_TYPE
+	operands, fold them right away to true or false.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/100785
+	* typeck.c (cxx_mark_addressable): Diagnose trying to make
+	bit-fields addressable.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100666
+	* call.c (convert_arg_to_ellipsis): For expressions with NULLPTR_TYPE
+	and side-effects, temporarily disable -Wunused-result warning when
+	building COMPOUND_EXPR.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 304c01619da..47db70a8f0b 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -2684,7 +2684,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,
 	  tree c1 = TREE_TYPE (type1);
 	  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);
 
-	  if (MAYBE_CLASS_TYPE_P (c1) && DERIVED_FROM_P (c2, c1)
+	  if (CLASS_TYPE_P (c1) && DERIVED_FROM_P (c2, c1)
 	      && (TYPE_PTRMEMFUNC_P (type2)
 		  || is_complete (TYPE_PTRMEM_POINTED_TO_TYPE (type2))))
 	    break;
@@ -3959,7 +3959,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 	{
 	  cand->second_conv = build_identity_conv (totype, NULL_TREE);
 
-	  /* If totype isn't a reference, and LOOKUP_NO_TEMP_BIND isn't
+	  /* If totype isn't a reference, and LOOKUP_ONLYCONVERTING is
 	     set, then this is copy-initialization.  In that case, "The
 	     result of the call is then used to direct-initialize the
 	     object that is the destination of the copy-initialization."
@@ -3968,6 +3968,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 	     We represent this in the conversion sequence with an
 	     rvalue conversion, which means a constructor call.  */
 	  if (!TYPE_REF_P (totype)
+	      && cxx_dialect < cxx17
+	      && (flags & LOOKUP_ONLYCONVERTING)
 	      && !(convflags & LOOKUP_NO_TEMP_BIND))
 	    cand->second_conv
 	      = build_conv (ck_rvalue, totype, cand->second_conv);
@@ -4584,7 +4586,6 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,
 
      we disregard block-scope declarations of "operator new".  */
   fns = lookup_name_real (fnname, 0, 1, /*block_p=*/false, 0, 0);
-  fns = lookup_arg_dependent (fnname, fns, *args);
 
   if (align_arg)
     {
@@ -7315,7 +7316,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,
   expr = convert_like_real (next_conversion (convs), expr, fn, argnum,
 			    convs->kind == ck_ref_bind
 			    ? issue_conversion_warnings : false, 
-			    c_cast_p, complain);
+			    c_cast_p, complain & ~tf_no_cleanup);
   if (expr == error_mark_node)
     return error_mark_node;
 
@@ -7564,7 +7565,10 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)
   else if (NULLPTR_TYPE_P (arg_type))
     {
       if (TREE_SIDE_EFFECTS (arg))
-	arg = cp_build_compound_expr (arg, null_pointer_node, complain);
+	{
+	  warning_sentinel w(warn_unused_result);
+	  arg = cp_build_compound_expr (arg, null_pointer_node, complain);
+	}
       else
 	arg = null_pointer_node;
     }
@@ -8659,8 +8663,11 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
 	   && DECL_OVERLOADED_OPERATOR_IS (fn, NOP_EXPR)
 	   && trivial_fn_p (fn))
     {
-      tree to = cp_stabilize_reference
-	(cp_build_fold_indirect_ref (argarray[0]));
+      /* Don't use cp_build_fold_indirect_ref, op= returns an lvalue even if
+	 the object argument isn't one.  */
+      tree to = cp_build_indirect_ref (argarray[0],
+				       RO_ARROW, complain);
+      to = cp_stabilize_reference (to);
       tree type = TREE_TYPE (to);
       tree as_base = CLASSTYPE_AS_BASE (type);
       tree arg = argarray[1];
@@ -9641,7 +9648,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,
   struct z_candidate *candidates = 0, *cand;
   tree explicit_targs = NULL_TREE;
   tree basetype = NULL_TREE;
-  tree access_binfo, binfo;
+  tree access_binfo;
   tree optype;
   tree first_mem_arg = NULL_TREE;
   tree name;
@@ -9680,7 +9687,6 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,
   if (!conversion_path)
     conversion_path = BASELINK_BINFO (fns);
   access_binfo = BASELINK_ACCESS_BINFO (fns);
-  binfo = BASELINK_BINFO (fns);
   optype = BASELINK_OPTYPE (fns);
   fns = BASELINK_FUNCTIONS (fns);
   if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index a81eeee77d9..26e6882aa2b 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -331,6 +331,15 @@ build_base_path (enum tree_code code,
       return error_mark_node;
     }
 
+  bool uneval = (cp_unevaluated_operand != 0
+		 || processing_template_decl
+		 || in_template_function ());
+
+  /* For a non-pointer simple base reference, express it as a COMPONENT_REF
+     without taking its address (and so causing lambda capture, 91933).  */
+  if (code == PLUS_EXPR && !v_binfo && !want_pointer && !has_empty && !uneval)
+    return build_simple_base_path (expr, binfo);
+
   if (!want_pointer)
     {
       rvalue = !lvalue_p (expr);
@@ -358,9 +367,7 @@ build_base_path (enum tree_code code,
      template (even in instantiate_non_dependent_expr), we don't have vtables
      set up properly yet, and the value doesn't matter there either; we're
      just interested in the result of overload resolution.  */
-  if (cp_unevaluated_operand != 0
-      || processing_template_decl
-      || in_template_function ())
+  if (uneval)
     {
       expr = build_nop (ptr_target_type, expr);
       goto indout;
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index 43929e5c40b..b886082d128 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -890,7 +890,7 @@ register_constexpr_fundef (tree fun, tree body)
       return NULL;
     }
 
-  if (DECL_CONSTRUCTOR_P (fun)
+  if (DECL_CONSTRUCTOR_P (fun) && !DECL_DEFAULTED_FN (fun)
       && cx_check_missing_mem_inits (DECL_CONTEXT (fun),
 				     massaged, !DECL_GENERATED_P (fun)))
     return NULL;
@@ -1529,13 +1529,10 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,
 						 false, non_constant_p,
 						 overflow_p);
 	if (TREE_CODE (arg) == VECTOR_CST)
-	  return fold_const_call (CFN_VEC_CONVERT, TREE_TYPE (t), arg);
-	else
-	  {
-	    *non_constant_p = true;
-	    return t;
-	  }
+	  if (tree r = fold_const_call (CFN_VEC_CONVERT, TREE_TYPE (t), arg))
+	    return r;
       }
+      /* FALLTHRU */
 
     default:
       if (!ctx->quiet)
@@ -2063,7 +2060,7 @@ cxx_eval_check_shift_p (location_t loc, const constexpr_ctx *ctx,
      The value of E1 << E2 is the unique value congruent to E1 x 2^E2 modulo
      2^N, where N is the range exponent of the type of the result.  */
   if (code == LSHIFT_EXPR
-      && !TYPE_UNSIGNED (lhstype)
+      && !TYPE_OVERFLOW_WRAPS (lhstype)
       && cxx_dialect >= cxx11
       && cxx_dialect < cxx2a)
     {
@@ -4469,6 +4466,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 
       if (TREE_CODE (t) == INTEGER_CST
 	  && TYPE_PTR_P (TREE_TYPE (t))
+	  /* INTEGER_CST with pointer-to-method type is only used
+	     for a virtual method in a pointer to member function.
+	     Don't reject those.  */
+	  && TREE_CODE (TREE_TYPE (TREE_TYPE (t))) != METHOD_TYPE
 	  && !integer_zerop (t))
 	{
 	  if (!ctx->quiet)
@@ -6662,18 +6663,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
       tmp = DECL_EXPR_DECL (t);
       if (VAR_P (tmp) && !DECL_ARTIFICIAL (tmp))
 	{
-	  if (TREE_STATIC (tmp))
+	  if (CP_DECL_THREAD_LOCAL_P (tmp) && !DECL_REALLY_EXTERN (tmp))
 	    {
 	      if (flags & tf_error)
 		error_at (DECL_SOURCE_LOCATION (tmp), "%qD declared "
-			  "%<static%> in %<constexpr%> context", tmp);
+			  "%<thread_local%> in %<constexpr%> context", tmp);
 	      return false;
 	    }
-	  else if (CP_DECL_THREAD_LOCAL_P (tmp))
+	  else if (TREE_STATIC (tmp))
 	    {
 	      if (flags & tf_error)
 		error_at (DECL_SOURCE_LOCATION (tmp), "%qD declared "
-			  "%<thread_local%> in %<constexpr%> context", tmp);
+			  "%<static%> in %<constexpr%> context", tmp);
 	      return false;
 	    }
 	  else if (!check_for_uninitialized_const_var
@@ -6927,8 +6928,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
     case GOTO_EXPR:
       {
 	tree *target = &TREE_OPERAND (t, 0);
-	/* Gotos representing break and continue are OK.  */
-	if (breaks (target) || continues (target))
+	/* Gotos representing break, continue and cdtor return are OK.  */
+	if (breaks (target) || continues (target) || returns (target))
 	  {
 	    *jump_target = *target;
 	    return true;
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index 5dde4f005bf..6e26ee99cf7 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -637,6 +637,47 @@ lvalue_has_side_effects (tree e)
     return TREE_SIDE_EFFECTS (e);
 }
 
+/* Like gimplify_arg, but if ORDERED is set (which should be set if
+   any of the arguments this argument is sequenced before has
+   TREE_SIDE_EFFECTS set, make sure expressions with is_gimple_reg_type type
+   are gimplified into SSA_NAME or a fresh temporary and for
+   non-is_gimple_reg_type we don't optimize away TARGET_EXPRs.  */
+
+static enum gimplify_status
+cp_gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location,
+		 bool ordered)
+{
+  enum gimplify_status t;
+  if (ordered
+      && !is_gimple_reg_type (TREE_TYPE (*arg_p))
+      && TREE_CODE (*arg_p) == TARGET_EXPR)
+    {
+      /* gimplify_arg would strip away the TARGET_EXPR, but
+	 that can mean we don't copy the argument and some following
+	 argument with side-effect could modify it.  */
+      protected_set_expr_location (*arg_p, call_location);
+      return gimplify_expr (arg_p, pre_p, NULL, is_gimple_lvalue, fb_either);
+    }
+  else
+    {
+      t = gimplify_arg (arg_p, pre_p, call_location);
+      if (t == GS_ERROR)
+	return GS_ERROR;
+      else if (ordered
+	       && is_gimple_reg_type (TREE_TYPE (*arg_p))
+	       && is_gimple_variable (*arg_p)
+	       && TREE_CODE (*arg_p) != SSA_NAME
+	       /* No need to force references into register, references
+		  can't be modified.  */
+	       && !TYPE_REF_P (TREE_TYPE (*arg_p))
+	       /* And this can't be modified either.  */
+	       && *arg_p != current_class_ptr)
+	*arg_p = get_initialized_tmp_var (*arg_p, pre_p, NULL);
+      return t;
+    }
+
+}
+
 /* Do C++-specific gimplification.  Args are as for gimplify_expr.  */
 
 int
@@ -846,7 +887,8 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	  gcc_assert (call_expr_nargs (*expr_p) == 2);
 	  gcc_assert (!CALL_EXPR_ORDERED_ARGS (*expr_p));
 	  enum gimplify_status t
-	    = gimplify_arg (&CALL_EXPR_ARG (*expr_p, 1), pre_p, loc);
+	    = cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, 1), pre_p, loc,
+			       TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, 0)));
 	  if (t == GS_ERROR)
 	    ret = GS_ERROR;
 	}
@@ -855,10 +897,18 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	  /* Leave the last argument for gimplify_call_expr, to avoid problems
 	     with __builtin_va_arg_pack().  */
 	  int nargs = call_expr_nargs (*expr_p) - 1;
+	  int last_side_effects_arg = -1;
+	  for (int i = nargs; i > 0; --i)
+	    if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))
+	      {
+		last_side_effects_arg = i;
+		break;
+	      }
 	  for (int i = 0; i < nargs; ++i)
 	    {
 	      enum gimplify_status t
-		= gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p, loc);
+		= cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p, loc,
+				   i < last_side_effects_arg);
 	      if (t == GS_ERROR)
 		ret = GS_ERROR;
 	    }
@@ -872,8 +922,17 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	    fntype = TREE_TYPE (fntype);
 	  if (TREE_CODE (fntype) == METHOD_TYPE)
 	    {
+	      int nargs = call_expr_nargs (*expr_p);
+	      bool side_effects = false;
+	      for (int i = 1; i < nargs; ++i)
+		if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))
+		  {
+		    side_effects = true;
+		    break;
+		  }
 	      enum gimplify_status t
-		= gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p, loc);
+		= cp_gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p, loc,
+				   side_effects);
 	      if (t == GS_ERROR)
 		ret = GS_ERROR;
 	    }
@@ -2537,6 +2596,32 @@ cp_fold (tree x)
       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);
       op1 = cp_fold_rvalue (TREE_OPERAND (x, 1));
 
+      /* decltype(nullptr) has only one value, so optimize away all comparisons
+	 with that type right away, keeping them in the IL causes troubles for
+	 various optimizations.  */
+      if (COMPARISON_CLASS_P (org_x)
+	  && TREE_CODE (TREE_TYPE (op0)) == NULLPTR_TYPE
+	  && TREE_CODE (TREE_TYPE (op1)) == NULLPTR_TYPE)
+	{
+	  switch (code)
+	    {
+	    case EQ_EXPR:
+	    case LE_EXPR:
+	    case GE_EXPR:
+	      x = constant_boolean_node (true, TREE_TYPE (x));
+	      break;
+	    case NE_EXPR:
+	    case LT_EXPR:
+	    case GT_EXPR:
+	      x = constant_boolean_node (false, TREE_TYPE (x));
+	      break;
+	    default:
+	      gcc_unreachable ();
+	    }
+	  return omit_two_operands_loc (loc, TREE_TYPE (x), x,
+					op0, op1);
+	}
+
       if (op0 != TREE_OPERAND (x, 0) || op1 != TREE_OPERAND (x, 1))
 	{
 	  if (op0 == error_mark_node || op1 == error_mark_node)
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index 3b8656c2a6b..c2bad5eb43d 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -1960,6 +1960,11 @@ can_convert_qual (tree type, tree expr)
   tree expr_type = TREE_TYPE (expr);
   gcc_assert (!same_type_p (type, expr_type));
 
+  /* A function pointer conversion also counts as a Qualification Adjustment
+     under [over.ics.scs].  */
+  if (fnptr_conv_p (type, expr_type))
+    return true;
+
   if (TYPE_PTR_P (type) && TYPE_PTR_P (expr_type))
     return comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (expr_type));
   else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (expr_type))
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 782f0f6e60f..bf732ba65cd 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -5267,7 +5267,7 @@ start_decl (const cp_declarator *declarator,
       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))
     {
       bool ok = false;
-      if (CP_DECL_THREAD_LOCAL_P (decl))
+      if (CP_DECL_THREAD_LOCAL_P (decl) && !DECL_REALLY_EXTERN (decl))
 	error_at (DECL_SOURCE_LOCATION (decl),
 		  "%qD declared %<thread_local%> in %<constexpr%> function",
 		  decl);
@@ -5616,6 +5616,38 @@ layout_var_decl (tree decl)
 	  error_at (DECL_SOURCE_LOCATION (decl),
 		    "storage size of %qD isn%'t constant", decl);
 	  TREE_TYPE (decl) = error_mark_node;
+	  type = error_mark_node;
+	}
+    }
+
+  /* If the final element initializes a flexible array field, add the size of
+     that initializer to DECL's size.  */
+  if (type != error_mark_node
+      && DECL_INITIAL (decl)
+      && TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR
+      && !vec_safe_is_empty (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)))
+      && DECL_SIZE (decl) != NULL_TREE
+      && TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST
+      && TYPE_SIZE (type) != NULL_TREE
+      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
+      && tree_int_cst_equal (DECL_SIZE (decl), TYPE_SIZE (type)))
+    {
+      constructor_elt &elt = CONSTRUCTOR_ELTS (DECL_INITIAL (decl))->last ();
+      if (elt.index)
+	{
+	  tree itype = TREE_TYPE (elt.index);
+	  tree vtype = TREE_TYPE (elt.value);
+	  if (TREE_CODE (itype) == ARRAY_TYPE
+	      && TYPE_DOMAIN (itype) == NULL
+	      && TREE_CODE (vtype) == ARRAY_TYPE
+	      && COMPLETE_TYPE_P (vtype))
+	    {
+	      DECL_SIZE (decl)
+		= size_binop (PLUS_EXPR, DECL_SIZE (decl), TYPE_SIZE (vtype));
+	      DECL_SIZE_UNIT (decl)
+		= size_binop (PLUS_EXPR, DECL_SIZE_UNIT (decl),
+			      TYPE_SIZE_UNIT (vtype));
+	    }
 	}
     }
 }
@@ -6978,10 +7010,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
   if (asmspec_tree && asmspec_tree != error_mark_node)
     asmspec = TREE_STRING_POINTER (asmspec_tree);
 
-  if (current_class_type
-      && CP_DECL_CONTEXT (decl) == current_class_type
-      && TYPE_BEING_DEFINED (current_class_type)
-      && !CLASSTYPE_TEMPLATE_INSTANTIATION (current_class_type)
+  bool in_class_decl
+    = (current_class_type
+       && CP_DECL_CONTEXT (decl) == current_class_type
+       && TYPE_BEING_DEFINED (current_class_type)
+       && !CLASSTYPE_TEMPLATE_INSTANTIATION (current_class_type));
+
+  if (in_class_decl
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
@@ -7313,6 +7348,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 	{
 	  layout_var_decl (decl);
 	  maybe_commonize_var (decl);
+	  /* A class-scope constexpr variable with an out-of-class declaration.
+	     C++17 makes them implicitly inline, but still force it out.  */
+	  if (DECL_INLINE_VAR_P (decl)
+	      && !DECL_VAR_DECLARED_INLINE_P (decl)
+	      && !DECL_TEMPLATE_INSTANTIATION (decl)
+	      && !in_class_decl)
+	    mark_needed (decl);
 	}
 
       /* This needs to happen after the linkage is set. */
@@ -7400,7 +7442,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     {
       unsigned i; tree t;
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
       release_tree_vector (cleanups);
     }
 
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 672bd62f1ce..b64a4d7caa1 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -5403,6 +5403,7 @@ mark_used (tree decl, tsubst_flags_t complain)
     used_types_insert (DECL_CONTEXT (decl));
 
   if (TREE_CODE (decl) == FUNCTION_DECL
+      && !DECL_DELETED_FN (decl)
       && !maybe_instantiate_noexcept (decl, complain))
     return false;
 
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 44f767481c4..8e60b947397 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -591,6 +591,7 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 	    {
 	      push_to_top_level ();
 	      push_nested_class (ctx);
+	      push_deferring_access_checks (dk_no_deferred);
 	      pushed = true;
 	    }
 
@@ -620,6 +621,7 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 
 	  if (pushed)
 	    {
+	      pop_deferring_access_checks ();
 	      pop_nested_class ();
 	      pop_from_top_level ();
 	    }
@@ -876,7 +878,7 @@ perform_member_init (tree member, tree init)
       init = build2 (INIT_EXPR, type, decl, init);
       finish_expr_stmt (init);
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
       release_tree_vector (cleanups);
     }
   else if (type_build_ctor_call (type)
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index 1ee75814004..46ee390a9b8 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -745,6 +745,7 @@ lambda_expr_this_capture (tree lambda, int add_capture_p)
     {
       tree lambda_stack = NULL_TREE;
       tree init = NULL_TREE;
+      bool saw_complete = false;
 
       /* If we are in a lambda function, we can move out until we hit:
            1. a non-lambda function or NSDMI,
@@ -763,6 +764,11 @@ lambda_expr_this_capture (tree lambda, int add_capture_p)
 				      lambda_stack);
 
 	  tree closure = LAMBDA_EXPR_CLOSURE (tlambda);
+	  if (COMPLETE_TYPE_P (closure))
+	    /* We're instantiating a generic lambda op(), the containing
+	       scope may be gone.  */
+	    saw_complete = true;
+
 	  tree containing_function
 	    = decl_function_context (TYPE_NAME (closure));
 
@@ -772,7 +778,7 @@ lambda_expr_this_capture (tree lambda, int add_capture_p)
 	      /* Lambda in an NSDMI.  We don't have a function to look up
 		 'this' in, but we can find (or rebuild) the fake one from
 		 inject_this_parameter.  */
-	      if (!containing_function && !COMPLETE_TYPE_P (closure))
+	      if (!containing_function && !saw_complete)
 		/* If we're parsing a lambda in a non-local class,
 		   we can find the fake 'this' in scope_chain.  */
 		init = scope_chain->x_current_class_ptr;
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index 74a1e8187a8..8c891dc08f3 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -1196,6 +1196,7 @@ constructible_expr (tree to, tree from)
 static tree
 is_xible_helper (enum tree_code code, tree to, tree from, bool trivial)
 {
+  to = complete_type (to);
   if (VOID_TYPE_P (to) || ABSTRACT_CLASS_TYPE_P (to)
       || (from && FUNC_OR_METHOD_TYPE_P (from)
 	  && (TYPE_READONLY (from) || FUNCTION_REF_QUALIFIED (from))))
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 96151a70a7f..61df63be92f 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -7077,8 +7077,10 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,
 	}
 	/* Look for the closing `)'.  */
 	parens.require_close (parser);
-	return cp_build_vec_convert (expression, type_location, type,
-				     tf_warning_or_error);
+	postfix_expression
+	  = cp_build_vec_convert (expression, type_location, type,
+				  tf_warning_or_error);
+	break;
       }
 
     default:
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 612557bb717..b4d522b3769 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -6255,6 +6255,10 @@ get_underlying_template (tree tmpl)
 	      != num_innermost_template_parms (underlying)))
 	break;
 
+      /* Does the alias add cv-quals?  */
+      if (TYPE_QUALS (TREE_TYPE (underlying)) != TYPE_QUALS (TREE_TYPE (tmpl)))
+	break;
+
       tree alias_args = INNERMOST_TEMPLATE_ARGS
 	(template_parms_to_args (DECL_TEMPLATE_PARMS (tmpl)));
       if (!comp_template_args (TI_ARGS (tinfo), alias_args))
@@ -13522,6 +13526,19 @@ enclosing_instantiation_of (tree otctx)
 		  || instantiated_lambda_fn_p (tctx));
        tctx = decl_function_context (tctx))
     ++lambda_count;
+
+  if (!tctx)
+    {
+      /* Match using DECL_SOURCE_LOCATION, which is unique for all lambdas.
+
+	 For GCC 11 the above condition limits this to the previously failing
+	 case where all enclosing functions are lambdas (95870).  FIXME.  */
+      for (tree ofn = fn; ofn; ofn = decl_function_context (ofn))
+	if (DECL_SOURCE_LOCATION (ofn) == DECL_SOURCE_LOCATION (otctx))
+	  return ofn;
+      gcc_unreachable ();
+    }
+
   for (; fn; fn = decl_function_context (fn))
     {
       tree ofn = fn;
@@ -14078,6 +14095,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	  {
 	    DECL_ORIGINAL_TYPE (r) = NULL_TREE;
 	    set_underlying_type (r);
+
+	    /* common_handle_aligned_attribute doesn't apply the alignment
+	       to DECL_ORIGINAL_TYPE.  */
+	    if (TYPE_USER_ALIGN (TREE_TYPE (t)))
+	      TREE_TYPE (r) = build_aligned_type (TREE_TYPE (r),
+						  TYPE_ALIGN (TREE_TYPE (t)));
+
 	    if (TYPE_DECL_ALIAS_P (r))
 	      /* An alias template specialization can be dependent
 		 even if its underlying type is not.  */
@@ -15409,7 +15433,8 @@ tsubst_baselink (tree baselink, tree object_type,
 
   tree binfo_type = BINFO_TYPE (BASELINK_BINFO (baselink));
   binfo_type = tsubst (binfo_type, args, complain, in_decl);
-  bool dependent_p = binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink));
+  bool dependent_p = (binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink))
+		      || optype != BASELINK_OPTYPE (baselink));
 
   if (dependent_p)
     {
@@ -15435,8 +15460,19 @@ tsubst_baselink (tree baselink, tree object_type,
 	fns = BASELINK_FUNCTIONS (baselink);
     }
   else
-    /* We're going to overwrite pieces below, make a duplicate.  */
-    baselink = copy_node (baselink);
+    {
+      /* We're going to overwrite pieces below, make a duplicate.  */
+      baselink = copy_node (baselink);
+
+      if (qualifying_scope != BINFO_TYPE (BASELINK_ACCESS_BINFO (baselink)))
+	{
+	  /* The decl we found was from non-dependent scope, but we still need
+	     to update the binfos for the instantiated qualifying_scope.  */
+	  BASELINK_ACCESS_BINFO (baselink) = TYPE_BINFO (qualifying_scope);
+	  BASELINK_BINFO (baselink) = lookup_base (qualifying_scope, binfo_type,
+						   ba_unique, NULL, complain);
+	}
+    }
 
   /* If lookup found a single function, mark it as used at this point.
      (If lookup found multiple functions the one selected later by
@@ -18447,8 +18483,13 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	 the purposes of template argument deduction. */
       complain = tf_warning_or_error;
 
-      tsubst_expr (DECL_SAVED_TREE (oldfn), args, complain, r,
-		   /*constexpr*/false);
+      tree saved = DECL_SAVED_TREE (oldfn);
+      if (TREE_CODE (saved) == BIND_EXPR && BIND_EXPR_BODY_BLOCK (saved))
+	/* We already have a body block from start_lambda_function, we don't
+	   need another to confuse NRV (91217).  */
+	saved = BIND_EXPR_BODY (saved);
+
+      tsubst_expr (saved, args, complain, r, /*constexpr*/false);
 
       finish_lambda_function (body);
 
@@ -20824,8 +20865,10 @@ static bool uses_deducible_template_parms (tree type);
 static bool
 deducible_expression (tree expr)
 {
-  /* Strip implicit conversions.  */
-  while (CONVERT_EXPR_P (expr) || TREE_CODE (expr) == VIEW_CONVERT_EXPR)
+  /* Strip implicit conversions and implicit INDIRECT_REFs.  */
+  while (CONVERT_EXPR_P (expr)
+	 || TREE_CODE (expr) == VIEW_CONVERT_EXPR
+	 || REFERENCE_REF_P (expr))
     expr = TREE_OPERAND (expr, 0);
   return (TREE_CODE (expr) == TEMPLATE_PARM_INDEX);
 }
@@ -23139,7 +23182,10 @@ mark_decl_instantiated (tree result, int extern_p)
   DECL_COMDAT (result) = 0;
 
   if (extern_p)
-    DECL_NOT_REALLY_EXTERN (result) = 0;
+    {
+      DECL_EXTERNAL (result) = 1;
+      DECL_NOT_REALLY_EXTERN (result) = 0;
+    }
   else
     {
       mark_definable (result);
diff --git a/gcc/cp/search.c b/gcc/cp/search.c
index 4c3fffda717..39b8680d642 100644
--- a/gcc/cp/search.c
+++ b/gcc/cp/search.c
@@ -1249,6 +1249,13 @@ lookup_field_fuzzy_info::fuzzy_lookup_field (tree type)
       if (is_lambda_ignored_entity (field))
 	continue;
 
+      /* Ignore special identifiers with space at the end like cdtor or
+	 conversion op identifiers.  */
+      if (TREE_CODE (DECL_NAME (field)) == IDENTIFIER_NODE)
+	if (unsigned int len = IDENTIFIER_LENGTH (DECL_NAME (field)))
+	  if (IDENTIFIER_POINTER (DECL_NAME (field))[len - 1] == ' ')
+	    continue;
+
       m_candidates.safe_push (DECL_NAME (field));
     }
 }
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 3c578fbfa60..579bfcbdc5c 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -476,7 +476,8 @@ do_pushlevel (scope_kind sk)
 
 /* Queue a cleanup.  CLEANUP is an expression/statement to be executed
    when the current scope is exited.  EH_ONLY is true when this is not
-   meant to apply to normal control flow transfer.  */
+   meant to apply to normal control flow transfer.  DECL is the VAR_DECL
+   being cleaned up, if any, or null for temporaries or subobjects.  */
 
 void
 push_cleanup (tree decl, tree cleanup, bool eh_only)
@@ -5682,7 +5683,8 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)
       if (!processing_template_decl)
 	{
 	  t = require_complete_type (t);
-	  if (t == error_mark_node)
+	  if (t == error_mark_node
+	      || !complete_type_or_else (oatype, NULL_TREE))
 	    return true;
 	  tree size = size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (oatype),
 				  TYPE_SIZE_UNIT (type));
@@ -5712,6 +5714,8 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)
       case PLUS_EXPR:
       case MULT_EXPR:
       case MINUS_EXPR:
+      case TRUTH_ANDIF_EXPR:
+      case TRUTH_ORIF_EXPR:
 	predefined = true;
 	break;
       case MIN_EXPR:
@@ -5727,12 +5731,6 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)
 	  break;
 	predefined = true;
 	break;
-      case TRUTH_ANDIF_EXPR:
-      case TRUTH_ORIF_EXPR:
-	if (FLOAT_TYPE_P (type))
-	  break;
-	predefined = true;
-	break;
       default:
 	break;
       }
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 896c67c850a..57b9ade7396 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -1408,9 +1408,9 @@ apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)
 	      p = &TREE_CHAIN (*p);
 	    }
 	}
-      else if (first_ident)
+      else if (first_ident && first_ident != error_mark_node)
 	{
-	  for (tree a2 = first_ident; a2; a2 = TREE_CHAIN (a2))
+	  for (tree a2 = first_ident; a2 != a; a2 = TREE_CHAIN (a2))
 	    {
 	      *p = tree_cons (TREE_PURPOSE (a2), TREE_VALUE (a2), NULL_TREE);
 	      p = &TREE_CHAIN (*p);
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index ab703a3ff07..39f354a373f 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -4838,6 +4838,7 @@ cp_build_binary_op (const op_location_t &location,
 	  doing_shift = true;
 	  if (TREE_CODE (const_op0) == INTEGER_CST
 	      && tree_int_cst_sgn (const_op0) < 0
+	      && !TYPE_OVERFLOW_WRAPS (type0)
 	      && (complain & tf_warning)
 	      && c_inhibit_evaluation_warnings == 0)
 	    warning (OPT_Wshift_negative_value,
@@ -6665,9 +6666,14 @@ cxx_mark_addressable (tree exp, bool array_ref_p)
 	    && TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE
 	    && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))))
 	  return true;
+	x = TREE_OPERAND (x, 0);
+	break;
+
+      case COMPONENT_REF:
+	if (bitfield_p (x))
+	  error ("attempt to take address of bit-field");
 	/* FALLTHRU */
       case ADDR_EXPR:
-      case COMPONENT_REF:
       case ARRAY_REF:
       case REALPART_EXPR:
       case IMAGPART_EXPR:
@@ -9714,6 +9720,9 @@ check_return_expr (tree retval, bool *no_warning)
     dependent:
       /* We should not have changed the return value.  */
       gcc_assert (retval == saved_retval);
+      /* We don't know if this is an lvalue or rvalue use, but
+	 either way we can mark it as read.  */
+      mark_exp_read (retval);
       return retval;
     }
 
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index aae5ff24c98..72d2bc3121e 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -654,7 +654,20 @@ split_nonconstant_init_1 (tree dest, tree init)
 		sub = build3 (COMPONENT_REF, inner_type, dest, field_index,
 			      NULL_TREE);
 
-	      if (!split_nonconstant_init_1 (sub, value))
+	      if (!split_nonconstant_init_1 (sub, value)
+		      /* For flexible array member with initializer we
+			 can't remove the initializer, because only the
+			 initializer determines how many elements the
+			 flexible array member has.  */
+		  || (!array_type_p
+		      && TREE_CODE (inner_type) == ARRAY_TYPE
+		      && TYPE_DOMAIN (inner_type) == NULL
+		      && TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE
+		      && COMPLETE_TYPE_P (TREE_TYPE (value))
+		      && !integer_zerop (TYPE_SIZE (TREE_TYPE (value)))
+		      && idx == CONSTRUCTOR_NELTS (init) - 1
+		      && TYPE_HAS_TRIVIAL_DESTRUCTOR
+				(strip_array_types (inner_type))))
 		complete_p = false;
 	      else
 		CONSTRUCTOR_ELTS (init)->ordered_remove (idx--);
@@ -1345,9 +1358,6 @@ massage_init_elt (tree type, tree init, int nested, int flags,
   flags &= LOOKUP_ALLOW_FLEXARRAY_INIT;
   flags |= LOOKUP_IMPLICIT;
   init = digest_init_r (type, init, nested ? 2 : 1, flags, complain);
-  /* Strip a simple TARGET_EXPR when we know this is an initializer.  */
-  if (SIMPLE_TARGET_EXPR_P (init))
-    init = TARGET_EXPR_INITIAL (init);
   /* When we defer constant folding within a statement, we may want to
      defer this folding as well.  */
   tree t = fold_non_dependent_init (init, complain);
@@ -1425,6 +1435,14 @@ process_init_constructor_array (tree type, tree init, int nested, int flags,
 	      strip_array_types (TREE_TYPE (ce->value)))));
 
       picflags |= picflag_from_initializer (ce->value);
+      /* Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY to outer
+	 CONSTRUCTOR.  */
+      if (TREE_CODE (ce->value) == CONSTRUCTOR
+	  && CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ce->value))
+	{
+	  CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init) = 1;
+	  CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ce->value) = 0;
+	}
     }
 
   /* No more initializers. If the array is unbounded, we are done. Otherwise,
@@ -1459,6 +1477,14 @@ process_init_constructor_array (tree type, tree init, int nested, int flags,
 	if (next)
 	  {
 	    picflags |= picflag_from_initializer (next);
+	    /* Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY to outer
+	       CONSTRUCTOR.  */
+	    if (TREE_CODE (next) == CONSTRUCTOR
+		&& CONSTRUCTOR_PLACEHOLDER_BOUNDARY (next))
+	      {
+		CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init) = 1;
+		CONSTRUCTOR_PLACEHOLDER_BOUNDARY (next) = 0;
+	      }
 	    if (len > i+1
 		&& (initializer_constant_valid_p (next, TREE_TYPE (next))
 		    == null_pointer_node))
@@ -1665,6 +1691,13 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,
       if (type != TREE_TYPE (field))
 	next = cp_convert_and_check (TREE_TYPE (field), next, complain);
       picflags |= picflag_from_initializer (next);
+      /* Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY to outer CONSTRUCTOR.  */
+      if (TREE_CODE (next) == CONSTRUCTOR
+	  && CONSTRUCTOR_PLACEHOLDER_BOUNDARY (next))
+	{
+	  CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init) = 1;
+	  CONSTRUCTOR_PLACEHOLDER_BOUNDARY (next) = 0;
+	}
       CONSTRUCTOR_APPEND_ELT (v, field, next);
     }
 
@@ -1818,6 +1851,14 @@ process_init_constructor_union (tree type, tree init, int nested, int flags,
     ce->value = massage_init_elt (TREE_TYPE (ce->index), ce->value, nested,
 				  flags, complain);
 
+  /* Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY to outer CONSTRUCTOR.  */
+  if (ce->value
+      && TREE_CODE (ce->value) == CONSTRUCTOR
+      && CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ce->value))
+    {
+      CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init) = 1;
+      CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ce->value) = 0;
+    }
   return picflag_from_initializer (ce->value);
 }
 
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index b0e68a99a73..9a3c98f19d6 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,144 @@
+2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (get_symbol_decl): Align methods to MINIMUM_METHOD_BOUNDARY.
+
+2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (d_finish_decl): Use HOST_WIDE_INT for type size
+	temporaries.
+
+2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/102574
+	* d-spec.cc (lang_specific_driver): Link libstdc++ statically if
+	-static-libstdc++ was given on command-line.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* d-convert.cc (convert_for_rvalue): New function.
+	* d-tree.h (convert_for_rvalue): Declare.
+	* expr.cc (ExprVisitor::visit (CastExp *)): Use convert_for_rvalue.
+	(build_return_dtor): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* expr.cc (binary_op): Use build2 instead of fold_build2.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* d-codegen.cc (build_array_index): Handle void arrays same as byte.
+	* d-convert.cc (convert_expr): Handle converting to zero-sized arrays.
+	* dmd/dcast.c (castTo): Handle casting to zero-sized arrays.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* dmd/expression.c (FuncInitExp::resolveLoc): Set type as `string'.
+	(PrettyFuncInitExp::resolveLoc): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* d-builtins.cc (d_builtin_function_ext_scope): New function.
+	* d-lang.cc (LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE): Define.
+	* d-tree.h (d_builtin_function_ext_scope): Declare.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* d-frontend.cc (getTypeInfoType): Move TypeInfo checks to
+	check_typeinfo_type and call new function.
+	* d-tree.h (check_typeinfo_type): Declare.
+	* typeinfo.cc: Include dmd/scope.h.
+	(create_frontend_tinfo_types): Generate front-end types even if Object
+	is missing.
+	(build_typeinfo): Move TypeInfo checks to check_typeinfo_type and call
+	new function.
+	(check_typeinfo_type): New function.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit (TypeidExp)):
+	Error when TypeInfo doesn't exist.
+	* dmd/func.c (FuncDeclaration::semantic3): Likewise.
+	* dmd/mtype.c (TypeClass::dotExp): Likewise.
+	* typeinfo.cc (object_module): New variable.
+	(make_frontend_typeinfo): Update signature.  Set temporary on
+	generated TypeInfo classes.
+	(create_tinfo_types): Set object_module.  Move generation of front-end
+	typeinfo into ...
+	(create_frontend_tinfo_types): ... New function.
+	(layout_typeinfo): Call create_frontend_tinfo_types.
+	(layout_classinfo): Likewise.
+	(layout_cpp_typeinfo): Likewise.
+	(create_typeinfo): Likewise.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* dmd/expression.c (Expression::checkPostblit): Don't generate
+	TypeInfo when RTTI is disabled.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* dmd/mtype.c (Type::getProperty): Prefer explicit alignment over
+	natural alignment for alignof property.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* d-codegen.cc (build_assign): Construct initializations inside
+	TARGET_EXPR_INITIAL.
+	(compound_expr): Remove intermediate expressions that have no
+	side-effects.
+	(return_expr): Construct returns inside TARGET_EXPR_INITIAL.
+	* expr.cc (ExprVisitor::visit (CallExp *)): Remove useless assignment
+	to TARGET_EXPR_SLOT.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/d/d-builtins.cc b/gcc/d/d-builtins.cc
index 3dbdafb492a..333c4930318 100644
--- a/gcc/d/d-builtins.cc
+++ b/gcc/d/d-builtins.cc
@@ -1175,5 +1175,20 @@ d_builtin_function (tree decl)
   return decl;
 }
 
+/* Same as d_builtin_function, but used to delay putting in back-end builtin
+   functions until the ISA that defines the builtin has been declared.
+   However in D, there is no global namespace.  All builtins get pushed into the
+   `gcc.builtins' module, which is constructed during the semantic analysis
+   pass, which has already finished by the time target attributes are evaluated.
+   So builtins are not pushed because they would be ultimately ignored.
+   The purpose of having this function then is to improve compile-time
+   reflection support to allow user-code to determine whether a given back end
+   function is enabled by the ISA.  */
+
+tree
+d_builtin_function_ext_scope (tree decl)
+{
+  return decl;
+}
 
 #include "gt-d-d-builtins.h"
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index 17f624b5a4f..fb83770d64a 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -1304,6 +1304,7 @@ component_ref (tree object, tree field)
 tree
 build_assign (tree_code code, tree lhs, tree rhs)
 {
+  tree result;
   tree init = stabilize_expr (&lhs);
   init = compound_expr (init, stabilize_expr (&rhs));
 
@@ -1322,19 +1323,27 @@ build_assign (tree_code code, tree lhs, tree rhs)
   if (TREE_CODE (rhs) == TARGET_EXPR)
     {
       /* If CODE is not INIT_EXPR, can't initialize LHS directly,
-	 since that would cause the LHS to be constructed twice.
-	 So we force the TARGET_EXPR to be expanded without a target.  */
+	 since that would cause the LHS to be constructed twice.  */
       if (code != INIT_EXPR)
-	rhs = compound_expr (rhs, TARGET_EXPR_SLOT (rhs));
+	{
+	  init = compound_expr (init, rhs);
+	  result = build_assign (code, lhs, TARGET_EXPR_SLOT (rhs));
+	}
       else
 	{
 	  d_mark_addressable (lhs);
-	  rhs = TARGET_EXPR_INITIAL (rhs);
+	  TARGET_EXPR_INITIAL (rhs) = build_assign (code, lhs,
+						    TARGET_EXPR_INITIAL (rhs));
+	  result = rhs;
 	}
     }
+  else
+    {
+      /* Simple assignment.  */
+      result = fold_build2_loc (input_location, code,
+				TREE_TYPE (lhs), lhs, rhs);
+    }
 
-  tree result = fold_build2_loc (input_location, code,
-				 TREE_TYPE (lhs), lhs, rhs);
   return compound_expr (init, result);
 }
 
@@ -1456,6 +1465,11 @@ compound_expr (tree arg0, tree arg1)
   if (arg0 == NULL_TREE || !TREE_SIDE_EFFECTS (arg0))
     return arg1;
 
+  /* Remove intermediate expressions that have no side-effects.  */
+  while (TREE_CODE (arg0) == COMPOUND_EXPR
+	 && !TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
+    arg0 = TREE_OPERAND (arg0, 0);
+
   if (TREE_CODE (arg1) == TARGET_EXPR)
     {
       /* If the rhs is a TARGET_EXPR, then build the compound expression
@@ -1476,6 +1490,19 @@ compound_expr (tree arg0, tree arg1)
 tree
 return_expr (tree ret)
 {
+  /* Same as build_assign, the DECL_RESULT assignment replaces the temporary
+     in TARGET_EXPR_SLOT.  */
+  if (ret != NULL_TREE && TREE_CODE (ret) == TARGET_EXPR)
+    {
+      tree exp = TARGET_EXPR_INITIAL (ret);
+      tree init = stabilize_expr (&exp);
+
+      exp = fold_build1_loc (input_location, RETURN_EXPR, void_type_node, exp);
+      TARGET_EXPR_INITIAL (ret) = compound_expr (init, exp);
+
+      return ret;
+    }
+
   return fold_build1_loc (input_location, RETURN_EXPR,
 			  void_type_node, ret);
 }
@@ -1579,21 +1606,9 @@ build_array_index (tree ptr, tree index)
   /* Array element size.  */
   tree size_exp = size_in_bytes (target_type);
 
-  if (integer_zerop (size_exp))
-    {
-      /* Test for array of void.  */
-      if (TYPE_MODE (target_type) == TYPE_MODE (void_type_node))
-	index = fold_convert (type, index);
-      else
-	{
-	  /* Should catch this earlier.  */
-	  error ("invalid use of incomplete type %qD", TYPE_NAME (target_type));
-	  ptr_type = error_mark_node;
-	}
-    }
-  else if (integer_onep (size_exp))
+  if (integer_zerop (size_exp) || integer_onep (size_exp))
     {
-      /* Array of bytes -- No need to multiply.  */
+      /* Array of void or bytes -- No need to multiply.  */
       index = fold_convert (type, index);
     }
   else
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index 761ab3c5435..537324ddb35 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -473,13 +473,18 @@ convert_expr (tree exp, Type *etype, Type *totype)
 
 	  tree ptrtype = build_ctype (tbtype->nextOf ()->pointerTo ());
 
-	  if ((dim * esize) % tsize != 0)
+	  if (esize != tsize)
 	    {
-	      error ("cannot cast %qs to %qs since sizes don't line up",
-		     etype->toChars (), totype->toChars ());
-	      return error_mark_node;
+	      /* Array element sizes do not match, so we must adjust the
+		 dimensions.  */
+	      if (tsize == 0 || (dim * esize) % tsize != 0)
+		{
+		  error ("cannot cast %qs to %qs since sizes don't line up",
+			 etype->toChars (), totype->toChars ());
+		  return error_mark_node;
+		}
+	      dim = (dim * esize) / tsize;
 	    }
-	  dim = (dim * esize) / tsize;
 
 	  /* Assumes casting to dynamic array of same type or void.  */
 	  return d_array_value (build_ctype (totype), size_int (dim),
@@ -596,6 +601,42 @@ convert_expr (tree exp, Type *etype, Type *totype)
   return result ? result : convert (build_ctype (totype), exp);
 }
 
+/* Return a TREE represenwation of EXPR, whose type has been converted from
+ * ETYPE to TOTYPE, and is being used in an rvalue context.  */
+
+tree
+convert_for_rvalue (tree expr, Type *etype, Type *totype)
+{
+  tree result = NULL_TREE;
+
+  Type *ebtype = etype->toBasetype ();
+  Type *tbtype = totype->toBasetype ();
+
+  switch (ebtype->ty)
+    {
+    case Tbool:
+      /* If casting from bool, the result is either 0 or 1, any other value
+	 violates @safe code, so enforce that it is never invalid.  */
+      if (CONSTANT_CLASS_P (expr))
+	result = d_truthvalue_conversion (expr);
+      else
+	{
+	  /* Reinterpret the boolean as an integer and test the first bit.
+	     The generated code should end up being equivalent to:
+		*cast(ubyte *)&expr & 1;  */
+	  machine_mode bool_mode = TYPE_MODE (TREE_TYPE (expr));
+	  tree mtype = lang_hooks.types.type_for_mode (bool_mode, 1);
+	  result = fold_build2 (BIT_AND_EXPR, mtype,
+				build_vconvert (mtype, expr),
+				build_one_cst (mtype));
+	}
+
+      result = convert (build_ctype (tbtype), result);
+      break;
+    }
+
+  return result ? result : convert_expr (expr, etype, totype);
+}
 
 /* Apply semantics of assignment to a value of type TOTYPE to EXPR
    (e.g., pointer = array -> pointer = &array[0])
diff --git a/gcc/d/d-frontend.cc b/gcc/d/d-frontend.cc
index ccd5f50130f..563696bdf9f 100644
--- a/gcc/d/d-frontend.cc
+++ b/gcc/d/d-frontend.cc
@@ -614,39 +614,8 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)
 Type *
 getTypeInfoType (Loc loc, Type *type, Scope *sc)
 {
-  if (!global.params.useTypeInfo)
-    {
-      /* Even when compiling without RTTI we should still be able to evaluate
-	 TypeInfo at compile-time, just not at run-time.  */
-      if (!sc || !(sc->flags & SCOPEctfe))
-	{
-	  static int warned = 0;
-
-	  if (!warned)
-	    {
-	      error_at (make_location_t (loc),
-			"%<object.TypeInfo%> cannot be used with -fno-rtti");
-	      warned = 1;
-	    }
-	}
-    }
-
-  if (Type::dtypeinfo == NULL
-      || (Type::dtypeinfo->storage_class & STCtemp))
-    {
-      /* If TypeInfo has not been declared, warn about each location once.  */
-      static Loc warnloc;
-
-      if (!loc.equals (warnloc))
-	{
-	  error_at (make_location_t (loc),
-		    "%<object.TypeInfo%> could not be found, "
-		    "but is implicitly used");
-	  warnloc = loc;
-	}
-    }
-
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, sc);
   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);
   return type->vtinfo->type;
 }
diff --git a/gcc/d/d-lang.cc b/gcc/d/d-lang.cc
index 62a8ddd69b2..322a93ee139 100644
--- a/gcc/d/d-lang.cc
+++ b/gcc/d/d-lang.cc
@@ -1783,6 +1783,7 @@ d_build_eh_runtime_type (tree type)
 #undef LANG_HOOKS_GET_ALIAS_SET
 #undef LANG_HOOKS_TYPES_COMPATIBLE_P
 #undef LANG_HOOKS_BUILTIN_FUNCTION
+#undef LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE
 #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE
 #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL
 #undef LANG_HOOKS_GIMPLIFY_EXPR
@@ -1813,6 +1814,7 @@ d_build_eh_runtime_type (tree type)
 #define LANG_HOOKS_GET_ALIAS_SET	    d_get_alias_set
 #define LANG_HOOKS_TYPES_COMPATIBLE_P	    d_types_compatible_p
 #define LANG_HOOKS_BUILTIN_FUNCTION	    d_builtin_function
+#define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE d_builtin_function_ext_scope
 #define LANG_HOOKS_REGISTER_BUILTIN_TYPE    d_register_builtin_type
 #define LANG_HOOKS_FINISH_INCOMPLETE_DECL   d_finish_incomplete_decl
 #define LANG_HOOKS_GIMPLIFY_EXPR	    d_gimplify_expr
diff --git a/gcc/d/d-spec.cc b/gcc/d/d-spec.cc
index 9eba6902bb9..cf55c76250c 100644
--- a/gcc/d/d-spec.cc
+++ b/gcc/d/d-spec.cc
@@ -94,6 +94,9 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
   /* "-lstdc++" if it appears on the command line.  */
   const cl_decoded_option *saw_libcxx = 0;
 
+  /* True if we saw `-static-libstdc++'.  */
+  bool saw_static_libcxx = false;
+
   /* Whether we need the C++ STD library.  */
   bool need_stdcxx = false;
 
@@ -259,6 +262,11 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 	  shared_libgcc = false;
 	  break;
 
+	case OPT_static_libstdc__:
+	  saw_static_libcxx = true;
+	  args[i] |= SKIPOPT;
+	  break;
+
 	case OPT_static_libphobos:
 	  if (phobos_library != PHOBOS_NOLINK)
 	    phobos_library = PHOBOS_STATIC;
@@ -476,16 +484,33 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
       added_libraries++;
     }
 
-  if (saw_libcxx)
-    new_decoded_options[j++] = *saw_libcxx;
-  else if (need_stdcxx)
+  if (saw_libcxx || need_stdcxx)
     {
-      generate_option (OPT_l,
-		       (saw_profile_flag
-			? LIBSTDCXX_PROFILE
-			: LIBSTDCXX),
-		       1, CL_DRIVER, &new_decoded_options[j++]);
-      added_libraries++;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#endif
+      if (saw_libcxx)
+	new_decoded_options[j++] = *saw_libcxx;
+      else if (need_stdcxx)
+	{
+	  generate_option (OPT_l,
+			   (saw_profile_flag
+			    ? LIBSTDCXX_PROFILE
+			    : LIBSTDCXX),
+			   1, CL_DRIVER, &new_decoded_options[j++]);
+	  added_libraries++;
+	}
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#endif
     }
 
   if (shared_libgcc && !static_link)
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index 7a54dfbc59e..ad8e25fa45d 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -488,6 +488,7 @@ extern const attribute_spec d_langhook_attribute_table[];
 extern const attribute_spec d_langhook_common_attribute_table[];
 
 extern tree d_builtin_function (tree);
+extern tree d_builtin_function_ext_scope (tree);
 extern void d_init_builtins (void);
 extern void d_register_builtin_type (tree, const char *);
 extern void d_build_builtins_module (Module *);
@@ -577,6 +578,7 @@ extern bool decl_with_nonnull_addr_p (const_tree);
 extern tree d_truthvalue_conversion (tree);
 extern tree d_convert (tree, tree);
 extern tree convert_expr (tree, Type *, Type *);
+extern tree convert_for_rvalue (tree, Type *, Type *);
 extern tree convert_for_assignment (tree, Type *, Type *);
 extern tree convert_for_argument (tree, Parameter *);
 extern tree convert_for_condition (tree, Type *);
@@ -650,6 +652,7 @@ extern tree layout_typeinfo (TypeInfoDeclaration *);
 extern tree layout_classinfo (ClassDeclaration *);
 extern tree get_typeinfo_decl (TypeInfoDeclaration *);
 extern tree get_classinfo_decl (ClassDeclaration *);
+extern void check_typeinfo_type (const Loc &, Scope *);
 extern tree build_typeinfo (const Loc &, Type *);
 extern void create_typeinfo (Type *, Module *);
 extern void create_tinfo_types (Module *);
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index d24f5dcd958..7aaaf49f02f 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -1233,6 +1233,9 @@ get_symbol_decl (Declaration *decl)
 	      DECL_VINDEX (decl->csym) = size_int (fd->vtblIndex);
 	      DECL_VIRTUAL_P (decl->csym) = 1;
 	    }
+
+	  /* Align method to the minimum boundary for target.  */
+	  SET_DECL_ALIGN (decl->csym, MINIMUM_METHOD_BOUNDARY);
 	}
       else if (fd->isMain () || fd->isCMain ())
 	{
@@ -1559,8 +1562,9 @@ d_finish_decl (tree decl)
   if (flag_checking && DECL_INITIAL (decl))
     {
       /* Initializer must never be bigger than symbol size.  */
-      dinteger_t tsize = int_size_in_bytes (TREE_TYPE (decl));
-      dinteger_t dtsize = int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
+      HOST_WIDE_INT tsize = int_size_in_bytes (TREE_TYPE (decl));
+      HOST_WIDE_INT dtsize =
+	int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
 
       if (tsize < dtsize)
 	{
diff --git a/gcc/d/dmd/dcast.c b/gcc/d/dmd/dcast.c
index a3df701c341..905aed72625 100644
--- a/gcc/d/dmd/dcast.c
+++ b/gcc/d/dmd/dcast.c
@@ -1494,13 +1494,16 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)
                     // cast(U[])sa; // ==> cast(U[])sa[];
                     d_uns64 fsize = t1b->nextOf()->size();
                     d_uns64 tsize = tob->nextOf()->size();
-                    if ((((TypeSArray *)t1b)->dim->toInteger() * fsize) % tsize != 0)
+                    if (fsize != tsize)
                     {
-                        // copied from sarray_toDarray() in e2ir.c
-                        e->error("cannot cast expression %s of type %s to %s since sizes don't line up",
-                            e->toChars(), e->type->toChars(), t->toChars());
-                        result = new ErrorExp();
-                        return;
+                        dinteger_t dim = ((TypeSArray *)t1b)->dim->toInteger();
+                        if (tsize == 0 || (dim * fsize) % tsize != 0)
+                        {
+                            e->error("cannot cast expression `%s` of type `%s` to `%s` since sizes don't line up",
+                                     e->toChars(), e->type->toChars(), t->toChars());
+                            result = new ErrorExp();
+                            return;
+                        }
                     }
                     goto Lok;
                 }
diff --git a/gcc/d/dmd/expression.c b/gcc/d/dmd/expression.c
index af762eb3c66..e59c5b114dd 100644
--- a/gcc/d/dmd/expression.c
+++ b/gcc/d/dmd/expression.c
@@ -2647,8 +2647,11 @@ bool Expression::checkPostblit(Scope *sc, Type *t)
     t = t->baseElemOf();
     if (t->ty == Tstruct)
     {
-        // Bugzilla 11395: Require TypeInfo generation for array concatenation
-        semanticTypeInfo(sc, t);
+        if (global.params.useTypeInfo)
+        {
+            // Bugzilla 11395: Require TypeInfo generation for array concatenation
+            semanticTypeInfo(sc, t);
+        }
 
         StructDeclaration *sd = ((TypeStruct *)t)->sym;
         if (sd->postblit)
@@ -6714,7 +6717,7 @@ Expression *FuncInitExp::resolveLoc(Loc loc, Scope *sc)
         s = "";
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
@@ -6748,7 +6751,7 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)
 
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 75794a03285..847a0796792 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -1806,11 +1806,19 @@ public:
         Expression *e;
         if (ea && ta->toBasetype()->ty == Tclass)
         {
-            /* Get the dynamic type, which is .classinfo
-            */
-            ea = semantic(ea, sc);
-            e = new TypeidExp(ea->loc, ea);
-            e->type = Type::typeinfoclass->type;
+            if (!Type::typeinfoclass)
+            {
+                error(exp->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                e = new ErrorExp();
+            }
+            else
+            {
+                /* Get the dynamic type, which is .classinfo
+                */
+                ea = semantic(ea, sc);
+                e = new TypeidExp(ea->loc, ea);
+                e->type = Type::typeinfoclass->type;
+            }
         }
         else if (ta->ty == Terror)
         {
diff --git a/gcc/d/dmd/func.c b/gcc/d/dmd/func.c
index 568decc8cee..04c70cf3b7b 100644
--- a/gcc/d/dmd/func.c
+++ b/gcc/d/dmd/func.c
@@ -1520,6 +1520,18 @@ void FuncDeclaration::semantic3(Scope *sc)
         {
             if (f->linkage == LINKd)
             {
+                // Variadic arguments depend on Typeinfo being defined
+                if (!global.params.useTypeInfo || !Type::dtypeinfo || !Type::typeinfotypelist)
+                {
+                    if (!global.params.useTypeInfo)
+                        error("D-style variadic functions cannot be used with -betterC");
+                    else if (!Type::typeinfotypelist)
+                        error("`object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions");
+                    else
+                        error("`object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions");
+                    fatal();
+                }
+
                 // Declare _arguments[]
                 v_arguments = new VarDeclaration(Loc(), Type::typeinfotypelist->type, Id::_arguments_typeinfo, NULL);
                 v_arguments->storage_class |= STCtemp | STCparameter;
diff --git a/gcc/d/dmd/mtype.c b/gcc/d/dmd/mtype.c
index d0e73967d45..0204860fec3 100644
--- a/gcc/d/dmd/mtype.c
+++ b/gcc/d/dmd/mtype.c
@@ -2059,7 +2059,10 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)
     }
     else if (ident == Id::__xalignof)
     {
-        e = new IntegerExp(loc, alignsize(), Type::tsize_t);
+        unsigned explicitAlignment = alignment();
+        unsigned naturalAlignment = alignsize();
+        unsigned actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);
+        e = new IntegerExp(loc, actualAlignment, Type::tsize_t);
     }
     else if (ident == Id::_init)
     {
@@ -8344,7 +8347,12 @@ L1:
 
         if (ident == Id::classinfo)
         {
-            assert(Type::typeinfoclass);
+            if (!Type::typeinfoclass)
+            {
+                error(e->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                return new ErrorExp();
+            }
+
             Type *t = Type::typeinfoclass->type;
             if (e->op == TOKtype || e->op == TOKdottype)
             {
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 3a2823d6e46..244dd860b7f 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -162,7 +162,7 @@ class ExprVisitor : public Visitor
 	    eptype = type;
 	  }
 
-	ret = fold_build2 (code, eptype, arg0, arg1);
+	ret = build2 (code, eptype, arg0, arg1);
       }
 
     return d_convert (type, ret);
@@ -1435,7 +1435,7 @@ public:
     if (tbtype->ty == Tvoid)
       this->result_ = build_nop (build_ctype (tbtype), result);
     else
-      this->result_ = convert_expr (result, ebtype, tbtype);
+      this->result_ = convert_for_rvalue (result, ebtype, tbtype);
   }
 
   /* Build a delete expression.  */
@@ -1837,15 +1837,10 @@ public:
       exp = d_convert (build_ctype (e->type), exp);
 
     /* If this call was found to be a constructor for a temporary with a
-       cleanup, then move the call inside the TARGET_EXPR.  The original
-       initializer is turned into an assignment, to keep its side effect.  */
+       cleanup, then move the call inside the TARGET_EXPR.  */
     if (cleanup != NULL_TREE)
       {
 	tree init = TARGET_EXPR_INITIAL (cleanup);
-	tree slot = TARGET_EXPR_SLOT (cleanup);
-	d_mark_addressable (slot);
-	init = build_assign (INIT_EXPR, slot, init);
-
 	TARGET_EXPR_INITIAL (cleanup) = compound_expr (init, exp);
 	exp = cleanup;
       }
@@ -3111,11 +3106,14 @@ build_return_dtor (Expression *e, Type *type, TypeFunction *tf)
   tree result = build_expr (e);
 
   /* Convert for initializing the DECL_RESULT.  */
-  result = convert_expr (result, e->type, type);
-
-  /* If we are returning a reference, take the address.  */
   if (tf->isref)
-    result = build_address (result);
+    {
+      /* If we are returning a reference, take the address.  */
+      result = convert_expr (result, e->type, type);
+      result = build_address (result);
+    }
+  else
+    result = convert_for_rvalue (result, e->type, type);
 
   /* The decl to store the return expression.  */
   tree decl = DECL_RESULT (cfun->decl);
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 0b19bcf7f34..117a5bd1592 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dmd/identifier.h"
 #include "dmd/module.h"
 #include "dmd/mtype.h"
+#include "dmd/scope.h"
 #include "dmd/template.h"
 #include "dmd/target.h"
 
@@ -185,28 +186,36 @@ make_internal_typeinfo (tinfo_kind tk, Identifier *ident, ...)
   va_end (ap);
 }
 
-/* Helper for create_tinfo_types.  Creates a typeinfo class declaration
-   incase one wasn't supplied by reading `object.d'.  */
+/* Reference to the `object` module, where all TypeInfo is defined.  */
+
+static Module *object_module;
+
+/* Helper for create_frontend_tinfo_types.  Creates a typeinfo class
+   declaration incase one wasn't supplied by reading `object.d'.  */
 
 static void
-make_frontend_typeinfo (Module *mod, Identifier *ident,
-			ClassDeclaration *base = NULL)
+make_frontend_typeinfo (Identifier *ident, ClassDeclaration *base = NULL)
 {
   if (!base)
     base = Type::dtypeinfo;
 
+  gcc_assert (object_module);
+
   /* Create object module in order to complete the semantic.  */
-  if (!mod->_scope)
-    mod->importAll (NULL);
+  if (!object_module->_scope)
+    object_module->importAll (NULL);
 
   /* Assignment of global typeinfo variables is managed by the ClassDeclaration
      constructor, so only need to new the declaration here.  */
-  Loc loc = (mod->md) ? mod->md->loc : mod->loc;
+  Loc loc = (object_module->md) ? object_module->md->loc : object_module->loc;
   ClassDeclaration *tinfo = ClassDeclaration::create (loc, ident, NULL, NULL,
 						      true);
-  tinfo->parent = mod;
-  tinfo->semantic (mod->_scope);
+  tinfo->parent = object_module;
+  tinfo->semantic (object_module->_scope);
   tinfo->baseClass = base;
+  /* This is a compiler generated class, and shouldn't be mistaken for being
+     the type declared in the runtime library.  */
+  tinfo->storage_class |= STCtemp;
 }
 
 /* Make sure the required builtin types exist for generating the TypeInfo
@@ -227,69 +236,78 @@ create_tinfo_types (Module *mod)
 			  ptr_type_node, d_uint_type, ptr_type_node,
 			  array_type_node, ptr_type_node, ptr_type_node, NULL);
 
-  /* If there's no Object class defined, then neither can TypeInfo be.  */
-  if (ClassDeclaration::object == NULL)
+  object_module = mod;
+}
+
+/* Same as create_tinfo_types, but builds all front-end TypeInfo variable
+   definitions.  */
+
+static void
+create_frontend_tinfo_types (void)
+{
+  /* If there's no object module, then neither can there be TypeInfo.  */
+  if (object_module == NULL)
     return;
 
   /* Create all frontend TypeInfo classes declarations.  We rely on all
      existing, even if only just as stubs.  */
   if (!Type::dtypeinfo)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo"),
 			    ClassDeclaration::object);
 
   if (!Type::typeinfoclass)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Class"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Class"));
 
   if (!Type::typeinfointerface)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Interface"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Interface"));
 
   if (!Type::typeinfostruct)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Struct"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Struct"));
 
   if (!Type::typeinfopointer)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Pointer"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Pointer"));
 
   if (!Type::typeinfoarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Array"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Array"));
 
   if (!Type::typeinfostaticarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_StaticArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_StaticArray"));
 
   if (!Type::typeinfoassociativearray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_AssociativeArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_AssociativeArray"));
 
   if (!Type::typeinfoenum)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Enum"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Enum"));
 
   if (!Type::typeinfofunction)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Function"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Function"));
 
   if (!Type::typeinfodelegate)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Delegate"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Delegate"));
 
   if (!Type::typeinfotypelist)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Tuple"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Tuple"));
 
   if (!Type::typeinfoconst)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Const"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Const"));
 
   if (!Type::typeinfoinvariant)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Invariant"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Invariant"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfoshared)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Shared"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Shared"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfowild)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Wild"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Wild"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfovector)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Vector"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Vector"));
 
   if (!ClassDeclaration::cpp_type_info_ptr)
-    make_frontend_typeinfo (mod, Identifier::idPool ("__cpp_type_info_ptr"),
+    make_frontend_typeinfo (Identifier::idPool ("__cpp_type_info_ptr"),
 			    ClassDeclaration::object);
 }
 
@@ -1143,6 +1161,9 @@ public:
 tree
 layout_typeinfo (TypeInfoDeclaration *d)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoVisitor v = TypeInfoVisitor (get_typeinfo_decl (d));
   d->accept (&v);
   return v.result ();
@@ -1154,6 +1175,9 @@ layout_typeinfo (TypeInfoDeclaration *d)
 tree
 layout_classinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoClassDeclaration *d = TypeInfoClassDeclaration::create (cd->type);
   TypeInfoVisitor v = TypeInfoVisitor (get_classinfo_decl (cd));
   d->accept (&v);
@@ -1347,16 +1371,19 @@ get_classinfo_decl (ClassDeclaration *decl)
   return decl->csym;
 }
 
-/* Returns typeinfo reference for TYPE.  */
+/* Performs sanity checks on the `object.TypeInfo' type, raising an error if
+   RTTI is disabled, or the type is missing.  */
 
-tree
-build_typeinfo (const Loc &loc, Type *type)
+void
+check_typeinfo_type (const Loc &loc, Scope *sc)
 {
   if (!global.params.useTypeInfo)
     {
       static int warned = 0;
 
-      if (!warned)
+      /* Even when compiling without RTTI we should still be able to evaluate
+	 TypeInfo at compile-time, just not at run-time.  */
+      if (!warned && (!sc || !(sc->flags & SCOPEctfe)))
 	{
 	  error_at (make_location_t (loc),
 		    "%<object.TypeInfo%> cannot be used with -fno-rtti");
@@ -1364,7 +1391,29 @@ build_typeinfo (const Loc &loc, Type *type)
 	}
     }
 
+  if (Type::dtypeinfo == NULL
+      || (Type::dtypeinfo->storage_class & STCtemp))
+    {
+      /* If TypeInfo has not been declared, warn about each location once.  */
+      static Loc warnloc;
+
+      if (!warnloc.equals (loc))
+	{
+	  error_at (make_location_t (loc),
+		    "%<object.TypeInfo%> could not be found, "
+		    "but is implicitly used");
+	  warnloc = loc;
+	}
+    }
+}
+
+/* Returns typeinfo reference for TYPE.  */
+
+tree
+build_typeinfo (const Loc &loc, Type *type)
+{
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, NULL);
   create_typeinfo (type, NULL);
   return build_address (get_typeinfo_decl (type->vtinfo));
 }
@@ -1375,6 +1424,9 @@ build_typeinfo (const Loc &loc, Type *type)
 void
 layout_cpp_typeinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   gcc_assert (cd->isCPPclass ());
 
   tree decl = get_cpp_typeinfo_decl (cd);
@@ -1443,6 +1495,9 @@ get_cpp_typeinfo_decl (ClassDeclaration *decl)
 void
 create_typeinfo (Type *type, Module *mod)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   /* Do this since not all Type's are merged.  */
   Type *t = type->merge2 ();
   Identifier *ident;
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 7b5f6e03d9f..8bae3271c27 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -4467,7 +4467,7 @@ name is still supported, but the newer name is more descriptive.)
 -Wredundant-move @r{(only for C++)}  @gol
 -Wtype-limits  @gol
 -Wuninitialized  @gol
--Wshift-negative-value @r{(in C++03 and in C99 and newer)}  @gol
+-Wshift-negative-value @r{(in C++11 to C++17 and in C99 and newer)}  @gol
 -Wunused-parameter @r{(only with} @option{-Wunused} @r{or} @option{-Wall}@r{)} @gol
 -Wunused-but-set-parameter @r{(only with} @option{-Wunused} @r{or} @option{-Wall}@r{)}}
 
@@ -5307,7 +5307,7 @@ Warn if shift count >= width of type. This warning is enabled by default.
 @opindex Wshift-negative-value
 @opindex Wno-shift-negative-value
 Warn if left shifting a negative value.  This warning is enabled by
-@option{-Wextra} in C99 and C++11 modes (and newer).
+@option{-Wextra} in C99 (and newer) and C++11 to C++17 modes.
 
 @item -Wshift-overflow
 @itemx -Wshift-overflow=@var{n}
@@ -12484,7 +12484,8 @@ The option cannot be combined with @option{-fsanitize=thread}.
 @opindex fsanitize=undefined
 Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
 Various computations are instrumented to detect undefined behavior
-at runtime.  Current suboptions are:
+at runtime.  See @uref{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html} for more details.   The run-time behavior can be influenced using the
+@env{UBSAN_OPTIONS} environment variable.  Current suboptions are:
 
 @table @gcctabopt
 
@@ -12764,7 +12765,8 @@ which functions and calls should be skipped from instrumentation
 (@pxref{Function Attributes}).
 
 Currently the x86 GNU/Linux target provides an implementation based
-on Intel Control-flow Enforcement Technology (CET).
+on Intel Control-flow Enforcement Technology (CET) which works for
+i686 processor or newer.
 
 @item -fstack-protector
 @opindex fstack-protector
@@ -15858,6 +15860,7 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
 @samp{cortex-a76}, @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
 @samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1},
+@samp{neoverse-512tvb},
 @samp{qdf24xx}, @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
 @samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
 @samp{a64fx},
@@ -15874,6 +15877,15 @@ The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55} specify that GCC
 should tune for a big.LITTLE system.
 
+The value @samp{neoverse-512tvb} specifies that GCC should tune
+for Neoverse cores that (a) implement SVE and (b) have a total vector
+bandwidth of 512 bits per cycle.  In other words, the option tells GCC to
+tune for Neoverse cores that can execute 4 128-bit Advanced SIMD arithmetic
+instructions a cycle and that can execute an equivalent number of SVE
+arithmetic instructions per cycle (2 for 256-bit SVE, 4 for 128-bit SVE).
+This is more general than tuning for a specific core like Neoverse V1
+but is more specific than the default tuning described below.
+
 Additionally on native AArch64 GNU/Linux systems the value
 @samp{native} tunes performance to the host system.  This option has no effect
 if the compiler is unable to recognize the processor of the host system.
@@ -15903,6 +15915,16 @@ by @option{-mtune}).  Where this option is used in conjunction
 with @option{-march} or @option{-mtune}, those options take precedence
 over the appropriate part of this option.
 
+@option{-mcpu=neoverse-512tvb} is special in that it does not refer
+to a specific core, but instead refers to all Neoverse cores that
+(a) implement SVE and (b) have a total vector bandwidth of 512 bits
+a cycle.  Unless overridden by @option{-march},
+@option{-mcpu=neoverse-512tvb} generates code that can run on a
+Neoverse V1 core, since Neoverse V1 is the first Neoverse core with
+these properties.  Unless overridden by @option{-mtune},
+@option{-mcpu=neoverse-512tvb} tunes code in the same way as for
+@option{-mtune=neoverse-512tvb}.
+
 @item -moverride=@var{string}
 @opindex moverride
 Override tuning decisions made by the back-end in response to a
@@ -29379,8 +29401,7 @@ Substitute the contents of spec string @var{name} at this point.
 Accumulate an option for @samp{%X}.
 
 @item %X
-Output the accumulated linker options specified by @option{-Wl} or a @samp{%x}
-spec string.
+Output the accumulated linker options specified by a @samp{%x} spec string.
 
 @item %Y
 Output the accumulated assembler options specified by @option{-Wa}.
diff --git a/gcc/doc/trouble.texi b/gcc/doc/trouble.texi
index 693912ea355..aaee8fba6bb 100644
--- a/gcc/doc/trouble.texi
+++ b/gcc/doc/trouble.texi
@@ -865,10 +865,11 @@ objects behave unspecified when being assigned.  For example:
 @smallexample
 struct Base@{
   char *name;
-  Base(char *n) : name(strdup(n))@{@}
+  Base(const char *n) : name(strdup(n))@{@}
   Base& operator= (const Base& other)@{
    free (name);
    name = strdup (other.name);
+   return *this;
   @}
 @};
 
@@ -901,8 +902,8 @@ inside @samp{func} in the example).
 G++ implements the ``intuitive'' algorithm for copy-assignment: assign all
 direct bases, then assign all members.  In that algorithm, the virtual
 base subobject can be encountered more than once.  In the example, copying
-proceeds in the following order: @samp{val}, @samp{name} (via
-@code{strdup}), @samp{bval}, and @samp{name} again.
+proceeds in the following order: @samp{name} (via @code{strdup}),
+@samp{val}, @samp{name} again, and @samp{bval}.
 
 If application code relies on copy-assignment, a user-defined
 copy-assignment operator removes any uncertainties.  With such an
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 6f2bfb919a9..a12d491fa38 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -18900,6 +18900,10 @@ loc_list_from_tree_1 (tree loc, int want_address,
     case FIX_TRUNC_EXPR:
       return 0;
 
+    case COMPOUND_LITERAL_EXPR:
+      return loc_list_from_tree_1 (COMPOUND_LITERAL_EXPR_DECL (loc),
+				   0, context);
+
     default:
       /* Leave front-end specific codes as simply unknown.  This comes
 	 up, for instance, with the C STMT_EXPR.  */
@@ -19132,6 +19136,7 @@ field_byte_offset (const_tree decl, struct vlr_context *ctx,
      properly dynamic byte offsets only when PCC bitfield type doesn't
      matter.  */
   if (PCC_BITFIELD_TYPE_MATTERS
+      && DECL_BIT_FIELD_TYPE (decl)
       && TREE_CODE (DECL_FIELD_OFFSET (decl)) == INTEGER_CST)
     {
       offset_int object_offset_in_bits;
@@ -24019,7 +24024,26 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)
 	      && DECL_RTL_SET_P (decl_or_origin))))
     {
       if (early_dwarf)
-	add_pubname (decl_or_origin, var_die);
+	{
+	  add_pubname (decl_or_origin, var_die);
+	  /* For global register variables, emit DW_AT_location if possible
+	     already during early_dwarf, as late_global_decl won't be usually
+	     called.  */
+	  if (DECL_HARD_REGISTER (decl_or_origin)
+	      && TREE_STATIC (decl_or_origin)
+	      && !decl_by_reference_p (decl_or_origin)
+	      && !get_AT (var_die, DW_AT_location)
+	      && !get_AT (var_die, DW_AT_const_value)
+	      && DECL_RTL_SET_P (decl_or_origin)
+	      && REG_P (DECL_RTL (decl_or_origin)))
+	    {
+	      dw_loc_descr_ref descr
+		= reg_loc_descriptor (DECL_RTL (decl_or_origin),
+				      VAR_INIT_STATUS_INITIALIZED);
+	      if (descr)
+		add_AT_loc (var_die, DW_AT_location, descr);
+	    }
+	}
       else
 	add_location_or_const_value_attribute (var_die, decl_or_origin,
 					       decl == NULL);
diff --git a/gcc/expmed.c b/gcc/expmed.c
index 13a9f7c1b95..f28aa79fecd 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -915,7 +915,10 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,
 	}
 
       subreg_off = bitnum / BITS_PER_UNIT;
-      if (validate_subreg (fieldmode, GET_MODE (arg0), arg0, subreg_off))
+      if (validate_subreg (fieldmode, GET_MODE (arg0), arg0, subreg_off)
+	  /* STRICT_LOW_PART must have a non-paradoxical subreg as
+	     operand.  */
+	  && !paradoxical_subreg_p (fieldmode, GET_MODE (arg0)))
 	{
 	  arg0 = gen_rtx_SUBREG (fieldmode, arg0, subreg_off);
 
diff --git a/gcc/expr.c b/gcc/expr.c
index 8cf9f879235..90df028fad2 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -9537,6 +9537,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,
     case VEC_PACK_SAT_EXPR:
     case VEC_PACK_FIX_TRUNC_EXPR:
       mode = TYPE_MODE (TREE_TYPE (treeop0));
+      subtarget = NULL_RTX;
       goto binop;
 
     case VEC_PACK_TRUNC_EXPR:
@@ -9560,6 +9561,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,
 	  return eops[0].value;
 	}
       mode = TYPE_MODE (TREE_TYPE (treeop0));
+      subtarget = NULL_RTX;
       goto binop;
 
     case VEC_PACK_FLOAT_EXPR:
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index a7eff832ff6..6b8541feeb4 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -510,7 +510,7 @@ negate_expr_p (tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    return true;
 	}
       break;
@@ -703,7 +703,7 @@ fold_negate_expr_1 (location_t loc, tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    {
 	      tree ntype = TYPE_UNSIGNED (type)
 			   ? signed_type_for (type)
@@ -4761,7 +4761,7 @@ make_range_step (location_t loc, enum tree_code code, tree arg0, tree arg1,
 	n_high = fold_convert_loc (loc, arg0_type, n_high);
 
       /* If we're converting arg0 from an unsigned type, to exp,
-	 a signed type,  we will be doing the comparison as unsigned.
+	 a signed type, we will be doing the comparison as unsigned.
 	 The tests above have already verified that LOW and HIGH
 	 are both positive.
 
@@ -4823,6 +4823,32 @@ make_range_step (location_t loc, enum tree_code code, tree arg0, tree arg1,
 	    }
 	}
 
+      /* Otherwise, if we are converting arg0 from signed type, to exp,
+	 an unsigned type, we will do the comparison as signed.  If
+	 high is non-NULL, we punt above if it doesn't fit in the signed
+	 type, so if we get through here, +[-, high] or +[low, high] are
+	 equivalent to +[-, n_high] or +[n_low, n_high].  Similarly,
+	 +[-, -] or -[-, -] are equivalent too.  But if low is specified and
+	 high is not, the +[low, -] range is equivalent to union of
+	 +[n_low, -] and +[-, -1] ranges, so +[low, -] is equivalent to
+	 -[0, n_low-1] and similarly -[low, -] to +[0, n_low-1], except for
+	 low being 0, which should be treated as [-, -].  */
+      else if (TYPE_UNSIGNED (exp_type)
+	       && !TYPE_UNSIGNED (arg0_type)
+	       && low
+	       && !high)
+	{
+	  if (integer_zerop (low))
+	    n_low = NULL_TREE;
+	  else
+	    {
+	      n_high = fold_build2_loc (loc, PLUS_EXPR, arg0_type,
+					n_low, build_int_cst (arg0_type, -1));
+	      n_low = build_zero_cst (arg0_type);
+	      in_p = !in_p;
+	    }
+	}
+
       *p_low = n_low;
       *p_high = n_high;
       *p_in_p = in_p;
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index f1d66e38980..cb6ff3a656f 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,314 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/103315
+	* trans-types.c (gfc_get_array_descr_info): Use DW_OP_deref_size 1
+	instead of DW_OP_deref for DW_AT_rank.
+
+2022-05-09  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-24  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/104228
+	PR fortran/104570
+	* parse.c (parse_associate): Use a new distinct gfc_charlen if
+	the copied type has one whose length is not known to be
+	constant.
+	* resolve.c (resolve_assoc_var): Also create a new character
+	length for non-dummy associate targets.  Reset charlen if it’s
+	shared with the associate target regardless of the expression
+	type.  Don’t reinitialize charlen if it’s deferred.
+	* trans-stmt.c (trans_associate_var): Initialize character
+	length even if no temporary is used for the associate variable.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* trans-expr.c (gfc_conv_union_initializer): Pass vec* by reference.
+
+2022-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-02-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104311
+	* check.c (gfc_calculate_transfer_sizes): Checks for case when
+	storage size of SOURCE is greater than zero while the storage size
+	of MOLD is zero and MOLD is an array shall not depend on SIZE.
+
+2022-01-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104127
+	* simplify.c (gfc_simplify_transfer): Ensure that the result
+	typespec is set up for TRANSFER with MOLD of type CHARACTER
+	including character length even if the result is a zero-sized
+	array.
+
+2022-01-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-25  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104227
+	* check.c (gfc_calculate_transfer_sizes): Fix checking of arrays
+	passed as MOLD argument to the TRANSFER intrinsic for having
+	storage size zero.
+
+2022-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103782
+	* expr.c (gfc_simplify_expr): Adjust logic for when to scalarize a
+	call of an intrinsic which may have been overloaded.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* array.c (gfc_ref_dimen_size): Do not generate internal error on
+	failed simplification of stride expression; just return failure.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* array.c (spec_dimen_size): Fix simplification of SHAPE:
+	dimensions must be non-negative.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* resolve.c (resolve_fl_procedure): Do not access CLASS components
+	before class container has been built.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* frontend-passes.c (doloop_code): Prevent NULL pointer
+	dereference when checking for passing a do-loop variable to a
+	contained procedure with an interface mismatch.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* frontend-passes.c (do_subscript): Ensure that array bounds are
+	of type INTEGER before performing checks on array subscripts.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* simplify.c (simplify_bound): Do not try to simplify
+	LBOUND/UBOUND for arrays with POINTER or ALLOCATABLE attribute.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* expr.c (find_array_element): When bounds cannot be determined as
+	constant, return error instead of aborting.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* trans-expr.c (gfc_conv_substring): Do not generate substring
+	bounds check for implied do loop index variable before it actually
+	becomes defined.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* decl.c (add_init_expr_to_sym): For proper initialization of
+	array-valued named constants the array bounds need to be
+	simplified before adding the initializer.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* expr.c (find_substring_ref): Handle given substring start and
+	end indices as signed integers, not unsigned.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* trans-expr.c (gfc_conv_procedure_call): Wrap deallocation of
+	allocatable components of optional allocatable derived type
+	procedure arguments with INTENT(OUT) into a presence check.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* primary.c (build_actual_constructor): Missing allocatable
+	components are set unallocated using EXPR_NULL. Then missing
+	components are tested for a default initializer.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* trans-intrinsic.c (gfc_conv_associated): Do not add a _data
+	component for scalar class function targets. Instead, fix the
+	function result and access the _data from that.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* resolve.c (find_array_spec): Put static prototype for
+	resolve_assoc_var before this function and call for associate
+	variables.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* trans-array.c (gfc_conv_expr_descriptor): Include elemental
+	procedure pointers in the assert under the comment 'elemental
+	function' and eliminate the second, spurious assert.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* trans-decl.c (gfc_get_symbol_decl): Replace test for host
+	association with a check that the current and symbol namespaces
+	are the same.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* class.c (gfc_build_class_symbol): Remove the error that
+	disables assumed size class arrays. Class array types that are
+	not deferred shape or assumed rank are given a unique name and
+	placed in the procedure namespace.
+	* trans-array.c (gfc_trans_g77_array): Obtain the data pointer
+	for class arrays.
+	(gfc_trans_dummy_array_bias): Suppress the runtime error for
+	extent violations in explicit shape class arrays because it
+	always fails.
+	* trans-expr.c (gfc_conv_procedure_call): Handle assumed size
+	class actual arguments passed to non-descriptor formal args by
+	using the data pointer, stored as the symbol's backend decl.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* trans-array.c (gfc_conv_expr_descriptor): For deferred length
+	length components use the ss_info string length instead of
+	gfc_get_expr_charlen. Make sure that the deferred string length
+	is a variable before assigning to it. Otherwise use the expr.
+	* trans-expr.c (gfc_conv_string_length): Make sure that the
+	deferred string length is a variable before assigning to it.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* trans-expr.c (gfc_conv_procedure_call): Suppress the call to
+	gfc_conv_intrinsic_to_class for unlimited polymorphic procedure
+	pointers.
+	(gfc_trans_assignment_1): Similarly suppress class assignment
+	for class valued procedure pointers.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* trans-expr.c (gfc_conv_component_ref): Remove the condition
+	that deferred character length components only be allocatable.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* trans-expr.c (gfc_trans_class_init_assign): Call
+	gfc_conv_expr_present only for dummy variables.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* frontend-passes.c (traverse_io_block): Adjust test for
+	when a variable is eligible for the transformation to
+	array slice.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* frontend-passes.c (inline_matmul_assign): Do not inline matmul
+	if the assignment to the resulting array if it is not of canonical
+	type (real/integer/complex/logical).
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 017334839ed..c5d813a2dc3 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -2224,8 +2224,7 @@ gfc_copy_iterator (gfc_iterator *src)
 /********* Subroutines for determining the size of an array *********/
 
 /* These are needed just to accommodate RESHAPE().  There are no
-   diagnostics here, we just return a negative number if something
-   goes wrong.  */
+   diagnostics here, we just return false if something goes wrong.  */
 
 
 /* Get the size of single dimension of an array specification.  The
@@ -2254,6 +2253,9 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)
 
   mpz_add_ui (*result, *result, 1);
 
+  if (mpz_cmp_si (*result, 0) < 0)
+    mpz_set_si (*result, 0);
+
   return true;
 }
 
@@ -2327,12 +2329,11 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)
 	{
 	  stride_expr = gfc_copy_expr(ar->stride[dimen]); 
 
-	  if(!gfc_simplify_expr(stride_expr, 1))
-	    gfc_internal_error("Simplification error");
-
-	  if (stride_expr->expr_type != EXPR_CONSTANT
-	      || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
+	  if (!gfc_simplify_expr (stride_expr, 1)
+	     || stride_expr->expr_type != EXPR_CONSTANT
+	     || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
 	    {
+	      gfc_free_expr (stride_expr);
 	      mpz_clear (stride);
 	      return false;
 	    }
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index df95d0b65ca..3f5b057c0d4 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -5562,8 +5562,8 @@ gfc_calculate_transfer_sizes (gfc_expr *source, gfc_expr *mold, gfc_expr *size,
    * representation is not shorter than that of SOURCE.
    * If SIZE is present, the result is an array of rank one and size SIZE.
    */
-  if (result_elt_size == 0 && *source_size > 0 && !size
-      && mold->expr_type == EXPR_ARRAY)
+  if (result_elt_size == 0 && *source_size > 0
+      && (mold->expr_type == EXPR_ARRAY || mold->rank))
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L is an "
 		 "array and shall not have storage size 0 when %<SOURCE%> "
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 1a5bcfae3c0..928a50a6cd1 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -613,6 +613,7 @@ gfc_get_len_component (gfc_expr *e, int k)
    component '_vptr' which determines the dynamic type.  When this CLASS
    entity is unlimited polymorphic, then also add a component '_len' to
    store the length of string when that is stored in it.  */
+static int ctr = 0;
 
 bool
 gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
@@ -628,13 +629,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
 
   gcc_assert (as);
 
-  if (*as && (*as)->type == AS_ASSUMED_SIZE)
-    {
-      gfc_error ("Assumed size polymorphic objects or components, such "
-		 "as that at %C, have not yet been implemented");
-      return false;
-    }
-
   if (attr->class_ok)
     /* Class container has already been built.  */
     return true;
@@ -672,7 +666,30 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
   else
     ns = ts->u.derived->ns;
 
-  gfc_find_symbol (name, ns, 0, &fclass);
+  /* Although this might seem to be counterintuitive, we can build separate
+     class types with different array specs because the TKR interface checks
+     work on the declared type. All array type other than deferred shape or
+     assumed rank are added to the function namespace to ensure that they
+     are properly distinguished.  */
+  if (attr->dummy && !attr->codimension && (*as)
+      && !((*as)->type == AS_DEFERRED || (*as)->type == AS_ASSUMED_RANK))
+    {
+      char *sname;
+      ns = gfc_current_ns;
+      gfc_find_symbol (name, ns, 0, &fclass);
+      /* If a local class type with this name already exists, update the
+	 name with an index.  */
+      if (fclass)
+	{
+	  fclass = NULL;
+	  sname = xasprintf ("%s_%d", name, ++ctr);
+	  free (name);
+	  name = sname;
+	}
+    }
+  else
+    gfc_find_symbol (name, ns, 0, &fclass);
+
   if (fclass == NULL)
     {
       gfc_symtree *st;
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 00321da827e..51238e49fb1 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -2043,6 +2043,24 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	  sym->as->type = AS_EXPLICIT;
 	}
 
+      /* Ensure that explicit bounds are simplified.  */
+      if (sym->attr.flavor == FL_PARAMETER && sym->attr.dimension
+	  && sym->as->type == AS_EXPLICIT)
+	{
+	  for (int dim = 0; dim < sym->as->rank; ++dim)
+	    {
+	      gfc_expr *e;
+
+	      e = sym->as->lower[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+
+	      e = sym->as->upper[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+	    }
+	}
+
       /* Need to check if the expression we initialized this
 	 to was one of the iso_c_binding named constants.  If so,
 	 and we're a parameter (constant), let it be iso_c.
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 019245a3ab8..7b61488bfe9 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1330,7 +1330,9 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
   for (i = 0; i < ar->dimen; i++)
     {
       if (!gfc_reduce_init_expr (ar->as->lower[i])
-	  || !gfc_reduce_init_expr (ar->as->upper[i]))
+	  || !gfc_reduce_init_expr (ar->as->upper[i])
+	  || ar->as->upper[i]->expr_type != EXPR_CONSTANT
+	  || ar->as->lower[i]->expr_type != EXPR_CONSTANT)
 	{
 	  t = false;
 	  cons = NULL;
@@ -1344,9 +1346,6 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
 	  goto depart;
 	}
 
-      gcc_assert (ar->as->upper[i]->expr_type == EXPR_CONSTANT
-		  && ar->as->lower[i]->expr_type == EXPR_CONSTANT);
-
       /* Check the bounds.  */
       if ((ar->as->upper[i]
 	   && mpz_cmp (e->value.integer,
@@ -1718,8 +1717,8 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)
   *newp = gfc_copy_expr (p);
   free ((*newp)->value.character.string);
 
-  end = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.end->value.integer);
-  start = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.start->value.integer);
+  end = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.end->value.integer);
+  start = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.start->value.integer);
   if (end >= start)
     length = end - start + 1;
   else
@@ -2144,10 +2143,9 @@ gfc_simplify_expr (gfc_expr *p, int type)
 	  && gfc_intrinsic_func_interface (p, 1) == MATCH_ERROR)
 	return false;
 
-      if (p->expr_type == EXPR_FUNCTION)
+      if (p->symtree && (p->value.function.isym || p->ts.type == BT_UNKNOWN))
 	{
-	  if (p->symtree)
-	    isym = gfc_find_function (p->symtree->n.sym->name);
+	  isym = gfc_find_function (p->symtree->n.sym->name);
 	  if (isym && isym->elemental)
 	    scalarize_intrinsic_call (p, false);
 	}
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index ff71b44b409..7b0428d27f2 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1301,8 +1301,8 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)
 		std::swap (start->value.op.op1, start->value.op.op2);
 	      gcc_fallthrough ();
 	    case INTRINSIC_MINUS:
-	      if ((start->value.op.op1->expr_type!= EXPR_VARIABLE
-		   && start->value.op.op2->expr_type != EXPR_CONSTANT)
+	      if (start->value.op.op1->expr_type!= EXPR_VARIABLE
+		  || start->value.op.op2->expr_type != EXPR_CONSTANT
 		  || start->value.op.op1->ref)
 		return false;
 	      if (!stack_top || !stack_top->iter
@@ -2416,7 +2416,7 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
 
 	      do_sym = cl->ext.iterator->var->symtree->n.sym;
 
-	      if (a->expr && a->expr->symtree
+	      if (a->expr && a->expr->symtree && f->sym
 		  && a->expr->symtree->n.sym == do_sym)
 		{
 		  if (f->sym->attr.intent == INTENT_OUT)
@@ -2679,6 +2679,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2688,6 +2689,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			    gfc_warning (warn, "Array reference at %L out of bounds "
 					 "(%ld > %ld) in loop beginning at %L",
@@ -2703,6 +2705,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2712,6 +2715,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld > %ld) in loop beginning at %L",
@@ -3921,6 +3925,19 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,
   if (m_case == none)
     return 0;
 
+  /* We only handle assignment to numeric or logical variables.  */
+  switch(expr1->ts.type)
+    {
+    case BT_INTEGER:
+    case BT_LOGICAL:
+    case BT_REAL:
+    case BT_COMPLEX:
+      break;
+
+    default:
+      return 0;
+    }
+
   ns = insert_block ();
 
   /* Assign the type of the zero expression for initializing the resulting
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 8426f3b2839..0e2f9f6c131 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -4551,6 +4551,24 @@ parse_associate (void)
 	 in case of association to a derived-type.  */
       sym->ts = a->target->ts;
 
+      /* Don’t share the character length information between associate
+	 variable and target if the length is not a compile-time constant,
+	 as we don’t want to touch some other character length variable when
+	 we try to initialize the associate variable’s character length
+	 variable.
+	 We do it here rather than later so that expressions referencing the
+	 associate variable will automatically have the correctly setup length
+	 information.  If we did it at resolution stage the expressions would
+	 use the original length information, and the variable a new different
+	 one, but only the latter one would be correctly initialized at
+	 translation stage, and the former one would need some additional setup
+	 there.  */
+      if (sym->ts.type == BT_CHARACTER
+	  && sym->ts.u.cl
+	  && !(sym->ts.u.cl->length
+	       && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT))
+	sym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);
+
       /* Check if the target expression is array valued.  This cannot always
 	 be done by looking at target.rank, because that might not have been
 	 set yet.  Therefore traverse the chain of refs, looking for the last
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index cbd84bb0abc..1e1f16ebacf 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -3023,26 +3023,36 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,
 	  continue;
 	}
 
-      /* If it was not found, try the default initializer if there's any;
+      /* If it was not found, apply NULL expression to set the component as
+	 unallocated. Then try the default initializer if there's any;
 	 otherwise, it's an error unless this is a deferred parameter.  */
       if (!comp_iter)
 	{
-	  if (comp->initializer)
-	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
-				   "with missing optional arguments at %C"))
-		return false;
-	      value = gfc_copy_expr (comp->initializer);
-	    }
-	  else if (comp->attr.allocatable
-		   || (comp->ts.type == BT_CLASS
-		       && CLASS_DATA (comp)->attr.allocatable))
+	  /* F2018 7.5.10: If an allocatable component has no corresponding
+	     component-data-source, then that component has an allocation
+	     status of unallocated....  */
+	  if (comp->attr.allocatable
+	      || (comp->ts.type == BT_CLASS
+		  && CLASS_DATA (comp)->attr.allocatable))
 	    {
 	      if (!gfc_notify_std (GFC_STD_F2008, "No initializer for "
 				   "allocatable component %qs given in the "
 				   "structure constructor at %C", comp->name))
 		return false;
+	      value = gfc_get_null_expr (&gfc_current_locus);
+	    }
+	  /* ....(Preceeding sentence) If a component with default
+	     initialization has no corresponding component-data-source, then
+	     the default initialization is applied to that component.  */
+	  else if (comp->initializer)
+	    {
+	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
+				   "with missing optional arguments at %C"))
+		return false;
+	      value = gfc_copy_expr (comp->initializer);
 	    }
+	  /* Do not trap components such as the string length for deferred
+	     length character components.  */
 	  else if (!comp->attr.artificial)
 	    {
 	      gfc_error ("No initializer for component %qs given in the"
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 1c72e0db9ea..507e232b983 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -4736,6 +4736,8 @@ gfc_resolve_dim_arg (gfc_expr *dim)
    base symbol.  We traverse the list of reference structures, setting
    the stored reference to references.  Component references can
    provide an additional array specification.  */
+static void
+resolve_assoc_var (gfc_symbol* sym, bool resolve_target);
 
 static void
 find_array_spec (gfc_expr *e)
@@ -4745,6 +4747,13 @@ find_array_spec (gfc_expr *e)
   gfc_ref *ref;
   bool class_as = false;
 
+  if (e->symtree->n.sym->assoc)
+    {
+      if (e->symtree->n.sym->assoc->target)
+	gfc_resolve_expr (e->symtree->n.sym->assoc->target);
+      resolve_assoc_var (e->symtree->n.sym, false);
+    }
+
   if (e->symtree->n.sym->ts.type == BT_CLASS)
     {
       as = CLASS_DATA (e->symtree->n.sym)->as;
@@ -8933,8 +8942,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)
       if (!sym->ts.u.cl)
 	sym->ts.u.cl = target->ts.u.cl;
 
-      if (sym->ts.deferred && target->expr_type == EXPR_VARIABLE
-	  && target->symtree->n.sym->attr.dummy
+      if (sym->ts.deferred
 	  && sym->ts.u.cl == target->ts.u.cl)
 	{
 	  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);
@@ -8953,8 +8961,11 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)
 		|| sym->ts.u.cl->length->expr_type != EXPR_CONSTANT)
 		&& target->expr_type != EXPR_VARIABLE)
 	{
-	  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);
-	  sym->ts.deferred = 1;
+	  if (!sym->ts.deferred)
+	    {
+	      sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);
+	      sym->ts.deferred = 1;
+	    }
 
 	  /* This is reset in trans-stmt.c after the assignment
 	     of the target expression to the associate name.  */
@@ -12735,7 +12746,8 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 
   /* An elemental function is required to return a scalar 12.7.1  */
   if (sym->attr.elemental && sym->attr.function
-      && (sym->as || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)))
+      && (sym->as || (sym->ts.type == BT_CLASS && sym->attr.class_ok
+		      && CLASS_DATA (sym)->as)))
     {
       gfc_error ("ELEMENTAL function %qs at %L must have a scalar "
 		 "result", sym->name, &sym->declared_at);
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 2004895fbe3..7b3a7186522 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -4197,6 +4197,12 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)
 	     || (as->type == AS_ASSUMED_SHAPE && upper)))
     return NULL;
 
+  /* 'array' shall not be an unallocated allocatable variable or a pointer that
+     is not associated.  */
+  if (array->expr_type == EXPR_VARIABLE
+      && (gfc_expr_attr (array).allocatable || gfc_expr_attr (array).pointer))
+    return NULL;
+
   gcc_assert (!as
 	      || (as->type != AS_DEFERRED
 		  && array->expr_type == EXPR_VARIABLE
@@ -7964,7 +7970,18 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)
      set even for array expressions, in order to pass this information into
      gfc_target_interpret_expr.  */
   if (result->ts.type == BT_CHARACTER && gfc_is_constant_expr (mold_element))
-    result->value.character.length = mold_element->value.character.length;
+    {
+      result->value.character.length = mold_element->value.character.length;
+
+      /* Let the typespec of the result inherit the string length.
+	 This is crucial if a resulting array has size zero.  */
+      if (mold_element->ts.u.cl->length)
+	result->ts.u.cl->length = gfc_copy_expr (mold_element->ts.u.cl->length);
+      else
+	result->ts.u.cl->length =
+	  gfc_get_int_expr (gfc_charlen_int_kind, NULL,
+			    mold_element->value.character.length);
+    }
 
   /* Set the number of elements in the result, and determine its size.  */
 
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index c6efe95e236..d6315624f2c 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -6609,7 +6609,14 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)
   /* Set the pointer itself if we aren't using the parameter directly.  */
   if (TREE_CODE (parm) != PARM_DECL)
     {
-      tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));
+      tmp = GFC_DECL_SAVED_DESCRIPTOR (parm);
+      if (sym->ts.type == BT_CLASS)
+	{
+	  tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	  tmp = gfc_class_data_get (tmp);
+	  tmp = gfc_conv_descriptor_data_get (tmp);
+	}
+      tmp = convert (TREE_TYPE (parm), tmp);
       gfc_add_modify (&init, parm, tmp);
     }
   stmt = gfc_finish_block (&init);
@@ -6705,7 +6712,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,
       && VAR_P (sym->ts.u.cl->backend_decl))
     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);
 
-  checkparm = (as->type == AS_EXPLICIT
+  /* TODO: Fix the exclusion of class arrays from extent checking.  */
+  checkparm = (as->type == AS_EXPLICIT && !is_classarray
 	       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));
 
   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)
@@ -7521,9 +7529,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
 			 && expr->value.function.esym->attr.elemental)
 			|| (expr->value.function.isym != NULL
 			    && expr->value.function.isym->elemental)
+			|| (gfc_expr_attr (expr).proc_pointer
+			    && gfc_expr_attr (expr).elemental)
 			|| gfc_inline_intrinsic_function_p (expr));
-	  else
-	    gcc_assert (ss_type == GFC_SS_INTRINSIC);
 
 	  need_tmp = 1;
 	  if (expr->ts.type == BT_CHARACTER
@@ -7712,15 +7720,21 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
       /* Set the string_length for a character array.  */
       if (expr->ts.type == BT_CHARACTER)
 	{
-	  se->string_length =  gfc_get_expr_charlen (expr);
+	  if (deferred_array_component)
+	    se->string_length = ss_info->string_length;
+	  else
+	    se->string_length =  gfc_get_expr_charlen (expr);
+
 	  if (VAR_P (se->string_length)
 	      && expr->ts.u.cl->backend_decl == se->string_length)
 	    tmp = ss_info->string_length;
 	  else
 	    tmp = se->string_length;
 
-	  if (expr->ts.deferred)
+	  if (expr->ts.deferred && VAR_P (expr->ts.u.cl->backend_decl))
 	    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl, tmp);
+	  else
+	    expr->ts.u.cl->backend_decl = tmp;
 	}
 
       /* If we have an array section or are assigning make sure that
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index fb957d187d3..99772db9ca1 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1506,7 +1506,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)
      declaration of the entity and memory allocated/deallocated.  */
   if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
       && sym->param_list != NULL
-      && !(sym->attr.host_assoc || sym->attr.use_assoc || sym->attr.dummy))
+      && gfc_current_ns == sym->ns
+      && !(sym->attr.use_assoc || sym->attr.dummy))
     gfc_defer_symbol_init (sym);
 
   /* Dummy PDT 'len' parameters should be checked when they are explicit.  */
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index 9be8dd185bf..34f8a1abdba 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1655,8 +1655,9 @@ gfc_trans_class_init_assign (gfc_code *code)
 	}
     }
 
-  if (code->expr1->symtree->n.sym->attr.optional
-      || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master)
+  if (code->expr1->symtree->n.sym->attr.dummy
+      && (code->expr1->symtree->n.sym->attr.optional
+	  || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master))
     {
       tree present = gfc_conv_expr_present (code->expr1->symtree->n.sym);
       tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),
@@ -2470,7 +2471,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)
 			     se.expr, build_zero_cst (TREE_TYPE (se.expr)));
   gfc_add_block_to_block (pblock, &se.pre);
 
-  if (cl->backend_decl)
+  if (cl->backend_decl && VAR_P (cl->backend_decl))
     gfc_add_modify (pblock, cl->backend_decl, se.expr);
   else
     cl->backend_decl = gfc_evaluate_now (se.expr, pblock);
@@ -2530,7 +2531,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
   if (!CONSTANT_CLASS_P (tmp) && !DECL_P (tmp))
     end.expr = gfc_evaluate_now (end.expr, &se->pre);
 
-  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+  if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+      && (ref->u.ss.start->symtree
+	  && !ref->u.ss.start->symtree->n.sym->attr.implied_index))
     {
       tree nonempty = fold_build2_loc (input_location, LE_EXPR,
 				       logical_type_node, start.expr,
@@ -2663,7 +2666,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   /* Allocatable deferred char arrays are to be handled by the gfc_deferred_
      strlen () conditional below.  */
   if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-      && !(c->attr.allocatable && c->ts.deferred)
+      && !c->ts.deferred
       && !c->attr.pdt_string)
     {
       tmp = c->ts.u.cl->backend_decl;
@@ -5566,7 +5569,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				     CLASS_DATA (fsym)->attr.class_pointer
 				     || CLASS_DATA (fsym)->attr.allocatable);
 	}
-      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS)
+      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS
+	       && gfc_expr_attr (e).flavor != FL_PROCEDURE)
 	{
 	  /* The intrinsic type needs to be converted to a temporary
 	     CLASS object for the unlimited polymorphic formal.  */
@@ -6159,6 +6163,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
+	      else if (e->ts.type == BT_CLASS && CLASS_DATA (e)->as
+		       && CLASS_DATA (e)->as->type == AS_ASSUMED_SIZE
+		       && nodesc_arg && fsym->ts.type == BT_DERIVED)
+		/* An assumed size class actual argument being passed to
+		   a 'no descriptor' formal argument just requires the
+		   data pointer to be passed. For class dummy arguments
+		   this is stored in the symbol backend decl..  */
+		parmse.expr = e->symtree->n.sym->backend_decl;
+
 	      else if (gfc_is_class_array_ref (e, NULL)
 		       && fsym && fsym->ts.type == BT_DERIVED)
 		/* The actual argument is a component reference to an
@@ -6229,6 +6242,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    // deallocate the components first
 		    tmp = gfc_deallocate_alloc_comp (fsym->ts.u.derived,
 						     parmse.expr, e->rank);
+		    /* But check whether dummy argument is optional.  */
+		    if (tmp != NULL_TREE
+			&& fsym->attr.optional
+			&& e->expr_type == EXPR_VARIABLE
+			&& e->symtree->n.sym->attr.optional)
+		      {
+			tree present;
+			present = gfc_conv_expr_present (e->symtree->n.sym);
+			tmp = build3_v (COND_EXPR, present, tmp,
+					build_empty_stmt (input_location));
+		      }
 		    if (tmp != NULL_TREE)
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		  }
@@ -8423,8 +8447,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)
   return gfc_finish_block (&block);
 }
 
-void
-gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,
+static void
+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *&v,
                             gfc_component *un, gfc_expr *init)
 {
   gfc_constructor *ctor;
@@ -10806,7 +10830,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 		       || gfc_is_class_array_ref (expr1, NULL)
 		       || gfc_is_class_scalar_expr (expr1)
 		       || gfc_is_class_array_ref (expr2, NULL)
-		       || gfc_is_class_scalar_expr (expr2));
+		       || gfc_is_class_scalar_expr (expr2))
+		   && lhs_attr.flavor != FL_PROCEDURE;
 
   realloc_flag = flag_realloc_lhs
 		 && gfc_is_reallocatable_lhs (expr1)
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 1b51e870f04..729f933ac11 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -8473,7 +8473,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
   else
     {
       /* An optional target.  */
-      if (arg2->expr->ts.type == BT_CLASS)
+      if (arg2->expr->ts.type == BT_CLASS
+	  && arg2->expr->expr_type != EXPR_FUNCTION)
 	gfc_add_data_component (arg2->expr);
 
       nonzero_charlen = NULL_TREE;
@@ -8501,6 +8502,11 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
 	      && arg2->expr->symtree->n.sym->attr.dummy)
 	    arg2se.expr = build_fold_indirect_ref_loc (input_location,
 						       arg2se.expr);
+	  if (arg2->expr->ts.type == BT_CLASS)
+	    {
+	      arg2se.expr = gfc_evaluate_now (arg2se.expr, &arg2se.pre);
+	      arg2se.expr = gfc_class_data_get (arg2se.expr);
+	    }
 	  gfc_add_block_to_block (&se->pre, &arg1se.pre);
 	  gfc_add_block_to_block (&se->post, &arg1se.post);
 	  gfc_add_block_to_block (&se->pre, &arg2se.pre);
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index d5aec5286fc..a02731c9b09 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1719,7 +1719,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
       gfc_conv_expr_descriptor (&se, e);
 
       if (sym->ts.type == BT_CHARACTER
-	  && !se.direct_byref && sym->ts.deferred
+	  && sym->ts.deferred
 	  && !sym->attr.select_type_temporary
 	  && VAR_P (sym->ts.u.cl->backend_decl)
 	  && se.string_length != sym->ts.u.cl->backend_decl)
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d0f1095edd5..d35968e1ba1 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -3414,8 +3414,8 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)
       if (!integer_zerop (dtype_off))
 	t = fold_build_pointer_plus (t, rank_off);
 
-      t = build1 (NOP_EXPR, build_pointer_type (gfc_array_index_type), t);
-      t = build1 (INDIRECT_REF, gfc_array_index_type, t);
+      t = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (field)), t);
+      t = build1 (INDIRECT_REF, TREE_TYPE (field), t);
       info->rank = t;
       t = build0 (PLACEHOLDER_EXPR, TREE_TYPE (dim_off));
       t = size_binop (MULT_EXPR, t, dim_size);
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index 408b93b2200..0166fdae0c0 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -274,7 +274,9 @@ get_symbol_constant_value (tree sym)
       if (val)
 	{
 	  val = canonicalize_constructor_val (unshare_expr (val), sym);
-	  if (val && is_gimple_min_invariant (val))
+	  if (val
+	      && is_gimple_min_invariant (val)
+	      && useless_type_conversion_p (TREE_TYPE (sym), TREE_TYPE (val)))
 	    return val;
 	  else
 	    return NULL_TREE;
@@ -434,7 +436,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)
 					   CONSTRUCTOR_ELTS (rhs));
 	  }
 
-	else if (DECL_P (rhs))
+	else if (DECL_P (rhs)
+		 && is_gimple_reg_type (TREE_TYPE (rhs)))
 	  return get_symbol_constant_value (rhs);
       }
       break;
diff --git a/gcc/gimple-loop-interchange.cc b/gcc/gimple-loop-interchange.cc
index b188ce86d5e..d10089b8c22 100644
--- a/gcc/gimple-loop-interchange.cc
+++ b/gcc/gimple-loop-interchange.cc
@@ -1042,7 +1042,10 @@ tree_loop_interchange::valid_data_dependences (unsigned i_idx, unsigned o_idx,
 
 	  /* Be conservative, skip case if either direction at i_idx/o_idx
 	     levels is not '=' or '<'.  */
-	  if (dist_vect[i_idx] < 0 || dist_vect[o_idx] < 0)
+	  if ((!DDR_REVERSED_P (ddr) && dist_vect[i_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[i_idx] > 0)
+	      || (!DDR_REVERSED_P (ddr) && dist_vect[o_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[o_idx] > 0))
 	    return false;
 	}
     }
diff --git a/gcc/gimple-loop-jam.c b/gcc/gimple-loop-jam.c
index 236349e36ba..4a1d42d98a9 100644
--- a/gcc/gimple-loop-jam.c
+++ b/gcc/gimple-loop-jam.c
@@ -404,10 +404,10 @@ adjust_unroll_factor (class loop *inner, struct data_dependence_relation *ddr,
 	     a >= N, or b > 0, or b is zero and a > 0.  Otherwise the unroll
 	     factor needs to be limited so that the first condition holds.
 	     That may limit the factor down to zero in the worst case.  */
-	  int dist = dist_v[0];
+	  lambda_int dist = dist_v[0];
 	  if (dist < 0)
 	    gcc_unreachable ();
-	  else if ((unsigned)dist >= *unroll)
+	  else if (dist >= (lambda_int)*unroll)
 	    ;
 	  else if (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))
 	    {
diff --git a/gcc/gimple-ssa-evrp-analyze.c b/gcc/gimple-ssa-evrp-analyze.c
index bb4e2d6e798..3a6956c59c6 100644
--- a/gcc/gimple-ssa-evrp-analyze.c
+++ b/gcc/gimple-ssa-evrp-analyze.c
@@ -217,7 +217,11 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)
 	      push_value_range (vrs[i].first, vrs[i].second);
 	      if (is_fallthru
 		  && m_update_global_ranges
-		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt))
+		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt)
+		  /* The condition must post-dominate the definition point.  */
+		  && (SSA_NAME_IS_DEFAULT_DEF (vrs[i].first)
+		      || (gimple_bb (SSA_NAME_DEF_STMT (vrs[i].first))
+			  == pred_e->src)))
 		{
 		  set_ssa_range_info (vrs[i].first, vrs[i].second);
 		  maybe_set_nonzero_bits (pred_e, vrs[i].first);
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index c1081da9c0e..1206efe4a1e 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -818,12 +818,18 @@ find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,
 	{
 	  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;
 	  *cmpxchg &= mask;
-	  *cmpnop >>= (n->range - rsize) * BITS_PER_MARKER;
+	  if (n->range - rsize == sizeof (int64_t))
+	    *cmpnop = 0;
+	  else
+	    *cmpnop >>= (n->range - rsize) * BITS_PER_MARKER;
 	}
       else
 	{
 	  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;
-	  *cmpxchg >>= (n->range - rsize) * BITS_PER_MARKER;
+	  if (n->range - rsize == sizeof (int64_t))
+	    *cmpxchg = 0;
+	  else
+	    *cmpxchg >>= (n->range - rsize) * BITS_PER_MARKER;
 	  *cmpnop &= mask;
 	}
       n->range = rsize;
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index ba72ff2faa5..1998da526ba 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -7575,7 +7575,13 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)
 
       if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0
 	  && (n == NULL || (n->value & GOVD_DATA_SHARE_CLASS) == 0))
-	continue;
+	{
+	  if ((ctx->region_type & ORT_TARGET_DATA) != 0
+	      || n == NULL
+	      || (n->value & GOVD_MAP) == 0)
+	    continue;
+	  return false;
+	}
 
       if (n != NULL)
 	{
@@ -7584,11 +7590,16 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)
 	    return false;
 	  return (n->value & GOVD_SHARED) == 0;
 	}
+
+      if (ctx->region_type == ORT_WORKSHARE
+	  || ctx->region_type == ORT_TASKGROUP
+	  || ctx->region_type == ORT_SIMD
+	  || ctx->region_type == ORT_ACC)
+	continue;
+
+      break;
     }
-  while (ctx->region_type == ORT_WORKSHARE
-	 || ctx->region_type == ORT_TASKGROUP
-	 || ctx->region_type == ORT_SIMD
-	 || ctx->region_type == ORT_ACC);
+  while (1);
   return false;
 }
 
diff --git a/gcc/godump.c b/gcc/godump.c
index 617a96486cd..961f97e2f80 100644
--- a/gcc/godump.c
+++ b/gcc/godump.c
@@ -56,6 +56,8 @@ static FILE *go_dump_file;
 
 static GTY(()) vec<tree, va_gc> *queue;
 
+struct godump_str_hash : string_hash, ggc_remove <const char *> {};
+
 /* A hash table of macros we have seen.  */
 
 static htab_t macro_hash;
@@ -542,7 +544,7 @@ struct godump_container
 
   /* Types which may potentially have to be defined as dummy
      types.  */
-  hash_set<const char *> pot_dummy_types;
+  hash_set<const char *, false, godump_str_hash> pot_dummy_types;
 
   /* Go keywords.  */
   htab_t keyword_hash;
diff --git a/gcc/ifcvt.c b/gcc/ifcvt.c
index 7f73b2999d6..ca7aa33c3c2 100644
--- a/gcc/ifcvt.c
+++ b/gcc/ifcvt.c
@@ -3065,6 +3065,12 @@ bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,
 
   if (!insn_valid_noce_process_p (last_insn, cc))
     return false;
+
+  /* Punt on blocks ending with asm goto or jumps with other side-effects,
+     last_active_insn ignores JUMP_INSNs.  */
+  if (JUMP_P (BB_END (test_bb)) && !onlyjump_p (BB_END (test_bb)))
+    return false;
+
   last_set = single_set (last_insn);
 
   rtx x = SET_DEST (last_set);
diff --git a/gcc/ipa-fnsummary.c b/gcc/ipa-fnsummary.c
index 7c5562ad801..2b8c21ddd4f 100644
--- a/gcc/ipa-fnsummary.c
+++ b/gcc/ipa-fnsummary.c
@@ -3319,13 +3319,20 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,
       bp = streamer_read_bitpack (&ib);
       if (info)
 	{
-          info->inlinable = bp_unpack_value (&bp, 1);
-          info->fp_expressions = bp_unpack_value (&bp, 1);
+	  info->inlinable = bp_unpack_value (&bp, 1);
+	  /* On the side of streaming out, there is still one bit
+	     streamed out between inlinable and fp_expressions bits,
+	     which was used for cilk+ before but now always false.
+	     To remove the bit packing need to bump LTO minor version,
+	     so unpack a dummy bit here to keep consistent instead.  */
+	  bp_unpack_value (&bp, 1);
+	  info->fp_expressions = bp_unpack_value (&bp, 1);
 	}
       else
 	{
-          bp_unpack_value (&bp, 1);
-          bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
 	}
 
       count2 = streamer_read_uhwi (&ib);
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index 0c6f84ff72d..1cc69cd05d7 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -1654,9 +1654,9 @@ propagate_pure_const (void)
 	  if (w_l->state_previously_known != IPA_NEITHER
 	      && this_state > w_l->state_previously_known)
 	    {
-              this_state = w_l->state_previously_known;
 	      if (this_state == IPA_NEITHER)
-	        this_looping = w_l->looping_previously_known;
+		this_looping = w_l->looping_previously_known;
+	      this_state = w_l->state_previously_known;
 	    }
 	  if (!this_looping && self_recursive_p (w))
 	    this_looping = true;
diff --git a/gcc/jit/ChangeLog b/gcc/jit/ChangeLog
index 56168ba677a..61067c2ff13 100644
--- a/gcc/jit/ChangeLog
+++ b/gcc/jit/ChangeLog
@@ -1,3 +1,10 @@
+2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	* jit-playback.c (function): Initialize m_blocks vector.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/jit/jit-playback.c b/gcc/jit/jit-playback.c
index b74495c58b2..ebdb56cbc6d 100644
--- a/gcc/jit/jit-playback.c
+++ b/gcc/jit/jit-playback.c
@@ -1287,7 +1287,8 @@ function (context *ctxt,
 : m_ctxt(ctxt),
   m_inner_fndecl (fndecl),
   m_inner_bind_expr (NULL),
-  m_kind (kind)
+  m_kind (kind),
+  m_blocks ()
 {
   if (m_kind != GCC_JIT_FUNCTION_IMPORTED)
     {
diff --git a/gcc/loop-invariant.c b/gcc/loop-invariant.c
index b880ead3d15..4d955a616bf 100644
--- a/gcc/loop-invariant.c
+++ b/gcc/loop-invariant.c
@@ -1692,6 +1692,7 @@ can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)
   unsigned int dest_regno, defs_in_loop_count = 0;
   rtx_insn *insn = inv->insn;
   basic_block bb = BLOCK_FOR_INSN (inv->insn);
+  auto_vec <rtx_insn *, 16> debug_insns_to_reset;
 
   /* We ignore hard register and memory access for cost and complexity reasons.
      Hard register are few at this stage and expensive to consider as they
@@ -1726,10 +1727,13 @@ can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)
 	continue;
 
       /* Don't move if a use is not dominated by def in insn.  */
-      if (use_bb == bb && DF_INSN_LUID (insn) >= DF_INSN_LUID (use_insn))
-	return false;
-      if (!dominated_by_p (CDI_DOMINATORS, use_bb, bb))
-	return false;
+      if ((use_bb == bb && DF_INSN_LUID (insn) >= DF_INSN_LUID (use_insn))
+	  || !dominated_by_p (CDI_DOMINATORS, use_bb, bb))
+	{
+	  if (!DEBUG_INSN_P (use_insn))
+	    return false;
+	  debug_insns_to_reset.safe_push (use_insn);
+	}
     }
 
   /* Check for other defs.  Any other def in the loop might reach a use
@@ -1752,6 +1756,15 @@ can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)
 	return false;
     }
 
+  /* Reset debug uses if a use is not dominated by def in insn.  */
+  rtx_insn *use_insn;
+  unsigned i;
+  FOR_EACH_VEC_ELT (debug_insns_to_reset, i, use_insn)
+    {
+      INSN_VAR_LOCATION_LOC (use_insn) = gen_rtx_UNKNOWN_VAR_LOC ();
+      df_insn_rescan (use_insn);
+    }
+
   return true;
 }
 
diff --git a/gcc/match.pd b/gcc/match.pd
index 633eb5dc170..596d6e33b05 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -304,12 +304,15 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
     { build_minus_one_cst (type); })))
 
 /* For unsigned integral types, FLOOR_DIV_EXPR is the same as
-   TRUNC_DIV_EXPR.  Rewrite into the latter in this case.  */
-(simplify
- (floor_div @0 @1)
- (if ((INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type))
-      && TYPE_UNSIGNED (type))
-  (trunc_div @0 @1)))
+   TRUNC_DIV_EXPR.  Rewrite into the latter in this case.  Similarly
+   for MOD instead of DIV.  */
+(for floor_divmod (floor_div floor_mod)
+     trunc_divmod (trunc_div trunc_mod)
+ (simplify
+  (floor_divmod @0 @1)
+  (if ((INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type))
+       && TYPE_UNSIGNED (type))
+   (trunc_divmod @0 @1))))
 
 /* Combine two successive divisions.  Note that combining ceil_div
    and floor_div is trickier and combining round_div even more so.  */
@@ -564,7 +567,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 /* Simplify (unsigned t * 2)/2 -> unsigned t & 0x7FFFFFFF.  */
 (simplify
  (trunc_div (mult @0 integer_pow2p@1) @1)
- (if (TYPE_UNSIGNED (TREE_TYPE (@0)))
+ (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)) && TYPE_UNSIGNED (TREE_TYPE (@0)))
   (bit_and @0 { wide_int_to_tree
 		(type, wi::mask (TYPE_PRECISION (type)
 				 - wi::exact_log2 (wi::to_wide (@1)),
@@ -573,7 +576,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 /* Simplify (unsigned t / 2) * 2 -> unsigned t & ~1.  */
 (simplify
  (mult (trunc_div @0 integer_pow2p@1) @1)
- (if (TYPE_UNSIGNED (TREE_TYPE (@0)))
+ (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)) && TYPE_UNSIGNED (TREE_TYPE (@0)))
   (bit_and @0 (negate @1))))
 
 /* Simplify (t * 2) / 2) -> t.  */
@@ -1984,13 +1987,15 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
   (simplify
    (minus (convert? (negate @0)) integer_each_onep)
    (if (!TYPE_OVERFLOW_TRAPS (type)
+	&& TREE_CODE (type) != COMPLEX_TYPE
 	&& tree_nop_conversion_p (type, TREE_TYPE (@0)))
     (bit_not (convert @0))))
 
   /* -1 - A -> ~A */
   (simplify
    (minus integer_all_onesp @0)
-   (bit_not @0))
+   (if (TREE_CODE (type) != COMPLEX_TYPE)
+    (bit_not @0)))
 
   /* (T)(P + A) - (T)P -> (T) A */
   (simplify
@@ -4044,7 +4049,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
   (cmp (convert @0) INTEGER_CST@1)
   (if (((POINTER_TYPE_P (TREE_TYPE (@0))
 	 && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
-	 && INTEGRAL_TYPE_P (TREE_TYPE (@1)))
+	 && INTEGRAL_TYPE_P (TREE_TYPE (@1))
+	 /* Don't perform this optimization in GENERIC if @0 has reference
+	    type when sanitizing.  See PR101210.  */
+	 && !(GENERIC
+	      && TREE_CODE (TREE_TYPE (@0)) == REFERENCE_TYPE
+	      && (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))))
 	|| (INTEGRAL_TYPE_P (TREE_TYPE (@0))
 	    && POINTER_TYPE_P (TREE_TYPE (@1))
 	    && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 615f7f6327e..23ef347657a 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -141,6 +141,7 @@ static int target_nesting_level;
 static bitmap task_shared_vars;
 static bitmap global_nonaddressable_vars;
 static vec<omp_context *> taskreg_contexts;
+static vec<gomp_task *> task_cpyfns;
 
 static void scan_omp (gimple_seq *, omp_context *);
 static tree scan_omp_1_op (tree *, int *, void *);
@@ -980,9 +981,6 @@ delete_omp_context (splay_tree_value value)
 	DECL_ABSTRACT_ORIGIN (t) = NULL;
     }
 
-  if (is_task_ctx (ctx))
-    finalize_task_copyfn (as_a <gomp_task *> (ctx->stmt));
-
   if (ctx->task_reduction_map)
     {
       ctx->task_reductions.release ();
@@ -5177,6 +5175,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 		  if (code == MINUS_EXPR)
 		    code = PLUS_EXPR;
 
+		  bool is_truth_op
+		    = (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR);
 		  tree new_vard = new_var;
 		  if (is_simd && omp_is_reference (var))
 		    {
@@ -5202,7 +5202,21 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 			  x = build2 (code, TREE_TYPE (ivar), ivar, x);
 			  gimplify_assign (ivar, x, &llist[2]);
 			}
-		      x = build2 (code, TREE_TYPE (ref), ref, ivar);
+		      tree ivar2 = ivar;
+		      tree ref2 = ref;
+		      if (is_truth_op)
+			{
+			  tree zero = build_zero_cst (TREE_TYPE (ivar));
+			  ivar2 = fold_build2_loc (clause_loc, NE_EXPR,
+						   boolean_type_node, ivar,
+						   zero);
+			  ref2 = fold_build2_loc (clause_loc, NE_EXPR,
+						  boolean_type_node, ref,
+						  zero);
+			}
+		      x = build2 (code, TREE_TYPE (ref), ref2, ivar2);
+		      if (is_truth_op)
+			x = fold_convert (TREE_TYPE (ref), x);
 		      ref = build_outer_var_ref (var, ctx);
 		      gimplify_assign (ref, x, &llist[1]);
 
@@ -5221,8 +5235,22 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 		      if (is_simd)
 			{
 			  tree ref = build_outer_var_ref (var, ctx);
-
-			  x = build2 (code, TREE_TYPE (ref), ref, new_var);
+			  tree new_var2 = new_var;
+			  tree ref2 = ref;
+			  if (is_truth_op)
+			    {
+			      tree zero = build_zero_cst (TREE_TYPE (new_var));
+			      new_var2
+				= fold_build2_loc (clause_loc, NE_EXPR,
+						   boolean_type_node, new_var,
+						   zero);
+			      ref2 = fold_build2_loc (clause_loc, NE_EXPR,
+						      boolean_type_node, ref,
+						      zero);
+			    }
+			  x = build2 (code, TREE_TYPE (ref2), ref2, new_var2);
+			  if (is_truth_op)
+			    x = fold_convert (TREE_TYPE (new_var), x);
 			  ref = build_outer_var_ref (var, ctx);
 			  gimplify_assign (ref, x, dlist);
 			}
@@ -5942,13 +5970,27 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
       if (code == MINUS_EXPR)
         code = PLUS_EXPR;
 
+      bool is_truth_op = (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR);
       if (count == 1)
 	{
 	  tree addr = build_fold_addr_expr_loc (clause_loc, ref);
 
 	  addr = save_expr (addr);
 	  ref = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (addr)), addr);
-	  x = fold_build2_loc (clause_loc, code, TREE_TYPE (ref), ref, new_var);
+	  tree new_var2 = new_var;
+	  tree ref2 = ref;
+	  if (is_truth_op)
+	    {
+	      tree zero = build_zero_cst (TREE_TYPE (new_var));
+	      new_var2 = fold_build2_loc (clause_loc, NE_EXPR,
+					  boolean_type_node, new_var, zero);
+	      ref2 = fold_build2_loc (clause_loc, NE_EXPR, boolean_type_node,
+				      ref, zero);
+	    }
+	  x = fold_build2_loc (clause_loc, code, TREE_TYPE (new_var2), ref2,
+			       new_var2);
+	  if (is_truth_op)
+	    x = fold_convert (TREE_TYPE (new_var), x);
 	  x = build2 (OMP_ATOMIC, void_type_node, addr, x);
 	  OMP_ATOMIC_MEMORY_ORDER (x) = OMP_MEMORY_ORDER_RELAXED;
 	  gimplify_and_add (x, stmt_seqp);
@@ -6053,7 +6095,19 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
 	    }
 	  else
 	    {
-	      x = build2 (code, TREE_TYPE (out), out, priv);
+	      tree out2 = out;
+	      tree priv2 = priv;
+	      if (is_truth_op)
+		{
+		  tree zero = build_zero_cst (TREE_TYPE (out));
+		  out2 = fold_build2_loc (clause_loc, NE_EXPR,
+					  boolean_type_node, out, zero);
+		  priv2 = fold_build2_loc (clause_loc, NE_EXPR,
+					   boolean_type_node, priv, zero);
+		}
+	      x = build2 (code, TREE_TYPE (out2), out2, priv2);
+	      if (is_truth_op)
+		x = fold_convert (TREE_TYPE (out), x);
 	      out = unshare_expr (out);
 	      gimplify_assign (out, x, &sub_seq);
 	    }
@@ -6087,7 +6141,19 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
 	}
       else
 	{
-	  x = build2 (code, TREE_TYPE (ref), ref, new_var);
+	  tree new_var2 = new_var;
+	  tree ref2 = ref;
+	  if (is_truth_op)
+	    {
+	      tree zero = build_zero_cst (TREE_TYPE (new_var));
+	      new_var2 = fold_build2_loc (clause_loc, NE_EXPR,
+					  boolean_type_node, new_var, zero);
+	      ref2 = fold_build2_loc (clause_loc, NE_EXPR, boolean_type_node,
+				      ref, zero);
+	    }
+	  x = build2 (code, TREE_TYPE (ref), ref2, new_var2);
+	  if (is_truth_op)
+	    x = fold_convert (TREE_TYPE (new_var), x);
 	  ref = build_outer_var_ref (var, ctx);
 	  gimplify_assign (ref, x, &sub_seq);
 	}
@@ -7187,7 +7253,7 @@ lower_omp_task_reductions (omp_context *ctx, enum tree_code code, tree clauses,
   tree num_thr_sz = create_tmp_var (size_type_node);
   tree lab1 = create_artificial_label (UNKNOWN_LOCATION);
   tree lab2 = create_artificial_label (UNKNOWN_LOCATION);
-  tree lab3 = NULL_TREE;
+  tree lab3 = NULL_TREE, lab7 = NULL_TREE;
   gimple *g;
   if (code == OMP_FOR || code == OMP_SECTIONS)
     {
@@ -7252,6 +7318,14 @@ lower_omp_task_reductions (omp_context *ctx, enum tree_code code, tree clauses,
 	      NULL_TREE, NULL_TREE);
   tree data = create_tmp_var (pointer_sized_int_node);
   gimple_seq_add_stmt (end, gimple_build_assign (data, t));
+  if (code == OMP_TASKLOOP)
+    {
+      lab7 = create_artificial_label (UNKNOWN_LOCATION);
+      g = gimple_build_cond (NE_EXPR, data,
+			     build_zero_cst (pointer_sized_int_node),
+			     lab1, lab7);
+      gimple_seq_add_stmt (end, g);
+    }
   gimple_seq_add_stmt (end, gimple_build_label (lab1));
   tree ptr;
   if (TREE_CODE (TYPE_SIZE_UNIT (record_type)) == INTEGER_CST)
@@ -7615,6 +7689,8 @@ lower_omp_task_reductions (omp_context *ctx, enum tree_code code, tree clauses,
       g = gimple_build_call (t, 1, build_fold_addr_expr (avar));
     }
   gimple_seq_add_stmt (end, g);
+  if (lab7)
+    gimple_seq_add_stmt (end, gimple_build_label (lab7));
   t = build_constructor (atype, NULL);
   TREE_THIS_VOLATILE (t) = 1;
   gimple_seq_add_stmt (end, gimple_build_assign (avar, t));
@@ -8570,6 +8646,7 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)
   size_t looptempno = 0;
 
   child_fn = gimple_omp_task_copy_fn (task_stmt);
+  task_cpyfns.safe_push (task_stmt);
   child_cfun = DECL_STRUCT_FUNCTION (child_fn);
   gcc_assert (child_cfun->cfg == NULL);
   DECL_SAVED_TREE (child_fn) = alloc_stmt_list ();
@@ -10292,7 +10369,9 @@ lower_omp_regimplify_p (tree *tp, int *walk_subtrees,
   tree t = *tp;
 
   /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */
-  if (VAR_P (t) && data == NULL && DECL_HAS_VALUE_EXPR_P (t))
+  if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)
+      && data == NULL
+      && DECL_HAS_VALUE_EXPR_P (t))
     return t;
 
   if (task_shared_vars
@@ -10644,6 +10723,12 @@ execute_lower_omp (void)
       && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
 	  == POINTER_TYPE))
     remove_member_access_dummy_vars (DECL_INITIAL (current_function_decl));
+
+  gomp_task *task_stmt;
+  unsigned j;
+  FOR_EACH_VEC_ELT (task_cpyfns, j, task_stmt)
+    finalize_task_copyfn (task_stmt);
+  task_cpyfns.release ();
   return 0;
 }
 
diff --git a/gcc/optabs-tree.c b/gcc/optabs-tree.c
index 8157798cc71..024af299188 100644
--- a/gcc/optabs-tree.c
+++ b/gcc/optabs-tree.c
@@ -53,17 +53,32 @@ optab_for_tree_code (enum tree_code code, const_tree type,
     case MULT_HIGHPART_EXPR:
       return TYPE_UNSIGNED (type) ? umul_highpart_optab : smul_highpart_optab;
 
-    case TRUNC_MOD_EXPR:
     case CEIL_MOD_EXPR:
     case FLOOR_MOD_EXPR:
     case ROUND_MOD_EXPR:
+      /* {s,u}mod_optab implements TRUNC_MOD_EXPR.  For scalar modes,
+	 expansion has code to adjust TRUNC_MOD_EXPR into the desired other
+	 modes, but for vector modes it does not.  The adjustment code
+	 should be instead emitted in tree-vect-patterns.cc.  */
+      if (TREE_CODE (type) == VECTOR_TYPE)
+	return unknown_optab;
+      /* FALLTHRU */
+    case TRUNC_MOD_EXPR:
       return TYPE_UNSIGNED (type) ? umod_optab : smod_optab;
 
-    case RDIV_EXPR:
-    case TRUNC_DIV_EXPR:
     case CEIL_DIV_EXPR:
     case FLOOR_DIV_EXPR:
     case ROUND_DIV_EXPR:
+      /* {,u}{s,u}div_optab implements {TRUNC,EXACT}_DIV_EXPR or RDIV_EXPR.
+	 For scalar modes, expansion has code to adjust TRUNC_DIV_EXPR
+	 into the desired other modes, but for vector modes it does not.
+	 The adjustment code should be instead emitted in
+	 tree-vect-patterns.cc.  */
+      if (TREE_CODE (type) == VECTOR_TYPE)
+	return unknown_optab;
+      /* FALLTHRU */
+    case RDIV_EXPR:
+    case TRUNC_DIV_EXPR:
     case EXACT_DIV_EXPR:
       if (TYPE_SATURATING (type))
 	return TYPE_UNSIGNED (type) ? usdiv_optab : ssdiv_optab;
diff --git a/gcc/optabs.c b/gcc/optabs.c
index 0ae429cad8e..38b5aa2850e 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -3861,12 +3861,14 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,
   /* If we are optimizing, force expensive constants into a register.  */
   if (CONSTANT_P (x) && optimize
       && (rtx_cost (x, mode, COMPARE, 0, optimize_insn_for_speed_p ())
-          > COSTS_N_INSNS (1)))
+          > COSTS_N_INSNS (1))
+      && can_create_pseudo_p ())
     x = force_reg (mode, x);
 
   if (CONSTANT_P (y) && optimize
       && (rtx_cost (y, mode, COMPARE, 1, optimize_insn_for_speed_p ())
-          > COSTS_N_INSNS (1)))
+          > COSTS_N_INSNS (1))
+      && can_create_pseudo_p ())
     y = force_reg (mode, y);
 
 #if HAVE_cc0
@@ -3942,6 +3944,8 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,
      compare and branch in different basic blocks.  */
   if (cfun->can_throw_non_call_exceptions)
     {
+      if (!can_create_pseudo_p () && (may_trap_p (x) || may_trap_p (y)))
+	goto fail;
       if (may_trap_p (x))
 	x = copy_to_reg (x);
       if (may_trap_p (y))
diff --git a/gcc/sanopt.c b/gcc/sanopt.c
index 159d720bc19..64905523e08 100644
--- a/gcc/sanopt.c
+++ b/gcc/sanopt.c
@@ -488,7 +488,10 @@ maybe_optimize_ubsan_ptr_ifn (sanopt_ctx *ctx, gimple *stmt)
 				  &unsignedp, &reversep, &volatilep);
       if ((offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)
 	  && DECL_P (base)
-	  && !DECL_REGISTER (base)
+	  && ((!VAR_P (base)
+	       && TREE_CODE (base) != PARM_DECL
+	       && TREE_CODE (base) != RESULT_DECL)
+	      || !DECL_REGISTER (base))
 	  && pbitpos.is_constant (&bitpos))
 	{
 	  offset_int expr_offset;
diff --git a/gcc/shrink-wrap.c b/gcc/shrink-wrap.c
index 57124db92c6..e6c53dfbdb3 100644
--- a/gcc/shrink-wrap.c
+++ b/gcc/shrink-wrap.c
@@ -777,7 +777,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)
   unsigned max_grow_size = get_uncond_jump_length ();
   max_grow_size *= PARAM_VALUE (PARAM_MAX_GROW_COPY_BB_INSNS);
 
-  while (!vec.is_empty () && pro != entry)
+  while (pro != entry)
     {
       while (pro != entry && !can_get_prologue (pro, prologue_clobbered))
 	{
@@ -787,6 +787,9 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)
 	    vec.quick_push (pro);
 	}
 
+      if (vec.is_empty ())
+	break;
+
       basic_block bb = vec.pop ();
       if (!can_dup_for_shrink_wrapping (bb, pro, max_grow_size))
 	while (!dominated_by_p (CDI_DOMINATORS, bb, pro))
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index 125fc66b5ce..fb7ff272c97 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -2032,9 +2032,14 @@ finish_bitfield_representative (tree repr, tree field)
   bitsize = (bitsize + BITS_PER_UNIT - 1) & ~(BITS_PER_UNIT - 1);
 
   /* Now nothing tells us how to pad out bitsize ...  */
-  nextf = DECL_CHAIN (field);
-  while (nextf && TREE_CODE (nextf) != FIELD_DECL)
-    nextf = DECL_CHAIN (nextf);
+  if (TREE_CODE (DECL_CONTEXT (field)) == RECORD_TYPE)
+    {
+      nextf = DECL_CHAIN (field);
+      while (nextf && TREE_CODE (nextf) != FIELD_DECL)
+	nextf = DECL_CHAIN (nextf);
+    }
+  else
+    nextf = NULL_TREE;
   if (nextf)
     {
       tree maxsize;
@@ -2127,11 +2132,7 @@ finish_bitfield_layout (tree t)
   tree field, prev;
   tree repr = NULL_TREE;
 
-  /* Unions would be special, for the ease of type-punning optimizations
-     we could use the underlying type as hint for the representative
-     if the bitfield would fit and the representative would not exceed
-     the union in size.  */
-  if (TREE_CODE (t) != RECORD_TYPE)
+  if (TREE_CODE (t) == QUAL_UNION_TYPE)
     return;
 
   for (prev = NULL_TREE, field = TYPE_FIELDS (t);
@@ -2193,7 +2194,13 @@ finish_bitfield_layout (tree t)
       if (repr)
 	DECL_BIT_FIELD_REPRESENTATIVE (field) = repr;
 
-      prev = field;
+      if (TREE_CODE (t) == RECORD_TYPE)
+	prev = field;
+      else if (repr)
+	{
+	  finish_bitfield_representative (repr, field);
+	  repr = NULL_TREE;
+	}
     }
 
   if (repr)
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 47eac19a1f6..2507ec523d4 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,1308 @@
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101078
+	* g++.dg/template/access39.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99066
+	* g++.dg/cpp0x/extern_template-6.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100838
+	PR c++/105265
+	* g++.dg/init/no-elide2.C: New test.
+	* g++.dg/cpp0x/initlist-new6.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91217
+	* g++.dg/opt/nrv20.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99643
+	* g++.dg/cpp0x/initlist-new5.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* g++.target/i386/vec-tmpl1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* g++.dg/template/conv19.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* g++.dg/cpp0x/initlist-nrv1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/98249
+	* g++.dg/lookup/new3.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* g++.dg/cpp0x/constexpr-fno-elide-ctors1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/59950
+	* g++.dg/init/assign2.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/99901
+	* g++.dg/cpp1z/inline-var9.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101717
+	* g++.dg/cpp1y/lambda-generic-this4.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90664
+	* g++.dg/cpp1z/noexcept-type24.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95870
+	* g++.dg/cpp0x/lambda/lambda-nsdmi10.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96311
+	* g++.dg/cpp1y/lambda-generic-Wunused.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/96673
+	* g++.dg/cpp1y/nsdmi-aggr13.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91933
+	* g++.dg/cpp0x/constexpr-base7.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/100032
+	* g++.dg/cpp0x/alias-decl-equiv1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/cpp0x/constexpr-array23.C: Remove xfail.
+	* g++.dg/cpp2a/lambda-pack-init6.C: Removed.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/102860
+	PR testsuite/105570
+	* gfortran.dg/pr102860.f90: Use -mcpu=power9 instead of -mcpu=power10.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/103455
+	* g++.dg/overload/builtin6.C: New test.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-01-25  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/101532
+	PR c++/104225
+	* g++.dg/cpp0x/nsdmi-template21.C: New test.
+	* g++.dg/cpp0x/nsdmi-template21a.C: New test.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-04-14  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/83476
+	PR c++/99885
+	* g++.dg/cpp1z/class-deduction85.C: New test.
+	* g++.dg/template/ref11.C: New test.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR testsuite/100422
+	* g++.dg/gomp/clause-3.C: Use 'reduction(&:..)' instead of '...(&&:..)'.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* gcc.dg/asan/pr105396.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* gcc.dg/pr105257.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105256
+	* g++.dg/cpp0x/pr105256.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105214
+	* gcc.dg/asan/pr105214.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105211
+	* gcc.dg/pr105211.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105186
+	* c-c++-common/pr105186.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105189
+	* g++.dg/torture/pr105189.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105123
+	* gcc.target/i386/pr105123.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105093
+	* g++.dg/ubsan/pr105093.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-c++-common/builtin-convertvector-3.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104994
+	* g++.dg/cpp2a/constexpr-nonlit7.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/104971
+	* gcc.target/i386/pr104971.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104711
+	* c-c++-common/Wshift-negative-value-1.c: Remove
+	dg-additional-options, instead in target selectors of each diagnostic
+	check for exact C++ versions where it should be diagnosed.
+	* c-c++-common/Wshift-negative-value-2.c: Likewise.
+	* c-c++-common/Wshift-negative-value-3.c: Likewise.
+	* c-c++-common/Wshift-negative-value-4.c: Likewise.
+	* c-c++-common/Wshift-negative-value-7.c: New test.
+	* c-c++-common/Wshift-negative-value-8.c: New test.
+	* c-c++-common/Wshift-negative-value-9.c: New test.
+	* c-c++-common/Wshift-negative-value-10.c: New test.
+	* c-c++-common/Wshift-overflow-1.c: Remove
+	dg-additional-options, instead in target selectors of each diagnostic
+	check for exact C++ versions where it should be diagnosed.
+	* c-c++-common/Wshift-overflow-2.c: Likewise.
+	* c-c++-common/Wshift-overflow-5.c: Likewise.
+	* c-c++-common/Wshift-overflow-6.c: Likewise.
+	* c-c++-common/Wshift-overflow-7.c: Likewise.
+	* c-c++-common/Wshift-overflow-8.c: New test.
+	* c-c++-common/Wshift-overflow-9.c: New test.
+	* c-c++-common/Wshift-overflow-10.c: New test.
+	* c-c++-common/Wshift-overflow-11.c: New test.
+	* c-c++-common/Wshift-overflow-12.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104806
+	* g++.dg/spellcheck-pr104806.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104775
+	* gcc.target/s390/pr104775.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+		    Marc Glisse  <marc.glisse@inria.fr>
+
+	PR tree-optimization/104675
+	* gcc.dg/pr104675-3.c : New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104681
+	* g++.dg/opt/pr104681.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/104675
+	* gcc.dg/pr104675-1.c: New test.
+	* gcc.dg/pr104675-2.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/104557
+	* gcc.dg/dfp/pr104557.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/104510
+	* gcc.dg/dfp/pr104510.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104513
+	* g++.dg/cpp1y/constexpr-104513.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/104449
+	* gcc.dg/asan/pr104449.c: New test.
+	* g++.dg/asan/pr104449.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104502
+	* gcc.target/i386/pr104502.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/104472
+	* g++.dg/cpp0x/constexpr-104472.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/104446
+	* gcc.target/i386/pr104446.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102140
+	* gcc.dg/pr102140.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/104147
+	* c-c++-common/cpp/pr104147.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/102478
+	* gcc.dg/pr102478.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/102860
+	* gfortran.dg/pr102860.f90: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103908
+	* gcc.target/i386/pr103908.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/89971
+	* c-c++-common/cpp/va-opt-9.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103860
+	* gcc.dg/pr103860.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/103837
+	* gcc.dg/pr103837.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/70796
+	* g++.dg/cpp1z/eval-order11.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/103205
+	* gcc.target/i386/pr103205.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-11-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101378
+	* g++.dg/debug/dwarf2/pr101378.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64888
+	* c-c++-common/ubsan/pr64888.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102786
+	* g++.dg/cpp2a/constexpr-virtual19.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102548
+	* g++.target/i386/pr102548.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR sanitizer/102515
+	* c-c++-common/ubsan/float-div-by-zero-2.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102498
+	* gcc.target/i386/pr102498.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88578
+	PR c++/102295
+	* g++.dg/ext/flexary39.C: New test.
+	* g++.dg/ext/flexary40.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102295
+	* g++.target/i386/pr102295.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/102305
+	* g++.dg/cpp0x/pr102305.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-09-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/102224
+	* gcc.dg/pr102224.c: New test.
+	* gcc.target/i386/avx-pr102224.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-08-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101905
+	* gcc.dg/guality/pr101905.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101624
+	* gfortran.dg/ubsan/ubsan.exp: New file.
+	* gfortran.dg/ubsan/pr101624.f90: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/101562
+	* gcc.c-torture/compile/pr101562.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101535
+	* c-c++-common/gomp/pr101535-1.c: New test.
+	* c-c++-common/gomp/pr101535-2.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101516
+	* g++.dg/gomp/pr101516.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/101384
+	* gcc.dg/pr101384.c: New test.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* gcc.dg/gomp/clause-1.c: Use 'reduction(&:..)' instead of '...(&&:..)'.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101443
+	* g++.dg/cpp0x/nullptr46.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/101266
+	* gcc.dg/pr101266.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/101210
+	* g++.dg/ubsan/pr101210.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/101171
+	* gcc.dg/pr101171.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/100785
+	* c-c++-common/pr100785.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101062
+	* gcc.dg/pr101062.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/guality/pr49888.c (f): Use noipa attribute instead of
+	noinline, noclone.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100898
+	* g++.dg/ext/va-arg-pack-3.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/100666
+	* g++.dg/cpp1z/nodiscard8.C: New test.
+	* g++.dg/cpp1z/nodiscard9.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp1y/pr88872.C: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100508
+	* gcc.dg/gomp/pr100508.c: New test.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20220510-1.c: New test.
+
+2022-05-09  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-24  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/104228
+	PR fortran/104570
+	* gfortran.dg/asan_associate_58.f90: New test.
+	* gfortran.dg/asan_associate_59.f90: New test.
+	* gfortran.dg/associate_58.f90: New test.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-03-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104786
+	* gcc.dg/pr104786.c: New testcase.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103361
+	* g++.dg/torture/pr103361.C: New testcase.
+
+2022-05-06  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-01-20  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100786
+	* gcc.dg/torture/pr100786.c: New testcase.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* gcc.target/i386/sse-14.c: Add tests for new macro.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* gfortran.dg/dec_union_12.f90: New test.
+
+2022-04-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/99977
+	* gcc.target/arm/pr99977.c: New test.
+
+2022-03-30  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2020-10-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/97456
+	* gcc.dg/tree-ssa/pr97456.c: New test.
+
+2022-03-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR target/104453
+	* gcc.target/i386/pr104453.c: New testcase.
+
+2022-02-18  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96522
+	* gcc.dg/torture/pr96522.c: New testcase.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/102798
+	* gcc.dg/pr102798.c: New testcase.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/103181
+	PR middle-end/103248
+	* gcc.dg/torture/pr103181.c: New testcase.
+	* gcc.dg/pr103248.c: Likewise.
+
+2022-02-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103237
+	* gcc.dg/torture/pr103237.c: New testcase.
+
+2022-02-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-02-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/104469
+	* gcc.target/i386/pr104469.c: New test.
+
+2022-02-09  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/104451
+	* gcc.target/i386/pr104451.c: New test.
+
+2022-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-02-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104311
+	* gfortran.dg/transfer_simplify_15.f90: New test.
+
+2022-01-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104127
+	* gfortran.dg/transfer_simplify_11.f90: Fix logic.
+	* gfortran.dg/transfer_simplify_13.f90: New test.
+
+2022-01-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-25  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104227
+	* gfortran.dg/transfer_check_6.f90: New test.
+
+2022-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-01-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103782
+	* gfortran.dg/overload_4.f90: New test.
+
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gcc.dg/pr97953.c: New testcase.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* gfortran.dg/intrinsic_pack_6.f90: New test.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* gfortran.dg/pr103588.f90: New test.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* gfortran.dg/shape_11.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* gfortran.dg/pr103606.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* gfortran.dg/do_check_19.f90: New test.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* gcc.target/powerpc/pr102347.c: New test.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* gfortran.dg/pr103607.f90: New test.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* gfortran.dg/bound_simplification_7.f90: New test.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* gcc.c-torture/execute/pr103052.c: New test.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* gcc.target/powerpc/pr101985-1.c: New.
+	* gcc.target/powerpc/pr101985-2.c: New.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/20211119.c: New test.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* gcc.dg/torture/pr100672.c: New testcase.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* gcc.dg/lto/pr101868_0.c: New testcase.
+	* gcc.dg/lto/pr101868_1.c: Likewise.
+	* gcc.dg/lto/pr101868_2.c: Likewise.
+	* gcc.dg/lto/pr101868_3.c: Likewise.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* gcc.dg/tree-ssa/pr101824.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gcc.dg/torture/pr101173.c: New testcase.
+	* gcc.dg/tree-ssa/loop-interchange-16.c: New file.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* gcc.dg/torture/pr101394.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* gcc.dg/torture/pr101105.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* gcc.dg/torture/pr100934.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gcc.dg/pr100509.c: New testcase.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* gcc.c-torture/execute/bitfld-10.c: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* gfortran.dg/pr101327.f90: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* gfortran.dg/bounds_check_23.f90: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* gfortran.dg/pr82314.f90: New test.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* gfortran.dg/substr_6.f90: Revert commit r8-7574, adding again
+	test that was erroneously considered as illegal.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* gfortran.dg/intent_out_14.f90: New test.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20210917-1.c: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* gfortran.dg/structure_constructor_17.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* gfortran.dg/associated_target_7.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* gfortran.dg/associate_54.f90: New test.
+	* gfortran.dg/associate_55.f90: New test.
+	* gfortran.dg/associate_56.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* gfortran.dg/elemental_function_5.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* gfortran.dg/pdt_31.f03: New test.
+	* gfortran.dg/pdt_26.f03: Reduce 'builtin_malloc' count from 9
+	to 8.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* gfortran.dg/class_dummy_6.f90: New test.
+	* gfortran.dg/class_dummy_7.f90: New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* gfortran.dg/alloc_deferred_comp_1.f90: New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* gfortran.dg/proc_ptr_52.f90 : New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* gfortran.dg/deferred_character_35.f90 : New test.
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* gcc.target/i386/avx512f-pr101471.c: New test.
+
+2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	Backported from master:
+	2021-08-06  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	PR target/101723
+	* gcc.target/arm/pr69245.c: Make sure to emit code for fn1, fix
+	typo.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* gcc.target/arm/attr-neon.c: Tighten scan-assembler tests.
+	* gcc.target/arm/attr-neon2.c: Likewise.
+	* gcc.target/arm/attr-neon3.c: Likewise.
+	* gcc.target/arm/pr69245.c: Tighten scan-assembler match, but allow
+	multiple instances.
+	* gcc.target/arm/pragma_fpu_attribute.c: Likewise.
+	* gcc.target/arm/pragma_fpu_attribute_2.c: Likewise.
+
+2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/101969
+	* gcc.dg/pr78213.c: Fix up for '--enable-checking=release' etc.
+
+2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* gcc.dg/pr78213.c: Restore testing.
+
+2021-07-29  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101531
+	* gcc.target/powerpc/pr101129.c: Adjust.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* gdc.dg/pr96435.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* gdc.dg/pr101640.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* gdc.dg/pr101490.d: New test.
+	* gdc.test/fail_compilation/fail22144.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* gdc.test/compilable/b19002.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* gdc.dg/pr101127a.d: New test.
+	* gdc.dg/pr101127b.d: New test.
+
+2021-07-20  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* gcc.target/i386/pr71245-1.c: Remove.
+	* gcc.target/i386/pr71245-2.c: Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* gcc.target/powerpc/pr101129.c: New.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* gfortran.dg/pr100949.f90: New test.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* gfortran.dg/implied_do_io_7.f90: New test.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* gcc.target/i386/pr101175.c: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* gdc.dg/pr100967.d: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* gdc.test/fail_compilation/extra-files/minimal/object.d: New file.
+	* gdc.test/fail_compilation/fail19911a.d: New test.
+	* gdc.test/fail_compilation/fail19911b.d: New test.
+	* gdc.test/fail_compilation/fail19911c.d: New test.
+	* gdc.test/fail_compilation/fail19922.d: New test.
+	* gdc.test/fail_compilation/fail19923.d: New test.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* gdc.test/compilable/betterCarray.d: Add test cases.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* gdc.test/compilable/aggr_alignment.d: Add test cases.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* gdc.dg/pr100882a.d: New test.
+	* gdc.dg/pr100882b.d: New test.
+	* gdc.dg/pr100882c.d: New test.
+	* gdc.dg/pr100882d.d: New test.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* gfortran.dg/inline_matmul_25.f90: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-1.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-1.c
index 7df1804615d..b643fcf898e 100644
--- a/gcc/testsuite/c-c++-common/Wshift-negative-value-1.c
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-1.c
@@ -1,13 +1,12 @@
 /* PR c/65179 */
 /* { dg-do compile } */
 /* { dg-options "-O -Wextra" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 enum E {
   A = 0 << 1,
   B = 1 << 1,
-  C = -1 << 1, /* { dg-warning "left shift of negative value|not an integer constant" } */
-  /* { dg-error "left operand of shift expression" "shift" { target c++ } .-1 } */
+  C = -1 << 1, /* { dg-warning "left shift of negative value|not an integer constant" "" { target { c || { c++11 && c++17_down } } } } */
+  /* { dg-error "left operand of shift expression" "shift" { target { c++11 && c++17_down } } .-1 } */
   D = 0 >> 1,
   E = 1 >> 1,
   F = -1 >> 1
@@ -23,10 +22,10 @@ left (int x)
   int r = 0;
   r += z << x;
   r += o << x;
-  r += m << x; /* { dg-warning "left shift of negative value" } */
+  r += m << x; /* { dg-warning "left shift of negative value" "" { target { c || { c++11 && c++17_down } } } } */
   r += 0 << x;
   r += 1 << x;
-  r += -1 << x; /* { dg-warning "left shift of negative value" } */
+  r += -1 << x; /* { dg-warning "left shift of negative value" "" { target { c || { c++11 && c++17_down } } } } */
   r += -1U << x;
   return r;
 }
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-10.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-10.c
new file mode 100644
index 00000000000..eee414de32b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-10.c
@@ -0,0 +1,7 @@
+/* PR c/65179 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wshift-negative-value -fwrapv" } */
+/* { dg-additional-options "-std=c++03" { target c++ } } */
+/* { dg-additional-options "-std=c90" { target c } } */
+
+#include "Wshift-negative-value-1.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-2.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-2.c
index 3a60ed7e1b8..a104a51744b 100644
--- a/gcc/testsuite/c-c++-common/Wshift-negative-value-2.c
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-2.c
@@ -1,14 +1,13 @@
 /* PR c/65179 */
 /* { dg-do compile } */
 /* { dg-options "-O -Wshift-negative-value" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 enum E {
   A = 0 << 1,
   B = 1 << 1,
   C = -1 << 1, /* { dg-warning "left shift of negative value" } */
-  /* { dg-error "not an integer constant" "no constant" { target c++ } .-1 } */
-  /* { dg-error "left operand of shift expression" "shift" { target c++ } .-2 } */
+  /* { dg-error "not an integer constant" "no constant" { target { c++11 && c++17_down } } .-1 } */
+  /* { dg-error "left operand of shift expression" "shift" { target { c++11 && c++17_down } } .-2 } */
   D = 0 >> 1,
   E = 1 >> 1,
   F = -1 >> 1
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-3.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-3.c
index 503ca61eb61..402db9db9c9 100644
--- a/gcc/testsuite/c-c++-common/Wshift-negative-value-3.c
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-3.c
@@ -1,14 +1,13 @@
 /* PR c/65179 */
 /* { dg-do compile } */
 /* { dg-options "-O -Wextra -Wno-shift-negative-value" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 enum E {
   A = 0 << 1,
   B = 1 << 1,
   C = -1 << 1,
-  /* { dg-error "not an integer constant" "no constant" { target c++ } .-1 } */
-  /* { dg-error "left operand of shift expression" "shift" { target c++ } .-2 } */
+  /* { dg-error "not an integer constant" "no constant" { target { c++11 && c++17_down } } .-1 } */
+  /* { dg-error "left operand of shift expression" "shift" { target { c++11 && c++17_down } } .-2 } */
   D = 0 >> 1,
   E = 1 >> 1,
   F = -1 >> 1
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-4.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-4.c
index fa7cb4e7f51..a47213d8109 100644
--- a/gcc/testsuite/c-c++-common/Wshift-negative-value-4.c
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-4.c
@@ -1,14 +1,13 @@
 /* PR c/65179 */
 /* { dg-do compile } */
 /* { dg-options "-O" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 enum E {
   A = 0 << 1,
   B = 1 << 1,
   C = -1 << 1,
-  /* { dg-error "not an integer constant" "no constant" { target c++ } .-1 } */
-  /* { dg-error "left operand of shift expression" "shift" { target c++ } .-2 } */
+  /* { dg-error "not an integer constant" "no constant" { target { c++11 && c++17_down } } .-1 } */
+  /* { dg-error "left operand of shift expression" "shift" { target { c++11 && c++17_down } } .-2 } */
   D = 0 >> 1,
   E = 1 >> 1,
   F = -1 >> 1
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-7.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-7.c
new file mode 100644
index 00000000000..f58b0f11d0d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-7.c
@@ -0,0 +1,5 @@
+/* PR c/65179 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wextra -fwrapv" } */
+
+#include "Wshift-negative-value-1.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-8.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-8.c
new file mode 100644
index 00000000000..d1e5fe7a2f2
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-8.c
@@ -0,0 +1,5 @@
+/* PR c/65179 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wshift-negative-value -fwrapv" } */
+
+#include "Wshift-negative-value-1.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-negative-value-9.c b/gcc/testsuite/c-c++-common/Wshift-negative-value-9.c
new file mode 100644
index 00000000000..3243010be72
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-negative-value-9.c
@@ -0,0 +1,5 @@
+/* PR c/65179 */
+/* { dg-do compile } */
+/* { dg-options "-O -fwrapv" } */
+
+#include "Wshift-negative-value-1.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-1.c b/gcc/testsuite/c-c++-common/Wshift-overflow-1.c
index a69f2b83464..be5535f7c23 100644
--- a/gcc/testsuite/c-c++-common/Wshift-overflow-1.c
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-1.c
@@ -1,7 +1,6 @@
 /* PR c++/55095 */
 /* { dg-do compile { target int32 } } */
 /* { dg-options "-O" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 #define INTM1 (sizeof (int) * __CHAR_BIT__ - 1)
 #define INTM2 (sizeof (int) * __CHAR_BIT__ - 2)
@@ -12,16 +11,16 @@
 #define LONG_LONG_MIN (-__LONG_LONG_MAX__-1)
 
 int i1 = 1 << INTM1;
-int i2 = 9 << INTM1; /* { dg-warning "requires 36 bits to represent" } */
-int i3 = 10 << INTM2; /* { dg-warning "requires 35 bits to represent" } */
-int i4 = __INT_MAX__ << 2; /* { dg-warning "requires 34 bits to represent" } */
-int i5 = __INT_MAX__ << INTM1; /* { dg-warning "requires 63 bits to represent" } */
+int i2 = 9 << INTM1; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i3 = 10 << INTM2; /* { dg-warning "requires 35 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i4 = __INT_MAX__ << 2; /* { dg-warning "requires 34 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i5 = __INT_MAX__ << INTM1; /* { dg-warning "requires 63 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 int i6 = -1 << INTM1;
-int i7 = -9 << INTM1; /* { dg-warning "requires 36 bits to represent" } */
-int i8 = -10 << INTM2; /* { dg-warning "requires 35 bits to represent" } */
-int i9 = -__INT_MAX__ << 2; /* { dg-warning "requires 34 bits to represent" } */
-int i10 = -__INT_MAX__ << INTM1; /* { dg-warning "requires 63 bits to represent" } */
-int i11 = INT_MIN << 1; /* { dg-warning "requires 33 bits to represent" } */
+int i7 = -9 << INTM1; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i8 = -10 << INTM2; /* { dg-warning "requires 35 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i9 = -__INT_MAX__ << 2; /* { dg-warning "requires 34 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i10 = -__INT_MAX__ << INTM1; /* { dg-warning "requires 63 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+int i11 = INT_MIN << 1; /* { dg-warning "requires 33 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 
 int r1 = 1 >> INTM1;
 int r2 = 9 >> INTM1;
@@ -35,29 +34,29 @@ int r9 = -__INT_MAX__ >> 2;
 int r10 = -__INT_MAX__ >> INTM1;
 
 unsigned u1 = 1 << INTM1;
-unsigned u2 = 9 << INTM1; /* { dg-warning "requires 36 bits to represent" } */
+unsigned u2 = 9 << INTM1; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 unsigned u3 = 2U << INTM1;
 unsigned u4 = 9U << INTM1;
 unsigned u5 = 10U << INTM2;
 
 long long int l1 = 1LL << LLONGM1;
-long long int l2 = 9LL << LLONGM1; /* { dg-warning "requires 68 bits to represent" } */
-long long int l3 = 10LL << LLONGM2; /* { dg-warning "requires 67 bits to represent" } */
-long long int l4 = __LONG_LONG_MAX__ << 2; /* { dg-warning "requires 66 bits to represent" } */
-long long int l5 = __LONG_LONG_MAX__ << LLONGM1; /* { dg-warning "requires 127 bits to represent" } */
+long long int l2 = 9LL << LLONGM1; /* { dg-warning "requires 68 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l3 = 10LL << LLONGM2; /* { dg-warning "requires 67 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l4 = __LONG_LONG_MAX__ << 2; /* { dg-warning "requires 66 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l5 = __LONG_LONG_MAX__ << LLONGM1; /* { dg-warning "requires 127 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 long long int l6 = -1LL << LLONGM1;
-long long int l7 = -9LL << LLONGM1; /* { dg-warning "requires 68 bits to represent" } */
-long long int l8 = -10LL << LLONGM2; /* { dg-warning "requires 67 bits to represent" } */
-long long int l9 = -__LONG_LONG_MAX__ << 2; /* { dg-warning "requires 66 bits to represent" } */
-long long int l10 = -__LONG_LONG_MAX__ << LLONGM1; /* { dg-warning "requires 127 bits to represent" } */
-long long int l11 = LONG_LONG_MIN << 1; /* { dg-warning "requires 65 bits to represent" } */
+long long int l7 = -9LL << LLONGM1; /* { dg-warning "requires 68 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l8 = -10LL << LLONGM2; /* { dg-warning "requires 67 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l9 = -__LONG_LONG_MAX__ << 2; /* { dg-warning "requires 66 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l10 = -__LONG_LONG_MAX__ << LLONGM1; /* { dg-warning "requires 127 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+long long int l11 = LONG_LONG_MIN << 1; /* { dg-warning "requires 65 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 
 void
 fn (void)
 {
   const int a = 10;
   const __SIZE_TYPE__ b = INTM1;
-  int k1 = a << b; /* { dg-warning "requires 36 bits to represent" } */
-  int k2 = 10 << b; /* { dg-warning "requires 36 bits to represent" } */
-  int k3 = a << INTM1; /* { dg-warning "requires 36 bits to represent" } */
+  int k1 = a << b; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+  int k2 = 10 << b; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
+  int k3 = a << INTM1; /* { dg-warning "requires 36 bits to represent" "" { target { c || { c++11 && c++17_down } } } } */
 }
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-10.c b/gcc/testsuite/c-c++-common/Wshift-overflow-10.c
new file mode 100644
index 00000000000..3efd3912d11
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-10.c
@@ -0,0 +1,5 @@
+/* PR c++/55095 */
+/* { dg-do compile { target int32 } } */
+/* { dg-options "-O -Wshift-overflow=2 -fwrapv" } */
+
+#include "Wshift-overflow-5.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-11.c b/gcc/testsuite/c-c++-common/Wshift-overflow-11.c
new file mode 100644
index 00000000000..9063d80d7e0
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-11.c
@@ -0,0 +1,5 @@
+/* PR c++/55095 */
+/* { dg-do compile { target int32 } } */
+/* { dg-options "-Wshift-overflow=1 -fwrapv" } */
+
+#include "Wshift-overflow-6.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-12.c b/gcc/testsuite/c-c++-common/Wshift-overflow-12.c
new file mode 100644
index 00000000000..5c1c42e3712
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-12.c
@@ -0,0 +1,5 @@
+/* PR c++/55095 */
+/* { dg-do compile { target int32 } } */
+/* { dg-options "-Wshift-overflow=2 -fwrapv" } */
+
+#include "Wshift-overflow-7.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-2.c b/gcc/testsuite/c-c++-common/Wshift-overflow-2.c
index 30fd2552df3..3fc05dc4f80 100644
--- a/gcc/testsuite/c-c++-common/Wshift-overflow-2.c
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-2.c
@@ -1,7 +1,6 @@
 /* PR c++/55095 */
 /* { dg-do compile { target int32 } } */
 /* { dg-options "-O -Wno-shift-overflow" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 #define INTM1 (sizeof (int) * __CHAR_BIT__ - 1)
 #define INTM2 (sizeof (int) * __CHAR_BIT__ - 2)
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-5.c b/gcc/testsuite/c-c++-common/Wshift-overflow-5.c
index c9f464355dc..36d617ee254 100644
--- a/gcc/testsuite/c-c++-common/Wshift-overflow-5.c
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-5.c
@@ -1,11 +1,10 @@
 /* PR c++/55095 */
 /* { dg-do compile { target int32 } } */
 /* { dg-options "-O -Wshift-overflow=2" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 #define INTM1 (sizeof (int) * __CHAR_BIT__ - 1)
 #define LLONGM1 (sizeof (long long) * __CHAR_BIT__ - 1)
 
-int i1 = 1 << INTM1; /* { dg-warning "requires 33 bits to represent" } */
-unsigned u1 = 1 << INTM1; /* { dg-warning "requires 33 bits to represent" } */
-long long int l1 = 1LL << LLONGM1; /* { dg-warning "requires 65 bits to represent" } */
+int i1 = 1 << INTM1; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+unsigned u1 = 1 << INTM1; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+long long int l1 = 1LL << LLONGM1; /* { dg-warning "requires 65 bits to represent" "" { target { c || c++11_down } } } */
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-6.c b/gcc/testsuite/c-c++-common/Wshift-overflow-6.c
index 64797f44a13..c5141185737 100644
--- a/gcc/testsuite/c-c++-common/Wshift-overflow-6.c
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-6.c
@@ -1,7 +1,6 @@
 /* PR c++/55095 */
 /* { dg-do compile { target int32 } } */
 /* { dg-options "-Wshift-overflow=1" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
 int i00 = 0b1 << 31;
 int i01 = 0b10 << 30;
@@ -34,4 +33,4 @@ int i27 = 0b1000000000000000000000000000 << 4;
 int i28 = 0b10000000000000000000000000000 << 3;
 int i29 = 0b100000000000000000000000000000 << 2;
 int i30 = 0b1000000000000000000000000000000 << 1;
-int i31 = (int) 0b10000000000000000000000000000000u << 1; /* { dg-warning "requires 33 bits to represent" } */
+int i31 = (int) 0b10000000000000000000000000000000u << 1; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++17_down } } } */
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-7.c b/gcc/testsuite/c-c++-common/Wshift-overflow-7.c
index ca99d2e46fe..2779a15c630 100644
--- a/gcc/testsuite/c-c++-common/Wshift-overflow-7.c
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-7.c
@@ -1,37 +1,36 @@
 /* PR c++/55095 */
 /* { dg-do compile { target int32 } } */
 /* { dg-options "-Wshift-overflow=2" } */
-/* { dg-additional-options "-std=c++11" { target c++ } } */
 
-int i00 = 0b1 << 31; /* { dg-warning "requires 33 bits to represent" } */
-int i01 = 0b10 << 30; /* { dg-warning "requires 33 bits to represent" } */
-int i02 = 0b100 << 29; /* { dg-warning "requires 33 bits to represent" } */
-int i03 = 0b1000 << 28; /* { dg-warning "requires 33 bits to represent" } */
-int i04 = 0b10000 << 27; /* { dg-warning "requires 33 bits to represent" } */
-int i05 = 0b100000 << 26; /* { dg-warning "requires 33 bits to represent" } */
-int i06 = 0b1000000 << 25; /* { dg-warning "requires 33 bits to represent" } */
-int i07 = 0b10000000 << 24; /* { dg-warning "requires 33 bits to represent" } */
-int i08 = 0b100000000 << 23; /* { dg-warning "requires 33 bits to represent" } */
-int i09 = 0b1000000000 << 22; /* { dg-warning "requires 33 bits to represent" } */
-int i10 = 0b10000000000 << 21; /* { dg-warning "requires 33 bits to represent" } */
-int i11 = 0b100000000000 << 20; /* { dg-warning "requires 33 bits to represent" } */
-int i12 = 0b1000000000000 << 19; /* { dg-warning "requires 33 bits to represent" } */
-int i13 = 0b10000000000000 << 18; /* { dg-warning "requires 33 bits to represent" } */
-int i14 = 0b100000000000000 << 17; /* { dg-warning "requires 33 bits to represent" } */
-int i15 = 0b1000000000000000 << 16; /* { dg-warning "requires 33 bits to represent" } */
-int i16 = 0b10000000000000000 << 15; /* { dg-warning "requires 33 bits to represent" } */
-int i17 = 0b100000000000000000 << 14; /* { dg-warning "requires 33 bits to represent" } */
-int i18 = 0b1000000000000000000 << 13; /* { dg-warning "requires 33 bits to represent" } */
-int i19 = 0b10000000000000000000 << 12; /* { dg-warning "requires 33 bits to represent" } */
-int i20 = 0b100000000000000000000 << 11; /* { dg-warning "requires 33 bits to represent" } */
-int i21 = 0b1000000000000000000000 << 10; /* { dg-warning "requires 33 bits to represent" } */
-int i22 = 0b10000000000000000000000 << 9; /* { dg-warning "requires 33 bits to represent" } */
-int i23 = 0b100000000000000000000000 << 8; /* { dg-warning "requires 33 bits to represent" } */
-int i24 = 0b1000000000000000000000000 << 7; /* { dg-warning "requires 33 bits to represent" } */
-int i25 = 0b10000000000000000000000000 << 6; /* { dg-warning "requires 33 bits to represent" } */
-int i26 = 0b100000000000000000000000000 << 5; /* { dg-warning "requires 33 bits to represent" } */
-int i27 = 0b1000000000000000000000000000 << 4; /* { dg-warning "requires 33 bits to represent" } */
-int i28 = 0b10000000000000000000000000000 << 3; /* { dg-warning "requires 33 bits to represent" } */
-int i29 = 0b100000000000000000000000000000 << 2; /* { dg-warning "requires 33 bits to represent" } */
-int i30 = 0b1000000000000000000000000000000 << 1; /* { dg-warning "requires 33 bits to represent" } */
-int i31 = (int) 0b10000000000000000000000000000000u << 1; /* { dg-warning "requires 33 bits to represent" } */
+int i00 = 0b1 << 31; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i01 = 0b10 << 30; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i02 = 0b100 << 29; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i03 = 0b1000 << 28; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i04 = 0b10000 << 27; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i05 = 0b100000 << 26; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i06 = 0b1000000 << 25; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i07 = 0b10000000 << 24; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i08 = 0b100000000 << 23; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i09 = 0b1000000000 << 22; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i10 = 0b10000000000 << 21; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i11 = 0b100000000000 << 20; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i12 = 0b1000000000000 << 19; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i13 = 0b10000000000000 << 18; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i14 = 0b100000000000000 << 17; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i15 = 0b1000000000000000 << 16; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i16 = 0b10000000000000000 << 15; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i17 = 0b100000000000000000 << 14; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i18 = 0b1000000000000000000 << 13; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i19 = 0b10000000000000000000 << 12; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i20 = 0b100000000000000000000 << 11; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i21 = 0b1000000000000000000000 << 10; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i22 = 0b10000000000000000000000 << 9; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i23 = 0b100000000000000000000000 << 8; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i24 = 0b1000000000000000000000000 << 7; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i25 = 0b10000000000000000000000000 << 6; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i26 = 0b100000000000000000000000000 << 5; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i27 = 0b1000000000000000000000000000 << 4; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i28 = 0b10000000000000000000000000000 << 3; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i29 = 0b100000000000000000000000000000 << 2; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i30 = 0b1000000000000000000000000000000 << 1; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++11_down } } } */
+int i31 = (int) 0b10000000000000000000000000000000u << 1; /* { dg-warning "requires 33 bits to represent" "" { target { c || c++17_down } } } */
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-8.c b/gcc/testsuite/c-c++-common/Wshift-overflow-8.c
new file mode 100644
index 00000000000..1de228a0763
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-8.c
@@ -0,0 +1,5 @@
+/* PR c++/55095 */
+/* { dg-do compile { target int32 } } */
+/* { dg-options "-O -fwrapv" } */
+
+#include "Wshift-overflow-1.c"
diff --git a/gcc/testsuite/c-c++-common/Wshift-overflow-9.c b/gcc/testsuite/c-c++-common/Wshift-overflow-9.c
new file mode 100644
index 00000000000..7d84bada3b6
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wshift-overflow-9.c
@@ -0,0 +1,7 @@
+/* PR c++/55095 */
+/* { dg-do compile { target int32 } } */
+/* { dg-options "-O -Wshift-overflow -fwrapv" } */
+/* { dg-additional-options "-std=gnu90" { target c } } */
+/* { dg-additional-options "-std=c++03" { target c++ } } */
+
+#include "Wshift-overflow-1.c"
diff --git a/gcc/testsuite/c-c++-common/builtin-convertvector-3.c b/gcc/testsuite/c-c++-common/builtin-convertvector-3.c
new file mode 100644
index 00000000000..882cd551ef8
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/builtin-convertvector-3.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef int v4si __attribute__((vector_size (4 * sizeof (int))));
+typedef double v4df __attribute__((vector_size (4 * sizeof (double))));
+double
+foo (void)
+{
+  v4si a = { 1, 2, 3, 4 };
+  return __builtin_convertvector (a, v4df)[1];
+}
diff --git a/gcc/testsuite/c-c++-common/cpp/pr104147.c b/gcc/testsuite/c-c++-common/cpp/pr104147.c
new file mode 100644
index 00000000000..4ee237ed6ba
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr104147.c
@@ -0,0 +1,27 @@
+/* PR preprocessor/104147 */
+/* { dg-do run } */
+
+#define X(x,y) 	x y
+#define STR_(x) #x
+#define STR(x) 	STR_(x)
+const char *str =
+STR(X(Y,Y))
+#define Y()
+STR(X(Y,Y))
+#undef Y
+STR(X(Y,Y))
+#define Y()
+STR(X(Y,Y))
+STR(X(Y,
+Y))
+STR(X(Y
+,Y))
+;
+
+int
+main ()
+{
+  if (__builtin_strcmp (str, "Y YY YY YY YY YY Y") != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/c-c++-common/cpp/va-opt-9.c b/gcc/testsuite/c-c++-common/cpp/va-opt-9.c
new file mode 100644
index 00000000000..3f1d42b352f
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/va-opt-9.c
@@ -0,0 +1,20 @@
+/* PR preprocessor/89971 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" { target c } } */
+/* { dg-options "-std=c++2a" { target c++ } } */
+
+int a, c;
+#define m1(...) a /##__VA_OPT__(b) c
+#define m2(...) a /##__VA_OPT__() c
+#define m3(...) a##__VA_OPT__()##b = 1
+#define m4(...) a##__VA_OPT__(b c d)##e = 2
+
+int
+foo (void)
+{
+  int d = m1();
+  int e = m2(1);
+  int m3(1 2 3);
+  int m4();
+  return d + e + ab + ae;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr101535-1.c b/gcc/testsuite/c-c++-common/gomp/pr101535-1.c
new file mode 100644
index 00000000000..8285ce011df
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr101535-1.c
@@ -0,0 +1,31 @@
+/* PR middle-end/101535 */
+
+void
+foo (void)
+{
+  int a = 1, i;
+  #pragma omp target data map(to:a)
+  #pragma omp for lastprivate(i)	/* { dg-error "lastprivate variable 'i' is private in outer context" } */
+  for (i = 1; i < 2; i++)
+    ;
+}
+
+void
+bar (void)
+{
+  int a = 1, i;
+  #pragma omp target private(i)
+  #pragma omp for lastprivate(i)	/* { dg-error "lastprivate variable 'i' is private in outer context" } */
+  for (i = 1; i < 2; i++)
+    ;
+}
+
+void
+baz (void)
+{
+  int a = 1, i;
+  #pragma omp target firstprivate(i)
+  #pragma omp for lastprivate(i)	/* { dg-error "lastprivate variable 'i' is private in outer context" } */
+  for (i = 1; i < 2; i++)
+    ;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr101535-2.c b/gcc/testsuite/c-c++-common/gomp/pr101535-2.c
new file mode 100644
index 00000000000..23c84af4879
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr101535-2.c
@@ -0,0 +1,11 @@
+/* PR middle-end/101535 */
+
+void
+foo (void)
+{
+  int a = 1, i;
+  #pragma omp target map(tofrom:i)
+  #pragma omp for lastprivate(i)
+  for (i = 1; i < 2; i++)
+    ;
+}
diff --git a/gcc/testsuite/c-c++-common/pr100785.c b/gcc/testsuite/c-c++-common/pr100785.c
new file mode 100644
index 00000000000..1095845e6f1
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr100785.c
@@ -0,0 +1,21 @@
+/* PR inline-asm/100785 */
+
+struct S { int a : 1; };
+
+void
+foo (struct S *x)
+{
+  __asm__ ("" : "+m" (x->a));	/* { dg-error "address of bit-field" } */
+}				/* { dg-error "invalid lvalue in asm output 0" "" { target c } .-1 } */
+				/* { dg-error "memory input 1 is not directly addressable" "" { target c } .-2 } */
+void
+bar (struct S *x)
+{
+  __asm__ ("" : "=m" (x->a));	/* { dg-error "address of bit-field" } */
+}				/* { dg-error "invalid lvalue in asm output 0" "" { target c } .-1 } */
+
+void
+baz (struct S *x)
+{
+  __asm__ ("" : : "m" (x->a));	/* { dg-error "address of bit-field" } */
+}				/* { dg-error "memory input 0 is not directly addressable" "" { target c } .-1 } */
diff --git a/gcc/testsuite/c-c++-common/pr105186.c b/gcc/testsuite/c-c++-common/pr105186.c
new file mode 100644
index 00000000000..86b61f36b3e
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr105186.c
@@ -0,0 +1,5 @@
+/* PR c++/105186 */
+/* { dg-do compile } */
+
+__attribute__((__int128)) int i;	/* { dg-warning "'__int128' attribute directive ignored" } */
+__attribute__((__int128__)) int j;	/* { dg-warning "'int128' attribute directive ignored" } */
diff --git a/gcc/testsuite/c-c++-common/ubsan/float-div-by-zero-2.c b/gcc/testsuite/c-c++-common/ubsan/float-div-by-zero-2.c
new file mode 100644
index 00000000000..61d050ae23b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/ubsan/float-div-by-zero-2.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-shouldfail "ubsan" } */
+/* { dg-options "-fsanitize=float-divide-by-zero -fno-sanitize-recover=float-divide-by-zero -fsanitize-recover=integer-divide-by-zero" } */
+
+int
+main (void)
+{
+  volatile float a = 1.3f;
+  volatile double b = 0.0;
+  volatile int c = 4;
+  volatile float res;
+
+  res = a / b;
+
+  return 0;
+}
+
+/* { dg-output "division by zero" } */
diff --git a/gcc/testsuite/c-c++-common/ubsan/pr64888.c b/gcc/testsuite/c-c++-common/ubsan/pr64888.c
new file mode 100644
index 00000000000..6319c2feced
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/ubsan/pr64888.c
@@ -0,0 +1,27 @@
+/* PR middle-end/64888 */
+/* { dg-do compile { target fopenmp } } */
+/* { dg-options "-fopenmp -fsanitize=undefined" } */
+
+int a, b;
+
+void
+foo ()
+{
+  int c;
+#pragma omp parallel default (none) shared (a, b) private (c)
+  {
+    c = a / b;	/* { dg-bogus "not specified in enclosing" } */
+    (void) c;
+  }
+#pragma omp task default (none) shared (a, b) private (c)
+  {
+    c = a << b;	/* { dg-bogus "not specified in enclosing" } */
+    (void) c;
+  }
+#pragma omp teams default (none) shared (a, b)
+  {
+    int d[a];	/* { dg-bogus "not specified in enclosing" } */
+    d[0] = 0;
+    (void) d[0];
+  }
+}
diff --git a/gcc/testsuite/g++.dg/asan/pr104449.C b/gcc/testsuite/g++.dg/asan/pr104449.C
new file mode 100644
index 00000000000..166ed8ddb91
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asan/pr104449.C
@@ -0,0 +1,16 @@
+// PR sanitizer/104449
+// { dg-do compile }
+// { dg-options "-fexceptions -fsanitize=address -fstack-check=generic" }
+
+void bar (int *);
+struct A { A (); ~A (); };
+
+void
+foo (int n)
+{
+  A b;
+  {
+    int a[n];
+    bar (a);
+  }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C
new file mode 100644
index 00000000000..ae27c43bc0a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-equiv1.C
@@ -0,0 +1,13 @@
+// PR c++/100032
+// { dg-do compile { target c++11 } }
+
+template <template<class> class> struct X { };
+template <class> struct Y { };
+template <class T> using Z = const Y<T>;
+
+template <class T> using W = Z<T>;
+using U = X<Z>;
+using U = X<W>;
+
+using T = X<Y>;
+using T = X<Z>;			// { dg-error "conflicting declaration" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-104472.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-104472.C
new file mode 100644
index 00000000000..c9c8bf414fe
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-104472.C
@@ -0,0 +1,9 @@
+// PR c++/104472
+// { dg-options "-O2 -frounding-math" }
+// { dg-add-options float16 }
+// { dg-require-effective-target float16 }
+
+typedef short __attribute__((__vector_size__ (16))) V;
+typedef _Float16 __attribute__((__vector_size__ (16))) F;
+
+V v = __builtin_convertvector (__builtin_convertvector ((V){5534}, F), V) < 8;
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C
index e94695efa2a..47079dc38fc 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C
@@ -11,7 +11,7 @@ struct A
 struct B
 {				// This should really be target { ! c++2a }
   typedef A W[4];		// { dg-error "paren" "" { xfail *-*-* } .+1 }
-  constexpr B () : w ({ A::z, A::z, A::z, A::z }) {} // { dg-error "constant" "" { xfail *-*-* } }
+  constexpr B () : w ({ A::z, A::z, A::z, A::z }) {} // { dg-error "constant" }
   W w;
 };
 
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C
new file mode 100644
index 00000000000..14e026ec202
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-base7.C
@@ -0,0 +1,15 @@
+// PR c++/91933
+// { dg-do compile { target c++11 } }
+
+struct NoMut1 { int a, b; };
+struct NoMut3 : NoMut1 {
+  constexpr NoMut3(int a, int b) : NoMut1{a, b} {}
+};
+void mutable_subobjects() {
+  constexpr NoMut3 nm3 = {1, 2};
+  struct A {
+    void f() {
+      static_assert(nm3.a == 1, "");
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
new file mode 100644
index 00000000000..71c76fa0247
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
@@ -0,0 +1,89 @@
+// PR c++/104646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fno-elide-constructors }
+
+template <typename _T1> struct pair {
+  _T1 first;
+  int second;
+};
+template <typename _Iterator> class __normal_iterator {
+  _Iterator __traits_type;
+
+public:
+  constexpr __normal_iterator() {}
+};
+template <typename> class allocator;
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using value_type = _Tp;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+};
+template <typename _Alloc> struct __alloc_traits {
+  typedef allocator_traits<_Alloc> _Base_type;
+  typedef typename _Base_type::value_type &const_reference;
+  template <typename _Tp> struct rebind {
+    typedef typename _Base_type::template rebind_alloc<_Tp> other;
+  };
+};
+template <typename _Tp, typename _Alloc> struct _Vector_base {
+  typedef typename __alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
+};
+template <typename _Tp, typename _Alloc = allocator<_Tp>> class vector {
+public:
+  typename __alloc_traits<
+      typename _Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_reference
+  operator[](long);
+};
+enum match_flag_type {};
+template <typename, typename> class Trans_NS___cxx11_basic_regex;
+class Trans_NS___cxx11_match_results;
+enum _RegexExecutorPolicy { _S_auto };
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                       const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &);
+template <typename, typename, typename, bool> class _Executor;
+template <typename _Ch_type, typename = _Ch_type>
+class Trans_NS___cxx11_basic_regex {};
+class Trans_NS___cxx11_match_results : vector<int> {
+  template <typename, typename, typename _Cp, typename _Rp,
+            _RegexExecutorPolicy, bool>
+  friend bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                                const Trans_NS___cxx11_basic_regex<_Cp, _Rp> &);
+};
+template <typename _Bi_iter, typename _Alloc, typename _Ch_type,
+          typename _Rx_traits>
+void regex_search(_Bi_iter, _Alloc,
+                  Trans_NS___cxx11_basic_regex<_Ch_type, _Rx_traits>) {
+  __regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits, _S_auto, false>;
+}
+match_flag_type __regex_algo_impl___flags;
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(
+    Trans_NS___cxx11_match_results &__m,
+    const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &__re) {
+  __normal_iterator<const char *> __e, __s;
+  _Executor<int, int, _TraitsT, false> __executor(__s, __e, __m, __re,
+                                                  __regex_algo_impl___flags);
+  __executor._M_match();
+  return false;
+}
+template <typename, typename, typename, bool> class _Executor {
+public:
+  _Executor(__normal_iterator<const char *>, __normal_iterator<const char *>,
+            vector<int>, Trans_NS___cxx11_basic_regex<char>, match_flag_type);
+  void _M_match() { _M_dfs(); }
+  void _M_dfs();
+  vector<pair<__normal_iterator<char *>>> _M_rep_count;
+};
+long _M_rep_once_more___i;
+template <typename _BiIter, typename _Alloc, typename _TraitsT, bool __dfs_mode>
+void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::_M_dfs() {
+  auto __rep_count = _M_rep_count[_M_rep_once_more___i];
+}
+char main___trans_tmp_1;
+void main___trans_tmp_2() {
+  Trans_NS___cxx11_basic_regex<char> re;
+  regex_search(main___trans_tmp_1, main___trans_tmp_2, re);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/extern_template-6.C b/gcc/testsuite/g++.dg/cpp0x/extern_template-6.C
new file mode 100644
index 00000000000..8aff3ae6b02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/extern_template-6.C
@@ -0,0 +1,17 @@
+// PR c++/99066
+// { dg-do compile { target c++11 } }
+
+template <typename a> struct basic_string {
+  static const int npos = 1;
+};
+template <typename a> const int basic_string<a>::npos;
+
+struct e { template <bool> int f() const; };
+
+template <bool> int e::f() const {
+  return basic_string<char>::npos;
+}
+
+extern template class basic_string<char>;
+
+// { dg-final { scan-assembler-not "_ZN12basic_stringIcE4nposE" } }
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C
new file mode 100644
index 00000000000..da54d8981d4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new5.C
@@ -0,0 +1,9 @@
+// PR c++/99643
+// { dg-do compile { target c++11 } }
+
+struct Foo {};
+Foo get_foo();
+
+int main() {
+    new Foo[1]{get_foo()};
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
new file mode 100644
index 00000000000..0ef27806acf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
@@ -0,0 +1,39 @@
+// PR c++/105265
+// { dg-do run { target c++11 } }
+
+int c;
+
+class Block
+{
+public:
+  Block(int n) : data{new char[n]}, size{n}
+  {
+    ++c;
+  }
+
+  ~Block()
+  {
+    --c;
+    delete[] data;
+  }
+
+private:
+  char* data;
+  int size;
+};
+
+struct Cargo
+{
+  Block const& block;
+};
+
+int main()
+{
+  {
+    Cargo* c = new Cargo{{4000}};
+    delete c;
+  }
+  if (c != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
new file mode 100644
index 00000000000..e44dbecfece
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
@@ -0,0 +1,34 @@
+// PR c++/101442
+// { dg-do run { target c++11 } }
+
+bool destroyed = false;
+
+struct A
+{
+  A() {}
+  A(const A &) = delete;
+  A &operator=(const A &) = delete;
+  ~A() {destroyed = true;}
+};
+
+struct B
+{
+  const A &a;
+  struct string {
+    string(const char*) { }
+    ~string() { }
+  } s;
+};
+
+B foo()
+{
+  B ret{ A{}, "" };
+  return ret;
+}
+
+int main()
+{
+  B b = foo();
+  if (!destroyed)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C
new file mode 100644
index 00000000000..810ed538719
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nsdmi10.C
@@ -0,0 +1,12 @@
+// PR c++/95870
+// { dg-do compile { target c++11 } }
+
+template <typename> struct S {
+  S();
+  int b = []() -> int { enum E {}; return 1; }();
+};
+struct C : S<int> {
+  C();
+};
+template <typename T> S<T>::S() = default;
+C::C() {}
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21.C
new file mode 100644
index 00000000000..79d43a54153
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21.C
@@ -0,0 +1,8 @@
+// PR c++/101532
+// { dg-do compile { target c++11 } }
+
+struct A { private: ~A(); };
+
+template<class> struct B { A a = A(); }; // { dg-error "private" }
+
+B<int> b; // { dg-error "deleted" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21a.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21a.C
new file mode 100644
index 00000000000..08fd37b8035
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template21a.C
@@ -0,0 +1,10 @@
+// PR c++/104225
+// { dg-do compile { target c++11 } }
+
+struct A { private: ~A(); };
+
+template<class> struct B { A a = A(); }; // { dg-error "private" }
+
+int main() {
+  new B<int>; // { dg-error "deleted" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr46.C b/gcc/testsuite/g++.dg/cpp0x/nullptr46.C
new file mode 100644
index 00000000000..1514cee3c3b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr46.C
@@ -0,0 +1,11 @@
+// PR c++/101443
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+decltype(nullptr) foo ();
+
+bool
+bar ()
+{
+  return foo () > nullptr || foo () < nullptr;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr102305.C b/gcc/testsuite/g++.dg/cpp0x/pr102305.C
new file mode 100644
index 00000000000..e63adcf5364
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr102305.C
@@ -0,0 +1,39 @@
+// PR c++/102305
+// { dg-do compile { target c++11 } }
+
+namespace std
+{
+  template<typename _Tp, _Tp __v>
+    struct integral_constant
+    {
+      static constexpr _Tp value = __v;
+      typedef integral_constant<_Tp, __v> type;
+    };
+
+  template<typename _Tp, _Tp __v>
+    constexpr _Tp integral_constant<_Tp, __v>::value;
+
+  typedef integral_constant<bool, true> true_type;
+  typedef integral_constant<bool, false> false_type;
+
+  template<bool __v>
+    using bool_constant = integral_constant<bool, __v>;
+
+  template<typename _Tp, typename... _Args>
+    struct is_constructible
+    : public bool_constant<__is_constructible(_Tp, _Args...)>
+    {
+    };
+}
+
+template<typename>
+struct A {
+  virtual ~A() = 0;
+};
+
+struct B {
+  virtual ~B() = 0;
+};
+
+static_assert(!std::is_constructible<A<int> >::value, "");
+static_assert(!std::is_constructible<B>::value, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr105256.C b/gcc/testsuite/g++.dg/cpp0x/pr105256.C
new file mode 100644
index 00000000000..a97949d796a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr105256.C
@@ -0,0 +1,18 @@
+// PR c++/105256
+// { dg-do compile { target c++11 } }
+
+int bar (int &);
+
+struct S {
+  struct T {
+    struct U {
+      int i = bar (i);
+    } u;
+  };
+};
+
+void
+foo (S::T *p)
+{
+  *p = {};
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-104513.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-104513.C
new file mode 100644
index 00000000000..4fa78a3e025
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-104513.C
@@ -0,0 +1,10 @@
+// PR c++/104513
+// { dg-do compile { target c++14 } }
+
+struct A {
+  int a1;
+  short a2, a3;
+  long a4;
+  constexpr A() : a1(42), a2(42), a3(42), a4(42) { return; }
+};
+constexpr A a;
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C
new file mode 100644
index 00000000000..b43cbe6b675
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-Wunused.C
@@ -0,0 +1,18 @@
+// PR c++/96311
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -Wunused }
+
+auto foo()
+{
+  constexpr int used = 0;
+  return
+    [](auto unused)
+    {
+      return used;
+    };
+}
+
+int main()
+{
+  foo()(42);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-this4.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-this4.C
new file mode 100644
index 00000000000..38d582bec5e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-this4.C
@@ -0,0 +1,7 @@
+// PR c++/101717
+// { dg-do compile { target c++14 } }
+
+struct x {
+  static void f() { }
+  void (*_)() = [] { [=](auto) { f(); }(0); };
+};
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C
new file mode 100644
index 00000000000..845e26ff593
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr13.C
@@ -0,0 +1,33 @@
+// PR c++/96673
+// { dg-do compile { target c++11 } }
+
+template <class T>
+class A {};
+
+template <class T>
+class B;
+
+template <class T>
+class C {
+    private:
+
+    friend class B<T>;
+
+    explicit C(A<T>&) {};
+};
+
+
+template <class T>
+class B {
+    public:
+    B() = default;
+    //B() {};       // << This implementation of the constructor makes it work
+
+    A<T> a = {};
+    C<T> c = C<T>{a};
+};
+
+int main() {
+    auto b = B<int>{};
+    auto &c = b.c;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr88872.C b/gcc/testsuite/g++.dg/cpp1y/pr88872.C
new file mode 100644
index 00000000000..3719e395c0e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr88872.C
@@ -0,0 +1,24 @@
+// PR c++/88872
+// { dg-do compile { target c++14 } }
+
+struct a {
+  template <typename b> constexpr a(b) : c() {}
+  int c;
+};
+void d();
+template <char...> constexpr a operator"" _n() { return d; }
+struct e;
+struct f {
+  e operator[](int);
+};
+struct g {
+  void h();
+  f i;
+};
+template <typename> struct j {
+  void k() { [](auto) { constexpr auto l = 2_n; }(keywords); }
+  int keywords;
+};
+using m = j<int>;
+class e : public m {};
+void g::h() { i[0].k(); }
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
new file mode 100644
index 00000000000..0b22f8eb982
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction85.C
@@ -0,0 +1,16 @@
+// PR c++/99885
+// { dg-do compile { target c++17 } }
+
+template <auto const& A>
+struct Foo {};
+
+template <auto const& A>
+struct Bar {
+    constexpr auto foo() const -> Foo<A> {
+        return {};
+    }
+};
+
+constexpr int a = 1;
+constexpr Bar<a> bar;
+Foo foo = bar.foo(); // <-- CTAD failure
diff --git a/gcc/testsuite/g++.dg/cpp1z/eval-order11.C b/gcc/testsuite/g++.dg/cpp1z/eval-order11.C
new file mode 100644
index 00000000000..19a24c8ed22
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/eval-order11.C
@@ -0,0 +1,89 @@
+// PR c++/70796
+// { dg-do run { target c++11 } }
+// { dg-options "-fstrong-eval-order" { target c++14_down } }
+
+struct A
+{
+  int x = 0;
+  A & operator ++ () { ++x; return *this; }
+};
+struct B
+{
+  A first, second;
+  B (A x, A y) : first{x}, second{y} {}
+};
+struct C
+{
+  int first, second;
+  C (int x, int y) : first{x}, second{y} {}
+};
+struct D
+{
+  int d;
+  void foo (int x, D *y)
+  {
+    if (y != this + 1)
+      __builtin_abort ();
+    d = x;
+  }
+};
+D d[2] = { { 1 }, { 2 } };
+
+void
+foo ()
+{
+  int i = 0;
+  C p{++i, ++i};
+  if (p.first != 1 || p.second != 2)
+    __builtin_abort ();
+}
+
+void
+bar ()
+{
+  int i = 0;
+  C p{++i, ++i};
+  if (p.first != 1 || p.second != 2)
+    __builtin_abort ();
+  int &j = i;
+  C q{++j, ++j};
+  if (q.first != 3 || q.second != 4)
+    __builtin_abort ();
+}
+
+void
+baz ()
+{
+  int i = 0;
+  C p{(int &) ++i, (int &) ++i};
+  if (p.first != 1 || p.second != 2)
+    __builtin_abort ();
+}
+
+void
+qux ()
+{
+  A i;
+  B p{++i, ++i};
+  if (p.first.x != 1 || p.second.x != 2)
+    __builtin_abort ();
+}
+
+void
+corge ()
+{
+  D *p = &d[0];
+  p->foo (3, ++p);
+  if (d[0].d != 3 || d[1].d != 2)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  bar ();
+  baz ();
+  foo ();
+  qux ();
+  corge ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/inline-var9.C b/gcc/testsuite/g++.dg/cpp1z/inline-var9.C
new file mode 100644
index 00000000000..43c9748877b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/inline-var9.C
@@ -0,0 +1,40 @@
+// PR c++/99901
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler-not "_ZN1A1aE" } }
+// { dg-final { scan-assembler-not "_ZN2A21aE" } }
+// { dg-final { scan-assembler-not "_ZN1CIiE1cE" } }
+// { dg-final { scan-assembler "_ZN1B1bE" } }
+// { dg-final { scan-assembler "_ZN2B21bE" } }
+// { dg-final { scan-assembler "_ZN2B31bE" } }
+
+struct A {
+  static const int a = 5;
+};
+
+struct A2 {
+  static constexpr int a = 5;
+};
+
+struct B {
+  static const int b;
+};
+constexpr int B::b = 5;
+
+struct B2 {
+  static const int b = 5;
+};
+constexpr int B2::b;
+
+struct B3 {
+  static constexpr int b = 5;
+};
+const int B3::b;
+
+template <class T>
+struct C {
+  static constexpr int c = 5;
+};
+template <class T>
+constexpr int C<T>::c;
+
+int i = C<int>::c;
diff --git a/gcc/testsuite/g++.dg/cpp1z/nodiscard8.C b/gcc/testsuite/g++.dg/cpp1z/nodiscard8.C
new file mode 100644
index 00000000000..d33e8e69e2e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/nodiscard8.C
@@ -0,0 +1,15 @@
+// PR c++/100666
+// { dg-do compile { target c++11 } }
+
+[[nodiscard]] decltype(nullptr) bar ();
+extern void foo (...);
+template <typename T> void qux (T);
+
+void
+baz ()
+{
+  foo (bar ());		// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  bar ();		// { dg-warning "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  auto x = bar ();	// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  qux (bar ());		// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/nodiscard9.C b/gcc/testsuite/g++.dg/cpp1z/nodiscard9.C
new file mode 100644
index 00000000000..16142253019
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/nodiscard9.C
@@ -0,0 +1,22 @@
+// PR c++/100666
+// { dg-do compile { target c++11 } }
+
+struct S {};
+[[nodiscard]] S bar ();
+struct U { S s; };
+[[nodiscard]] U corge ();
+extern void foo (...);
+template <typename T> void qux (T);
+
+void
+baz ()
+{
+  foo (bar ());		// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  bar ();		// { dg-warning "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  auto x = bar ();	// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  qux (bar ());		// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  foo (corge ());	// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  corge ();		// { dg-warning "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  auto y = corge ();	// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+  qux (corge ());	// { dg-bogus "ignoring return value of '\[^\n\r]*', declared with attribute nodiscard" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C
new file mode 100644
index 00000000000..df16ea78641
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type24.C
@@ -0,0 +1,22 @@
+// PR c++/90664
+// { dg-do compile { target c++11 } }
+
+template <typename TT, typename MFP, MFP> struct OpM;
+
+template <typename TR, typename TT, TR (TT::*f)()>
+struct OpM<TT, TR (TT::*)(), f>
+{};
+
+class Class {
+public:
+  int address() noexcept { return 0; }
+  void address(int) noexcept {}
+};
+
+struct Sk {
+  template <class C, typename R> Sk(R (C::*p)()) {
+    typedef OpM<C, R (C::*)() /* noexcept */, &Class::address> OP;
+  }
+};
+
+Sk sk(static_cast<int (Class::*)()>(&Class::address));
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-nonlit7.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-nonlit7.C
new file mode 100644
index 00000000000..06125756f25
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-nonlit7.C
@@ -0,0 +1,6 @@
+// PR c++/104994
+// CWG2552
+// { dg-do compile { target c++14 } }
+
+constexpr bool foo () { extern thread_local int t; return true; }
+static constexpr bool a = foo ();
diff --git a/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual19.C b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual19.C
new file mode 100644
index 00000000000..a55c2b112b3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constexpr-virtual19.C
@@ -0,0 +1,11 @@
+// PR c++/102786
+// { dg-do compile { target c++2a } }
+
+struct S {
+  virtual constexpr int foo () const { return 42; }
+};
+
+constexpr S s;
+constexpr auto a = &S::foo;
+constexpr auto b = (s.*a) ();
+constexpr auto c = (s.*&S::foo) ();
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C
deleted file mode 100644
index 137e4e9fab3..00000000000
--- a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init6.C
+++ /dev/null
@@ -1,27 +0,0 @@
-// PR c++/97938
-// { dg-do compile { target c++2a } }
-
-template <typename... Args>
-int sink(Args&&... args) { return 2; }
-
-auto fwd1(const auto&&... ts1) {
-  return
-    [...ts1 = ts1] {
-      return sink(ts1...);
-    }();
-}
-
-template <typename T1>
-auto fwd2(const T1& t1) {
-  return
-    [] (auto&&... ts1) {
-      return
-	[...ts1 = ts1] {
-	  return sink(ts1...);
-	}();
-    }();
-}
-
-int main() {
-  return fwd1() + fwd2(1);
-}
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr101378.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr101378.C
new file mode 100644
index 00000000000..ec5e44df804
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr101378.C
@@ -0,0 +1,13 @@
+// PR debug/101378
+// { dg-do compile { target c++11 } }
+// { dg-options "-gdwarf-5 -dA" }
+// { dg-final { scan-assembler-times "0\[^0-9x\\r\\n\]* DW_AT_data_member_location" 1 } }
+// { dg-final { scan-assembler-times "1\[^0-9x\\r\\n\]* DW_AT_data_member_location" 1 } }
+// { dg-final { scan-assembler-times "2\[^0-9x\\r\\n\]* DW_AT_data_member_location" 1 } }
+// { dg-final { scan-assembler-not "-1\[^0-9x\\r\\n\]* DW_AT_data_member_location" } }
+
+struct E {};
+struct S
+{
+  [[no_unique_address]] E e, f, g;
+} s;
diff --git a/gcc/testsuite/g++.dg/ext/flexary39.C b/gcc/testsuite/g++.dg/ext/flexary39.C
new file mode 100644
index 00000000000..8eb81f26cf5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/flexary39.C
@@ -0,0 +1,65 @@
+// PR c++/88578
+// { dg-do run }
+// { dg-options -Wno-pedantic }
+
+#define STR(s) #s
+#define ASSERT(exp) \
+  ((exp) ? (void)0 : (void)(__builtin_printf ("%s:%i: assertion %s failed\n", \
+                     __FILE__, __LINE__, STR(exp)), \
+                      __builtin_abort ()))
+
+typedef int int32_t __attribute__((mode (__SI__)));
+
+struct Ax { int32_t n, a[]; };
+struct AAx { int32_t i; Ax ax; };
+
+int32_t i = 12345678;
+
+void
+test ()
+{
+  {
+    // OK.  Does not assign any elements to flexible array.
+    Ax s = { 0 };
+    ASSERT (s.n == 0);
+  }
+  {
+    // OK only for statically allocated objects, otherwise error.
+    static Ax s = { 0, { } };
+    ASSERT (s.n == 0);
+  }
+  {
+    static Ax s = { 1, { 2 } };
+    ASSERT (s.n == 1 && s.a [0] == 2);
+  }
+  {
+    static Ax s = { 2, { 3, 4 } };
+    ASSERT (s.n = 2 && s.a [0] == 3 && s.a [1] == 4);
+  }
+  {
+    static Ax s = { 123, i };
+    ASSERT (s.n == 123 && s.a [0] == i);
+  }
+  {
+    static Ax s = { 456, { i } };
+    ASSERT (s.n == 456 && s.a [0] == i);
+  }
+  {
+    int32_t j = i + 1, k = j + 1;
+    static Ax s = { 3, { i, j, k } };
+    ASSERT (s.n == 3 && s.a [0] == i && s.a [1] == j && s.a [2] == k);
+  }
+
+  {
+    // OK.  Does not assign any elements to flexible array.
+    AAx s = { 1, { 2 } };
+    ASSERT (s.i == 1 && s.ax.n == 2);
+  }
+}
+
+int
+main ()
+{
+  test ();
+  test ();
+}
diff --git a/gcc/testsuite/g++.dg/ext/flexary40.C b/gcc/testsuite/g++.dg/ext/flexary40.C
new file mode 100644
index 00000000000..ee824c29d3a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/flexary40.C
@@ -0,0 +1,50 @@
+// PR c++/102295
+// { dg-do run }
+// { dg-options "" }
+
+struct A { int a; int b[]; };
+struct B { B (); int k; };
+struct C { int l; B m[]; };
+
+int x[4];
+A c = { 42, { ++x[0], ++x[1], ++x[2], ++x[3] } };
+A d = { 43, { 0, ++x[0], ++x[1], ++x[2], ++x[3] } };
+A e = { 44, { ++x[0], ++x[1], ++x[2], 17 } };
+A f = { 45 };
+C n = { 50, { B (), B () } };
+C o = { 51, {} };
+
+int
+main ()
+{
+  static A g = { 46, { ++x[0], ++x[1], ++x[2], ++x[3] } };
+  static A h = { 47, { 0, ++x[0], ++x[1], ++x[2], ++x[3] } };
+  static A i = { 48, { ++x[0], ++x[1], ++x[2], 18 } };
+  static A j = { 49 };
+  if (c.a != 42 || c.b[0] != 1 || c.b[1] != 1 || c.b[2] != 1 || c.b[3] != 1)
+    __builtin_abort ();
+  if (d.a != 43 || d.b[0] != 0 || d.b[1] != 2 || d.b[2] != 2 || d.b[3] != 2 || d.b[4] != 2)
+    __builtin_abort ();
+  if (e.a != 44 || e.b[0] != 3 || e.b[1] != 3 || e.b[2] != 3 || e.b[3] != 17)
+    __builtin_abort ();
+  if (f.a != 45)
+    __builtin_abort ();
+  if (g.a != 46 || g.b[0] != 4 || g.b[1] != 4 || g.b[2] != 4 || g.b[3] != 3)
+    __builtin_abort ();
+  if (h.a != 47 || h.b[0] != 0 || h.b[1] != 5 || h.b[2] != 5 || h.b[3] != 5 || h.b[4] != 4)
+    __builtin_abort ();
+  if (i.a != 48 || i.b[0] != 6 || i.b[1] != 6 || i.b[2] != 6 || i.b[3] != 18)
+    __builtin_abort ();
+  if (j.a != 49)
+    __builtin_abort ();
+  if (n.l != 50 || n.m[0].k != 42 || n.m[1].k != 42)
+    __builtin_abort ();
+  if (o.l != 51)
+    __builtin_abort ();
+  if (x[0] != 6 || x[1] != 6 || x[2] != 6 || x[3] != 4)
+    __builtin_abort ();
+}
+
+B::B () : k (42)
+{
+}
diff --git a/gcc/testsuite/g++.dg/ext/va-arg-pack-3.C b/gcc/testsuite/g++.dg/ext/va-arg-pack-3.C
new file mode 100644
index 00000000000..0e8203ca173
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/va-arg-pack-3.C
@@ -0,0 +1,18 @@
+// PR middle-end/100898
+
+int a;
+int bar (int, ...);
+
+static inline __attribute__((always_inline)) int
+foo (...)
+{
+  while (a)
+    return bar (0, __builtin_va_arg_pack ());
+  return 0;
+}
+
+void
+baz (void)
+{
+  foo ();
+}
diff --git a/gcc/testsuite/g++.dg/gomp/clause-3.C b/gcc/testsuite/g++.dg/gomp/clause-3.C
index e0edc873483..aad97d6ad62 100644
--- a/gcc/testsuite/g++.dg/gomp/clause-3.C
+++ b/gcc/testsuite/g++.dg/gomp/clause-3.C
@@ -56,7 +56,7 @@ foo (int x)
     ;
 #pragma omp p reduction (|:d) // { dg-error "user defined reduction not found for" }
     ;
-#pragma omp p reduction (&&:d) // { dg-error "user defined reduction not found for" }
+#pragma omp p reduction (&:d) // { dg-error "user defined reduction not found for" }
     ;
 #pragma omp p copyin (d) // { dg-error "must be 'threadprivate'" }
     ;
diff --git a/gcc/testsuite/g++.dg/gomp/pr101516.C b/gcc/testsuite/g++.dg/gomp/pr101516.C
new file mode 100644
index 00000000000..48f60de6bb0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr101516.C
@@ -0,0 +1,8 @@
+// PR c++/101516
+
+void
+foo (int (&v) [])
+{
+  #pragma omp parallel reduction (+:v)	// { dg-error "invalid use of array with unspecified bounds" }
+  ;
+}
diff --git a/gcc/testsuite/g++.dg/init/assign2.C b/gcc/testsuite/g++.dg/init/assign2.C
new file mode 100644
index 00000000000..72d1264f3c9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/assign2.C
@@ -0,0 +1,6 @@
+// PR c++/59950
+
+ struct Foo {};
+
+ int f(Foo *p);
+ int n = f(&(Foo() = Foo()));
diff --git a/gcc/testsuite/g++.dg/init/no-elide2.C b/gcc/testsuite/g++.dg/init/no-elide2.C
new file mode 100644
index 00000000000..9a0ba1936ab
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/no-elide2.C
@@ -0,0 +1,32 @@
+// PR c++/100838
+// { dg-do run }
+// { dg-additional-options -fno-elide-constructors }
+
+extern "C" int puts (const char *);
+
+int c,d;
+class MyString {
+public:
+  MyString(const char* s = "") {
+    puts ("ctor");
+    ++c;
+  }
+  ~MyString() {
+    puts ("dtor");
+    ++d;
+  }
+  MyString(const MyString& s) {
+    puts ("copy ctor");
+    ++c;
+  }
+  MyString& operator=(const MyString& s);
+};
+
+int main() {
+  {
+    MyString s1 = "Hello";
+    puts ("main");
+  }
+  if (c != d)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/lookup/new3.C b/gcc/testsuite/g++.dg/lookup/new3.C
new file mode 100644
index 00000000000..36afb5b48e2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/new3.C
@@ -0,0 +1,10 @@
+// PR c++/98249
+
+#include <new>
+struct Incomplete;
+template<class T> struct Holder { T t; };
+Holder<Incomplete> *p;
+void test() {
+    ::new (p) int;
+    new (p) int;
+}
diff --git a/gcc/testsuite/g++.dg/opt/nrv20.C b/gcc/testsuite/g++.dg/opt/nrv20.C
new file mode 100644
index 00000000000..ade0c28824a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/nrv20.C
@@ -0,0 +1,20 @@
+// PR c++/91217
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fdump-tree-gimple }
+// { dg-final { scan-tree-dump-not "<retval> = a" "gimple" } }
+
+struct A
+{
+  int ar[42];
+};
+
+template <class T>
+A f()
+{
+  return [] { A a; return a; }();
+}
+
+int main()
+{
+  f<int>();
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr104681.C b/gcc/testsuite/g++.dg/opt/pr104681.C
new file mode 100644
index 00000000000..ea54940e7a3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr104681.C
@@ -0,0 +1,19 @@
+// PR target/104681
+// { dg-do compile }
+// { dg-options "-O2" }
+
+void bar ();
+struct A {
+  A (bool) : a(7.0L), b(0) {}
+  long double a;
+  long b;
+};
+struct B {
+  void foo () { c = bar; }
+  A c;
+};
+struct C {
+  void baz ();
+  B d;
+};
+void C::baz () { d.foo (); }
diff --git a/gcc/testsuite/g++.dg/overload/builtin6.C b/gcc/testsuite/g++.dg/overload/builtin6.C
new file mode 100644
index 00000000000..de192be67ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/overload/builtin6.C
@@ -0,0 +1,14 @@
+// PR c++/103455
+
+struct A { };
+
+struct B {
+  operator A*() const;
+  template<class T> operator T*() const;
+};
+
+typedef void (A::*F)();
+
+void f(B b, F pmf) {
+  (b->*pmf)();
+}
diff --git a/gcc/testsuite/g++.dg/spellcheck-pr104806.C b/gcc/testsuite/g++.dg/spellcheck-pr104806.C
new file mode 100644
index 00000000000..559e6019163
--- /dev/null
+++ b/gcc/testsuite/g++.dg/spellcheck-pr104806.C
@@ -0,0 +1,5 @@
+// PR c++/104806
+
+struct S {};
+int main() { S s; s.__d; }	// { dg-bogus "'struct S' has no member named '__d'; did you mean '__\[a-z]* '" }
+				// { dg-error "'struct S' has no member named '__d'" "" { target *-*-* } .-1 }
diff --git a/gcc/testsuite/g++.dg/template/access39.C b/gcc/testsuite/g++.dg/template/access39.C
new file mode 100644
index 00000000000..d941555577e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/access39.C
@@ -0,0 +1,17 @@
+// PR c++/101078
+
+struct A {
+  static void f();
+};
+
+template<class>
+struct B : private A {
+  struct C {
+    void g() { f(); }
+    void g2() { B::f(); }
+  };
+};
+
+int main() {
+  B<int>::C().g();
+}
diff --git a/gcc/testsuite/g++.dg/template/conv19.C b/gcc/testsuite/g++.dg/template/conv19.C
new file mode 100644
index 00000000000..7a3da939c1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/conv19.C
@@ -0,0 +1,34 @@
+// PR c++/101698
+// { dg-do compile { target c++11 } }
+
+class Base {
+ public:
+  template <class T>
+  operator const T&() const = delete;
+
+  virtual operator const int&() const {
+    static int res;
+    return res;
+  }
+};
+
+template <class T>
+class Derive : public Base {
+ public:
+  operator const T&() const override {
+    using Y = int;
+    //static_assert(__is_same_as(T,Y), "");
+
+    static int res;
+
+    res = Base::operator const Y&(); // OK
+    res = Base::operator const T&(); // { dg-bogus "deleted" }
+    return res;
+  }
+};
+
+int main() {
+  Derive<int> a;
+  const int& b = a;
+  (void)b;
+}
diff --git a/gcc/testsuite/g++.dg/template/ref11.C b/gcc/testsuite/g++.dg/template/ref11.C
new file mode 100644
index 00000000000..c43c67edf70
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/ref11.C
@@ -0,0 +1,9 @@
+// PR c++/83476
+
+int n;
+template <int& V> struct A {};
+template <int& V> void f(A<V>);
+int main() {
+  A<n> a;
+  f(a);
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr103361.C b/gcc/testsuite/g++.dg/torture/pr103361.C
new file mode 100644
index 00000000000..ec1d6e1bae4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr103361.C
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-floop-unroll-and-jam" } */
+
+char a, b;
+extern unsigned short c[];
+extern bool d[];
+const unsigned short &e(const unsigned short &f, const unsigned short &g) {
+  if (g < f)
+    return g;
+  return f;
+}
+void k() {
+  for (int h = 0; b; h += 3)
+    for (unsigned long i = 0; i < 11104842004558084287ULL;
+         i += -11104842004558084300ULL)
+      for (bool j(e(6, e(6, c[h + i]))); j < (bool)a; j = 7)
+        d[7] = 0;
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr105189.C b/gcc/testsuite/g++.dg/torture/pr105189.C
new file mode 100644
index 00000000000..a3870772cfe
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr105189.C
@@ -0,0 +1,19 @@
+// PR tree-optimization/105189
+// { dg-do run }
+
+int
+foo ()
+{
+  return -1;
+}
+
+int
+main ()
+{
+  int c = foo () >= 0U && 1;
+  if (c != 1)
+    __builtin_abort ();
+  int d = foo () >= 3U && 1;
+  if (d != 1)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr101210.C b/gcc/testsuite/g++.dg/ubsan/pr101210.C
new file mode 100644
index 00000000000..955b8203f44
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr101210.C
@@ -0,0 +1,13 @@
+// PR c++/101210
+// { dg-do run }
+// { dg-options "-fsanitize=null,alignment -fno-sanitize-recover=null,alignment" }
+
+int v[2];
+int
+main ()
+{
+  int x;
+  int &y = x;
+  v[0] = reinterpret_cast<__INTPTR_TYPE__>(&y) == 0;
+  v[1] = reinterpret_cast<__INTPTR_TYPE__>(&y) == 1;
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr105093.C b/gcc/testsuite/g++.dg/ubsan/pr105093.C
new file mode 100644
index 00000000000..49f75ed69cf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr105093.C
@@ -0,0 +1,12 @@
+// PR sanitizer/105093
+// { dg-do compile }
+// { dg-options "-O2 -fsanitize=undefined -Wno-volatile" }
+
+struct X { X (); ~X (); };
+
+volatile X
+foo ()
+{
+  X x;
+  return x;
+}
diff --git a/gcc/testsuite/g++.target/i386/pr102295.C b/gcc/testsuite/g++.target/i386/pr102295.C
new file mode 100644
index 00000000000..09efc3c8a86
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr102295.C
@@ -0,0 +1,12 @@
+// PR c++/102295
+// { dg-do compile { target *-*-linux* } }
+// { dg-options "-Wno-pedantic" }
+
+struct S {
+  int a;
+  int b[];
+} S;
+
+struct S s = { 1, { 2, 3 } };
+
+/* { dg-final { scan-assembler ".size\[\t \]*s, 12" } } */
diff --git a/gcc/testsuite/g++.target/i386/pr102548.C b/gcc/testsuite/g++.target/i386/pr102548.C
new file mode 100644
index 00000000000..e1238c3f904
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr102548.C
@@ -0,0 +1,12 @@
+// PR c++/102548
+// { dg-do compile { target { c++14 && ia32 } } }
+
+typedef decltype(sizeof(0)) size_t;
+struct tm;
+extern "C" size_t __attribute__((__cdecl__)) strftime (char *, size_t, const char *, const struct tm *);
+
+auto
+foo (void)
+{
+  return strftime;
+}
diff --git a/gcc/testsuite/g++.target/i386/vec-tmpl1.C b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
new file mode 100644
index 00000000000..e0865e3515b
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
@@ -0,0 +1,17 @@
+// PR c++/65211
+// { dg-additional-options "-Wno-psabi" }
+// { dg-final { scan-assembler-not "movdqa" } }
+
+typedef unsigned v4ui __attribute__ ((vector_size(16), aligned (16)));
+
+template<int I>
+static v4ui t1(unsigned *dest_data)
+{
+  typedef unsigned v4ui_1 __attribute__ ((vector_size (16), aligned (4)));
+  return ((const v4ui_1*)dest_data)[0];
+}
+
+v4ui f(unsigned int *array)
+{
+    return t1<1>(array+7);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr101562.c b/gcc/testsuite/gcc.c-torture/compile/pr101562.c
new file mode 100644
index 00000000000..ea4a5f7103a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr101562.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/101562 */
+
+struct S { char c; };
+void baz (struct S a, struct S b);
+
+void
+foo (void)
+{
+  struct S x[1];
+  *(short *)&x[0] = 256;
+  baz (x[0], x[1]);
+}
+
+void
+bar (void)
+{
+  struct S x[1];
+  x[0].c = 0;
+  x[1].c = 1;
+  baz (x[0], x[1]);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
new file mode 100644
index 00000000000..bdbf5733ce7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
@@ -0,0 +1,24 @@
+/* PR tree-optimization/102622 */
+/* Wrong code introduced due to phi-opt
+   introducing undefined signed interger overflow
+   with one bit signed integer negation. */
+
+struct f{signed t:1;};
+int g(struct f *a, int t) __attribute__((noipa));
+int g(struct f *a, int t)
+{
+    if (t)
+      a->t = -1;
+    else
+      a->t = 0;
+    int t1 = a->t;
+    if (t1) return 1;
+    return t1;
+}
+
+int main(void)
+{
+    struct f a;
+    if (!g(&a, 1))  __builtin_abort();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr103052.c b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
new file mode 100644
index 00000000000..bef8674a43c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
@@ -0,0 +1,35 @@
+static void js_error(void);
+static int top;
+static void js_throw(void)
+{
+	__builtin_exit(0);
+}
+
+// LOCATION A -- if js_pop is here, the bug is present
+static void js_pop(void)
+{
+	if (++top > 100)
+		js_error();
+}
+
+static void jsC_error(const char *v)
+{
+	if (v[0] == 0)
+		js_error();
+	js_throw();
+}
+static void checkfutureword(const char *exp)
+{
+	if (!__builtin_strcmp(exp, "const"))
+		jsC_error("boom");
+}
+static void js_error(void) {
+	checkfutureword("foo");
+	checkfutureword("bar");
+	js_pop();
+}
+int main(void)
+{
+	checkfutureword("const");
+	__builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr104449.c b/gcc/testsuite/gcc.dg/asan/pr104449.c
new file mode 100644
index 00000000000..50540273a3d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr104449.c
@@ -0,0 +1,12 @@
+/* PR sanitizer/104449 */
+/* { dg-do compile } */
+/* { dg-options "-fexceptions -fsanitize=address -fstack-check=generic" } */
+
+void bar (int *);
+
+void
+foo (void)
+{
+  int a[16];
+  bar (a);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr105214.c b/gcc/testsuite/gcc.dg/asan/pr105214.c
new file mode 100644
index 00000000000..a755336c7d8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr105214.c
@@ -0,0 +1,16 @@
+/* PR target/105214 */
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "*" } { "-O2" } } */
+/* { dg-options "-Ofast -fnon-call-exceptions -fexceptions -fstack-check=generic -fsanitize=address -fno-finite-math-only -fsignaling-nans -fno-associative-math" } */
+
+float f;
+void bar (int *);
+
+void
+foo (void)
+{
+  int a[1600], b[1];
+  f += __builtin_log1pf (f);
+  bar (a);
+  bar (b);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr105396.c b/gcc/testsuite/gcc.dg/asan/pr105396.c
new file mode 100644
index 00000000000..d4bd7f12476
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr105396.c
@@ -0,0 +1,19 @@
+/* PR sanitizer/105396 */
+/* { dg-do run } */
+/* { dg-skip-if "" { *-*-* } { "*" } { "-O0" } } */
+/* { dg-shouldfail "asan" } */
+
+int
+main ()
+{
+  int a;
+  int *b[1];
+  int c[10];
+  int d[1][1];
+  for (a = 0; a < 1; a++)
+    d[1][a] = 0;
+  return 0;
+}
+
+/* { dg-output "ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\n|\r\n|\r)" } */
+/* { dg-output "WRITE of size.*" } */
diff --git a/gcc/testsuite/gcc.dg/dfp/pr104510.c b/gcc/testsuite/gcc.dg/dfp/pr104510.c
new file mode 100644
index 00000000000..85f4e9707de
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/pr104510.c
@@ -0,0 +1,12 @@
+/* PR c/104510 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+float f;
+_Decimal64 d;
+
+int
+foo (void)
+{
+  return d > (_Decimal32) (_Decimal64) f;
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/pr104557.c b/gcc/testsuite/gcc.dg/dfp/pr104557.c
new file mode 100644
index 00000000000..a4a1cc63409
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/pr104557.c
@@ -0,0 +1,22 @@
+/* PR debug/104557 */
+/* { dg-do compile } */
+/* { dg-options "-O -g -Wno-psabi" } */
+
+typedef int __attribute__((__vector_size__ (32))) U;
+typedef double __attribute__((__vector_size__ (32))) F;
+typedef _Decimal64 __attribute__((__vector_size__ (32))) D;
+
+F
+bar (void)
+{
+  F f = __builtin_convertvector ((D) (-10.d < (D) ((D) (U) { 0, 0, 0, 0, 0, 0, 0, -0xe0 }
+						   >= (D) { 80000000 })), F);
+  return f;
+}
+
+F
+foo ()
+{
+  F x = bar ();
+  return x;
+}
diff --git a/gcc/testsuite/gcc.dg/gomp/clause-1.c b/gcc/testsuite/gcc.dg/gomp/clause-1.c
index 9d34b041606..8e7cc950d22 100644
--- a/gcc/testsuite/gcc.dg/gomp/clause-1.c
+++ b/gcc/testsuite/gcc.dg/gomp/clause-1.c
@@ -56,7 +56,7 @@ foo (int x)
     ;
 #pragma omp p reduction (|:d) /* { dg-error "has invalid type for" } */
     ;
-#pragma omp p reduction (&&:d) /* { dg-error "has invalid type for" } */
+#pragma omp p reduction (&:d) /* { dg-error "has invalid type for" } */
     ;
 #pragma omp p copyin (d) /* { dg-error "must be 'threadprivate'" } */
     ;
diff --git a/gcc/testsuite/gcc.dg/gomp/pr100508.c b/gcc/testsuite/gcc.dg/gomp/pr100508.c
new file mode 100644
index 00000000000..c3fa2fc258e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gomp/pr100508.c
@@ -0,0 +1,14 @@
+/* PR middle-end/100508 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -fopenmp-simd" } */
+
+typedef int __attribute__((__vector_size__(32))) V;
+V j;
+
+#pragma omp declare simd
+int
+foo (void)
+{
+  V m = j;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/guality/pr101905.c b/gcc/testsuite/gcc.dg/guality/pr101905.c
new file mode 100644
index 00000000000..71b7516905b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/guality/pr101905.c
@@ -0,0 +1,15 @@
+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
+/* { dg-options "-g -ffixed-r15" } */
+/* { dg-skip-if "" { *-*-* }  { "*" } { "-O0" } } */
+
+register unsigned long long regVar asm ("r15");
+
+int
+main()
+{
+  regVar = 0xdeadbeefcafebabeULL;
+  asm ("nop" : "+r" (regVar));
+  asm volatile ("nop");		/* { dg-final { gdb-test . "regVar" "0xdeadbeefcafebabeULL" } } */
+  asm volatile ("nop" : : "r" (regVar));
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/guality/pr49888.c b/gcc/testsuite/gcc.dg/guality/pr49888.c
index 4f3a2501eb7..919cfc9c769 100644
--- a/gcc/testsuite/gcc.dg/guality/pr49888.c
+++ b/gcc/testsuite/gcc.dg/guality/pr49888.c
@@ -4,7 +4,7 @@
 
 static int v __attribute__((used));
 
-static void __attribute__((noinline, noclone))
+static void __attribute__((noipa))
 f (int *p)
 {
   int c = *p;
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_0.c b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
new file mode 100644
index 00000000000..c84d19b0267
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
@@ -0,0 +1,33 @@
+/* { dg-lto-do run } */
+/* { dg-lto-options { "-O2 -fno-strict-aliasing -flto" } } */
+
+typedef unsigned long VALUE;
+
+__attribute__ ((cold))
+void rb_check_type(VALUE, int);
+
+static VALUE
+repro(VALUE dummy, VALUE hash)
+{
+    if (hash == 0) {
+        rb_check_type(hash, 1);
+    }
+    else if (*(long *)hash) {
+        rb_check_type(hash, 1);
+    }
+
+
+    return *(long *)hash;
+}
+
+static VALUE (*that)(VALUE dummy, VALUE hash) = repro;
+
+int
+main(int argc, char **argv)
+{
+        argc--;
+        that(0, argc);
+
+        rb_check_type(argc, argc);
+
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_1.c b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
new file mode 100644
index 00000000000..146c14abc76
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
@@ -0,0 +1,23 @@
+typedef unsigned long VALUE;
+
+
+__attribute__ ((noreturn)) void rexc_raise(VALUE mesg);
+
+VALUE rb_donothing(VALUE klass);
+
+static void
+funexpected_type(VALUE x, int xt, int t)
+{
+    rexc_raise(rb_donothing(0));
+}
+
+__attribute__ ((cold))
+void
+rb_check_type(VALUE x, int t)
+{
+    int xt;
+
+    if (x == 0) {
+        funexpected_type(x, xt, t);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_2.c b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
new file mode 100644
index 00000000000..e6f01b23f45
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
@@ -0,0 +1,11 @@
+typedef unsigned long VALUE;
+
+static void thing(void) {}
+static void (*ptr)(void) = &thing;
+
+VALUE
+rb_donothing(VALUE klass)
+{
+        ptr();
+        return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_3.c b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
new file mode 100644
index 00000000000..61217625be7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
@@ -0,0 +1,8 @@
+typedef unsigned long VALUE;
+
+__attribute__((noreturn))
+void
+rexc_raise(VALUE mesg)
+{
+        __builtin_exit(0);
+}
diff --git a/gcc/testsuite/gcc.dg/pr100509.c b/gcc/testsuite/gcc.dg/pr100509.c
new file mode 100644
index 00000000000..9405e2a27df
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100509.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct X {
+  int a;
+};
+const int a = 0;
+static struct X A __attribute__((alias("a")));
+void foo() { struct X b = A; }
diff --git a/gcc/testsuite/gcc.dg/pr101062.c b/gcc/testsuite/gcc.dg/pr101062.c
new file mode 100644
index 00000000000..6c37ed88885
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr101062.c
@@ -0,0 +1,29 @@
+/* PR middle-end/101062 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-toplevel-reorder -frename-registers" } */
+
+union U { signed b : 5; };
+int c;
+volatile union U d[7] = { { 8 } };
+short e = 1;
+
+__attribute__((noipa)) void
+foo ()
+{
+  d[6].b = 0;
+  d[6].b = 0;
+  d[6].b = 0;
+  d[6].b = 0;
+  d[6].b = 0;
+  e = 0;
+  c = 0;
+}
+
+int
+main ()
+{
+  foo ();
+  if (e != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr101171.c b/gcc/testsuite/gcc.dg/pr101171.c
new file mode 100644
index 00000000000..8d2bcabd3e4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr101171.c
@@ -0,0 +1,13 @@
+/* PR c/101171 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+extern void foo (void);
+int x = 0x1234;
+
+void
+bar (void)
+{
+  if (x != (sizeof ((enum T) 0x1234)))	/* { dg-error "conversion to incomplete type" } */
+    foo ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr101266.c b/gcc/testsuite/gcc.dg/pr101266.c
new file mode 100644
index 00000000000..d1980891a01
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr101266.c
@@ -0,0 +1,8 @@
+/* PR debug/101266 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2" } */
+
+void
+foo (int (*p)[(int){1}])
+{
+}
diff --git a/gcc/testsuite/gcc.dg/pr101384.c b/gcc/testsuite/gcc.dg/pr101384.c
new file mode 100644
index 00000000000..7030c0a481e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr101384.c
@@ -0,0 +1,39 @@
+/* PR target/101384 */
+/* { dg-do run } */
+/* { dg-options "-O2 -Wno-psabi -w" } */
+
+typedef unsigned char __attribute__((__vector_size__ (16))) U;
+typedef unsigned short __attribute__((__vector_size__ (8 * sizeof (short)))) V;
+
+U u;
+V v;
+
+__attribute__((noipa)) U
+foo (void)
+{
+  U y = (U) { 0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff,
+              0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff } + u;
+  return y;
+}
+
+__attribute__((noipa)) V
+bar (void)
+{
+  V y = (V) { 0x8000, 0xffff, 0x8000, 0xffff,
+              0x8000, 0xffff, 0x8000, 0xffff } + v;
+  return y;
+}
+
+int
+main ()
+{
+  U x = foo ();
+  for (unsigned i = 0; i < 16; i++)
+    if (x[i] != ((i & 3) ? 0xff : 0x80))
+      __builtin_abort ();
+  V y = bar ();
+  for (unsigned i = 0; i < 8; i++)
+    if (y[i] != ((i & 1) ? 0xffff : 0x8000))
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr102140.c b/gcc/testsuite/gcc.dg/pr102140.c
new file mode 100644
index 00000000000..813ba8766aa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr102140.c
@@ -0,0 +1,23 @@
+/* PR target/102140 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-Og -fipa-cp -fno-tree-ccp -fno-tree-ter -Wno-psabi" } */
+
+typedef int __attribute__((__vector_size__ (64))) U;
+typedef __int128 __attribute__((__vector_size__ (64))) V;
+
+int a, b;
+
+static void
+bar (char c, V v)
+{
+  v *= c;
+  U u = a + (U) v;
+  (union { U b; }) { u };
+  b = 0;
+}
+
+void
+foo (void)
+{
+  bar (1, (V){((__int128) 9223372036854775808ULL) << 64});
+}
diff --git a/gcc/testsuite/gcc.dg/pr102224.c b/gcc/testsuite/gcc.dg/pr102224.c
new file mode 100644
index 00000000000..9f09ba5ccbb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr102224.c
@@ -0,0 +1,49 @@
+/* PR target/102224 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+__attribute__((noipa)) float
+foo (float x)
+{
+  return x * __builtin_copysignf (1.0f, x);
+}
+
+__attribute__((noipa)) float
+bar (float x, float y)
+{
+  return x * __builtin_copysignf (1.0f, y);
+}
+
+__attribute__((noipa)) float
+baz (float z, float x)
+{
+  return x * __builtin_copysignf (1.0f, x);
+}
+
+__attribute__((noipa)) float
+qux (float z, float x, float y)
+{
+  return x * __builtin_copysignf (1.0f, y);
+}
+
+int
+main ()
+{
+  if (foo (1.0f) != 1.0f
+      || foo (-4.0f) != 4.0f)
+    __builtin_abort ();
+  if (bar (1.25f, 7.25f) != 1.25f
+      || bar (1.75f, -3.25f) != -1.75f
+      || bar (-2.25f, 7.5f) != -2.25f
+      || bar (-3.0f, -4.0f) != 3.0f)
+    __builtin_abort ();
+  if (baz (5.5f, 1.0f) != 1.0f
+      || baz (4.25f, -4.0f) != 4.0f)
+    __builtin_abort ();
+  if (qux (1.0f, 1.25f, 7.25f) != 1.25f
+      || qux (2.0f, 1.75f, -3.25f) != -1.75f
+      || qux (3.0f, -2.25f, 7.5f) != -2.25f
+      || qux (4.0f, -3.0f, -4.0f) != 3.0f)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr102478.c b/gcc/testsuite/gcc.dg/pr102478.c
new file mode 100644
index 00000000000..43bc49b584d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr102478.c
@@ -0,0 +1,29 @@
+/* PR rtl-optimization/102478 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-if-conversion -Wno-div-by-zero" } */
+
+unsigned a, b, c;
+
+void
+foo (void)
+{
+  c |= __builtin_expect (65535 / a, 0) && 0 / 0;
+  b = 0;
+}
+
+void
+bar (void)
+{
+  if (a <= 65535)
+    __builtin_trap ();
+  b = 0;
+}
+
+void
+baz (void)
+{
+  if (a > 65535)
+    b = 0;
+  else
+    __builtin_trap ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr102798.c b/gcc/testsuite/gcc.dg/pr102798.c
new file mode 100644
index 00000000000..3a50546a16b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr102798.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-tree-pta" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+__attribute__((__noipa__))
+void BUF_reverse (unsigned char *out, const unsigned char *in, size_t size)
+{
+  size_t i;
+  if (in)
+    {
+      out += size - 1;
+      for (i = 0; i < size; i++)
+        *out++ = *in++;
+    }
+  else
+    {
+      unsigned char *q;
+      char c;
+      q = out + size - 1;
+      for (i = 0; i < size ; i++)
+            {
+              *out++ = 1;
+            }
+    }
+}
+
+int
+main (void)
+{
+  unsigned char buf[40];
+  unsigned char buf1[40];
+  for (unsigned i = 0; i < sizeof (buf); i++)
+    buf[i] = i;
+  BUF_reverse (buf, 0, sizeof (buf));
+  for (unsigned i = 0; i < sizeof (buf); i++)
+    if (buf[i] != 1)
+      __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr103248.c b/gcc/testsuite/gcc.dg/pr103248.c
new file mode 100644
index 00000000000..da6232d21ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr103248.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fixed_point } */
+/* { dg-options "-fnon-call-exceptions" } */
+
+_Accum sa;
+int c;
+
+void div_csa() { c /= sa; }
diff --git a/gcc/testsuite/gcc.dg/pr103837.c b/gcc/testsuite/gcc.dg/pr103837.c
new file mode 100644
index 00000000000..43593d52b6c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr103837.c
@@ -0,0 +1,19 @@
+/* PR rtl-optimization/103837 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fcompare-debug -fmove-loop-invariants -fnon-call-exceptions -fexceptions -fdelete-dead-exceptions -fno-tree-dce -w" } */
+
+unsigned long int
+foo (int x)
+{
+  double a;
+  int b;
+  unsigned long int ret = a;
+
+  for (;;)
+    {
+      b = !!((int) a);
+      a = x;
+    }
+
+  return ret;
+}
diff --git a/gcc/testsuite/gcc.dg/pr103860.c b/gcc/testsuite/gcc.dg/pr103860.c
new file mode 100644
index 00000000000..15eee558083
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr103860.c
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/103860 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-fPIC" { target fpic } } */
+
+static int d, *e;
+int f;
+
+__attribute__((noinline)) signed char
+foo (signed char b, signed char c)
+{
+  return b + c;
+}
+
+int
+main ()
+{
+  signed char l;
+  for (l = -1; l; l = foo (l, 1))
+    {
+      while (d < 0)
+	;
+      if (d > 0)
+	{
+	  f = 0;
+	  *e = 0;
+	}
+    }
+  d = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr104675-1.c b/gcc/testsuite/gcc.dg/pr104675-1.c
new file mode 100644
index 00000000000..af0b4390c30
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr104675-1.c
@@ -0,0 +1,29 @@
+/* PR tree-optimization/104675 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Complex int
+foo (_Complex int a)
+{
+  return (-1 + -1i) - a;
+}
+
+_Complex int
+bar (_Complex int a)
+{
+  return -a - (1 + 1i);
+}
+
+_Complex int
+baz (_Complex int a)
+{
+  _Complex int b = -1 + -1i;
+  return b - a;
+}
+
+_Complex int
+qux (_Complex int a)
+{
+  _Complex int b = 1 + 1i;
+  return -a - b;
+}
diff --git a/gcc/testsuite/gcc.dg/pr104675-2.c b/gcc/testsuite/gcc.dg/pr104675-2.c
new file mode 100644
index 00000000000..037d0c4f10d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr104675-2.c
@@ -0,0 +1,18 @@
+/* PR tree-optimization/104675 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void baz (int i);
+
+void
+bar (_Complex int c, short s)
+{
+  c -= s;
+  baz (__real__ c + __imag__ c);
+}
+
+void
+foo (void)
+{
+  bar (-1 - 1i, 0);
+}
diff --git a/gcc/testsuite/gcc.dg/pr104675-3.c b/gcc/testsuite/gcc.dg/pr104675-3.c
new file mode 100644
index 00000000000..3b2eb649403
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr104675-3.c
@@ -0,0 +1,29 @@
+/* PR tree-optimization/104675 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Complex unsigned int
+foo (_Complex unsigned int x)
+{
+  return (x / 2) * 2;
+}
+
+_Complex unsigned int
+bar (_Complex unsigned int x)
+{
+  return (x * 2) / 2;
+}
+
+_Complex unsigned int
+baz (_Complex unsigned int x)
+{
+  _Complex unsigned int y = x / 2;
+  return y * 2;
+}
+
+_Complex unsigned int
+qux (_Complex unsigned int x)
+{
+  _Complex unsigned int y = x * 2;
+  return y / 2;
+}
diff --git a/gcc/testsuite/gcc.dg/pr104786.c b/gcc/testsuite/gcc.dg/pr104786.c
new file mode 100644
index 00000000000..3076d236d21
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr104786.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-std=gnu90" } */
+
+void h(void *di, int num)
+{
+  char (*t)[num] = di;
+  __asm__ ("" : "=X"( *t));
+}
diff --git a/gcc/testsuite/gcc.dg/pr105211.c b/gcc/testsuite/gcc.dg/pr105211.c
new file mode 100644
index 00000000000..9bafe6feb19
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105211.c
@@ -0,0 +1,11 @@
+/* PR rtl-optimization/105211 */
+/* { dg-do compile } */
+/* { dg-options "-Os -ffast-math" } */
+/* { dg-add-options float32 } */
+/* { dg-require-effective-target float32 } */
+
+short
+foo (_Float32 f)
+{
+  return __builtin_roundf (f);
+}
diff --git a/gcc/testsuite/gcc.dg/pr105257.c b/gcc/testsuite/gcc.dg/pr105257.c
new file mode 100644
index 00000000000..4232942d791
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105257.c
@@ -0,0 +1,16 @@
+/* PR target/105257 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+extern int sigsetjmp (void **, int);
+void *buf[32];
+void (*fn) (void);
+
+const char *
+bar (void)
+{
+  sigsetjmp (buf, 0);
+  fn ();
+  return "";
+}
diff --git a/gcc/testsuite/gcc.dg/pr78213.c b/gcc/testsuite/gcc.dg/pr78213.c
index ebc2cce78f4..04bf0381f76 100644
--- a/gcc/testsuite/gcc.dg/pr78213.c
+++ b/gcc/testsuite/gcc.dg/pr78213.c
@@ -1,12 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-fself-test" } */
-
-/* When this test was written -fself-test took no argument, but it
-   has subsequently gained a mandatory argument, giving the path
-   to selftest support files (within the srcdir).
-   It's not clear how to provide this path sanely from
-   within DejaGnu, so for now, this test is disabled.  */
-/* { dg-skip-if "" { *-*-* } } */
+/* { dg-options "-fself-test=$srcdir/selftests" } */
 
 /* Verify that -fself-test does not fail on a non empty source.  */
 
@@ -15,4 +8,5 @@ int i;
   while (i--)
     bar();
 }
-/* { dg-message "fself\-test: " "-fself-test" { target *-*-* } 0 } */
+
+/* { dg-regexp {^-fself-test: [0-9]+ pass\(es\) in [.0-9]+ seconds$|.*: note: self-tests are not enabled in this build$} } */
diff --git a/gcc/testsuite/gcc.dg/pr97953.c b/gcc/testsuite/gcc.dg/pr97953.c
new file mode 100644
index 00000000000..6219619d67b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr97953.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-fre" } */
+
+int __attribute__((noipa))
+foo (int flag, int *p)
+{
+  int val = *p;
+  if (flag)
+    {
+      if (val != 1)
+        __builtin_unreachable ();
+      return 0;
+    }
+  int val2 = *p;
+  return val2 == 2;
+}
+
+int main()
+{
+  int i = 2;
+  if (foo (0, &i) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100672.c b/gcc/testsuite/gcc.dg/torture/pr100672.c
new file mode 100644
index 00000000000..cc62e71f9a3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100672.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-w -Wno-psabi" } */
+
+typedef long long __attribute__((__vector_size__ (4 * sizeof (long long)))) V;
+
+V
+foo (V v)
+{
+  return -(v >> 1);
+}
+
+int
+main (void)
+{
+  V v = foo ((V) { -2, -4, -6, -8 });
+  if (v[0] != 1 || v[1] != 2 || v[2] != 3 || v[3] != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100786.c b/gcc/testsuite/gcc.dg/torture/pr100786.c
new file mode 100644
index 00000000000..42f4e485593
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100786.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+
+const double a = 0;
+extern int b __attribute__((alias("a")));
+void inc() { b++; }
+
+const int a2 = 0;
+extern double b2 __attribute__((alias("a2")));
+void inc2() { b2+=1; }
diff --git a/gcc/testsuite/gcc.dg/torture/pr100934.c b/gcc/testsuite/gcc.dg/torture/pr100934.c
new file mode 100644
index 00000000000..43b78849895
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100934.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+
+int a, b, c, d, e;
+int main()
+{
+  int f = 0, g = 0;
+  for (; f < 2; f++)
+    {
+      int h, i;
+      for (h = 0; h < 2; h++)
+	{
+	  b = e = g ? a % g : 0;
+	  c = d;
+	  for (i = 0; i < 1; i++)
+	    g = 0;
+	  for (; g < 2; g++)
+	    ;
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101105.c b/gcc/testsuite/gcc.dg/torture/pr101105.c
new file mode 100644
index 00000000000..9222351683d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101105.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+short a;
+int b[5][4] = {2, 2};
+int d;
+short e(int f) { return f == 0 || a && f == 1 ? 0 : a; }
+int main() {
+  int g, h;
+  g = 3;
+  for (; g >= 0; g--) {
+    h = 3;
+    for (; h >= 0; h--)
+      b[g][h] = b[0][1] && e(1);
+  }
+  d = b[0][1];
+  if (d != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101173.c b/gcc/testsuite/gcc.dg/torture/pr101173.c
new file mode 100644
index 00000000000..0c9090d6686
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101173.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-additional-options "-floop-interchange" } */
+
+int a[6][9];
+int main()
+{
+  a[1][3] = 8;
+  for (int b = 1; b <= 5; b++)
+    for (int d = 0; d <= 5; d++)
+#pragma GCC unroll 0
+      for (int c = 0; c <= 5; c++)
+        a[b][c] = a[b][c + 2] & 216;
+  for (int e = 0; e < 6; e++)
+    for (int f = 0; f < 9; f++)
+      if (a[e][f] != 0)
+        __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101394.c b/gcc/testsuite/gcc.dg/torture/pr101394.c
new file mode 100644
index 00000000000..87fbdadc152
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101394.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+
+int a, b, c, d;
+void h();
+int e() __attribute__((returns_twice));
+void f() {
+  int *g = (int *)(__INTPTR_TYPE__)c;
+  if (b) {
+    h();
+    g--;
+    if (a)
+      if (d)
+        h();
+  }
+  if (g++)
+    e();
+  c = (__INTPTR_TYPE__)g;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr103181.c b/gcc/testsuite/gcc.dg/torture/pr103181.c
new file mode 100644
index 00000000000..6bc705ab52e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr103181.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+
+typedef unsigned char __attribute__((__vector_size__ (2))) U;
+typedef unsigned short S;
+typedef unsigned int __attribute__((__vector_size__ (64))) V;
+
+V v;
+U a, b, c;
+
+U
+foo (S s)
+{
+  v += __builtin_bswap16 (s) || (S) (a / ((U){3, 0}));
+  return b + c;
+}
+
+int
+main (void)
+{
+  U x = foo (4);
+  if (x[0] || x[1])
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr103237.c b/gcc/testsuite/gcc.dg/torture/pr103237.c
new file mode 100644
index 00000000000..f2399f9586e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr103237.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-additional-options "-ftree-vectorize" } */
+
+int g1;
+unsigned int g2 = -1U;
+static void __attribute__((noipa))
+func_1()
+{
+  int *l_1 = &g1;
+  for (int g3a = 0; g3a != 4; g3a++)
+    for (int l_2 = 0; l_2 <= 3; l_2++)
+      {
+        unsigned int *l_3 = &g2;
+        *l_1 = *l_3 ^= 1;
+      }
+}
+int
+main()
+{
+  func_1();
+  if (g1 != -1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr96522.c b/gcc/testsuite/gcc.dg/torture/pr96522.c
new file mode 100644
index 00000000000..2f55d1aeb4d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr96522.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fno-tree-pta" } */
+
+__attribute__((noipa)) void
+bar (void)
+{
+  volatile int v = 1;
+  if (v)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+baz (void)
+{
+}
+
+__attribute__((noipa)) void
+foo (int n, double *p, double *x)
+{
+  if (n < 10 && p != 0)
+    for (int i = 0; i < 10; i++)
+      if (x[0] < p[i])
+        x[i] = 0;
+  if (p != 0)
+    bar ();
+  else
+    baz ();
+}
+
+int
+main ()
+{
+  double arr[10];
+  foo (1000, 0, arr);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
new file mode 100644
index 00000000000..781555e085d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
@@ -0,0 +1,22 @@
+/* PR/101280 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-linterchange-details" } */
+
+void dummy (double *, double *);
+#define LEN_2D 32
+double aa[LEN_2D][LEN_2D], bb[LEN_2D][LEN_2D];
+double s231(int iterations)
+{
+//    loop interchange
+//    loop with data dependency
+    for (int nl = 0; nl < 100*(iterations/LEN_2D); nl++) {
+        for (int i = 0; i < LEN_2D; ++i) {
+            for (int j = 1; j < LEN_2D; j++) {
+                aa[j][i] = aa[j - 1][i] + bb[j][i];
+            }
+        }
+        dummy(aa[0],bb[0]);
+    }
+}
+
+/* { dg-final { scan-tree-dump "loops interchanged" "linterchange" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
new file mode 100644
index 00000000000..d5987e14360
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-pcom-details -fdump-tree-optimized" } */
+
+int main()
+{
+  volatile int y;
+  void bar()
+    {
+      __builtin_printf ("%d", y);
+    }
+  while (y)
+    ;
+  return 0;
+}
+
+/* Make sure the load from y is correctly interpreted as volatile, even
+   when going through FRAME.  */
+/* { dg-final { scan-tree-dump-not "Executing predictive commoning" "pcom" } } */
+/* { dg-final { scan-tree-dump " ={v} FRAME" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr97456.c b/gcc/testsuite/gcc.dg/tree-ssa/pr97456.c
new file mode 100644
index 00000000000..5171c9b4577
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr97456.c
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fwhole-program" } */
+
+
+float val2 = 1.710780f;
+float val3;
+volatile float vf;
+
+int __attribute__((noipa))
+get_bool (void)
+{
+  return 1;
+}
+
+int __attribute__((noinline))
+wrong (float *pos)
+{
+  _Complex float a;
+
+  __real__ a = *pos;
+  __imag__ a = *pos;
+
+  _Complex float b = 0 + 0i;
+
+  b = b + a;
+
+  if (b == 0.0f)
+    return 1;
+
+  vf = __imag__ b;
+  return 0;
+}
+
+int main(int argc, char **argv) {
+  float val = get_bool () == 1 ? val2 : val3;
+
+  if ((wrong(&val), wrong(&val)))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon.c b/gcc/testsuite/gcc.target/arm/attr-neon.c
index 225fb8dc3db..e8e3086247d 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon.c
@@ -1,7 +1,10 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-O2 -ftree-vectorize" } */
-/* { dg-add-options arm_neon arm_v8_vfp } */ /* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any -mfpu= option set by arm_neon, thus ensuring that the attributes below really are checked for correct fpu selection.  */
+/* { dg-add-options arm_neon arm_v8_vfp } */
+/* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any
+   -mfpu= option set by arm_neon, thus ensuring that the attributes below
+   really are checked for correct fpu selection.  */
 
 /* Verify that neon instructions are emitted once.  */
 void __attribute__ ((target("fpu=neon")))
@@ -18,6 +21,6 @@ f3(int n, int x[], int y[]) {
     y[i] = x[i] << 3;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+vfp\n" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+neon\n" 1 } } */
 /* { dg-final { scan-assembler-times "vshl" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon2.c b/gcc/testsuite/gcc.target/arm/attr-neon2.c
index 29668256cf5..91cf4dde8db 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon2.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon2.c
@@ -27,8 +27,8 @@ my1 (int8x8_t __a, int8x8_t __b)
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfp\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+neon\n} } } */
 /* { dg-final { scan-assembler "vadd" } } */
 
 
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon3.c b/gcc/testsuite/gcc.target/arm/attr-neon3.c
index 17e429ad739..0acb7f98dc6 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon3.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon3.c
@@ -31,8 +31,8 @@ my1 (int8x8_t __a, int8x8_t __b)
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu crypto-neon-fp-armv8" 1 } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfp\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+neon\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+crypto-neon-fp-armv8\n} } } */
 /* { dg-final { scan-assembler-times "vld1" 1 } } */
 /* { dg-final { scan-assembler-times "vadd" 1} } */
diff --git a/gcc/testsuite/gcc.target/arm/pr69245.c b/gcc/testsuite/gcc.target/arm/pr69245.c
index bd505187728..58a6104e8f6 100644
--- a/gcc/testsuite/gcc.target/arm/pr69245.c
+++ b/gcc/testsuite/gcc.target/arm/pr69245.c
@@ -12,7 +12,7 @@
 #pragma GCC target "fpu=neon-vfpv4"
 int a, c, d;
 float b;
-static int fn1 ()
+ int fn1 ()
 {
   return 0;
 }
@@ -23,4 +23,8 @@ void fn2 ()
   d = b * c + a;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
+/* Because we don't know the exact command-line options used to invoke the test
+   we cannot expect these tests to match exactly once.  But they must appear at
+   least once.  */
+/* { dg-final { scan-assembler "\.fpu\\s+vfp\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+neon-vfpv4\n" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr99977.c b/gcc/testsuite/gcc.target/arm/pr99977.c
new file mode 100644
index 00000000000..db330e4a4a3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr99977.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8m_base_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8m_base } */
+_Bool f1(int *p) { return __sync_bool_compare_and_swap (p, -1, 2); }
+_Bool f2(int *p) { return __sync_bool_compare_and_swap (p, -8, 2); }
+int g1(int *p) { return __sync_val_compare_and_swap (p, -1, 2); }
+int g2(int *p) { return __sync_val_compare_and_swap (p, -8, 3); }
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
index 174be85f3f7..7e63cf53013 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
@@ -22,5 +22,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
index add40ddc6b8..398d8fff35c 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
@@ -25,5 +25,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx-pr102224.c b/gcc/testsuite/gcc.target/i386/avx-pr102224.c
new file mode 100644
index 00000000000..be6b88c05db
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx-pr102224.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/51581 */
+/* { dg-do run } */
+/* { dg-options "-O2 -mavx" } */
+/* { dg-require-effective-target avx } */
+
+#ifndef CHECK_H
+#define CHECK_H "avx-check.h"
+#endif
+#ifndef TEST
+#define TEST avx_test
+#endif
+
+#define main main1
+#include "../../gcc.dg/pr102224.c"
+#undef main
+
+#include CHECK_H
+
+static void
+TEST (void)
+{
+  main1 ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
new file mode 100644
index 00000000000..4a0057b241e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-mavx512dq -O0" } */
+/* { dg-require-effective-target avx512dq } */
+
+#include "avx512f-check.h"
+
+static void
+avx512f_test (void)
+{
+  __m512 x = {
+      1, 1, 1, 1,
+      1, 1, 1, 1,
+      0, 0, 0, 0,
+      0, 0, 0, 0,  };
+  int ret = _mm512_fpclass_ps_mask(x, 0x26);
+  if (ret != 65280)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr101175.c b/gcc/testsuite/gcc.target/i386/pr101175.c
new file mode 100644
index 00000000000..ed7a08110a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr101175.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mlzcnt" } */
+/* { dg-require-effective-target lzcnt } */
+
+#include "lzcnt-check.h"
+
+static int
+foo (unsigned int v)
+{
+  return v ? __builtin_clz (v) : 32;
+}
+
+/* returns -1 if x == 0 */
+int
+__attribute__ ((noinline, noclone))
+bar (unsigned int x)
+{
+  return 31 - foo (x);
+}
+
+static void
+lzcnt_test ()
+{
+  int r = bar (0);
+
+  if (r != -1)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr102498.c b/gcc/testsuite/gcc.target/i386/pr102498.c
new file mode 100644
index 00000000000..44161c5730b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr102498.c
@@ -0,0 +1,59 @@
+/* PR target/102498 */
+/* { dg-do run { target fenv } } */
+/* { dg-options "-frounding-math" } */
+
+#include <fenv.h>
+#include <stdlib.h>
+
+__attribute__((noipa)) long double
+fldlg2 (void)
+{
+  return 0.3010299956639811952256464283594894482L;
+}
+
+__attribute__((noipa)) long double
+fldln2 (void)
+{
+  return 0.6931471805599453094286904741849753009L;
+}
+
+__attribute__((noipa)) long double
+fldl2e (void)
+{
+  return 1.4426950408889634073876517827983434472L;
+}
+
+__attribute__((noipa)) long double
+fldl2t (void)
+{
+  return 3.3219280948873623478083405569094566090L;
+}
+
+__attribute__((noipa)) long double
+fldpi (void)
+{
+  return 3.1415926535897932385128089594061862044L;
+}
+
+int
+main ()
+{
+  long double a = fldlg2 ();
+  long double b = fldln2 ();
+  long double c = fldl2e ();
+  long double d = fldl2t ();
+  long double e = fldpi ();
+  static int f[] = { FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD, FE_DOWNWARD };
+  int i;
+  for (i = 0; i < 4; i++)
+    {
+      fesetround (f[i]);
+      if (a != fldlg2 ()
+	  || b != fldln2 ()
+	  || c != fldl2e ()
+	  || d != fldl2t ()
+	  || e != fldpi ())
+	abort ();
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr103205.c b/gcc/testsuite/gcc.target/i386/pr103205.c
new file mode 100644
index 00000000000..eaeea82fee2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr103205.c
@@ -0,0 +1,11 @@
+/* PR target/103205 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mtune-ctrl=^himode_math" } */
+
+unsigned short a;
+
+unsigned short
+foo (void)
+{
+  return __sync_fetch_and_and (&a, ~1) & 1;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr103908.c b/gcc/testsuite/gcc.target/i386/pr103908.c
new file mode 100644
index 00000000000..7c57e1ddf6a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr103908.c
@@ -0,0 +1,24 @@
+/* PR rtl-optimization/103908 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdisable-tree-cselim -fno-tree-sink" } */
+/* { dg-final { scan-assembler "# insn 1" } } */
+/* { dg-final { scan-assembler "# insn 2" } } */
+
+int a, b;
+
+void
+foo (void)
+{
+  if (a)
+    {
+      b = 1;
+      asm goto ("# insn 1" : : : : lab1);
+    lab1:;
+    }
+  else
+    {
+      b = 1;
+      asm goto ("# insn 2" : : : : lab2);
+    lab2:;
+    }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104446.c b/gcc/testsuite/gcc.target/i386/pr104446.c
new file mode 100644
index 00000000000..510cb69cfb6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104446.c
@@ -0,0 +1,15 @@
+/* PR middle-end/104446 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mrtd" } */
+
+register volatile int a __asm__("%esp");
+void foo (void *);
+void bar (void *);
+
+void
+baz (void)
+{
+  foo (__builtin_return_address (0));
+  a = 0;
+  bar (__builtin_return_address (0));
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104451.c b/gcc/testsuite/gcc.target/i386/pr104451.c
new file mode 100644
index 00000000000..8b251ccf827
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104451.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx2 -mxop -O" } */
+
+typedef char __attribute__((__vector_size__ (16))) V;
+typedef unsigned char __attribute__((__vector_size__ (16))) UV;
+V v;
+UV uv;
+
+V
+foo (long c)
+{
+  return v << c;
+}
+
+V
+foo1 (long c)
+{
+  return v >> c;
+}
+
+UV
+foo2 (unsigned long uc)
+{
+  return uv >> uc;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104453.c b/gcc/testsuite/gcc.target/i386/pr104453.c
new file mode 100644
index 00000000000..325cedf0e2c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104453.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+typedef short __attribute__((__vector_size__ (32))) V;
+V g;
+
+void
+foo (void)
+{
+  __builtin_ia32_psrawi256 (g, 0);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104469.c b/gcc/testsuite/gcc.target/i386/pr104469.c
new file mode 100644
index 00000000000..39cc31fde1f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104469.c
@@ -0,0 +1,12 @@
+/* PR target/104469 */
+/* { dg-do compile } */
+/* { dg-options "-mavx512f" } */
+
+typedef double __attribute__((__vector_size__ (64))) F;
+typedef int __attribute__((__vector_size__ (32))) V;
+
+F
+foo (V v)
+{
+  return __builtin_convertvector (v, F);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104502.c b/gcc/testsuite/gcc.target/i386/pr104502.c
new file mode 100644
index 00000000000..7a6eb260e41
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104502.c
@@ -0,0 +1,31 @@
+/* PR target/104502 */
+/* { dg-do compile { target fstack_protector } } */
+/* { dg-options "-O -flive-range-shrinkage -march=barcelona -fstack-protector-all -mavx512f" } */
+
+typedef char __attribute__((__vector_size__ (8))) U;
+typedef int __attribute__((__vector_size__ (8))) A;
+typedef int __attribute__((__vector_size__ (16))) B;
+typedef int __attribute__((__vector_size__ (32))) C;
+typedef int __attribute__((__vector_size__ (64))) D;
+typedef __float128 __attribute__((__vector_size__ (32))) F;
+
+char s;
+U u;
+A a;
+int i;
+C c;
+double d;
+
+U
+foo (U u0, A a0, B b0, B b1, C c0, C c1, C c2, C c3, A a1, A a2, F f0)
+{
+  C ca = c |= (short) (float) d;
+  C cb = c0 + c1 + c2 + c3 + ca + (C) f0;
+  U ua = s << (u & 4);
+  B ba = ((union {C a; B b;}) cb).b + b0 + b1;
+  U ub = ((union {B a; U b;}) ba).b +
+    u0 + u + ua + (U) a + (U) a + (U) a0 + (U) a1 + (U) a2;
+  long long u64_r = i + d;
+  char u8_r = u64_r;
+  return ub + u8_r;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr104971.c b/gcc/testsuite/gcc.target/i386/pr104971.c
new file mode 100644
index 00000000000..80ac6b613f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104971.c
@@ -0,0 +1,18 @@
+/* PR middle-end/104971 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include <x86intrin.h>
+
+__attribute__((noipa)) void
+foo (void)
+{
+  __readeflags ();
+}
+
+int
+main ()
+{
+  foo ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr105123.c b/gcc/testsuite/gcc.target/i386/pr105123.c
new file mode 100644
index 00000000000..f00d98881a7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr105123.c
@@ -0,0 +1,22 @@
+/* PR target/105123 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-options "-msse2" } */
+/* { dg-additional-options "-mtune=i686" { target ia32 } } */
+
+typedef unsigned short __attribute__((__vector_size__ (4 * sizeof (unsigned short)))) V;
+
+V
+foo (unsigned short u, V v)
+{
+  return __builtin_shuffle (u * v, v);
+}
+
+int
+main ()
+{
+  V x = foo (1, (V) { 0, 1, 2, 3 });
+  for (unsigned i = 0; i < 4; i++)
+    if (x[i] != i)
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-1.c b/gcc/testsuite/gcc.target/i386/pr71245-1.c
deleted file mode 100644
index 02c0dcb80b6..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-1.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -mno-sse -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "(fistp|fild)" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-2.c b/gcc/testsuite/gcc.target/i386/pr71245-2.c
deleted file mode 100644
index bf37a8cbb71..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-2.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -msse -mno-sse2 -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "movlps" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 99719325773..44347e9b802 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -429,7 +429,9 @@ test_3 (_mm_maskz_mul_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_mul_round_ps, __m512, __mmask16, __m512, __m512, 9)
 test_3 (_mm_maskz_mul_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_scalef_round_pd, __m512d, __mmask8, __m512d, __m512d, 9)
+test_3 (_mm_maskz_scalef_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_scalef_round_ps, __m512, __mmask16, __m512, __m512, 9)
+test_3 (_mm_maskz_scalef_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_shuffle_f32x4, __m512, __mmask16, __m512, __m512, 1)
 test_3 (_mm512_maskz_shuffle_f64x2, __m512d, __mmask8, __m512d, __m512d, 1)
 test_3 (_mm512_maskz_shuffle_i32x4, __m512i, __mmask16, __m512i, __m512i, 1)
@@ -543,7 +545,9 @@ test_4 (_mm_mask_mul_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_mul_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
 test_4 (_mm_mask_mul_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_scalef_round_pd, __m512d, __m512d, __mmask8, __m512d, __m512d, 9)
+test_4 (_mm_mask_scalef_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_scalef_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
+test_4 (_mm_mask_scalef_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_shuffle_f32x4, __m512, __m512, __mmask16, __m512, __m512, 1)
 test_4 (_mm512_mask_shuffle_f64x2, __m512d, __m512d, __mmask8, __m512d, __m512d, 1)
 test_4 (_mm512_mask_shuffle_i32x4, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101129.c b/gcc/testsuite/gcc.target/powerpc/pr101129.c
new file mode 100644
index 00000000000..6b8e5a9b597
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101129.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-mdejagnu-cpu=power8 -O " } */
+
+/* PR101129: The swaps pass was turning a mult-lopart into a mult-hipart.
+   Make sure we aren't doing that anymore.  */
+
+typedef unsigned char u8;
+typedef unsigned char __attribute__((__vector_size__ (8))) U;
+typedef unsigned char __attribute__((__vector_size__ (16))) V;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef __int128 u128;
+
+u8 g;
+U u;
+
+void
+foo0 (u32 u32_0, U *ret)
+{
+  u128 u128_2 = u32_0 * (u128)((V){ 5 } > (u32_0 & 4));
+  u64 u64_r = u128_2 >> 64;
+  u8 u8_r = u64_r + g;
+  *ret = u + u8_r;
+}
+
+int
+main (void)
+{
+  U x;
+  foo0 (7, &x);
+  for (unsigned i = 0; i < sizeof (x); i++)
+    if (x[i] != 0) __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-1.c b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
new file mode 100644
index 00000000000..b4753ab83d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector float a = {  1,  2, - 3, - 4};
+  vector float b = {-10, 20, -30,  40};
+  vector float c = { 10, 20, -30, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-2.c b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
new file mode 100644
index 00000000000..148ad657366
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector double a = {   1,  -4};
+  vector double b = { -10,  40};
+  vector double c = {  10, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102347.c b/gcc/testsuite/gcc.target/powerpc/pr102347.c
new file mode 100644
index 00000000000..55e5374bfac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102347.c
@@ -0,0 +1,19 @@
+/* { dg-do link } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* { dg-require-effective-target lto } */
+/* { dg-options "-flto -mdejagnu-cpu=power8" } */
+
+/* Verify there are no error messages in LTO mode.  */
+
+#pragma GCC target "cpu=power9"
+int main ()
+{
+  int res;
+#ifdef __LP64__
+  res = (int) __builtin_darn ();
+#else
+  res = __builtin_darn_32 ();
+#endif
+  return res;
+}
diff --git a/gcc/testsuite/gcc.target/s390/20211119.c b/gcc/testsuite/gcc.target/s390/20211119.c
new file mode 100644
index 00000000000..b9d216389f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/20211119.c
@@ -0,0 +1,12 @@
+/* { dg-do run { target { s390_useable_hw } } } */
+/* { dg-options "-Os -march=z10" } */
+signed char a;
+int b = -925974181, c;
+unsigned *d = &b;
+int *e = &c;
+int main() {
+  *e = ((217 ^ a) > 585) < *d;
+  if (c != 1)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/s390/pr104775.c b/gcc/testsuite/gcc.target/s390/pr104775.c
new file mode 100644
index 00000000000..fd4258bb36f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr104775.c
@@ -0,0 +1,14 @@
+/* PR target/104775 */
+/* { dg-do assemble { target s390_zEC12_hw } } */
+/* { dg-options "-O2 -march=zEC12" } */
+
+long a[64];
+void bar (void);
+
+void
+foo (int x, int y)
+{
+  if (x != a[y])
+    bar ();
+  __builtin_trap ();
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20210917-1.c b/gcc/testsuite/gcc.target/sparc/20210917-1.c
new file mode 100644
index 00000000000..03e8bc58db9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20210917-1.c
@@ -0,0 +1,19 @@
+/* PR rtl-optimization/102306 */
+/* Reported by Daniel Cederman <cederman@gaisler.com> */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O -mcpu=v8" } */
+
+extern void foo (void);
+
+void test (volatile unsigned char *a) 
+{ 
+  char b = *a;
+  if (!b)
+    return;
+  if (b & 2)
+    foo ();
+}
+
+/* { dg-final { scan-assembler-times "ldub" 1 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/20220510-1.c b/gcc/testsuite/gcc.target/sparc/20220510-1.c
new file mode 100644
index 00000000000..f321cab8482
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20220510-1.c
@@ -0,0 +1,31 @@
+/* PR target/105292 */
+/* Reported by Koakuma <koachan+gccbugs@protonmail.com> */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis2" } */
+
+extern void get_vbytes_v2 (unsigned);
+
+typedef struct {
+  unsigned ctt_info;
+  unsigned ctt_size;
+} ctf_type_t;
+
+typedef struct {
+  unsigned short cts_offset;
+  unsigned short cts_bits;
+} ctf_slice_t;
+
+void flip_types_len (ctf_type_t *t, int bsx1, int bsx2)
+{
+  const int kind = t->ctt_info;
+
+  get_vbytes_v2 (t->ctt_size);
+
+  if (kind == 4)
+    {
+      ctf_slice_t *s = (ctf_slice_t *)t;
+      s->cts_offset = __builtin_bswap16(bsx1);
+      s->cts_bits   = __builtin_bswap16(bsx2);
+    }
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882a.d b/gcc/testsuite/gdc.dg/pr100882a.d
new file mode 100644
index 00000000000..d94baff97ac
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882a.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-additional-options "-fmain" }
+// { dg-do run }
+
+__gshared int counter = 0;
+struct S100882
+{
+    this(int) { counter++; }
+    ~this() { counter++; }
+}
+static S100882 s;
+static this()
+{
+    s = cast(shared) S100882(0);
+    assert(counter == 2);
+}
+
+auto test100882()
+{
+    return cast(shared) S100882(0);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882b.d b/gcc/testsuite/gdc.dg/pr100882b.d
new file mode 100644
index 00000000000..de92ab3bef1
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882b.d
@@ -0,0 +1,35 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct AllocatorList(Factory)
+{
+    Factory factory;
+    auto make(size_t n) { return factory(n); }
+    this(Factory plant)
+    {
+        factory = plant;
+    }
+}
+
+struct Region
+{
+    ~this()
+    {
+    }
+}
+
+auto mmapRegionList()
+{
+    struct Factory
+    {
+        this(size_t )
+        {
+        }
+        auto opCall(size_t )
+        {
+            return Region();
+        }
+    }
+    auto shop = Factory();
+    AllocatorList!Factory(shop);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882c.d b/gcc/testsuite/gdc.dg/pr100882c.d
new file mode 100644
index 00000000000..deaa4b44a16
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882c.d
@@ -0,0 +1,19 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+auto iota(int, int)
+{
+    struct Result
+    {
+        this(int)
+        {
+        }
+    }
+    return Result();
+}
+
+auto iota(int end)
+{
+    int begin;
+    return iota(begin, end);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882d.d b/gcc/testsuite/gdc.dg/pr100882d.d
new file mode 100644
index 00000000000..f4e6e4d3651
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882d.d
@@ -0,0 +1,25 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct CowArray
+{
+    this(this)
+    {
+    }
+}
+
+struct Tuple
+{
+    CowArray expand;
+}
+
+auto tuple(CowArray)
+{
+    return Tuple();
+}
+
+auto parseCharTerm()
+{
+    CowArray set;
+    return tuple(set);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100967.d b/gcc/testsuite/gdc.dg/pr100967.d
new file mode 100644
index 00000000000..582ad582676
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100967.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100967
+// { dg-do compile }
+
+module object; // { dg-error "class object.TypeInfo missing or corrupt object.d" }
+
+extern(C) int main()
+{
+    int[int] aa;
+    aa[0] = 1;  // { dg-error ".object.TypeInfo. could not be found, but is implicitly used" }
+    return 0;
+}
diff --git a/gcc/testsuite/gdc.dg/pr101127a.d b/gcc/testsuite/gdc.dg/pr101127a.d
new file mode 100644
index 00000000000..b56398e1929
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127a.d
@@ -0,0 +1,8 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+// { dg-additional-options "-mavx" }
+
+import gcc.builtins;
+
+static assert(__traits(compiles, __builtin_ia32_andps256));
+static assert(__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101127b.d b/gcc/testsuite/gdc.dg/pr101127b.d
new file mode 100644
index 00000000000..b462d75c424
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127b.d
@@ -0,0 +1,7 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+
+import gcc.builtins;
+
+static assert(!__traits(compiles, __builtin_ia32_andps256));
+static assert(!__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101490.d b/gcc/testsuite/gdc.dg/pr101490.d
new file mode 100644
index 00000000000..6929d406863
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101490.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101490
+// { dg-do compile }
+
+struct S101490
+{
+    int[0] arr;
+}
+
+void main()
+{
+    S101490* t;
+    auto a = cast(typeof(t.arr)[0])t.arr;
+    write(a);
+}
+
+void write(S)(S args)
+{
+    foreach (arg; args)
+    {
+    }
+}
diff --git a/gcc/testsuite/gdc.dg/pr101640.d b/gcc/testsuite/gdc.dg/pr101640.d
new file mode 100644
index 00000000000..68de4088512
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101640.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101640
+// { dg-do compile }
+// { dg-options "-fdump-tree-original" }
+
+int fun101640(ref int);
+
+int test101640(int val)
+{
+    // { dg-final { scan-tree-dump "= val \\\+ fun101640 \\\(\\\(int &\\\) &val\\\);" "original" } }
+    return val + fun101640(val);
+}
diff --git a/gcc/testsuite/gdc.dg/pr96435.d b/gcc/testsuite/gdc.dg/pr96435.d
new file mode 100644
index 00000000000..c6d8785ec5b
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr96435.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96435
+// { dg-do run }
+
+@safe bool test96435()
+{
+    int[2] array = [16, 678];
+    union U { int i; bool b; }
+    U u;
+    u.i = 0xDEADBEEF;
+    assert(array[u.b] == 678);
+    return u.b;
+}
+
+@safe void main()
+{
+    auto b = test96435();
+    if (b)
+        assert(true);
+    if (!b)
+        assert(false);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
index 3a80a039e26..5b3542828dd 100644
--- a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
+++ b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
@@ -26,3 +26,24 @@ enum payloadOffset = C2.bytes.offsetof;
 static assert(C2.int1.offsetof == payloadOffset + 8);
 static assert(C2.alignof == size_t.sizeof);
 static assert(__traits(classInstanceSize, C2) == payloadOffset + 12);
+
+align(8) struct PaddedStruct
+{
+    bool flag;
+    align(2) S1 s1;
+}
+
+static assert(PaddedStruct.s1.offsetof == 2);
+static assert(PaddedStruct.alignof == 8);
+static assert(PaddedStruct.sizeof == 16);
+
+align(1) struct UglyStruct
+{
+    bool flag;
+    int i;
+    ubyte u;
+}
+
+static assert(UglyStruct.i.offsetof == 4);
+static assert(UglyStruct.alignof == 1);
+static assert(UglyStruct.sizeof == 9);
diff --git a/gcc/testsuite/gdc.test/compilable/b19002.d b/gcc/testsuite/gdc.test/compilable/b19002.d
new file mode 100644
index 00000000000..fd8e6d18b37
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/b19002.d
@@ -0,0 +1,12 @@
+module b19002;
+
+void printf(scope const char* format){}
+
+void main()
+{
+    printf(__FILE__);
+    printf(__FILE_FULL_PATH__);
+    printf(__FUNCTION__);
+    printf(__PRETTY_FUNCTION__);
+    printf(__MODULE__);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/betterCarray.d b/gcc/testsuite/gdc.test/compilable/betterCarray.d
index 74c80be3b95..3f48b042bde 100644
--- a/gcc/testsuite/gdc.test/compilable/betterCarray.d
+++ b/gcc/testsuite/gdc.test/compilable/betterCarray.d
@@ -15,3 +15,13 @@ int foo(int[] a, int i)
 {
     return a[i];
 }
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=19234
+void issue19234()
+{
+    static struct A {}
+    A[10] a;
+    A[10] b;
+    b[] = a[];
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
new file mode 100644
index 00000000000..c7060b0d96c
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
@@ -0,0 +1 @@
+module object;
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
new file mode 100644
index 00000000000..672db305223
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
@@ -0,0 +1,11 @@
+/*
+REQUIRED_ARGS: -betterC
+TEST_OUTPUT:
+---
+fail_compilation/fail19911a.d(9): Error: function `fail19911a.fun` D-style variadic functions cannot be used with -betterC
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
new file mode 100644
index 00000000000..b4ad22b0896
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
@@ -0,0 +1,13 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+EXTRA_SOURCES: extra-files/minimal/object.d
+TEST_OUTPUT:
+---
+fail_compilation/fail19911b.d(10): Error: function `fail19911b.fun` `object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
new file mode 100644
index 00000000000..d1e954ed394
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
@@ -0,0 +1,17 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19911c.d(15): Error: function `object.fun` `object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+module object;
+
+class Object { }
+class TypeInfo_Tuple { }
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19922.d b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
new file mode 100644
index 00000000000..5c9e2bbe0ab
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19922.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = typeid(o);
+}
+
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19923.d b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
new file mode 100644
index 00000000000..042cf8af11a
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19923.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = o.classinfo;
+}
+
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22144.d b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
new file mode 100644
index 00000000000..e0fd5b19225
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
@@ -0,0 +1,14 @@
+// https://issues.dlang.org/show_bug.cgi?id=22144
+/* TEST_OUTPUT
+---
+fail_compilation/fail22144.d(12): Error: cannot cast expression `zarray1` of type `int[0]` to `int[0][]` since sizes don't line up
+---
+*/
+void main()
+{
+  int[0] zarray1;
+  int[0][0] zarray2;
+
+  auto zslice1 = cast(int[0][])zarray1; // ICE -> Error
+  auto zslice2 = cast(int[0][])zarray2; // ICE -> OK
+}
diff --git a/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90 b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
new file mode 100644
index 00000000000..0fc54d5331c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+!
+! Test the fix for PR99125, where the array reference in the print
+! statement caused an ICE because the gimplifier complained about '0'
+! being used as an lvalue.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), allocatable :: a(:)
+   end type
+   type(t) :: x
+   character(8) :: c(3) = ['12 45 78','23 56 89','34 67 90']
+   x%a = c
+   if (any (x%a(2:3) .ne. ['23 56 89','34 67 90'])) stop 1
+   if (any (x%a(2:3)(4:5) .ne. ['56','67'])) stop 2 ! Bizarrely this worked.
+end
diff --git a/gcc/testsuite/gfortran.dg/asan_associate_58.f90 b/gcc/testsuite/gfortran.dg/asan_associate_58.f90
new file mode 100644
index 00000000000..b5ea75498b7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/asan_associate_58.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-additional-options "-O0" }
+!
+! PR fortran/104228
+! The code generated code for the program below wrongly pushed the Y character
+! length variable to both P and S scope, which was leading to an ICE when
+! address sanitizer was in effect
+
+program p
+   character(:), save, allocatable :: x(:)
+   call s
+contains
+   subroutine s
+      associate (y => x)
+         y = [x]
+      end associate
+   end
+end
+
diff --git a/gcc/testsuite/gfortran.dg/asan_associate_59.f90 b/gcc/testsuite/gfortran.dg/asan_associate_59.f90
new file mode 100644
index 00000000000..9bfb2bfbafb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/asan_associate_59.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-additional-options "-O0" }
+!
+! PR fortran/104228
+! The code generated code for the program below wrongly pushed the Y character
+! length variable to both P and S scope, which was leading to an ICE when
+! address sanitizer was in effect
+
+program p
+   character(:), allocatable :: x(:)
+   call s
+contains
+   subroutine s
+      associate (y => x)
+         y = [x]
+      end associate
+   end
+end
+
diff --git a/gcc/testsuite/gfortran.dg/associate_54.f90 b/gcc/testsuite/gfortran.dg/associate_54.f90
new file mode 100644
index 00000000000..003175a47fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_54.f90
@@ -0,0 +1,34 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+  subroutine test_alter_state1 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "is used as array" }
+!      state = a
+      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state1
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_55.f90 b/gcc/testsuite/gfortran.dg/associate_55.f90
new file mode 100644
index 00000000000..2b9e8c727f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_55.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "no IMPLICIT type" }
+      state = a                                 ! { dg-error "vector-indexed target" }
+!      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_56.f90 b/gcc/testsuite/gfortran.dg/associate_56.f90
new file mode 100644
index 00000000000..429f129da6e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_56.f90
@@ -0,0 +1,36 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    integer, dimension(2) :: TEST_STATES = [1,2]
+    associate (state => obj%state(TEST_STATES))
+      state = a                                 ! { dg-error "vector-indexed target" }
+      state(TEST_STATE) = a                     ! { dg-error "vector-indexed target" }
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_58.f90 b/gcc/testsuite/gfortran.dg/associate_58.f90
new file mode 100644
index 00000000000..9c24f35c0d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_58.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! PR fortran/104570
+! The following used to cause an ICE because the string length
+! evaluation of the (y) expression was not prepared to handle
+! a non-scalar expression.
+
+program p
+   character(:), allocatable :: x(:)
+   x = ['abc']
+   call s
+contains
+   subroutine s
+      associate (y => x)
+         associate (z => (y))
+            print *, z
+         end associate
+      end associate
+   end
+end
+
diff --git a/gcc/testsuite/gfortran.dg/associated_target_7.f90 b/gcc/testsuite/gfortran.dg/associated_target_7.f90
new file mode 100644
index 00000000000..97f93b3c742
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associated_target_7.f90
@@ -0,0 +1,87 @@
+! { dg-do run }
+!
+! associated_target_7.f90: Test the fix for PR98565.
+!
+! Contributed by Yves Secretan  <yves.secretan@ete.inrs.ca>
+!
+MODULE PS_SN0N_M
+
+   IMPLICIT NONE
+   PRIVATE
+
+   TYPE, PUBLIC :: DT_GRID_T
+       INTEGER :: NNT
+   CONTAINS
+       ! PASS
+   END TYPE DT_GRID_T
+
+   TYPE, PUBLIC :: LM_ELEM_T
+       CLASS(DT_GRID_T), POINTER :: PGRID
+   CONTAINS
+       PROCEDURE, PUBLIC :: REQPGRID => LM_ELEM_REGPGRID
+   END TYPE LM_ELEM_T
+
+   TYPE, PUBLIC :: PS_SN0N_T
+      CLASS(DT_GRID_T), POINTER :: PGRID
+
+   CONTAINS
+      PROCEDURE, PUBLIC :: ASGOELE  => PS_SN0N_ASGOELE
+   END TYPE PS_SN0N_T
+
+
+CONTAINS
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION LM_ELEM_REGPGRID(SELF) RESULT(PGRID)
+   CLASS(DT_GRID_T), POINTER :: PGRID
+   CLASS(LM_ELEM_T), INTENT(IN) :: SELF
+   PGRID => SELF%PGRID
+   RETURN
+   END FUNCTION LM_ELEM_REGPGRID
+
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION PS_SN0N_ASGOELE(SELF, OELE) RESULT(ERMSG)
+
+   INTEGER :: ERMSG
+   CLASS(PS_SN0N_T), INTENT(IN) :: SELF
+   CLASS(LM_ELEM_T), INTENT(IN) :: OELE
+
+   !CLASS(DT_GRID_T), POINTER :: PGRID
+   LOGICAL :: ISOK
+   !------------------------------------------------------------------------
+
+   ! ASSOCIATED with temp variable compiles
+   !PGRID => OELE%REQPGRID()
+   !ISOK = ASSOCIATED(SELF%PGRID, PGRID)
+
+   ! ASSOCIATE without temp variable crashes with ICE
+   ISOK = ASSOCIATED(SELF%PGRID, OELE%REQPGRID())
+   ERMSG = 0
+   IF (ISOK) ERMSG = 1
+
+   RETURN
+   END FUNCTION PS_SN0N_ASGOELE
+
+END MODULE PS_SN0N_M
+
+
+   USE PS_SN0N_M
+   CLASS(PS_SN0N_T), ALLOCATABLE :: SELF
+   CLASS(LM_ELEM_T), ALLOCATABLE :: OELE
+   TYPE (DT_GRID_T), TARGET :: GRID1 = DT_GRID_T (42)
+   TYPE (DT_GRID_T), TARGET :: GRID2 = DT_GRID_T (84)
+
+   ALLOCATE (PS_SN0N_T :: SELF)
+   ALLOCATE (LM_ELEM_T :: OELE)
+   SELF%PGRID => GRID1
+
+   OELE%PGRID => NULL ()
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 1
+
+   OELE%PGRID => GRID2
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 2
+
+   OELE%PGRID => GRID1
+   IF (SELF%ASGOELE (OELE) .NE. 1) STOP 3
+END
diff --git a/gcc/testsuite/gfortran.dg/bound_simplification_7.f90 b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
new file mode 100644
index 00000000000..3efecdff769
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/103392 - ICE in simplify_bound
+
+program p
+  integer, allocatable :: a(1:1) ! { dg-error "deferred shape or assumed rank" }
+  integer :: b(1) = lbound(a)    ! { dg-error "does not reduce" }
+  integer :: c(1) = ubound(a)    ! { dg-error "does not reduce" }
+end
+
+subroutine s(x, y)
+  type t
+     integer :: i(3)
+  end type t
+  type(t), pointer     :: x(:)
+  type(t), allocatable :: y(:)
+  integer, parameter   :: m(1) = ubound (x(1)% i)
+  integer              :: n(1) = ubound (y(1)% i)
+end subroutine s
diff --git a/gcc/testsuite/gfortran.dg/bounds_check_23.f90 b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
new file mode 100644
index 00000000000..8de90c77c01
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+! { dg-options "-fcheck=bounds -fdump-tree-original" }
+! PR fortran/98490 - out of bounds in array constructor with implied do loop
+
+program test
+  implicit none
+  call sub('Lorem ipsum')
+contains
+  subroutine sub( text )
+    character(len=*), intent(in)  :: text
+    character(len=1), allocatable :: c(:)
+    integer :: i
+    c = [ ( text(i:i), i = 1, len(text) ) ]
+    if (c(1) /= 'L') stop 1
+  end subroutine sub
+end program test
+
+! { dg-final { scan-tree-dump-times "Substring out of bounds:" 2 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_6.f90 b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
new file mode 100644
index 00000000000..79f6e86daa7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
@@ -0,0 +1,65 @@
+! { dg-do run }
+!
+! Test the fix for PR99819 - explicit shape class arrays in different
+! procedures caused an ICE.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      integer :: i
+   end type
+   class(t), allocatable :: dum1(:), dum2(:), dum3(:,:)
+
+   allocate (t :: dum1(3), dum2(10), dum3(2,5))
+   dum2%i = [1,2,3,4,5,6,7,8,9,10]
+   dum3%i = reshape ([1,2,3,4,5,6,7,8,9,10],[2,5])
+
+! Somewhat elaborated versions of the PR procedures.
+   if (f (dum1, dum2, dum3) .ne. 10) stop 1
+   if (g (dum1) .ne. 3) stop 2
+
+! Test the original versions of the procedures.
+   if (f_original (dum1, dum2) .ne. 3) stop 3
+   if (g_original (dum2) .ne. 10) stop 4
+
+contains
+   integer function f(x, y, z)
+      class(t) :: x(:)
+      class(t) :: y(size( x))
+      class(t) :: z(2,*)
+      if (size (y) .ne. 3) stop 5
+      if (size (z) .ne. 0) stop 6
+      select type (y)
+        type is (t)
+          f = 1
+          if (any (y%i .ne. [1,2,3])) stop 7
+        class default
+          f = 0
+      end select
+      select type (z)
+        type is (t)
+          f = f*10
+          if (any (z(1,1:4)%i .ne. [1,3,5,7])) stop 8
+        class default
+          f = 0
+      end select
+   end
+   integer function g(z)
+      class(t) :: z(:)
+      type(t) :: u(size(z))
+      g = size (u)
+   end
+
+   integer function f_original(x, y)
+      class(t) :: x(:)
+      class(*) :: y(size (x))
+      f_original = size (y)
+   end
+
+   integer function g_original(z)
+      class(*) :: z(:)
+      type(t) :: u(size(z))
+      g_original = size (u)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_7.f90 b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
new file mode 100644
index 00000000000..913426804f3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
@@ -0,0 +1,60 @@
+! { dg-do run }
+!
+! Test the fix for PR46691 - enable class assumed size arrays
+!
+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>
+! from http://j3-fortran.org/pipermail/j3/2010-December/004084.html
+! submitted by Robert Corbett.
+!
+       MODULE TYPES
+         PRIVATE
+         PUBLIC REC, REC2
+
+         TYPE REC
+           INTEGER A
+         END TYPE
+
+         TYPE, EXTENDS(REC) :: REC2
+           INTEGER B
+         END TYPE
+       END
+
+       SUBROUTINE SUB1(A, N)
+         USE TYPES
+         CLASS(REC), INTENT(IN) :: A(*)
+         INTERFACE
+           SUBROUTINE SUB2(A, N, IARRAY)
+             USE TYPES
+             TYPE(REC) A(*)
+             INTEGER :: N, IARRAY(N)
+           END
+         END INTERFACE
+
+         CALL SUB2(A, N,[1,2,2,3,3,4,4,5,5,6])
+         select type (B => A(1:N))
+             type is (REC2)
+                 call SUB2(B%REC,N,[1,2,3,4,5,6,7,8,9,10])
+         end select
+
+       END
+
+       SUBROUTINE SUB2(A, N, IARRAY)
+         USE TYPES
+         TYPE(REC) A(*)
+         INTEGER :: N, IARRAY(N)
+         if (any (A(:N)%A .ne. IARRAY(:N))) stop 1
+       END
+
+       PROGRAM MAIN
+         USE TYPES
+         CLASS(REC), ALLOCATABLE :: A(:)
+         INTERFACE
+           SUBROUTINE SUB1(A, N)
+             USE TYPES
+             CLASS(REC), INTENT(IN) :: A(*)
+           END SUBROUTINE
+         END INTERFACE
+
+         A = [ (REC2(I, I+1), I = 1, 10) ]
+         CALL SUB1(A, 10)
+       END
diff --git a/gcc/testsuite/gfortran.dg/dec_union_12.f90 b/gcc/testsuite/gfortran.dg/dec_union_12.f90
new file mode 100755
index 00000000000..26671230b05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_union_12.f90
@@ -0,0 +1,43 @@
+! { dg-do compile }
+! { dg-options "-std=legacy -ffree-form -finit-local-zero -finit-derived -fdec-structure" }
+!
+! PR fortran/105310
+!
+! Test that gfc_conv_union_initializer does not cause an ICE when called
+! to build the constructor for a field which triggers a vector resize.
+!
+
+program dec_union_12
+  implicit none
+STRUCTURE /foo8u/
+  ! 8 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo16u/
+  ! 16 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo32u/
+  ! 32 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  INTEGER(4) :: aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+  record /foo8u/ bar8u
+  record /foo16u/ bar16u
+  record /foo32u/ bar32u
+  bar8u.a = 1
+  bar16u.a = 1
+  bar32u.a = 1
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_35.f90 b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
new file mode 100644
index 00000000000..c28f52f79ff
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+!
+! Test the fix for PR93794, where the ASSOCIATE statement ICED on the
+! deferred character length, pointer component.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), pointer :: a
+   end type
+   type(t) :: z
+   character(4), target :: c = 'abcd'
+   z%a => c
+   associate (y => z%a)
+      print *, y
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/do_check_19.f90 b/gcc/testsuite/gfortran.dg/do_check_19.f90
new file mode 100644
index 00000000000..1373a7374ce
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_check_19.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! { dg-prune-output "Obsolescent feature: Alternate-return argument" }
+! PR fortran/103717 - ICE in doloop_code
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+contains
+  subroutine s(*)
+  end
+end
+
+recursive subroutine s(*)
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/elemental_function_5.f90 b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
new file mode 100644
index 00000000000..315ff9162b3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
@@ -0,0 +1,46 @@
+! { dg-do compile }
+!
+! Test the fix for PR98472.
+!
+! Contributed by Rui Coelho  <ruicoelhopedro@hotmail.com>
+!
+module a
+        type, abstract :: base
+        contains
+                procedure(elem_func), deferred, nopass :: add
+        end type base
+
+        type, extends(base) :: derived
+        contains
+                procedure, nopass :: add => add_derived
+        end type derived
+
+        abstract interface
+                elemental function elem_func(x, y) result(out)
+                        integer, intent(in) :: x, y
+                        integer :: out
+                end function elem_func
+        end interface
+
+contains
+        elemental function add_derived(x, y) result(out)
+                integer, intent(in) :: x, y
+                integer :: out
+                out = x + y
+        end function add_derived
+end module a
+
+program main
+        use a
+        call foo
+contains
+        subroutine foo
+               integer, dimension(:), allocatable :: vec
+               class(base), allocatable :: instance
+               allocate(derived :: instance)
+               allocate(vec, source=instance%add([1, 2], [1, 2])) ! ICE here
+               if (any (vec .ne. [2, 4])) stop 1
+        end
+end program main
+
+
diff --git a/gcc/testsuite/gfortran.dg/implied_do_io_7.f90 b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
new file mode 100644
index 00000000000..63927aafea9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR 100227 - this was falsely optimized, leading to nonsense  results.
+! Original test case by "Mathieu".
+
+program p
+  implicit none
+  integer, parameter :: nbmode = 3
+  integer :: k
+  real    :: mass(nbmode*2)
+  character (len=80) :: line
+  do k = 1, nbmode*2
+     mass(k) = k
+  end do
+  write (unit=line,fmt='(*(F6.2))') (mass(k+k), k=1,nbmode)
+  if (line /= '  2.00  4.00  6.00') stop 1
+end program
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_25.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
new file mode 100644
index 00000000000..df8ad06c123
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/99839 - ICE in inline_matmul_assign
+
+program p
+  real :: x(3, 3) = 1.0
+  class(*), allocatable :: z(:, :)
+  z = matmul(x, x)
+end
diff --git a/gcc/testsuite/gfortran.dg/intent_out_14.f90 b/gcc/testsuite/gfortran.dg/intent_out_14.f90
new file mode 100644
index 00000000000..e5994635008
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_14.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+! PR fortran/102287 - optional allocatable DT array arguments (intent out)
+
+module m
+  type t
+     integer, allocatable :: a
+  end type t
+contains
+  subroutine a (x, v)
+    type(t), optional, allocatable, intent(out) :: x(:)
+    type(t), optional,              intent(out) :: v(:)
+    call b (x, v)
+  end subroutine a
+
+  subroutine b (y, w)
+    type(t), optional, allocatable, intent(out) :: y(:)
+    type(t), optional,              intent(out) :: w(:)
+  end subroutine b
+end module m
+
+program p
+  use m
+  call a ()
+end
diff --git a/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90 b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
new file mode 100644
index 00000000000..917944d8846
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
@@ -0,0 +1,57 @@
+! { dg-do run }
+! PR libfortran/103634 - Runtime crash with PACK on zero-sized arrays
+! Exercise PACK intrinsic for cases when it calls pack_internal
+
+program p
+  implicit none
+  type t
+     real :: r(24) = -99.
+  end type
+  type(t), allocatable :: new(:), old(:), vec(:)
+  logical, allocatable :: mask(:)
+  integer              :: n, m
+! m = 1    ! works
+  m = 0    ! failed with SIGSEGV in pack_internal
+  do m = 0, 2
+     print *, m
+     allocate (old(m), mask(m), vec(m))
+     if (m > 0) vec(m)% r(1) = 42
+     mask(:) = .true.
+     n = count (mask)
+     allocate (new(n))
+
+     mask(:) = .false.
+     if (size (pack (old, mask)) /= 0) stop 1
+     mask(:) = .true.
+     if (size (pack (old, mask)) /= m) stop 2
+     new(:) = pack (old, mask)              ! this used to segfault for m=0
+
+     mask(:) = .false.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 3
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (     new( m  )% r(1) /=  42)  stop 4
+        if (any (new(:m-1)% r(1) /= -99)) stop 5
+     end if
+
+     if (m > 0) mask(m) = .true.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 6
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (new(1)% r(1) /= -99) stop 7
+     end if
+     if (m > 1) then
+        if (new(m)% r(1) /=  42) stop 8
+     end if
+
+     if (size (pack (old(:0), mask(:0), vector=vec)) /= m) stop 9
+     new(:) = t()
+     new(:) = pack (old(:0), mask(:0), vector=vec) ! did segfault for m=0
+     if (m > 0) then
+        if (new(m)% r(1) /= 42) stop 10
+     end if
+     deallocate (old, mask, new, vec)
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/overload_4.f90 b/gcc/testsuite/gfortran.dg/overload_4.f90
new file mode 100644
index 00000000000..43207e358ba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/overload_4.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-additional-options "-Wno-intrinsic-shadow" }
+! PR fortran/103782 - ICE overloading an intrinsic like dble or real
+! Contributed by Urban Jost
+
+program runtest
+  implicit none
+  interface dble
+     procedure to_double
+  end interface dble
+  interface real
+     procedure floor ! not really FLOOR...
+  end interface real
+  if (any (dble ([10.0d0,20.0d0]) - [10.0d0,20.0d0] /= 0.d0)) stop 1
+  if (any (real ([1.5,2.5])       - [1.5,2.5]       /= 0.0 )) stop 2
+contains
+  elemental function to_double (valuein) result(d_out)
+    doubleprecision,intent(in) :: valuein
+    doubleprecision            :: d_out
+    d_out=valuein
+  end function to_double
+  elemental function floor (valuein) result(d_out) ! not really FLOOR...
+    real, intent(in) :: valuein
+    real             :: d_out
+    d_out=valuein
+  end function floor
+end program runtest
diff --git a/gcc/testsuite/gfortran.dg/pdt_26.f03 b/gcc/testsuite/gfortran.dg/pdt_26.f03
index bf1273743d3..59ddcfb6cc4 100644
--- a/gcc/testsuite/gfortran.dg/pdt_26.f03
+++ b/gcc/testsuite/gfortran.dg/pdt_26.f03
@@ -2,7 +2,7 @@
 ! { dg-options "-fdump-tree-original" }
 !
 ! Test the fix for PR83567 in which the parameterized component 'foo' was
-! being deallocated before return from 'addw', with consequent segfault in 
+! being deallocated before return from 'addw', with consequent segfault in
 ! the main program.
 !
 ! Contributed by Berke Durak  <berke.durak@gmail.com>
@@ -43,4 +43,4 @@ program test_pdt
   if (any (c(1)%foo .ne. [13,15,17])) STOP 2
 end program test_pdt
 ! { dg-final { scan-tree-dump-times "__builtin_free" 8 "original" } }
-! { dg-final { scan-tree-dump-times "__builtin_malloc" 9 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 8 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pdt_31.f03 b/gcc/testsuite/gfortran.dg/pdt_31.f03
new file mode 100644
index 00000000000..708c9454217
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pdt_31.f03
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! Test the fix for PR100110, in which 'obj' was not being initialized.
+!
+! Contributed by Xiao Liu  <xiao.liu@compiler-dev.com>
+!
+program p
+  implicit none
+  type t(n)
+    integer, len :: n
+    integer :: arr(n, n)
+  end type
+
+  type(t(2)) :: obj
+
+  obj%arr = reshape ([1,2,3,4],[2,2])
+  if (obj%n .ne. 2) stop 1
+  if (any (shape(obj%arr) .ne. [2,2])) stop 2
+  call test()
+contains
+  subroutine test()
+    if (obj%n .ne. 2) stop 3
+    if (any (shape(obj%arr) .ne. [2,2])) stop 4
+    if (any (reshape (obj%arr, [4]) .ne. [1,2,3,4])) stop 5
+  end subroutine
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr100949.f90 b/gcc/testsuite/gfortran.dg/pr100949.f90
new file mode 100644
index 00000000000..6c736fd7f72
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100949.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/100949 - ICE in gfc_conv_expr_present, at fortran/trans-expr.c:1975
+
+subroutine s
+entry f
+  type t
+  end type
+  class(t), allocatable :: y, z
+  allocate (z, mold=y)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101327.f90 b/gcc/testsuite/gfortran.dg/pr101327.f90
new file mode 100644
index 00000000000..f4377aabe7a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101327.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/101327 - ICE in find_array_element, at fortran/expr.c:1355
+
+subroutine s
+  integer, parameter :: n([2]) = [1, 2] ! { dg-error "must be scalar" }
+  type t
+     integer :: a(n(1):n(2))
+  end type
+end
+
+! { dg-error "cannot be automatic or of deferred shape" " " { target *-*-* } 5 }
diff --git a/gcc/testsuite/gfortran.dg/pr102860.f90 b/gcc/testsuite/gfortran.dg/pr102860.f90
new file mode 100644
index 00000000000..566fe059213
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr102860.f90
@@ -0,0 +1,10 @@
+! PR middle-end/102860
+! { dg-do compile { target { powerpc*-*-* } } }
+! { dg-require-effective-target powerpc_vsx_ok } 
+! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } 
+! { dg-options "-O2 -mcpu=power9" } 
+
+function foo(a)
+  integer(kind=4) :: a(1024)
+  a(:) = modulo (a(:), 39)
+end function
diff --git a/gcc/testsuite/gfortran.dg/pr103588.f90 b/gcc/testsuite/gfortran.dg/pr103588.f90
new file mode 100644
index 00000000000..198e1766cd2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103588.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/103588 - ICE: Simplification error in gfc_ref_dimen_size
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "cannot be automatic or of deferred shape" }
+  integer :: b(2) = a(::a(1))        ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103606.f90 b/gcc/testsuite/gfortran.dg/pr103606.f90
new file mode 100644
index 00000000000..43283184e89
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103606.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103606 -  ICE in resolve_fl_procedure
+! Contributed by G.Steinmetz
+
+program p
+  type t
+  end type
+contains
+  elemental function f() result(z) ! { dg-error "CLASS variable" }
+    class(t) :: z
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103607.f90 b/gcc/testsuite/gfortran.dg/pr103607.f90
new file mode 100644
index 00000000000..a6a2c4fdfd0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103607.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103607 - ICE in do_subscript, at fortran/frontend-passes.c:2927
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i, x(abs(2.)) ! { dg-error "must be of INTEGER type" }
+  do i = 1, 2
+     x(i) = 0
+  end do
+end
+
+! { dg-prune-output "must have constant shape" }
diff --git a/gcc/testsuite/gfortran.dg/pr82314.f90 b/gcc/testsuite/gfortran.dg/pr82314.f90
new file mode 100644
index 00000000000..3a147e22711
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr82314.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR fortran/82314 - ICE in gfc_conv_expr_descriptor
+
+program p
+  implicit none
+  integer, parameter :: karray(merge(3,7,.true.):merge(3,7,.false.)) = 1
+  integer, parameter :: i = size   (karray)
+  integer, parameter :: l = lbound (karray,1)
+  integer, parameter :: u = ubound (karray,1)
+  if (l /= 3 .or. u /= 7 .or. i /= 5) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_52.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
new file mode 100644
index 00000000000..cb7cf7040a9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
@@ -0,0 +1,72 @@
+! { dg-do run }
+!
+! Test the fix for PRs93924 & 93925.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+module cs
+
+implicit none
+
+integer, target :: integer_target
+
+abstract interface
+   function classStar_map_ifc(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+   end function classStar_map_ifc
+end interface
+
+contains
+
+   function fun(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+      select type (x)
+      type is (integer)
+         integer_target = x        ! Deals with dangling target.
+         y => integer_target
+      class default
+         y => null()
+      end select
+   end function fun
+
+   function apply(f, x) result(y)
+      procedure(classStar_map_ifc) :: f
+      integer, intent(in) :: x
+      integer :: y
+      class(*), pointer :: p
+      y = 0                        ! Get rid of 'y' undefined warning
+      p => f (x)
+      select type (p)
+      type is (integer)
+         y = p
+      end select
+   end function apply
+
+   function selector() result(f)
+      procedure(classStar_map_ifc), pointer :: f
+      f => fun
+   end function selector
+
+end module cs
+
+
+program classStar_map
+
+use cs
+implicit none
+
+integer :: x, y
+procedure(classStar_map_ifc), pointer :: f
+
+x = 123654
+f => selector ()               ! Fixed by second chunk in patch
+y = apply (f, x)               ! Fixed by first chunk in patch
+if (x .ne. y) stop 1
+
+x = 2 * x
+y = apply (fun, x)             ! PR93925; fixed as above
+if (x .ne. y) stop 2
+
+end program classStar_map
diff --git a/gcc/testsuite/gfortran.dg/shape_11.f90 b/gcc/testsuite/gfortran.dg/shape_11.f90
new file mode 100644
index 00000000000..127d221e710
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_11.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/103610 - ICE while simplifying SHAPE
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(-1) = 1
+  integer, parameter :: b(1)  = maskl(shape(a))
+  integer, parameter :: c(1)  = shape(a)
+  integer, parameter :: d(1)  = maskr(shape(a))
+  if (b(1) /= 0) stop 1
+  if (c(1) /= 0) stop 2
+  if (d(1) /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/structure_constructor_17.f90 b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
new file mode 100644
index 00000000000..8b8230c6f7e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Test the fix for PR97612.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+program constructor_allocatable
+  implicit none
+
+  type :: s
+    integer, dimension(:), allocatable :: u
+  end type s
+
+  type :: t
+    type(s), dimension(:), allocatable :: x
+  end type t
+
+  type(t) :: a = t()
+  if (allocated (a%x)) stop 1
+
+end program constructor_allocatable
diff --git a/gcc/testsuite/gfortran.dg/substr_6.f90 b/gcc/testsuite/gfortran.dg/substr_6.f90
index 0d5e3d75e88..83e788a55a6 100644
--- a/gcc/testsuite/gfortran.dg/substr_6.f90
+++ b/gcc/testsuite/gfortran.dg/substr_6.f90
@@ -6,6 +6,8 @@ CHARACTER(5), parameter :: c0(1) = (/ "123" // ACHAR(0) // "5" /)
 CHARACTER*5 c(1)
 CHARACTER(1), parameter :: c1(5) = (/ "1", "2", "3", ACHAR(0), "5" /)
 
+c = c0(1)(-5:-8)
+if (c(1) /= "     ") STOP 1
 c = (/ c0(1)(1:5) /)
 do i=1,5
    if (c(1)(i:i) /= c1(i)) STOP 2
diff --git a/gcc/testsuite/gfortran.dg/transfer_check_6.f90 b/gcc/testsuite/gfortran.dg/transfer_check_6.f90
new file mode 100644
index 00000000000..dffd0913f0d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transfer_check_6.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/104227 - ICE virtual memory exhausted
+! Contributed by G.Steinmetz
+
+program p
+  type t
+  end type
+  type(t) :: x(2)
+  print *, transfer(1, x) ! { dg-error "shall not have storage size 0" }
+  x = transfer(1, x)      ! { dg-error "shall not have storage size 0" }
+end
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_11.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_11.f90
index 0911f9dba3a..409e4768a10 100644
--- a/gcc/testsuite/gfortran.dg/transfer_simplify_11.f90
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_11.f90
@@ -4,5 +4,5 @@
    integer, parameter :: N = 2
    character(len=1) :: chr(N)
    chr = transfer(repeat("x",ncopies=N),[character(len=1) ::], N)
-   if (chr(1) /= 'x' .and. chr(2) /= 'x') STOP 1
+   if (chr(1) /= 'x' .or. chr(2) /= 'x') STOP 1
 end
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_13.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_13.f90
new file mode 100644
index 00000000000..b4e72c3628a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_13.f90
@@ -0,0 +1,34 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/104127 - ICE in get_array_charlen
+! Contributed by G.Steinmetz
+
+program p
+  character(4) :: mold = "XYZ"
+  integer      :: i = 0
+  integer, parameter :: l1 = len  (transfer('ab', 'xyz', size=0))
+  integer, parameter :: s1 = size (transfer('ab', 'xyz', size=0))
+  integer, parameter :: l4 = len  (transfer(4_'abcd', 4_'xy', size=0))
+  integer, parameter :: s4 = size (transfer(4_'abcd', 4_'xy', size=0))
+  integer, parameter :: l2 = len  (transfer('ab', mold,  size=0))
+  integer, parameter :: l3 = len  (transfer('ab', mold,  size=1))
+  integer, parameter :: l5 = len  (transfer('ab',['xyz'], size=0))
+  integer, parameter :: s5 = size (transfer('ab',['xyz'], size=0))
+  call sub0 ( transfer('a', 'y', size=0) )
+! call sub1 ([transfer('a', 'y', size=0)]) ! fails for gcc-9
+! call sub2 ([transfer('a',['y'],size=0)]) ! fails for gcc-9
+  call sub3 ( transfer('a', 'y', size=1) )
+  call sub4 ([transfer('a', 'y', size=1)])
+  call sub5 ( transfer('a', 'y', size=i) )
+  call sub6 ( transfer(1_'abcd', 1_'xy' , size=0))
+  call sub7 ( transfer(1_'abcd',[1_'xy'], size=0))
+  call sub8 ( transfer(4_'abcd', 4_'xy' , size=0))
+  call sub9 ( transfer(4_'abcd',[4_'xy'], size=0))
+  print *, transfer('abcd', 'xy', size=0)
+  if (l1 /= 3 .or. s1 /= 0) stop 1
+  if (l4 /= 2 .or. s4 /= 0) stop 2
+  if (l2 /= 4 .or. l3 /= 4) stop 3
+  if (l5 /= 3 .or. s5 /= 0) stop 4
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_15.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_15.f90
new file mode 100644
index 00000000000..cdbec97ae71
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_15.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/104311 - ICE out of memory
+! Contributed by G.Steinmetz
+
+program p
+  type t
+  end type
+  type(t) :: x(2)
+  print *, transfer(1,x,2)       ! { dg-error "shall not have storage size 0" }
+  print *, transfer(1,x,huge(1)) ! { dg-error "shall not have storage size 0" }
+end
diff --git a/gcc/testsuite/gfortran.dg/ubsan/pr101624.f90 b/gcc/testsuite/gfortran.dg/ubsan/pr101624.f90
new file mode 100644
index 00000000000..51783c8ddad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ubsan/pr101624.f90
@@ -0,0 +1,13 @@
+! PR middle-end/101624
+! { dg-do compile }
+! { dg-options "-O2 -fsanitize=undefined" }
+
+complex function foo (x)
+  complex, intent(in) :: x
+  foo = aimag (x)
+end
+program pr101624
+  complex, parameter :: a = (0.0, 1.0)
+  complex :: b, foo
+  b = foo (a)
+end
diff --git a/gcc/testsuite/gfortran.dg/ubsan/ubsan.exp b/gcc/testsuite/gfortran.dg/ubsan/ubsan.exp
new file mode 100644
index 00000000000..e44d946c4a0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ubsan/ubsan.exp
@@ -0,0 +1,38 @@
+# Copyright (C) 2021 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite for gfortran that checks undefined behavior sanitizer.
+
+# Load support procs.
+load_lib gfortran-dg.exp
+load_lib ubsan-dg.exp
+
+
+# Initialize `dg'.
+dg-init
+ubsan_init
+
+# Main loop.
+if [check_effective_target_fsanitize_undefined] {
+    gfortran-dg-runtest [lsort \
+       [glob -nocomplain $srcdir/$subdir/*.\[fF\]{,90,95,03,08} ] ] "" ""
+}
+
+# All done.
+ubsan_finish
+dg-finish
diff --git a/gcc/tree-complex.c b/gcc/tree-complex.c
index d4b053d68e1..36a4d6f06d5 100644
--- a/gcc/tree-complex.c
+++ b/gcc/tree-complex.c
@@ -569,7 +569,8 @@ set_component_ssa_name (tree ssa_name, bool imag_p, tree value)
     {
       /* Replace an anonymous base value with the variable from cvc_lookup.
 	 This should result in better debug info.  */
-      if (SSA_NAME_VAR (ssa_name)
+      if (!SSA_NAME_IS_DEFAULT_DEF (value)
+	  && SSA_NAME_VAR (ssa_name)
 	  && (!SSA_NAME_VAR (value) || DECL_IGNORED_P (SSA_NAME_VAR (value)))
 	  && !DECL_IGNORED_P (SSA_NAME_VAR (ssa_name)))
 	{
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 8aa4e39b5b9..81b0229c6db 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -391,7 +391,7 @@ print_lambda_vector (FILE * outfile, lambda_vector vector, int n)
   int i;
 
   for (i = 0; i < n; i++)
-    fprintf (outfile, "%3d ", (int)vector[i]);
+    fprintf (outfile, HOST_WIDE_INT_PRINT_DEC " ", vector[i]);
   fprintf (outfile, "\n");
 }
 
diff --git a/gcc/tree-eh.c b/gcc/tree-eh.c
index c8063486f2d..426f0a12ef7 100644
--- a/gcc/tree-eh.c
+++ b/gcc/tree-eh.c
@@ -2435,13 +2435,35 @@ operation_could_trap_helper_p (enum tree_code op,
     case FLOOR_MOD_EXPR:
     case ROUND_MOD_EXPR:
     case TRUNC_MOD_EXPR:
-    case RDIV_EXPR:
-      if (honor_snans)
-	return true;
-      if (fp_operation)
-	return flag_trapping_math;
       if (!TREE_CONSTANT (divisor) || integer_zerop (divisor))
         return true;
+      if (TREE_CODE (divisor) == VECTOR_CST)
+	{
+	  /* Inspired by initializer_each_zero_or_onep.  */
+	  unsigned HOST_WIDE_INT nelts = vector_cst_encoded_nelts (divisor);
+	  if (VECTOR_CST_STEPPED_P (divisor)
+	      && !TYPE_VECTOR_SUBPARTS (TREE_TYPE (divisor))
+		    .is_constant (&nelts))
+	    return true;
+	  for (unsigned int i = 0; i < nelts; ++i)
+	    {
+	      tree elt = vector_cst_elt (divisor, i);
+	      if (integer_zerop (elt))
+		return true;
+	    }
+	}
+      return false;
+
+    case RDIV_EXPR:
+      if (fp_operation)
+	{
+	  if (honor_snans)
+	    return true;
+	  return flag_trapping_math;
+	}
+      /* Fixed point operations also use RDIV_EXPR.  */
+      if (!TREE_CONSTANT (divisor) || fixed_zerop (divisor))
+	return true;
       return false;
 
     case LT_EXPR:
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index 878f1631a17..5d3abab1e6a 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -2021,27 +2021,29 @@ copy_bb (copy_body_data *id, basic_block bb,
 	      tree p;
 	      gcall *new_call;
 	      vec<tree> argarray;
-	      size_t nargs = gimple_call_num_args (id->call_stmt);
-	      size_t n;
+	      size_t nargs_caller = gimple_call_num_args (id->call_stmt);
+	      size_t nargs = nargs_caller;
 
 	      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))
 		nargs--;
 
 	      /* Create the new array of arguments.  */
-	      n = nargs + gimple_call_num_args (call_stmt);
+	      size_t nargs_callee = gimple_call_num_args (call_stmt);
+	      size_t n = nargs + nargs_callee;
 	      argarray.create (n);
 	      argarray.safe_grow_cleared (n);
 
 	      /* Copy all the arguments before '...'  */
-	      memcpy (argarray.address (),
-		      gimple_call_arg_ptr (call_stmt, 0),
-		      gimple_call_num_args (call_stmt) * sizeof (tree));
+	      if (nargs_callee)
+		memcpy (argarray.address (),
+			gimple_call_arg_ptr (call_stmt, 0),
+			nargs_callee * sizeof (tree));
 
 	      /* Append the arguments passed in '...'  */
-	      memcpy (argarray.address () + gimple_call_num_args (call_stmt),
-		      gimple_call_arg_ptr (id->call_stmt, 0)
-		      + (gimple_call_num_args (id->call_stmt) - nargs),
-		      nargs * sizeof (tree));
+	      if (nargs)
+		memcpy (argarray.address () + nargs_callee,
+			gimple_call_arg_ptr (id->call_stmt, 0)
+			+ (nargs_caller - nargs), nargs * sizeof (tree));
 
 	      new_call = gimple_build_call_vec (gimple_call_fn (call_stmt),
 						argarray);
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index dc0cfe27142..a2ae3aefe4a 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -923,6 +923,7 @@ get_frame_field (struct nesting_info *info, tree target_context,
     }
 
   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);
+  TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (field);
   return x;
 }
 
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 909b4fef9a8..252953b7512 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -1530,7 +1530,8 @@ scan_function (void)
 		    }
 
 		  if (final_bbs
-		      && (flags & (ECF_CONST | ECF_PURE)) == 0)
+		      && ((flags & (ECF_CONST | ECF_PURE)) == 0
+			  || (flags & ECF_LOOPING_CONST_OR_PURE)))
 		    bitmap_set_bit (final_bbs, bb->index);
 		}
 
diff --git a/gcc/tree-ssa-address.c b/gcc/tree-ssa-address.c
index 2e5d87734d6..8ab1cb262df 100644
--- a/gcc/tree-ssa-address.c
+++ b/gcc/tree-ssa-address.c
@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "tree-affine.h"
 #include "gimplify.h"
+#include "builtins.h"
 
 /* FIXME: We compute address costs using RTL.  */
 #include "tree-ssa-address.h"
@@ -1015,45 +1016,24 @@ copy_ref_info (tree new_ref, tree old_ref)
 
   new_ptr_base = TREE_OPERAND (new_ref, 0);
 
+  tree base = get_base_address (old_ref);
+  if (!base)
+    return;
+
   /* We can transfer points-to information from an old pointer
      or decl base to the new one.  */
   if (new_ptr_base
       && TREE_CODE (new_ptr_base) == SSA_NAME
       && !SSA_NAME_PTR_INFO (new_ptr_base))
     {
-      tree base = get_base_address (old_ref);
-      if (!base)
-	;
-      else if ((TREE_CODE (base) == MEM_REF
-		|| TREE_CODE (base) == TARGET_MEM_REF)
-	       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME
-	       && SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)))
+      if ((TREE_CODE (base) == MEM_REF
+	   || TREE_CODE (base) == TARGET_MEM_REF)
+	  && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME
+	  && SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)))
 	{
-	  struct ptr_info_def *new_pi;
-	  unsigned int align, misalign;
-
 	  duplicate_ssa_name_ptr_info
 	    (new_ptr_base, SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)));
-	  new_pi = SSA_NAME_PTR_INFO (new_ptr_base);
-	  /* We have to be careful about transferring alignment information.  */
-	  if (get_ptr_info_alignment (new_pi, &align, &misalign)
-	      && TREE_CODE (old_ref) == MEM_REF
-	      && !(TREE_CODE (new_ref) == TARGET_MEM_REF
-		   && (TMR_INDEX2 (new_ref)
-		       /* TODO: Below conditions can be relaxed if TMR_INDEX
-			  is an indcution variable and its initial value and
-			  step are aligned.  */
-		       || (TMR_INDEX (new_ref) && !TMR_STEP (new_ref))
-		       || (TMR_STEP (new_ref)
-			   && (TREE_INT_CST_LOW (TMR_STEP (new_ref))
-			       < align)))))
-	    {
-	      poly_uint64 inc = (mem_ref_offset (old_ref)
-				 - mem_ref_offset (new_ref)).force_uhwi ();
-	      adjust_ptr_info_misalignment (new_pi, inc);
-	    }
-	  else
-	    mark_ptr_info_alignment_unknown (new_pi);
+	  reset_flow_sensitive_info (new_ptr_base);
 	}
       else if (VAR_P (base)
 	       || TREE_CODE (base) == PARM_DECL
@@ -1063,6 +1043,14 @@ copy_ref_info (tree new_ref, tree old_ref)
 	  pt_solution_set_var (&pi->pt, base);
 	}
     }
+
+  /* And alignment info.  Note we cannot transfer misalignment info
+     since that sits on the SSA name but this is flow-sensitive info
+     which we cannot transfer in this generic routine.  */
+  unsigned old_align = get_object_alignment (old_ref);
+  unsigned new_align = get_object_alignment (new_ref);
+  if (new_align < old_align)
+    TREE_TYPE (new_ref) = build_aligned_type (TREE_TYPE (new_ref), old_align);
 }
 
 /* Move constants in target_mem_ref REF to offset.  Returns the new target
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index b0d56fcf3e3..5bb337b5417 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -695,7 +695,8 @@ pass_dominator::execute (function *fun)
      gcc.dg/tree-ssa/pr21417.c can't be threaded if loop preheader is
      missing.  We should improve jump threading in future then
      LOOPS_HAVE_PREHEADERS won't be needed here.  */
-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES
+		       | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS);
 
   /* Initialize the value-handle array.  */
   threadedge_initialize_values ();
diff --git a/gcc/tree-ssa-loop-im.c b/gcc/tree-ssa-loop-im.c
index 2064c2900fb..3f4ece1eb83 100644
--- a/gcc/tree-ssa-loop-im.c
+++ b/gcc/tree-ssa-loop-im.c
@@ -1170,14 +1170,10 @@ move_computations_worker (basic_block bb)
 					  COND_EXPR, t, arg0, arg1);
 	  todo |= TODO_cleanup_cfg;
 	}
-      if (INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (new_stmt)))
-	  && (!ALWAYS_EXECUTED_IN (bb)
-	      || (ALWAYS_EXECUTED_IN (bb) != level
-		  && !flow_loop_nested_p (ALWAYS_EXECUTED_IN (bb), level))))
-	{
-	  tree lhs = gimple_assign_lhs (new_stmt);
-	  SSA_NAME_RANGE_INFO (lhs) = NULL;
-	}
+      if (!ALWAYS_EXECUTED_IN (bb)
+	  || (ALWAYS_EXECUTED_IN (bb) != level
+	      && !flow_loop_nested_p (ALWAYS_EXECUTED_IN (bb), level)))
+	reset_flow_sensitive_info (gimple_assign_lhs (new_stmt));
       gsi_insert_on_edge (loop_preheader_edge (level), new_stmt);
       remove_phi_node (&bsi, false);
     }
@@ -1239,14 +1235,10 @@ move_computations_worker (basic_block bb)
       gsi_remove (&bsi, false);
       if (gimple_has_lhs (stmt)
 	  && TREE_CODE (gimple_get_lhs (stmt)) == SSA_NAME
-	  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_get_lhs (stmt)))
 	  && (!ALWAYS_EXECUTED_IN (bb)
 	      || !(ALWAYS_EXECUTED_IN (bb) == level
 		   || flow_loop_nested_p (ALWAYS_EXECUTED_IN (bb), level))))
-	{
-	  tree lhs = gimple_get_lhs (stmt);
-	  SSA_NAME_RANGE_INFO (lhs) = NULL;
-	}
+	reset_flow_sensitive_info (gimple_get_lhs (stmt));
       /* In case this is a stmt that is not unconditionally executed
          when the target loop header is executed and the stmt may
 	 invoke undefined integer or pointer overflow rewrite it to
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
index e5a47c6614b..ca1003361bb 100644
--- a/gcc/tree-ssa-phiopt.c
+++ b/gcc/tree-ssa-phiopt.c
@@ -753,9 +753,12 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,
   if ((integer_zerop (arg0) && integer_onep (arg1))
       || (integer_zerop (arg1) && integer_onep (arg0)))
     neg = false;
+  /* For signed one bit types, the negation is not needed and
+     should be avoided and is the same as 1 case for non-signed
+     one bit types.  */
   else if ((integer_zerop (arg0) && integer_all_onesp (arg1))
 	   || (integer_zerop (arg1) && integer_all_onesp (arg0)))
-    neg = true;
+    neg = TYPE_PRECISION (TREE_TYPE (arg0)) != 1;
   else
     return false;
 
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index c163c3823c2..5583db6db50 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -1972,6 +1972,13 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)
 			  && value_dies_in_block_x (expr, block))))
 		to_remove = i;
 	    }
+	  /* If the REFERENCE may trap make sure the block does not contain
+	     a possible exit point.
+	     ???  This is overly conservative if we translate AVAIL_OUT
+	     as the available expression might be after the exit point.  */
+	  if (BB_MAY_NOTRETURN (block)
+	      && vn_reference_may_trap (ref))
+	    to_remove = i;
 	}
       else if (expr->kind == NARY)
 	{
@@ -3302,7 +3309,11 @@ do_pre_regular_insertion (basic_block block, basic_block dom)
 	  /* If all edges produce the same value and that value is
 	     an invariant, then the PHI has the same value on all
 	     edges.  Note this.  */
-	  else if (!cant_insert && all_same)
+	  else if (!cant_insert
+		   && all_same
+		   && (edoubleprime->kind != NAME
+		       || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI
+			     (PRE_EXPR_NAME (edoubleprime))))
 	    {
 	      gcc_assert (edoubleprime->kind == CONSTANT
 			  || edoubleprime->kind == NAME);
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 066a0559b71..ccd3e1c4cc7 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -5080,8 +5080,7 @@ eliminate_dom_walker::eliminate_stmt (basic_block b, gimple_stmt_iterator *gsi)
 	      duplicate_ssa_name_ptr_info (sprime,
 					   SSA_NAME_PTR_INFO (lhs));
 	      if (b != sprime_b)
-		mark_ptr_info_alignment_unknown
-		    (SSA_NAME_PTR_INFO (sprime));
+		reset_flow_sensitive_info (sprime);
 	    }
 	  else if (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
 		   && SSA_NAME_RANGE_INFO (lhs)
diff --git a/gcc/tree-switch-conversion.c b/gcc/tree-switch-conversion.c
index dd6dd8064de..32c5f794ff2 100644
--- a/gcc/tree-switch-conversion.c
+++ b/gcc/tree-switch-conversion.c
@@ -1120,7 +1120,8 @@ group_cluster::dump (FILE *f, bool details)
 
 void
 jump_table_cluster::emit (tree index_expr, tree,
-			  tree default_label_expr, basic_block default_bb)
+			  tree default_label_expr, basic_block default_bb,
+			  location_t loc)
 {
   unsigned HOST_WIDE_INT range = get_range (get_low (), get_high ());
   unsigned HOST_WIDE_INT nondefault_range = 0;
@@ -1139,6 +1140,7 @@ jump_table_cluster::emit (tree index_expr, tree,
 
   gswitch *s = gimple_build_switch (index_expr,
 				    unshare_expr (default_label_expr), labels);
+  gimple_set_location (s, loc);
   gimple_stmt_iterator gsi = gsi_start_bb (m_case_bb);
   gsi_insert_after (&gsi, s, GSI_NEW_STMT);
 
@@ -1478,7 +1480,7 @@ case_bit_test::cmp (const void *p1, const void *p2)
 
 void
 bit_test_cluster::emit (tree index_expr, tree index_type,
-			tree, basic_block default_bb)
+			tree, basic_block default_bb, location_t loc)
 {
   struct case_bit_test test[m_max_case_bit_tests] = { {} };
   unsigned int i, j, k;
@@ -1572,9 +1574,9 @@ bit_test_cluster::emit (tree index_expr, tree index_type,
   gsi = gsi_last_bb (m_case_bb);
 
   /* idx = (unsigned)x - minval.  */
-  idx = fold_convert (unsigned_index_type, index_expr);
-  idx = fold_build2 (MINUS_EXPR, unsigned_index_type, idx,
-		     fold_convert (unsigned_index_type, minval));
+  idx = fold_convert_loc (loc, unsigned_index_type, index_expr);
+  idx = fold_build2_loc (loc, MINUS_EXPR, unsigned_index_type, idx,
+			 fold_convert_loc (loc, unsigned_index_type, minval));
   idx = force_gimple_operand_gsi (&gsi, idx,
 				  /*simple=*/true, NULL_TREE,
 				  /*before=*/true, GSI_SAME_STMT);
@@ -1587,17 +1589,17 @@ bit_test_cluster::emit (tree index_expr, tree index_type,
 				    fold_convert (unsigned_index_type, range),
 				    /*simple=*/true, NULL_TREE,
 				    /*before=*/true, GSI_SAME_STMT);
-      tmp = fold_build2 (GT_EXPR, boolean_type_node, idx, range);
+      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, idx, range);
       basic_block new_bb
 	= hoist_edge_and_branch_if_true (&gsi, tmp, default_bb,
-					 profile_probability::unlikely ());
+					 profile_probability::unlikely (), loc);
       gsi = gsi_last_bb (new_bb);
     }
 
   /* csui = (1 << (word_mode) idx) */
   csui = make_ssa_name (word_type_node);
-  tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,
-		     fold_convert (word_type_node, idx));
+  tmp = fold_build2_loc (loc, LSHIFT_EXPR, word_type_node, word_mode_one,
+			 fold_convert_loc (loc, word_type_node, idx));
   tmp = force_gimple_operand_gsi (&gsi, tmp,
 				  /*simple=*/false, NULL_TREE,
 				  /*before=*/true, GSI_SAME_STMT);
@@ -1615,13 +1617,15 @@ bit_test_cluster::emit (tree index_expr, tree index_type,
 							 bt_range);
       bt_range -= test[k].bits;
       tmp = wide_int_to_tree (word_type_node, test[k].mask);
-      tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);
+      tmp = fold_build2_loc (loc, BIT_AND_EXPR, word_type_node, csui, tmp);
       tmp = force_gimple_operand_gsi (&gsi, tmp,
 				      /*simple=*/true, NULL_TREE,
 				      /*before=*/true, GSI_SAME_STMT);
-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);
+      tmp = fold_build2_loc (loc, NE_EXPR, boolean_type_node,
+			     tmp, word_mode_zero);
       basic_block new_bb
-	= hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_bb, prob);
+	= hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_bb,
+					 prob, loc);
       gsi = gsi_last_bb (new_bb);
     }
 
@@ -1651,7 +1655,8 @@ bit_test_cluster::emit (tree index_expr, tree index_type,
 basic_block
 bit_test_cluster::hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,
 						 tree cond, basic_block case_bb,
-						 profile_probability prob)
+						 profile_probability prob,
+						 location_t loc)
 {
   tree tmp;
   gcond *cond_stmt;
@@ -1665,6 +1670,7 @@ bit_test_cluster::hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,
   tmp = force_gimple_operand_gsi (gsip, cond, /*simple=*/true, NULL,
 				  /*before=*/true, GSI_SAME_STMT);
   cond_stmt = gimple_build_cond_from_tree (tmp, NULL_TREE, NULL_TREE);
+  gimple_set_location (cond_stmt, loc);
   gsi_insert_before (gsip, cond_stmt, GSI_SAME_STMT);
 
   e_false = split_block (split_bb, cond_stmt);
@@ -1844,7 +1850,8 @@ switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)
     {
       cluster *c = clusters[0];
       c->emit (index_expr, index_type,
-	       gimple_switch_default_label (m_switch), m_default_bb);
+	       gimple_switch_default_label (m_switch), m_default_bb,
+	       gimple_location (m_switch));
       redirect_edge_succ (single_succ_edge (bb), c->m_case_bb);
     }
   else
@@ -1856,7 +1863,7 @@ switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)
 	if (clusters[i]->get_type () != SIMPLE_CASE)
 	  clusters[i]->emit (index_expr, index_type,
 			     gimple_switch_default_label (m_switch),
-			     m_default_bb);
+			     m_default_bb, gimple_location (m_switch));
     }
 
   fix_phi_operands_for_edges ();
diff --git a/gcc/tree-switch-conversion.h b/gcc/tree-switch-conversion.h
index b3bc4b9ddf7..e174b47e191 100644
--- a/gcc/tree-switch-conversion.h
+++ b/gcc/tree-switch-conversion.h
@@ -70,7 +70,7 @@ struct cluster
   virtual void dump (FILE *f, bool details = false) = 0;
 
   /* Emit GIMPLE code to handle the cluster.  */
-  virtual void emit (tree, tree, tree, basic_block) = 0;
+  virtual void emit (tree, tree, tree, basic_block, location_t) = 0;
 
   /* Return true if a cluster handles only a single case value and the
      value is not a range.  */
@@ -163,7 +163,7 @@ struct simple_cluster: public cluster
     fprintf (f, " ");
   }
 
-  void emit (tree, tree, tree, basic_block)
+  void emit (tree, tree, tree, basic_block, location_t)
   {
     gcc_unreachable ();
   }
@@ -247,7 +247,7 @@ struct jump_table_cluster: public group_cluster
   }
 
   void emit (tree index_expr, tree index_type,
-	     tree default_label_expr, basic_block default_bb);
+	     tree default_label_expr, basic_block default_bb, location_t loc);
 
   /* Find jump tables of given CLUSTERS, where all members of the vector
      are of type simple_cluster.  New clusters are returned.  */
@@ -370,7 +370,7 @@ struct bit_test_cluster: public group_cluster
     There *MUST* be max_case_bit_tests or less unique case
     node targets.  */
   void emit (tree index_expr, tree index_type,
-	     tree default_label_expr, basic_block default_bb);
+	     tree default_label_expr, basic_block default_bb, location_t loc);
 
   /* Find bit tests of given CLUSTERS, where all members of the vector
      are of type simple_cluster.  New clusters are returned.  */
@@ -411,7 +411,8 @@ struct bit_test_cluster: public group_cluster
   static basic_block hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,
 						    tree cond,
 						    basic_block case_bb,
-						    profile_probability prob);
+						    profile_probability prob,
+						    location_t);
 
   /* True when the jump table handles an entire switch statement.  */
   bool m_handles_entire_switch;
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index f2e1766432b..6d3806fc334 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -3424,9 +3424,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
   /* Step values are irrelevant for aliasing if the number of vector
      iterations is equal to the number of scalar iterations (which can
      happen for fully-SLP loops).  */
-  bool ignore_step_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
+  bool vf_one_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
 
-  if (!ignore_step_p)
+  if (!vf_one_p)
     {
       /* Convert the checks for nonzero steps into bound tests.  */
       tree value;
@@ -3478,10 +3478,18 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
       dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (DDR_B (ddr));
       stmt_vec_info stmt_info_b = dr_info_b->stmt;
 
+      bool preserves_scalar_order_p
+	= vect_preserves_scalar_order_p (dr_info_a, dr_info_b);
+      bool ignore_step_p
+	  = (vf_one_p
+	     && (preserves_scalar_order_p
+		 || operand_equal_p (DR_STEP (dr_info_a->dr),
+				     DR_STEP (dr_info_b->dr), 0)));
+
       /* Skip the pair if inter-iteration dependencies are irrelevant
 	 and intra-iteration dependencies are guaranteed to be honored.  */
       if (ignore_step_p
-	  && (vect_preserves_scalar_order_p (dr_info_a, dr_info_b)
+	  && (preserves_scalar_order_p
 	      || vectorizable_with_step_bound_p (dr_info_a, dr_info_b,
 						 &lower_bound)))
 	{
@@ -4556,7 +4564,8 @@ vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,
 
   if (DR_PTR_INFO (dr)
       && TREE_CODE (addr_base) == SSA_NAME
-      && !SSA_NAME_PTR_INFO (addr_base))
+      /* We should only duplicate pointer info to newly created SSA names.  */
+      && SSA_NAME_VAR (addr_base) == dest)
     {
       vect_duplicate_ssa_name_ptr_info (addr_base, dr_info);
       if (offset || byte_offset)
diff --git a/gcc/tree-vect-loop-manip.c b/gcc/tree-vect-loop-manip.c
index 030effcd79d..4951e1d505f 100644
--- a/gcc/tree-vect-loop-manip.c
+++ b/gcc/tree-vect-loop-manip.c
@@ -1774,7 +1774,8 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,
   FOR_EACH_VEC_ELT (datarefs, i, dr)
     {
       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);
-      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt))
+      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt)
+	  && !STMT_VINFO_SIMD_LANE_ACCESS_P (dr_info->stmt))
 	vect_update_init_of_dr (dr, niters, code);
     }
 }
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 21c53cbb4a7..795ab61a63b 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -2925,6 +2925,17 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,
 	}
     }
 
+  /* When the inner loop of a double reduction ends up with more than
+     one loop-closed PHI we have failed to classify alternate such
+     PHIs as double reduction, leading to wrong code.  See PR103237.  */
+  if (inner_loop_of_double_reduc && lcphis.length () != 1)
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "unhandle double reduction\n");
+      return NULL;
+    }
+
   /* If this isn't a nested cycle or if the nested cycle reduction value
      is used ouside of the inner loop we cannot handle uses of the reduction
      value.  */
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index 394c6ec39cd..3322abd86f9 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -2051,9 +2051,8 @@ vect_analyze_slp_instance (vec_info *vinfo,
 		  /* The load requires permutation when unrolling exposes
 		     a gap either because the group is larger than the SLP
 		     group-size or because there is a gap between the groups.  */
-		  && (known_eq (unrolling_factor, 1U)
-		      || (group_size == DR_GROUP_SIZE (first_stmt_info)
-			  && DR_GROUP_GAP (first_stmt_info) == 0)))
+		  && group_size == DR_GROUP_SIZE (first_stmt_info)
+		  && DR_GROUP_GAP (first_stmt_info) == 0)
 		{
 		  load_permutation.release ();
 		  continue;
diff --git a/gcc/tree.c b/gcc/tree.c
index be311754393..99f4318306a 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -12340,7 +12340,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	case OMP_CLAUSE_DEFAULTMAP:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
-	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE__SIMT_:
 	case OMP_CLAUSE_IF_PRESENT:
 	case OMP_CLAUSE_FINALIZE:
@@ -12352,6 +12351,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));
 
 	case OMP_CLAUSE_COLLAPSE:
+	case OMP_CLAUSE_TILE:
 	  {
 	    int i;
 	    for (i = 0; i < 3; i++)
diff --git a/gcc/ubsan.c b/gcc/ubsan.c
index 5d4af79177c..1803f2d5cf9 100644
--- a/gcc/ubsan.c
+++ b/gcc/ubsan.c
@@ -1440,7 +1440,10 @@ maybe_instrument_pointer_overflow (gimple_stmt_iterator *gsi, tree t)
   tree base;
   if (decl_p)
     {
-      if (DECL_REGISTER (inner))
+      if ((VAR_P (inner)
+	   || TREE_CODE (inner) == PARM_DECL
+	   || TREE_CODE (inner) == RESULT_DECL)
+	  && DECL_REGISTER (inner))
 	return;
       base = inner;
       /* If BASE is a fixed size automatic variable or
@@ -2104,7 +2107,12 @@ instrument_object_size (gimple_stmt_iterator *gsi, tree t, bool is_lhs)
   tree base;
   if (decl_p)
     {
-      if (DECL_REGISTER (inner))
+      if ((VAR_P (inner)
+	   || TREE_CODE (inner) == PARM_DECL
+	   || TREE_CODE (inner) == RESULT_DECL)
+	  && DECL_REGISTER (inner))
+	return;
+      if (t == inner && !is_global_var (t))
 	return;
       base = inner;
     }
@@ -2203,6 +2211,11 @@ instrument_object_size (gimple_stmt_iterator *gsi, tree t, bool is_lhs)
 	}
     }
 
+  if (DECL_P (base)
+      && decl_function_context (base) == current_function_decl
+      && !TREE_ADDRESSABLE (base))
+    mark_addressable (base);
+
   if (bos_stmt && gimple_call_builtin_p (bos_stmt, BUILT_IN_OBJECT_SIZE))
     ubsan_create_edge (bos_stmt);
 
diff --git a/gcc/valtrack.c b/gcc/valtrack.c
index 1f67378a867..793e5c2184f 100644
--- a/gcc/valtrack.c
+++ b/gcc/valtrack.c
@@ -559,7 +559,9 @@ debug_lowpart_subreg (machine_mode outer_mode, rtx expr,
   rtx ret = simplify_gen_subreg (outer_mode, expr, inner_mode, offset);
   if (ret)
     return ret;
-  return gen_rtx_raw_SUBREG (outer_mode, expr, offset);
+  if (GET_MODE (expr) != VOIDmode)
+    return gen_rtx_raw_SUBREG (outer_mode, expr, offset);
+  return NULL_RTX;
 }
 
 /* If UREGNO is referenced by any entry in DEBUG, emit a debug insn
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 7749be05b6f..944059d800f 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -5251,14 +5251,20 @@ output_constructor_regular_field (oc_local_state *local)
 	  && (!TYPE_DOMAIN (TREE_TYPE (local->field))
 	      || !TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (local->field)))))
 	{
-	  fieldsize = array_size_for_constructor (local->val);
+	  unsigned HOST_WIDE_INT fldsize
+	    = array_size_for_constructor (local->val);
+	  fieldsize = int_size_in_bytes (TREE_TYPE (local->val));
+	  /* In most cases fieldsize == fldsize as the size of the initializer
+	     determines how many elements the flexible array member has.  For
+	     C++ fldsize can be smaller though, if the last or several last or
+	     all initializers of the flexible array member have side-effects
+	     and the FE splits them into dynamic initialization.  */
+	  gcc_checking_assert (fieldsize >= fldsize);
 	  /* Given a non-empty initialization, this field had better
 	     be last.  Given a flexible array member, the next field
 	     on the chain is a TYPE_DECL of the enclosing struct.  */
 	  const_tree next = DECL_CHAIN (local->field);
 	  gcc_assert (!fieldsize || !next || TREE_CODE (next) != FIELD_DECL);
-	  tree size = TYPE_SIZE_UNIT (TREE_TYPE (local->val));
-	  gcc_checking_assert (compare_tree_int (size, fieldsize) == 0);
 	}
       else
 	fieldsize = tree_to_uhwi (DECL_SIZE_UNIT (local->field));
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index a823e93567b..da8a767560e 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,32 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/104147
+	* macro.c (funlike_invocation_p): For padding prefer a token
+	with val.source non-NULL especially if it has PREV_WHITE set
+	on val.source->flags.  Add gcc_assert that CPP_PADDING tokens
+	don't have PREV_WHITE set in flags.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* directives.c (destringize_and_run): Push &pfile->avoid_paste
+	instead of a copy of pfile->directive_result for the CPP_PADDING
+	case.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-12-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/89971
+	* macro.c (replace_args): For ##__VA_OPT__, if __VA_OPT__ expands
+	to no tokens at all, drop PASTE_LEFT flag from the previous token.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libcpp/directives.c b/libcpp/directives.c
index d78e4b7fc19..a41fb90764f 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -1896,8 +1896,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in,
   else
     {
       count = 1;
-      toks = XNEW (cpp_token);
-      toks[0] = pfile->directive_result;
+      toks = &pfile->avoid_paste;
 
       /* If we handled the entire pragma internally, make sure we get the
 	 line number correct for the next token.  */
diff --git a/libcpp/macro.c b/libcpp/macro.c
index 30d3686451c..5f50438cf4f 100644
--- a/libcpp/macro.c
+++ b/libcpp/macro.c
@@ -1209,8 +1209,11 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,
       token = cpp_get_token (pfile);
       if (token->type != CPP_PADDING)
 	break;
+      gcc_assert ((token->flags & PREV_WHITE) == 0);
       if (padding == NULL
-	  || (!(padding->flags & PREV_WHITE) && token->val.source == NULL))
+	  || padding->val.source == NULL
+	  || (!(padding->val.source->flags & PREV_WHITE)
+	      && token->val.source == NULL))
 	padding = token;
     }
 
@@ -1886,6 +1889,11 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,
 		  paste_flag = tokens_buff_last_token_ptr (buff);
 		}
 
+	      if (start && paste_flag == start && (*start)->flags & PASTE_LEFT)
+		/* If __VA_OPT__ expands to nothing (either because __VA_ARGS__
+		   is empty or because it is __VA_OPT__() ), drop PASTE_LEFT
+		   flag from previous token.  */
+		copy_paste_flag (pfile, start, &pfile->avoid_paste);
 	      if (src->flags & PASTE_LEFT)
 		{
 		  /* With a non-empty __VA_OPT__ on the LHS of ##, the last
diff --git a/libffi/ChangeLog b/libffi/ChangeLog
index 2027b848cc9..52ba40669f2 100644
--- a/libffi/ChangeLog
+++ b/libffi/ChangeLog
@@ -1,3 +1,14 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/x86/ffi64.c (classify_argument): For FFI_TYPE_STRUCT set words
+	to number of words needed for type->size + byte_offset bytes rather
+	than just type->size bytes.  Compute pos before the loop and check
+	total size of the structure.
+	* testsuite/libffi.call/nested_struct12.c: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libffi/src/x86/ffi64.c b/libffi/src/x86/ffi64.c
index 131b5e3d148..243cbc7689a 100644
--- a/libffi/src/x86/ffi64.c
+++ b/libffi/src/x86/ffi64.c
@@ -217,7 +217,8 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
     case FFI_TYPE_STRUCT:
       {
 	const size_t UNITS_PER_WORD = 8;
-	size_t words = (type->size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+	size_t words = (type->size + byte_offset + UNITS_PER_WORD - 1)
+		       / UNITS_PER_WORD;
 	ffi_type **ptr;
 	int i;
 	enum x86_64_reg_class subclasses[MAX_CLASSES];
@@ -241,16 +242,16 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
 	/* Merge the fields of structure.  */
 	for (ptr = type->elements; *ptr != NULL; ptr++)
 	  {
-	    size_t num;
+	    size_t num, pos;
 
 	    byte_offset = ALIGN (byte_offset, (*ptr)->alignment);
 
 	    num = classify_argument (*ptr, subclasses, byte_offset % 8);
 	    if (num == 0)
 	      return 0;
-	    for (i = 0; i < num; i++)
+	    pos = byte_offset / 8;
+	    for (i = 0; i < num && (i + pos) < words; i++)
 	      {
-		size_t pos = byte_offset / 8;
 		classes[i + pos] =
 		  merge_classes (subclasses[i], classes[i + pos]);
 	      }
diff --git a/libffi/testsuite/libffi.call/nested_struct12.c b/libffi/testsuite/libffi.call/nested_struct12.c
new file mode 100644
index 00000000000..6f3d7369f27
--- /dev/null
+++ b/libffi/testsuite/libffi.call/nested_struct12.c
@@ -0,0 +1,107 @@
+/* Area:	ffi_call, closure_call
+   Purpose:	Check structure passing.
+   Limitations:	none.
+   PR:		none.
+   Originator:	<jincheng@ca.ibm.com> and <jakub@redhat.com> 20210609	 */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct A {
+  float a, b;
+} A;
+
+typedef struct B {
+  float x;
+  struct A y;
+} B;
+
+B B_fn(float b0, struct B b1)
+{
+  struct B result;
+
+  result.x = b0 + b1.x;
+  result.y.a = b0 + b1.y.a;
+  result.y.b = b0 + b1.y.b;
+
+  printf("%g %g %g %g: %g %g %g\n", b0, b1.x, b1.y.a, b1.y.b,
+	 result.x, result.y.a, result.y.b);
+
+  return result;
+}
+
+static void
+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
+     void* userdata __UNUSED__)
+{
+  float b0;
+  struct B b1;
+
+  b0 = *(float*)(args[0]);
+  b1 = *(struct B*)(args[1]);
+
+  *(B*)resp = B_fn(b0, b1);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  void* args_dbl[3];
+  ffi_type* cls_struct_fields[3];
+  ffi_type* cls_struct_fields1[3];
+  ffi_type cls_struct_type, cls_struct_type1;
+  ffi_type* dbl_arg_types[3];
+
+  float e_dbl = 12.125f;
+  struct B f_dbl = { 24.75f, { 31.625f, 32.25f } };
+
+  struct B res_dbl;
+
+  cls_struct_type.size = 0;
+  cls_struct_type.alignment = 0;
+  cls_struct_type.type = FFI_TYPE_STRUCT;
+  cls_struct_type.elements = cls_struct_fields;
+
+  cls_struct_type1.size = 0;
+  cls_struct_type1.alignment = 0;
+  cls_struct_type1.type = FFI_TYPE_STRUCT;
+  cls_struct_type1.elements = cls_struct_fields1;
+
+  cls_struct_fields[0] = &ffi_type_float;
+  cls_struct_fields[1] = &ffi_type_float;
+  cls_struct_fields[2] = NULL;
+
+  cls_struct_fields1[0] = &ffi_type_float;
+  cls_struct_fields1[1] = &cls_struct_type;
+  cls_struct_fields1[2] = NULL;
+
+
+  dbl_arg_types[0] = &ffi_type_float;
+  dbl_arg_types[1] = &cls_struct_type1;
+  dbl_arg_types[2] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,
+		     dbl_arg_types) == FFI_OK);
+
+  args_dbl[0] = &e_dbl;
+  args_dbl[1] = &f_dbl;
+  args_dbl[2] = NULL;
+
+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);
+  /* { dg-output "12.125 24.75 31.625 32.25: 36.875 43.75 44.375" } */
+  CHECK( res_dbl.x == (e_dbl + f_dbl.x));
+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));
+  CHECK( res_dbl.y.b == (e_dbl + f_dbl.y.b));
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);
+
+  res_dbl = ((B(*)(float, B))(code))(e_dbl, f_dbl);
+  /* { dg-output "\n12.125 24.75 31.625 32.25: 36.875 43.75 44.375" } */
+  CHECK( res_dbl.x == (e_dbl + f_dbl.x));
+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));
+  CHECK( res_dbl.y.b == (e_dbl + f_dbl.y.b));
+
+  exit(0);
+}
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 399ab06f58b..252af8fd3db 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,25 @@
+2021-10-27  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config.host (hppa*64*-*-linux*): Don't add pa/t-linux to
+	tmake_file.
+	* config/pa/linux-atomic.c: Define u8, u16 and u64 types.
+	Use them in FETCH_AND_OP_2, OP_AND_FETCH_2, COMPARE_AND_SWAP_2,
+	SYNC_LOCK_TEST_AND_SET_2 and SYNC_LOCK_RELEASE_1 macros.
+	* config/pa/t-linux64 (LIB1ASMSRC): New define.
+	(LIB1ASMFUNCS): Revise.
+	(HOST_LIBGCC2_CFLAGS): Add "-DLINUX=1".
+
+2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/value-unwind.h: Add missing runtime exception
+	paragraph.
+	* config/frv/frv-abi.h: Likewise.
+	* config/i386/value-unwind.h: Likewise.
+	* config/pa/pa64-hpux-lib.h: Likewise.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index bdbf77a3e62..0486a0135e8 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -566,7 +566,7 @@ h8300-*-linux*)
 	tm_file="$tm_file h8300/h8300-lib.h"
 	;;
 hppa*64*-*-linux*)
-	tmake_file="$tmake_file pa/t-linux pa/t-linux64"
+	tmake_file="$tmake_file pa/t-linux64"
 	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
 	;;
 hppa*-*-linux*)
diff --git a/libgcc/config/aarch64/value-unwind.h b/libgcc/config/aarch64/value-unwind.h
index 8e99d8e12ae..fb40f639fa9 100644
--- a/libgcc/config/aarch64/value-unwind.h
+++ b/libgcc/config/aarch64/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/frv/frv-abi.h b/libgcc/config/frv/frv-abi.h
index 45ad606e785..45ac387b054 100644
--- a/libgcc/config/frv/frv-abi.h
+++ b/libgcc/config/frv/frv-abi.h
@@ -14,6 +14,10 @@
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/i386/value-unwind.h b/libgcc/config/i386/value-unwind.h
index 5c1157d00e8..e3c8b6356b3 100644
--- a/libgcc/config/i386/value-unwind.h
+++ b/libgcc/config/i386/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
index 4cd69f74cd2..0e7e83c8586 100644
--- a/libgcc/config/pa/linux-atomic.c
+++ b/libgcc/config/pa/linux-atomic.c
@@ -28,6 +28,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define EBUSY   16
 #define ENOSYS 251 
 
+typedef unsigned char u8;
+typedef short unsigned int u16;
+#ifdef __LP64__
+typedef long unsigned int u64;
+#else
+typedef long long unsigned int u64;
+#endif
+
 /* PA-RISC 2.0 supports out-of-order execution for loads and stores.
    Thus, we need to synchonize memory accesses.  For more info, see:
    "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
@@ -117,26 +125,26 @@ __kernel_cmpxchg2 (volatile void *mem, const void *oldval, const void *newval,
     return tmp;								\
   }
 
-FETCH_AND_OP_2 (add,   , +, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (sub,   , -, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (or,    , |, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (and,   , &, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (xor,   , ^, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-FETCH_AND_OP_2 (add,   , +, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (sub,   , -, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (or,    , |, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (and,   , &, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (xor,   , ^, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (nand, ~, &, short unsigned int, 2, 1)
-
-FETCH_AND_OP_2 (add,   , +, unsigned char, 1, 0)
-FETCH_AND_OP_2 (sub,   , -, unsigned char, 1, 0)
-FETCH_AND_OP_2 (or,    , |, unsigned char, 1, 0)
-FETCH_AND_OP_2 (and,   , &, unsigned char, 1, 0)
-FETCH_AND_OP_2 (xor,   , ^, unsigned char, 1, 0)
-FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
+FETCH_AND_OP_2 (add,   , +, u64, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, u64, 8, 3)
+FETCH_AND_OP_2 (or,    , |, u64, 8, 3)
+FETCH_AND_OP_2 (and,   , &, u64, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, u64, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, u64, 8, 3)
+
+FETCH_AND_OP_2 (add,   , +, u16, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, u16, 2, 1)
+FETCH_AND_OP_2 (or,    , |, u16, 2, 1)
+FETCH_AND_OP_2 (and,   , &, u16, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, u16, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, u16, 2, 1)
+
+FETCH_AND_OP_2 (add,   , +, u8, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, u8, 1, 0)
+FETCH_AND_OP_2 (or,    , |, u8, 1, 0)
+FETCH_AND_OP_2 (and,   , &, u8, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, u8, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, u8, 1, 0)
 
 #define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
@@ -154,26 +162,26 @@ FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
     return PFX_OP (tmp INF_OP val);					\
   }
 
-OP_AND_FETCH_2 (add,   , +, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (sub,   , -, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (or,    , |, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (and,   , &, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (xor,   , ^, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-OP_AND_FETCH_2 (add,   , +, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (sub,   , -, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (or,    , |, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (and,   , &, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (xor,   , ^, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (nand, ~, &, short unsigned int, 2, 1)
-
-OP_AND_FETCH_2 (add,   , +, unsigned char, 1, 0)
-OP_AND_FETCH_2 (sub,   , -, unsigned char, 1, 0)
-OP_AND_FETCH_2 (or,    , |, unsigned char, 1, 0)
-OP_AND_FETCH_2 (and,   , &, unsigned char, 1, 0)
-OP_AND_FETCH_2 (xor,   , ^, unsigned char, 1, 0)
-OP_AND_FETCH_2 (nand, ~, &, unsigned char, 1, 0)
+OP_AND_FETCH_2 (add,   , +, u64, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, u64, 8, 3)
+OP_AND_FETCH_2 (or,    , |, u64, 8, 3)
+OP_AND_FETCH_2 (and,   , &, u64, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, u64, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, u64, 8, 3)
+
+OP_AND_FETCH_2 (add,   , +, u16, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, u16, 2, 1)
+OP_AND_FETCH_2 (or,    , |, u16, 2, 1)
+OP_AND_FETCH_2 (and,   , &, u16, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, u16, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, u16, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, u8, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, u8, 1, 0)
+OP_AND_FETCH_2 (or,    , |, u8, 1, 0)
+OP_AND_FETCH_2 (and,   , &, u8, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, u8, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, u8, 1, 0)
 
 #define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
   unsigned int HIDDEN							\
@@ -254,9 +262,9 @@ typedef unsigned char bool;
     return (failure == 0);						\
   }
 
-COMPARE_AND_SWAP_2 (long long unsigned int, 8, 3)
-COMPARE_AND_SWAP_2 (short unsigned int, 2, 1)
-COMPARE_AND_SWAP_2 (unsigned char, 1, 0)
+COMPARE_AND_SWAP_2 (u64, 8, 3)
+COMPARE_AND_SWAP_2 (u16, 2, 1)
+COMPARE_AND_SWAP_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_val_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
@@ -304,9 +312,9 @@ TYPE HIDDEN								\
     return oldval;							\
   }
 
-SYNC_LOCK_TEST_AND_SET_2 (long long unsigned int, 8, 3)
-SYNC_LOCK_TEST_AND_SET_2 (short unsigned int, 2, 1)
-SYNC_LOCK_TEST_AND_SET_2 (unsigned char, 1, 0)
+SYNC_LOCK_TEST_AND_SET_2 (u64, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (u16, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
@@ -336,9 +344,9 @@ __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
     } while (failure != 0);					\
   }
 
-SYNC_LOCK_RELEASE_1 (long long unsigned int, 8, 3)
-SYNC_LOCK_RELEASE_1 (short unsigned int, 2, 1)
-SYNC_LOCK_RELEASE_1 (unsigned char, 1, 0)
+SYNC_LOCK_RELEASE_1 (u64, 8, 3)
+SYNC_LOCK_RELEASE_1 (u16, 2, 1)
+SYNC_LOCK_RELEASE_1 (u8, 1, 0)
 
 void HIDDEN
 __sync_lock_release_4 (volatile void *ptr)
diff --git a/libgcc/config/pa/pa64-hpux-lib.h b/libgcc/config/pa/pa64-hpux-lib.h
index 7112014d1e1..96441502497 100644
--- a/libgcc/config/pa/pa64-hpux-lib.h
+++ b/libgcc/config/pa/pa64-hpux-lib.h
@@ -14,8 +14,13 @@ but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
 /* We use DTOR_LIST_BEGIN to carry a bunch of hacks to allow us to use
diff --git a/libgcc/config/pa/t-linux64 b/libgcc/config/pa/t-linux64
index 1d0a6ada1a1..026b48b02e5 100644
--- a/libgcc/config/pa/t-linux64
+++ b/libgcc/config/pa/t-linux64
@@ -1,8 +1,8 @@
 # Plug millicode routines into libgcc.a  We want these on both native and
 # cross compiles.
-# FIXME: Explain.
-LIB1ASMFUNCS := $(filter-out _dyncall, $(LIB1ASMFUNCS))
+LIB1ASMSRC = pa/milli64.S
+LIB1ASMFUNCS = _divI _divU _remI _remU _div_const _mulI
 
-LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
+HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1 -DLINUX=1
 
-HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1
+LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index c24f0cc8546..66a6d996c07 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,13 @@
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* intrinsics/pack_generic.c (pack_internal): Handle case when the
+	array argument of PACK has one or more extents of size zero to
+	avoid invalid reads.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libgfortran/intrinsics/pack_generic.c b/libgfortran/intrinsics/pack_generic.c
index 69306747e9c..2b7c955da54 100644
--- a/libgfortran/intrinsics/pack_generic.c
+++ b/libgfortran/intrinsics/pack_generic.c
@@ -85,6 +85,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
 
   index_type count[GFC_MAX_DIMENSIONS];
   index_type extent[GFC_MAX_DIMENSIONS];
+  bool zero_sized;
   index_type n;
   index_type dim;
   index_type nelem;
@@ -114,10 +115,13 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   else
     runtime_error ("Funny sized logical array");
 
+  zero_sized = false;
   for (n = 0; n < dim; n++)
     {
       count[n] = 0;
       extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);
+      if (extent[n] <= 0)
+	zero_sized = true;
       sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);
       mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);
     }
@@ -126,6 +130,11 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   if (mstride[0] == 0)
     mstride[0] = mask_kind;
 
+  if (zero_sized)
+    sptr = NULL;
+  else
+    sptr = array->base_addr;
+
   if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))
     {
       /* Count the elements, either for allocating memory or
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index b6e0b53db15..7b1a4859614 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,71 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/104385
+	* task.c (gomp_task_run_post_handle_dependers): If parent is NULL,
+	clear task->parent.
+	* testsuite/libgomp.c/pr104385.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-10-15  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/linux/affinity.c (gomp_affinity_init_level_1): For level 1
+	after creating count places clean up and return immediately.
+	* testsuite/libgomp.c/places-6.c: New test.
+	* testsuite/libgomp.c/places-7.c: New test.
+	* testsuite/libgomp.c/places-8.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94366
+	* testsuite/libgomp.c-c++-common/pr94366.c: New test.
+
+2022-05-11  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* testsuite/libgomp.c-c++-common/reduction-1.c: New test.
+	* testsuite/libgomp.c-c++-common/reduction-2.c: New test.
+	* testsuite/libgomp.c-c++-common/reduction-3.c: New test.
+	* testsuite/libgomp.c-c++-common/reduction-4.c: New file.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-07-13  Jakub Jelinek  <jakub@redhat.com>
+		    Florian Weimer  <fweimer@redhat.com>
+
+	* config/linux/sem.h: Don't include limits.h.
+	(SEM_WAIT): Define to -__INT_MAX__ - 1 instead of INT_MIN.
+	* config/linux/affinity.c: Include limits.h.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-06-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/101167
+	* testsuite/libgomp.c-c++-common/task-reduction-15.c: New test.
+
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2021-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/100471
+	* taskloop.c (GOMP_taskloop): If GOMP_TASK_FLAG_REDUCTION and not
+	GOMP_TASK_FLAG_NOGROUP, when doing early return clear the task
+	reduction pointer.
+	* testsuite/libgomp.c/task-reduction-4.c: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libgomp/config/linux/affinity.c b/libgomp/config/linux/affinity.c
index 647d241b741..15f58f71d8d 100644
--- a/libgomp/config/linux/affinity.c
+++ b/libgomp/config/linux/affinity.c
@@ -35,6 +35,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
+#include <limits.h>
 
 #ifdef HAVE_PTHREAD_AFFINITY_NP
 
@@ -280,8 +281,13 @@ gomp_affinity_init_level_1 (int level, int this_level, unsigned long count,
 		      if (gomp_affinity_add_cpus (pl, first, 1, 0, true))
 			{
 			  CPU_CLR_S (first, gomp_cpuset_size, copy);
-			  if (level == 1)
-			    gomp_places_list_len++;
+			  if (level == 1
+			      && ++gomp_places_list_len >= count)
+			    {
+			      fclose (f);
+			      free (line);
+			      return;
+			    }
 			}
 		    }
 		if (*p == ',')
diff --git a/libgomp/config/linux/sem.h b/libgomp/config/linux/sem.h
index b9283955cd4..b0335c05de9 100644
--- a/libgomp/config/linux/sem.h
+++ b/libgomp/config/linux/sem.h
@@ -33,10 +33,8 @@
 #ifndef GOMP_SEM_H
 #define GOMP_SEM_H 1
 
-#include <limits.h> /* For INT_MIN */
-
 typedef int gomp_sem_t;
-#define SEM_WAIT INT_MIN
+#define SEM_WAIT (-__INT_MAX__ - 1)
 #define SEM_INC 1
 
 extern void gomp_sem_wait_slow (gomp_sem_t *, int);
diff --git a/libgomp/task.c b/libgomp/task.c
index 15177ac8824..3bd80678349 100644
--- a/libgomp/task.c
+++ b/libgomp/task.c
@@ -1188,6 +1188,8 @@ gomp_task_run_post_handle_dependers (struct gomp_task *child_task,
 		}
 	    }
 	}
+      else
+	task->parent = NULL;
       if (taskgroup)
 	{
 	  priority_queue_insert (PQ_TASKGROUP, &taskgroup->taskgroup_queue,
diff --git a/libgomp/taskloop.c b/libgomp/taskloop.c
index 5d3f810a8f2..30724ddd0ee 100644
--- a/libgomp/taskloop.c
+++ b/libgomp/taskloop.c
@@ -51,20 +51,32 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),
 
   /* If parallel or taskgroup has been cancelled, don't start new tasks.  */
   if (team && gomp_team_barrier_cancelled (&team->barrier))
-    return;
+    {
+    early_return:
+      if ((flags & (GOMP_TASK_FLAG_NOGROUP | GOMP_TASK_FLAG_REDUCTION))
+	  == GOMP_TASK_FLAG_REDUCTION)
+	{
+	  struct gomp_data_head { TYPE t1, t2; uintptr_t *ptr; };
+	  uintptr_t *ptr = ((struct gomp_data_head *) data)->ptr;
+	  /* Tell callers GOMP_taskgroup_reduction_register has not been
+	     called.  */
+	  ptr[2] = 0;
+	}
+      return;
+    }
 
 #ifdef TYPE_is_long
   TYPE s = step;
   if (step > 0)
     {
       if (start >= end)
-	return;
+	goto early_return;
       s--;
     }
   else
     {
       if (start <= end)
-	return;
+	goto early_return;
       s++;
     }
   UTYPE n = (end - start + s) / step;
@@ -73,13 +85,13 @@ GOMP_taskloop (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),
   if (flags & GOMP_TASK_FLAG_UP)
     {
       if (start >= end)
-	return;
+	goto early_return;
       n = (end - start + step - 1) / step;
     }
   else
     {
       if (start <= end)
-	return;
+	goto early_return;
       n = (start - end - step - 1) / -step;
     }
 #endif
diff --git a/libgomp/testsuite/libgomp.c-c++-common/pr94366.c b/libgomp/testsuite/libgomp.c-c++-common/pr94366.c
new file mode 100644
index 00000000000..5837cd01a47
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/pr94366.c
@@ -0,0 +1,17 @@
+/* PR middle-end/94366 */
+
+int
+main ()
+{
+  int a = 2;
+  #pragma omp parallel reduction(&& : a)
+    a = a && 1;
+  if (!a)
+    __builtin_abort ();
+  a = 4;
+  #pragma omp parallel reduction(|| : a)
+    a = a || 0;
+  if (!a)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-1.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-1.c
new file mode 100644
index 00000000000..30686031371
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-1.c
@@ -0,0 +1,192 @@
+/* C / C++'s logical AND and OR operators take any scalar argument
+   which compares (un)equal to 0 - the result 1 or 0 and of type int.
+
+   In this testcase, the int result is again converted to a floating-poing
+   or complex type.
+
+   While having a floating-point/complex array element with || and && can make
+   sense, having a non-integer/non-bool reduction variable is odd but valid.
+
+   Test: FP reduction variable + FP array.  */
+
+#define N 1024
+_Complex float rcf[N];
+_Complex double rcd[N];
+float rf[N];
+double rd[N];
+
+int
+reduction_or ()
+{
+  float orf = 0;
+  double ord = 0;
+  _Complex float orfc = 0;
+  _Complex double ordc = 0;
+
+  #pragma omp parallel reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp parallel for reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp parallel for simd reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp parallel for reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_or_teams ()
+{
+  float orf = 0;
+  double ord = 0;
+  _Complex float orfc = 0;
+  _Complex double ordc = 0;
+
+  #pragma omp teams distribute parallel for reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_and ()
+{
+  float andf = 1;
+  double andd = 1;
+  _Complex float andfc = 1;
+  _Complex double anddc = 1;
+
+  #pragma omp parallel reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp parallel for reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp parallel for simd reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp parallel for reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+reduction_and_teams ()
+{
+  float andf = 1;
+  double andd = 1;
+  _Complex float andfc = 1;
+  _Complex double anddc = 1;
+
+  #pragma omp teams distribute parallel for reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+main ()
+{
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 0;
+      rd[i] = 0;
+      rcf[i] = 0;
+      rcd[i] = 0;
+    }
+
+  if (reduction_or () != 0)
+    __builtin_abort ();
+  if (reduction_or_teams () != 0)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  rf[10] = 1.0;
+  rd[15] = 1.0;
+  rcf[10] = 1.0;
+  rcd[15] = 1.0i;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 1;
+      rd[i] = 1;
+      rcf[i] = 1;
+      rcd[i] = 1;
+    }
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 4)
+    __builtin_abort ();
+  if (reduction_and_teams () != 4)
+    __builtin_abort ();
+
+  rf[10] = 0.0;
+  rd[15] = 0.0;
+  rcf[10] = 0.0;
+  rcd[15] = 0.0;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-2.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-2.c
new file mode 100644
index 00000000000..6bb970f1a3d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-2.c
@@ -0,0 +1,192 @@
+/* C / C++'s logical AND and OR operators take any scalar argument
+   which compares (un)equal to 0 - the result 1 or 0 and of type int.
+
+   In this testcase, the int result is again converted to a floating-poing
+   or complex type.
+
+   While having a floating-point/complex array element with || and && can make
+   sense, having a non-integer/non-bool reduction variable is odd but valid.
+
+   Test: FP reduction variable + integer array.  */
+
+#define N 1024
+char rcf[N];
+short rcd[N];
+int rf[N];
+long rd[N];
+
+int
+reduction_or ()
+{
+  float orf = 0;
+  double ord = 0;
+  _Complex float orfc = 0;
+  _Complex double ordc = 0;
+
+  #pragma omp parallel reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp parallel for reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp parallel for simd reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp parallel for reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_or_teams ()
+{
+  float orf = 0;
+  double ord = 0;
+  _Complex float orfc = 0;
+  _Complex double ordc = 0;
+
+  #pragma omp teams distribute parallel for reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_and ()
+{
+  float andf = 1;
+  double andd = 1;
+  _Complex float andfc = 1;
+  _Complex double anddc = 1;
+
+  #pragma omp parallel reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp parallel for reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp parallel for simd reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp parallel for reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+reduction_and_teams ()
+{
+  float andf = 1;
+  double andd = 1;
+  _Complex float andfc = 1;
+  _Complex double anddc = 1;
+
+  #pragma omp teams distribute parallel for reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+main ()
+{
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 0;
+      rd[i] = 0;
+      rcf[i] = 0;
+      rcd[i] = 0;
+    }
+
+  if (reduction_or () != 0)
+    __builtin_abort ();
+  if (reduction_or_teams () != 0)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  rf[10] = 1;
+  rd[15] = 1;
+  rcf[10] = 1;
+  rcd[15] = 1;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 1;
+      rd[i] = 1;
+      rcf[i] = 1;
+      rcd[i] = 1;
+    }
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 4)
+    __builtin_abort ();
+  if (reduction_and_teams () != 4)
+    __builtin_abort ();
+
+  rf[10] = 0;
+  rd[15] = 0;
+  rcf[10] = 0;
+  rcd[15] = 0;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-3.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-3.c
new file mode 100644
index 00000000000..b63d53d6b92
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-3.c
@@ -0,0 +1,192 @@
+/* C / C++'s logical AND and OR operators take any scalar argument
+   which compares (un)equal to 0 - the result 1 or 0 and of type int.
+
+   In this testcase, the int result is again converted to a floating-poing
+   or complex type.
+
+   While having a floating-point/complex array element with || and && can make
+   sense, having a non-integer/non-bool reduction variable is odd but valid.
+
+   Test: integer reduction variable + FP array.  */
+
+#define N 1024
+_Complex float rcf[N];
+_Complex double rcd[N];
+float rf[N];
+double rd[N];
+
+int
+reduction_or ()
+{
+  char orf = 0;
+  short ord = 0;
+  int orfc = 0;
+  long ordc = 0;
+
+  #pragma omp parallel reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp parallel for reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp parallel for simd reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp parallel for reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_or_teams ()
+{
+  char orf = 0;
+  short ord = 0;
+  int orfc = 0;
+  long ordc = 0;
+
+  #pragma omp teams distribute parallel for reduction(||: orf)
+  for (int i=0; i < N; ++i)
+    orf = orf || rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ord)
+  for (int i=0; i < N; ++i)
+    ord = ord || rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(||: orfc)
+  for (int i=0; i < N; ++i)
+    orfc = orfc || rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ordc)
+  for (int i=0; i < N; ++i)
+    ordc = ordc || rcd[i];
+
+  return orf + ord + __real__ orfc + __real__ ordc;
+}
+
+int
+reduction_and ()
+{
+  unsigned char andf = 1;
+  unsigned short andd = 1;
+  unsigned int andfc = 1;
+  unsigned long anddc = 1;
+
+  #pragma omp parallel reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp parallel for reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp parallel for simd reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp parallel for reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+reduction_and_teams ()
+{
+  unsigned char andf = 1;
+  unsigned short andd = 1;
+  unsigned int andfc = 1;
+  unsigned long anddc = 1;
+
+  #pragma omp teams distribute parallel for reduction(&&: andf)
+  for (int i=0; i < N; ++i)
+    andf = andf && rf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: andd)
+  for (int i=0; i < N; ++i)
+    andd = andd && rcd[i];
+
+  #pragma omp teams distribute parallel for reduction(&&: andfc)
+  for (int i=0; i < N; ++i)
+    andfc = andfc && rcf[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)
+  for (int i=0; i < N; ++i)
+    anddc = anddc && rcd[i];
+
+  return andf + andd + __real__ andfc + __real__ anddc;
+}
+
+int
+main ()
+{
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 0;
+      rd[i] = 0;
+      rcf[i] = 0;
+      rcd[i] = 0;
+    }
+
+  if (reduction_or () != 0)
+    __builtin_abort ();
+  if (reduction_or_teams () != 0)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  rf[10] = 1.0;
+  rd[15] = 1.0;
+  rcf[10] = 1.0;
+  rcd[15] = 1.0i;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  for (int i = 0; i < N; ++i)
+    {
+      rf[i] = 1;
+      rd[i] = 1;
+      rcf[i] = 1;
+      rcd[i] = 1;
+    }
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 4)
+    __builtin_abort ();
+  if (reduction_and_teams () != 4)
+    __builtin_abort ();
+
+  rf[10] = 0.0;
+  rd[15] = 0.0;
+  rcf[10] = 0.0;
+  rcd[15] = 0.0;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/reduction-4.c b/libgomp/testsuite/libgomp.c-c++-common/reduction-4.c
new file mode 100644
index 00000000000..21cf8a843b7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/reduction-4.c
@@ -0,0 +1,194 @@
+/* C / C++'s logical AND and OR operators take any scalar argument
+   which compares (un)equal to 0 - the result 1 or 0 and of type int.
+
+   In this testcase, the int result is again converted to an integer complex
+   type.
+
+   While having a floating-point/complex array element with || and && can make
+   sense, having a complex reduction variable is odd but valid.
+
+   Test: int complex reduction variable + int complex array.  */
+
+#define N 1024
+_Complex char rcc[N];
+_Complex short rcs[N];
+_Complex int rci[N];
+_Complex long long rcl[N];
+
+int
+reduction_or ()
+{
+  _Complex char orc = 0;
+  _Complex short ors = 0;
+  _Complex int ori = 0;
+  _Complex long orl = 0;
+
+  #pragma omp parallel reduction(||: orc)
+  for (int i=0; i < N; ++i)
+    orc = orc || rcl[i];
+
+  #pragma omp parallel for reduction(||: ors)
+  for (int i=0; i < N; ++i)
+    ors = ors || rci[i];
+
+  #pragma omp parallel for simd reduction(||: ori)
+  for (int i=0; i < N; ++i)
+    ori = ori || rcs[i];
+
+  #pragma omp parallel for reduction(||: orl)
+  for (int i=0; i < N; ++i)
+    orl = orl || rcc[i];
+
+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);
+}
+
+int
+reduction_or_teams ()
+{
+  _Complex char orc = 0;
+  _Complex short ors = 0;
+  _Complex int ori = 0;
+  _Complex long orl = 0;
+
+  #pragma omp teams distribute parallel for reduction(||: orc)
+  for (int i=0; i < N; ++i)
+    orc = orc || rcc[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: ors)
+  for (int i=0; i < N; ++i)
+    ors = ors || rcs[i];
+
+  #pragma omp teams distribute parallel for reduction(||: ori)
+  for (int i=0; i < N; ++i)
+    ori = ori || rci[i];
+
+  #pragma omp teams distribute parallel for simd reduction(||: orl)
+  for (int i=0; i < N; ++i)
+    orl = orl || rcl[i];
+
+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);
+}
+
+int
+reduction_and ()
+{
+  _Complex char andc = 1;
+  _Complex short ands = 1;
+  _Complex int andi = 1;
+  _Complex long andl = 1;
+
+  #pragma omp parallel reduction(&&: andc)
+  for (int i=0; i < N; ++i)
+    andc = andc && rcc[i];
+
+  #pragma omp parallel for reduction(&&: ands)
+  for (int i=0; i < N; ++i)
+    ands = ands && rcs[i];
+
+  #pragma omp parallel for simd reduction(&&: andi)
+  for (int i=0; i < N; ++i)
+    andi = andi && rci[i];
+
+  #pragma omp parallel for reduction(&&: andl)
+  for (int i=0; i < N; ++i)
+    andl = andl && rcl[i];
+
+  return __real__ (andc + ands + andi + andl)
+	 + __imag__ (andc + ands + andi + andl);
+}
+
+int
+reduction_and_teams ()
+{
+  _Complex char andc = 1;
+  _Complex short ands = 1;
+  _Complex int andi = 1;
+  _Complex long andl = 1;
+
+  #pragma omp teams distribute parallel for reduction(&&: andc)
+  for (int i=0; i < N; ++i)
+    andc = andc && rcl[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: ands)
+  for (int i=0; i < N; ++i)
+    ands = ands && rci[i];
+
+  #pragma omp teams distribute parallel for reduction(&&: andi)
+  for (int i=0; i < N; ++i)
+    andi = andi && rcs[i];
+
+  #pragma omp teams distribute parallel for simd reduction(&&: andl)
+  for (int i=0; i < N; ++i)
+    andl = andl && rcc[i];
+
+  return __real__ (andc + ands + andi + andl)
+	 + __imag__ (andc + ands + andi + andl);
+}
+
+int
+main ()
+{
+  for (int i = 0; i < N; ++i)
+    {
+      rcc[i] = 0;
+      rcs[i] = 0;
+      rci[i] = 0;
+      rcl[i] = 0;
+    }
+
+  if (reduction_or () != 0)
+    __builtin_abort ();
+  if (reduction_or_teams () != 0)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  rcc[10] = 1.0;
+  rcs[15] = 1.0i;
+  rci[10] = 1.0;
+  rcl[15] = 1.0i;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  for (int i = 0; i < N; ++i)
+    {
+      rcc[i] = 1;
+      rcs[i] = 1i;
+      rci[i] = 1;
+      rcl[i] = 1 + 1i;
+    }
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 4)
+    __builtin_abort ();
+  if (reduction_and_teams () != 4)
+    __builtin_abort ();
+
+  rcc[10] = 0.0;
+  rcs[15] = 0.0;
+  rci[10] = 0.0;
+  rcl[15] = 0.0;
+
+  if (reduction_or () != 4)
+    __builtin_abort ();
+  if (reduction_or_teams () != 4)
+    __builtin_abort ();
+  if (reduction_and () != 0)
+    __builtin_abort ();
+  if (reduction_and_teams () != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/task-reduction-15.c b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-15.c
new file mode 100644
index 00000000000..5e87139ccfb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-15.c
@@ -0,0 +1,61 @@
+/* PR middle-end/101167 */
+
+extern
+#ifdef __cplusplus
+"C"
+#endif
+void abort (void);
+
+struct S { int a, b, c[2]; };
+
+void
+init (struct S *x)
+{
+  x->a = 0;
+  x->b = 0;
+  x->c[0] = 0;
+  x->c[1] = 0;
+}
+
+void
+merge (struct S *x, struct S *y)
+{
+  x->a += y->a;
+  x->b += y->b;
+}
+
+#pragma omp declare reduction (+: struct S : merge (&omp_out, &omp_in)) initializer (init (&omp_priv))
+
+void
+foo (struct S x)
+{
+  #pragma omp taskgroup task_reduction (+: x)
+  {
+    #pragma omp task in_reduction (+: x)
+    {
+      x.a++;
+      x.b++;
+    }
+    #pragma omp task in_reduction (+: x)
+    {
+      x.a += 4;
+      x.b += 14;
+    }
+    #pragma omp task in_reduction (+: x)
+    {
+      x.a += 9;
+      x.b += 19;
+    }
+  }
+  if (x.a != 56 || x.b != 86)
+    abort ();
+}
+
+int
+main ()
+{
+  struct S x = { 42, 52 };
+  #pragma omp parallel master num_threads(3)
+  foo (x);
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/places-6.c b/libgomp/testsuite/libgomp.c/places-6.c
new file mode 100644
index 00000000000..831034601eb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/places-6.c
@@ -0,0 +1,8 @@
+/* { dg-set-target-env-var OMP_PLACES "threads(1)" } */
+/* { dg-set-target-env-var OMP_DISPLAY_ENV "true" } */
+
+int
+main ()
+{
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/places-7.c b/libgomp/testsuite/libgomp.c/places-7.c
new file mode 100644
index 00000000000..f0a77f41def
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/places-7.c
@@ -0,0 +1,8 @@
+/* { dg-set-target-env-var OMP_PLACES "cores(1)" } */
+/* { dg-set-target-env-var OMP_DISPLAY_ENV "true" } */
+
+int
+main ()
+{
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/places-8.c b/libgomp/testsuite/libgomp.c/places-8.c
new file mode 100644
index 00000000000..31c698337e4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/places-8.c
@@ -0,0 +1,8 @@
+/* { dg-set-target-env-var OMP_PLACES "sockets(1)" } */
+/* { dg-set-target-env-var OMP_DISPLAY_ENV "true" } */
+
+int
+main ()
+{
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/pr104385.c b/libgomp/testsuite/libgomp.c/pr104385.c
new file mode 100644
index 00000000000..07495e65e58
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr104385.c
@@ -0,0 +1,26 @@
+/* PR libgomp/104385 */
+
+#include <unistd.h>
+
+int
+main ()
+{
+  int j = 0;
+  #pragma omp parallel shared(j) num_threads(2)
+  {
+    #pragma omp barrier
+    #pragma omp master
+    #pragma omp task shared(j)
+    {
+      #pragma omp task depend(out: j) shared(j)
+      {
+        usleep (10000);
+        j = 1;
+      }
+
+      #pragma omp task depend(inout: j) shared(j)
+      j += 1;
+    }
+  }
+  return j - 2;
+}
diff --git a/libgomp/testsuite/libgomp.c/task-reduction-4.c b/libgomp/testsuite/libgomp.c/task-reduction-4.c
new file mode 100644
index 00000000000..7ca1d02fa19
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/task-reduction-4.c
@@ -0,0 +1,21 @@
+/* PR middle-end/100471 */
+
+extern void abort (void);
+
+int c;
+
+int
+main ()
+{
+#pragma omp parallel
+#pragma omp single
+  {
+    int r = 0, i;
+    #pragma omp taskloop reduction(+:r)
+    for (i = 0; i < c; i++)
+      r++;
+    if (r != 0)
+      abort ();
+  }
+  return 0;
+}
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index 6c31817852b..58eadfebc0e 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,15 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/104617
+	* simple-object-elf.c (simple_object_elf_match): Fix up URL
+	in comment.
+	(simple_object_elf_copy_lto_debug_sections): Remap sh_info and
+	sh_link even if they are in the SHN_LORESERVE .. SHN_HIRESERVE
+	range (inclusive).
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libiberty/simple-object-elf.c b/libiberty/simple-object-elf.c
index a5cf6043dc3..fd41cc83c3d 100644
--- a/libiberty/simple-object-elf.c
+++ b/libiberty/simple-object-elf.c
@@ -528,7 +528,7 @@ simple_object_elf_match (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],
 	     not handle objects with more than SHN_LORESERVE sections
 	     correctly.  All large section indexes were offset by
 	     0x100.  There is more information at
-	     http://sourceware.org/bugzilla/show_bug.cgi?id-5900 .
+	     https://sourceware.org/PR5900 .
 	     Fortunately these object files are easy to detect, as the
 	     GNU binutils always put the section header string table
 	     near the end of the list of sections.  Thus if the
@@ -1536,17 +1536,13 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,
 	  {
 	    sh_info = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,
 				       shdr, sh_info, Elf_Word);
-	    if (sh_info < SHN_LORESERVE
-		|| sh_info > SHN_HIRESERVE)
-	      sh_info = sh_map[sh_info];
+	    sh_info = sh_map[sh_info];
 	    ELF_SET_FIELD (type_functions, ei_class, Shdr,
 			   shdr, sh_info, Elf_Word, sh_info);
 	  }
 	sh_link = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,
 				   shdr, sh_link, Elf_Word);
-	if (sh_link < SHN_LORESERVE
-	    || sh_link > SHN_HIRESERVE)
-	  sh_link = sh_map[sh_link];
+	sh_link = sh_map[sh_link];
 	ELF_SET_FIELD (type_functions, ei_class, Shdr,
 		       shdr, sh_link, Elf_Word, sh_link);
       }
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index 22d7711bb98..156378b7f0b 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,11 @@
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* testsuite/libitm.c++/libstdc++-pr91488.C: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libitm/testsuite/libitm.c++/libstdc++-pr91488.C b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
new file mode 100644
index 00000000000..e9e82bd1ce2
--- /dev/null
+++ b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
@@ -0,0 +1,9 @@
+// PR libstdc++/91488 "inlining failed in call to always_inline"
+// { dg-do run }
+// { dg-additional-options "-O1" }
+
+#include <string>
+
+int main() {
+    return std::char_traits<char>::length("");
+}
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 5c09737a6c2..b683d87d2bc 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,45 @@
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-09-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/unwind/generic.d (__aligned__): Define.
+	(_Unwind_Exception): Align struct to __aligned__.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Clear the per-thread
+	TLS array, don't call free().
+
+2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/103604
+	* libdruntime/core/sys/posix/sys/stat.d (struct stat_t): Fix
+	definition for MIPS64.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/thread.d (defaultStackPages): New constant.
+	(Fiber.this): Set stack size to be a multiple of defaultStackPages.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Don't remove entry
+	from global array.
+	(_d_emutls_destroy): Don't call __gthread_key_delete.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libphobos/libdruntime/core/sys/posix/sys/stat.d b/libphobos/libdruntime/core/sys/posix/sys/stat.d
index f394823767d..6c25bb45c9b 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/stat.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/stat.d
@@ -337,26 +337,23 @@ version (CRuntime_Glibc)
             }
             c_long[14]  st_pad5;
         }
+        static if (!__USE_FILE_OFFSET64)
+            static assert(stat_t.sizeof == 144);
+        else
+            static assert(stat_t.sizeof == 160);
     }
     else version (MIPS64)
     {
         struct stat_t
         {
-            c_ulong     st_dev;
+            dev_t       st_dev;
             int[3]      st_pad1;
-            static if (!__USE_FILE_OFFSET64)
-            {
-                ino_t       st_ino;
-            }
-            else
-            {
-                c_ulong     st_ino;
-            }
+            ino_t       st_ino;
             mode_t      st_mode;
             nlink_t     st_nlink;
             uid_t       st_uid;
             gid_t       st_gid;
-            c_ulong     st_rdev;
+            dev_t       st_rdev;
             static if (!__USE_FILE_OFFSET64)
             {
                 uint[2]     st_pad2;
@@ -365,8 +362,8 @@ version (CRuntime_Glibc)
             }
             else
             {
-                c_long[3]   st_pad2;
-                c_long      st_size;
+                uint[3]     st_pad2;
+                off_t       st_size;
             }
             static if (__USE_MISC || __USE_XOPEN2K8)
             {
@@ -391,15 +388,26 @@ version (CRuntime_Glibc)
             }
             blksize_t   st_blksize;
             uint        st_pad4;
+            blkcnt_t    st_blocks;
+            int[14]     st_pad5;
+        }
+        version (MIPS_N32)
+        {
             static if (!__USE_FILE_OFFSET64)
-            {
-                blkcnt_t    st_blocks;
-            }
+                static assert(stat_t.sizeof == 160);
             else
-            {
-                c_long  st_blocks;
-            }
-            c_long[14]  st_pad5;
+                static assert(stat_t.sizeof == 176);
+        }
+        else version (MIPS_O64)
+        {
+            static if (!__USE_FILE_OFFSET64)
+                static assert(stat_t.sizeof == 160);
+            else
+                static assert(stat_t.sizeof == 176);
+        }
+        else
+        {
+            static assert(stat_t.sizeof == 216);
         }
     }
     else version (PPC)
diff --git a/libphobos/libdruntime/core/thread.d b/libphobos/libdruntime/core/thread.d
index 3d2cd287a2e..feac50eb7f2 100644
--- a/libphobos/libdruntime/core/thread.d
+++ b/libphobos/libdruntime/core/thread.d
@@ -4144,6 +4144,24 @@ class Fiber
     // Initialization
     ///////////////////////////////////////////////////////////////////////////
 
+    version (Windows)
+        // exception handling walks the stack, invoking DbgHelp.dll which
+        // needs up to 16k of stack space depending on the version of DbgHelp.dll,
+        // the existence of debug symbols and other conditions. Avoid causing
+        // stack overflows by defaulting to a larger stack size
+        enum defaultStackPages = 8;
+    else version (OSX)
+    {
+        version (X86_64)
+            // libunwind on macOS 11 now requires more stack space than 16k, so
+            // default to a larger stack size. This is only applied to X86 as
+            // the PAGESIZE is still 4k, however on AArch64 it is 16k.
+            enum defaultStackPages = 8;
+        else
+            enum defaultStackPages = 4;
+    }
+    else
+        enum defaultStackPages = 4;
 
     /**
      * Initializes a fiber object which is associated with a static
@@ -4158,7 +4176,7 @@ class Fiber
      * In:
      *  fn must not be null.
      */
-    this( void function() fn, size_t sz = PAGESIZE*4,
+    this( void function() fn, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
@@ -4184,7 +4202,7 @@ class Fiber
      * In:
      *  dg must not be null.
      */
-    this( void delegate() dg, size_t sz = PAGESIZE*4,
+    this( void delegate() dg, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 461f20d9e28..fbc837672a0 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -222,16 +222,13 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 }
 
 /*
- * When a thread has finished, remove the TLS array from the GC
- * scan list emutlsArrays, free all allocated TLS variables and
- * finally free the array.
+ * When a thread has finished, free all allocated TLS variables and empty the
+ * array.  The pointer is not free'd as it is stil referenced by the GC scan
+ * list emutlsArrays, which gets destroyed when druntime is unloaded.
  */
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
     auto arr = cast(TlsArray*) ptr;
-    emutlsMutex.lock_nothrow();
-    emutlsArrays.remove(arr);
-    emutlsMutex.unlock_nothrow();
 
     foreach (entry; *arr)
     {
@@ -239,7 +236,7 @@ extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
             free(entry[-1]);
     }
 
-    free(arr);
+    arr.length = 0;
 }
 
 /*
@@ -308,9 +305,6 @@ void _d_emutls_scan(scope void delegate(void* pbeg, void* pend) nothrow cb) noth
 // Call this after druntime has been unloaded
 void _d_emutls_destroy() nothrow @nogc
 {
-    if (__gthread_key_delete(emutlsKey) != 0)
-        abort();
-
     (cast(Mutex) _emutlsMutex.ptr).__dtor();
     destroy(emutlsArrays);
 }
diff --git a/libphobos/libdruntime/gcc/unwind/generic.d b/libphobos/libdruntime/gcc/unwind/generic.d
index eefd90ce353..6508ee7c788 100644
--- a/libphobos/libdruntime/gcc/unwind/generic.d
+++ b/libphobos/libdruntime/gcc/unwind/generic.d
@@ -123,7 +123,27 @@ enum : _Unwind_Reason_Code
 // @@@ The IA-64 ABI says that this structure must be double-word aligned.
 // Taking that literally does not make much sense generically.  Instead we
 // provide the maximum alignment required by any type for the machine.
-struct _Unwind_Exception
+     version (ARM)      private enum __aligned__ = 8;
+else version (AArch64)  private enum __aligned__ = 16;
+else version (HPPA)     private enum __aligned__ = 8;
+else version (HPPA64)   private enum __aligned__ = 16;
+else version (MIPS_N32) private enum __aligned__ = 16;
+else version (MIPS_N64) private enum __aligned__ = 16;
+else version (MIPS32)   private enum __aligned__ = 8;
+else version (MIPS64)   private enum __aligned__ = 8;
+else version (PPC)      private enum __aligned__ = 16;
+else version (PPC64)    private enum __aligned__ = 16;
+else version (RISCV32)  private enum __aligned__ = 16;
+else version (RISCV64)  private enum __aligned__ = 16;
+else version (S390)     private enum __aligned__ = 8;
+else version (SPARC)    private enum __aligned__ = 8;
+else version (SPARC64)  private enum __aligned__ = 16;
+else version (SystemZ)  private enum __aligned__ = 8;
+else version (X86)      private enum __aligned__ = 16;
+else version (X86_64)   private enum __aligned__ = 16;
+else static assert( false, "Platform not supported.");
+
+align(__aligned__) struct _Unwind_Exception
 {
     _Unwind_Exception_Class exception_class;
     _Unwind_Exception_Cleanup_Fn exception_cleanup;
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index d8c2f6b863a..c1787d4a122 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,27 @@
+2022-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-02-15  Jakub Jelinek  <jakub@redhat.com>
+
+	* sanitizer_common/sanitizer_linux_libcdep.cc: Cherry-pick
+	llvm-project revision ef14b78d9a144ba81ba02083fe21eb286a88732b.
+
+2022-01-19  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-01-12  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR sanitizer/102911
+	* asan/asan_malloc_linux.cc (kDlsymAllocPoolSize): Set it to
+	8192 on Linux.
+
+2021-08-05  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/101749
+	* sanitizer_common/sanitizer_posix_libcdep.cc: Prevent
+	generation of dependency on _cxa_guard for static
+	initialization.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libsanitizer/asan/asan_malloc_linux.cc b/libsanitizer/asan/asan_malloc_linux.cc
index a6e692759ce..ddf898846a8 100644
--- a/libsanitizer/asan/asan_malloc_linux.cc
+++ b/libsanitizer/asan/asan_malloc_linux.cc
@@ -30,7 +30,7 @@ using namespace __asan;  // NOLINT
 
 static uptr allocated_for_dlsym;
 static uptr last_dlsym_alloc_size_in_words;
-static const uptr kDlsymAllocPoolSize = SANITIZER_RTEMS ? 4096 : 1024;
+static const uptr kDlsymAllocPoolSize = SANITIZER_RTEMS ? 4096 : 8192;
 static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];
 
 static INLINE bool IsInDlsymAllocPool(const void *ptr) {
diff --git a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
index 28360f5656a..bf91af98c33 100644
--- a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
@@ -263,10 +263,8 @@ void InitTlsSize() { }
 // sizeof(struct pthread) from glibc.
 static atomic_uintptr_t thread_descriptor_size;
 
-uptr ThreadDescriptorSize() {
-  uptr val = atomic_load_relaxed(&thread_descriptor_size);
-  if (val)
-    return val;
+static uptr ThreadDescriptorSizeFallback() {
+  uptr val = 0;
 #if defined(__x86_64__) || defined(__i386__) || defined(__arm__)
   int major;
   int minor;
@@ -306,8 +304,21 @@ uptr ThreadDescriptorSize() {
 #elif defined(__s390__)
   val = FIRST_32_SECOND_64(1152, 1776); // valid for glibc 2.22
 #endif
+  return val;
+}
+
+uptr ThreadDescriptorSize() {
+  uptr val = atomic_load_relaxed(&thread_descriptor_size);
   if (val)
-    atomic_store_relaxed(&thread_descriptor_size, val);
+    return val;
+  // _thread_db_sizeof_pthread is a GLIBC_PRIVATE symbol that is exported in
+  // glibc 2.34 and later.
+  if (unsigned *psizeof = static_cast<unsigned *>(
+          dlsym(RTLD_DEFAULT, "_thread_db_sizeof_pthread")))
+    val = *psizeof;
+  if (!val)
+    val = ThreadDescriptorSizeFallback();
+  atomic_store_relaxed(&thread_descriptor_size, val);
   return val;
 }
 
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
index 1917e29ced2..8c8aa75004e 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
@@ -170,9 +170,10 @@ bool SupportsColoredOutput(fd_t fd) {
 #if !SANITIZER_GO
 // TODO(glider): different tools may require different altstack size.
 static uptr GetAltStackSize() {
-  // SIGSTKSZ is not enough.
-  static const uptr kAltStackSize = SIGSTKSZ * 4;
-  return kAltStackSize;
+  // Note: since GLIBC_2.31, SIGSTKSZ may be a function call, so this may be
+  // more costly that you think. However GetAltStackSize is only call 2-3 times
+  // per thread so don't cache the evaluation.
+  return SIGSTKSZ * 4;
 }
 
 void SetAlternateSignalStack() {
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 4a898cd27d7..fe1bd8d2c79 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,459 @@
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105502
+	* include/bits/random.tcc
+	(operator>>(basic_istream<C,T>&, normal_distribution<R>&)):
+	Update state when __state_avail is false.
+	* testsuite/26_numerics/random/normal_distribution/operators/serialize.cc:
+	Check that deserialized object equals serialized one.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/types/1.cc: Add c++11 target selector to
+	warnings.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_ops.h (fs::copy_file): Remove
+	noexcept.
+	(fs::create_directories): Likewise.
+	(fs::remove_all): Likewise.
+	* src/filesystem/ops.cc (fs::copy_file): Remove noexcept.
+	(fs::create_directories): Likewise.
+	(fs::remove_all): Likewise.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103630
+	* libsupc++/exception_ptr.h (make_exception_ptr): Decay the
+	template parameter. Use typeid of the static type.
+	* testsuite/18_support/exception_ptr/103630.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-12-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93151
+	* config/os/djgpp/error_constants.h: Test POSIX errno macros
+	directly, instead of corresponding _GLIBCXX_HAVE_EXXX macros.
+	* config/os/mingw32-w64/error_constants.h: Likewise.
+	* config/os/mingw32/error_constants.h: Likewise.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93151
+	* acinclude.m4 (GLIBCXX_CHECK_SYSTEM_ERROR): Remove.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* configure.ac (GLIBCXX_CHECK_SYSTEM_ERROR): Do not use.
+	* config/os/generic/error_constants.h: Test POSIX errno macros
+	directly, instead of corresponding _GLIBCXX_HAVE_EXXX macros.
+	* testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc:
+	Likewise.
+	* testsuite/19_diagnostics/headers/system_error/93151.cc: New
+	test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/basic_string.h (basic_string(const CharT*, const A&)):
+	Do not do arithmetic on null pointer.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101870
+	* include/c_global/cmath (hypot): Use __promoted_t.
+	(lerp): Add new overload accepting any arithmetic types.
+	* include/ext/type_traits.h (__promoted_t): New alias template.
+	* testsuite/26_numerics/lerp.cc: Moved to...
+	* testsuite/26_numerics/lerp/1.cc: ...here.
+	* testsuite/26_numerics/lerp/constexpr.cc: New test.
+	* testsuite/26_numerics/lerp/version.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100153
+	* include/bits/vector.tcc (vector<bool>::_M_shrink_to_fit()):
+	When size() is zero just deallocate and reset.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/25_algorithms/is_permutation/2.cc: Include <iterator>.
+
+2022-05-09  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+
+	Backported from master:
+	2022-01-06  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103853
+	* include/bits/forward_list.tcc (forward_list::merge): Check for
+	self-merge.
+	* testsuite/23_containers/forward_list/operations/merge.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103549
+	* include/bits/regex.h (match_results): Give names to template
+	parameters in first declaration.
+	(match_results::_M_begin): Add default member-initializer.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103877
+	* doc/xml/faq.xml: Add '-x c++' to preprocessor command.
+	* doc/html/faq.html: Regenerate.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103650
+	* include/Makefile.am: Rename LT_OBJDIR and STDC_HEADERS.
+	* include/Makefile.in: Regenerate.
+	* testsuite/17_intro/headers/c++1998/103650.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_fwd.h (copy_file): Remove
+	incorrect noexcept from declaration.
+	* include/experimental/bits/fs_path.h (path::begin, path::end):
+	Add noexcept to declarations, to match definitions.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Fix comment.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102048
+	* include/ext/rope (rope::erase(size_type)): Deprecate broken
+	function.
+
+2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103381
+	* include/ext/bitmap_allocator.h: Include <bits/stl_function.h>
+	instead of <functional>.
+
+2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103022
+	* include/std/valarray (begin, end): Do not dereference an empty
+	valarray. Add noexcept.
+	* testsuite/26_numerics/valarray/range_access.cc: Check empty
+	valarray. Check iterator properties. Run as well as compiling.
+	* testsuite/26_numerics/valarray/range_access2.cc: Likewise.
+	* testsuite/26_numerics/valarray/103022.cc: New test.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/28_regex/match_results/102667.C: Moved to...
+	* testsuite/28_regex/match_results/102667.cc: ...here.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/26_numerics/valarray/dr630-3.C: Moved to...
+	* testsuite/26_numerics/valarray/dr630-3.cc: ...here.
+	* testsuite/27_io/basic_iostream/cons/16251.C: Moved to...
+	* testsuite/27_io/basic_iostream/cons/16251.cc: ...here.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (advance): Remove non-deducible
+	template parameter.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102425
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): Add 0 to
+	switch.
+	* testsuite/19_diagnostics/error_category/102425.cc: New test.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (StdErrorCodePrinter): Define.
+	(build_libstdcxx_dictionary): Register printer for
+	std::error_code and std::error_condition.
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Test it.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/Makefile.am [GLIBCXX_BUILD_DEBUG] (install-data-local):
+	Install another copy of the GDB hook.
+	* python/Makefile.in: Regenerate.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/remove_all.cc: Remove
+	test directory after making it writable again.
+	* testsuite/experimental/filesystem/operations/remove_all.cc:
+	Likewise.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102667
+	* include/bits/regex.h (match_result::empty()): Optimize by
+	calling the base function directly.
+	(match_results::end()): Check _Base_type::empty() not empty().
+	* testsuite/28_regex/match_results/102667.C: New test.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101866
+	* testsuite/experimental/random/randint.cc: Loop and retry if
+	reseed() produces the same sequence.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (fs::create_directories): Use status
+	instead of symlink_status.
+	* src/filesystem/ops.cc (fs::create_directories): Likewise.
+	* testsuite/27_io/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/27_io/filesystem/operations/create_directory.cc: Do
+	not test with symlinks on Windows.
+	* testsuite/experimental/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Do not test with symlinks on Windows.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (create_dir): Adjust whitespace.
+	* testsuite/27_io/filesystem/operations/create_directory.cc:
+	Test creating directory with name of existing symlink to
+	directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Likewise.
+
+2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-02-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/c++17/fs_ops.cc (fs::symlink_status): Re-enable workaround.
+
+2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-02-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/c++17/fs_ops.cc (fs::status): Re-enable workaround.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/profile/mutex_extensions_neg.cc: Prune
+	additional errors in C++20 mode.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96657
+	* libsupc++/Makefile.am: Add atomicity.cc here.
+	* src/c++98/Makefile.am: Remove it from here.
+	* libsupc++/Makefile.in: Regenerate.
+	* src/c++98/Makefile.in: Regenerate.
+	* testsuite/18_support/exception_ptr/96657.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101034
+	* include/std/any (any(in_place_t<T>, initializer_list<U>, A&&...))
+	(any::emplace<T>(initializer_list<U>, A&&...)): Fix constraint
+	to use lvalue.
+	* testsuite/20_util/any/cons/101034.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-04-23  Kamlesh Kumar  <kamleshbhalui@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90415
+	PR libstdc++/92156
+	* include/std/any (any): Rename template parameters for consistency
+	with the standard.
+	(any::_Decay): Rename to _Decay_if_not_any.
+	(any::any(T&&)): Remove is_constructible from constraints. Remove
+	non-standard overload.
+	(any::any(in_place_type_t<T>, Args&&...))
+	(any::any(in_place_type_t<T>, initializer_list<U>, Args&&...))
+	(any::emplace(Args&&...))
+	(any::emplace(initializer_list<U>, Args&&...)):
+	Use decay_t instead of _Decay.
+	* testsuite/20_util/any/cons/90415.cc: New test.
+	* testsuite/20_util/any/cons/92156.cc: New Test.
+	* testsuite/20_util/any/misc/any_cast_neg.cc: Make dg-error directives
+	more robust.
+	* testsuite/20_util/any/modifiers/92156.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100982
+	* include/std/optional (optional::operator=(const optional<U>&)):
+	Fix value category used in is_assignable check.
+	* testsuite/20_util/optional/assignment/100982.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95833
+	* include/std/numeric (reduce(Iter, Iter, T, BinaryOp)): Replace
+	incorrect static_assert with ones matching the 'Mandates'
+	conditions in the standard.
+	* testsuite/26_numerics/reduce/95833.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100630
+	* include/bits/fs_path.h (__is_constructible_from): Test
+	construction from a const lvalue, not an rvalue.
+	* include/experimental/bits/fs_path.h (__is_constructible_from):
+	Likewise.
+	* testsuite/27_io/filesystem/path/construct/100630.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/100630.cc:
+	New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100384
+	* include/std/variant (__get_t): New alias template yielding the
+	return type of std::get<N> on a variant.
+	(__visit_result_t): New alias template yielding the result of
+	std::visit.
+	(__do_visit): Use __get_t.
+	(visit): Use __visit_result_t for return type.
+	* testsuite/20_util/variant/100384.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99006
+	* include/bits/shared_ptr.h (allocate_shared): Assert that _Tp
+	is not an array type.
+	* include/bits/shared_ptr_base.h (__allocate_shared): Likewise.
+	* testsuite/20_util/shared_ptr/creation/99006.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* include/bits/char_traits.h (__constant_string_p)
+	(__constant_array_p): Give external linkage.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (find_type): Use tag attribute
+	instead of unqualified() method.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 93d86d2c363..a41f68790ae 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -2322,35 +2322,6 @@ AC_DEFUN([GLIBCXX_CHECK_MATH11_PROTO], [
   AC_LANG_RESTORE
 ])
 
-dnl
-dnl Check whether macros, etc are present for <system_error>
-dnl
-AC_DEFUN([GLIBCXX_CHECK_SYSTEM_ERROR], [
-
-m4_pushdef([n_syserr], [1])dnl
-m4_foreach([syserr], [EOWNERDEAD, ENOTRECOVERABLE, ENOLINK, EPROTO, ENODATA,
-		      ENOSR, ENOSTR, ETIME, EBADMSG, ECANCELED,
-		      EOVERFLOW, ENOTSUP, EIDRM, ETXTBSY,
-		      ECHILD, ENOSPC, EPERM,
-		      ETIMEDOUT, EWOULDBLOCK],
-[m4_pushdef([SYSERR], m4_toupper(syserr))dnl
-AC_MSG_CHECKING([for syserr])
-AC_CACHE_VAL([glibcxx_cv_system_error[]n_syserr], [
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <errno.h>]],
-				   [int i = syserr;])],
-		  [glibcxx_cv_system_error[]n_syserr=yes],
-		  [glibcxx_cv_system_error[]n_syserr=no])
-])
-AC_MSG_RESULT([$glibcxx_cv_system_error[]n_syserr])
-if test x"$glibcxx_cv_system_error[]n_syserr" = x"yes"; then
-  AC_DEFINE([HAVE_]SYSERR, 1, [Define if ]syserr[ exists.])
-fi
-m4_define([n_syserr], m4_incr(n_syserr))dnl
-m4_popdef([SYSERR])dnl
-])
-m4_popdef([n_syserr])dnl
-])
-
 dnl
 dnl Check for what type of C headers to use.
 dnl
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 1252e0c6f60..79e920c733d 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -69,66 +69,9 @@
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
-/* Define if EBADMSG exists. */
-#undef HAVE_EBADMSG
-
-/* Define if ECANCELED exists. */
-#undef HAVE_ECANCELED
-
-/* Define if ECHILD exists. */
-#undef HAVE_ECHILD
-
-/* Define if EIDRM exists. */
-#undef HAVE_EIDRM
-
 /* Define to 1 if you have the <endian.h> header file. */
 #undef HAVE_ENDIAN_H
 
-/* Define if ENODATA exists. */
-#undef HAVE_ENODATA
-
-/* Define if ENOLINK exists. */
-#undef HAVE_ENOLINK
-
-/* Define if ENOSPC exists. */
-#undef HAVE_ENOSPC
-
-/* Define if ENOSR exists. */
-#undef HAVE_ENOSR
-
-/* Define if ENOSTR exists. */
-#undef HAVE_ENOSTR
-
-/* Define if ENOTRECOVERABLE exists. */
-#undef HAVE_ENOTRECOVERABLE
-
-/* Define if ENOTSUP exists. */
-#undef HAVE_ENOTSUP
-
-/* Define if EOVERFLOW exists. */
-#undef HAVE_EOVERFLOW
-
-/* Define if EOWNERDEAD exists. */
-#undef HAVE_EOWNERDEAD
-
-/* Define if EPERM exists. */
-#undef HAVE_EPERM
-
-/* Define if EPROTO exists. */
-#undef HAVE_EPROTO
-
-/* Define if ETIME exists. */
-#undef HAVE_ETIME
-
-/* Define if ETIMEDOUT exists. */
-#undef HAVE_ETIMEDOUT
-
-/* Define if ETXTBSY exists. */
-#undef HAVE_ETXTBSY
-
-/* Define if EWOULDBLOCK exists. */
-#undef HAVE_EWOULDBLOCK
-
 /* Define to 1 if GCC 4.6 supported std::exception_ptr for the target */
 #undef HAVE_EXCEPTION_PTR_SINCE_GCC46
 
diff --git a/libstdc++-v3/config/os/djgpp/error_constants.h b/libstdc++-v3/config/os/djgpp/error_constants.h
index 7b8810d62f1..6540bdb13a0 100644
--- a/libstdc++-v3/config/os/djgpp/error_constants.h
+++ b/libstdc++-v3/config/os/djgpp/error_constants.h
@@ -48,7 +48,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bad_address = 				EFAULT,
       bad_file_descriptor = 			EBADF,
 
-#ifdef _GLIBCXX_HAVE_EBADMSG
+#ifdef EBADMSG
       bad_message = 				EBADMSG,
 #endif
 
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       function_not_supported = 			ENOSYS,
 //    host_unreachable = 			EHOSTUNREACH,
 
-#ifdef _GLIBCXX_HAVE_EIDRM
+#ifdef EIDRM
       identifier_removed = 			EIDRM,
 #endif
 
@@ -86,13 +86,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    no_buffer_space = 			ENOBUFS,
       no_child_process = 			ECHILD,
 
-#ifdef _GLIBCXX_HAVE_ENOLINK
+#ifdef ENOLINK
       no_link = 				ENOLINK,
 #endif
 
       no_lock_available = 			ENOLCK,
 
-#ifdef _GLIBCXX_HAVE_ENODATA
+#ifdef ENODATA
       no_message_available = 			ENODATA,
 #endif
 
@@ -100,7 +100,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    no_protocol_option = 			ENOPROTOOPT,
       no_space_on_device = 			ENOSPC,
 
-#ifdef _GLIBCXX_HAVE_ENOSR
+#ifdef ENOSR
       no_stream_resources = 			ENOSR,
 #endif
 
@@ -111,18 +111,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       not_a_directory = 			ENOTDIR,
 //    not_a_socket = 				ENOTSOCK,
 
-#ifdef _GLIBCXX_HAVE_ENOSTR
+#ifdef ENOSTR
       not_a_stream = 				ENOSTR,
 #endif
 
 //    not_connected = 				ENOTCONN,
       not_enough_memory = 			ENOMEM,
 
-#ifdef _GLIBCXX_HAVE_ENOTSUP
+#ifdef ENOTSUP
       not_supported = 				ENOTSUP,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ECANCELED
+#ifdef ECANCELED
       operation_canceled = 			ECANCELED,
 #endif
 
@@ -131,13 +131,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    operation_not_supported = 		EOPNOTSUPP,
 //    operation_would_block = 			EWOULDBLOCK,
 
-#ifdef _GLIBCXX_HAVE_EOWNERDEAD
+#ifdef EOWNERDEAD
       owner_dead = 				EOWNERDEAD,
 #endif
 
       permission_denied = 			EACCES,
 
-#ifdef _GLIBCXX_HAVE_EPROTO
+#ifdef EPROTO
       protocol_error = 				EPROTO,
 #endif
 
@@ -147,15 +147,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       resource_unavailable_try_again = 		EAGAIN,
       result_out_of_range = 			ERANGE,
 
-#ifdef _GLIBCXX_HAVE_ENOTRECOVERABLE
+#ifdef ENOTRECOVERABLE
       state_not_recoverable = 			ENOTRECOVERABLE,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETIME
+#ifdef ETIME
       stream_timeout = 				ETIME,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETXTBSY
+#ifdef ETXTBSY
       text_file_busy = 				ETXTBSY,
 #endif
 
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       too_many_links = 				EMLINK,
       too_many_symbolic_link_levels = 		ELOOP,
 
-#ifdef _GLIBCXX_HAVE_EOVERFLOW
+#ifdef EOVERFLOW
       value_too_large = 			EOVERFLOW,
 #endif
 
diff --git a/libstdc++-v3/config/os/generic/error_constants.h b/libstdc++-v3/config/os/generic/error_constants.h
index 95bef92d4cd..bf4bed28cad 100644
--- a/libstdc++-v3/config/os/generic/error_constants.h
+++ b/libstdc++-v3/config/os/generic/error_constants.h
@@ -48,7 +48,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bad_address = 				EFAULT,
       bad_file_descriptor = 			EBADF,
 
-#ifdef _GLIBCXX_HAVE_EBADMSG
+#ifdef EBADMSG
       bad_message = 				EBADMSG,
 #endif
 
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       function_not_supported = 			ENOSYS,
       host_unreachable = 			EHOSTUNREACH,
 
-#ifdef _GLIBCXX_HAVE_EIDRM
+#ifdef EIDRM
       identifier_removed = 			EIDRM,
 #endif
 
@@ -86,13 +86,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       no_buffer_space = 			ENOBUFS,
       no_child_process = 			ECHILD,
 
-#ifdef _GLIBCXX_HAVE_ENOLINK
+#ifdef ENOLINK
       no_link = 				ENOLINK,
 #endif
 
       no_lock_available = 			ENOLCK,
 
-#ifdef _GLIBCXX_HAVE_ENODATA
+#ifdef ENODATA
       no_message_available = 			ENODATA,
 #endif
 
@@ -100,7 +100,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       no_protocol_option = 			ENOPROTOOPT,
       no_space_on_device = 			ENOSPC,
 
-#ifdef _GLIBCXX_HAVE_ENOSR
+#ifdef ENOSR
       no_stream_resources = 			ENOSR,
 #endif
 
@@ -111,18 +111,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       not_a_directory = 			ENOTDIR,
       not_a_socket = 				ENOTSOCK,
 
-#ifdef _GLIBCXX_HAVE_ENOSTR
+#ifdef ENOSTR
       not_a_stream = 				ENOSTR,
 #endif
 
       not_connected = 				ENOTCONN,
       not_enough_memory = 			ENOMEM,
 
-#ifdef _GLIBCXX_HAVE_ENOTSUP
+#ifdef ENOTSUP
       not_supported = 				ENOTSUP,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ECANCELED
+#ifdef ECANCELED
       operation_canceled = 			ECANCELED,
 #endif
 
@@ -131,13 +131,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operation_not_supported = 		EOPNOTSUPP,
       operation_would_block = 			EWOULDBLOCK,
 
-#ifdef _GLIBCXX_HAVE_EOWNERDEAD
+#ifdef EOWNERDEAD
       owner_dead = 				EOWNERDEAD,
 #endif
 
       permission_denied = 			EACCES,
 
-#ifdef _GLIBCXX_HAVE_EPROTO
+#ifdef EPROTO
       protocol_error = 				EPROTO,
 #endif
 
@@ -147,15 +147,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       resource_unavailable_try_again = 		EAGAIN,
       result_out_of_range = 			ERANGE,
 
-#ifdef _GLIBCXX_HAVE_ENOTRECOVERABLE
+#ifdef ENOTRECOVERABLE
       state_not_recoverable = 			ENOTRECOVERABLE,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETIME
+#ifdef ETIME
       stream_timeout = 				ETIME,
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETXTBSY
+#ifdef ETXTBSY
       text_file_busy = 				ETXTBSY,
 #endif
 
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       too_many_links = 				EMLINK,
       too_many_symbolic_link_levels = 		ELOOP,
 
-#ifdef _GLIBCXX_HAVE_EOVERFLOW
+#ifdef EOVERFLOW
       value_too_large = 			EOVERFLOW,
 #endif
 
diff --git a/libstdc++-v3/config/os/mingw32-w64/error_constants.h b/libstdc++-v3/config/os/mingw32-w64/error_constants.h
index ea893b1f59d..2394a04bd11 100644
--- a/libstdc++-v3/config/os/mingw32-w64/error_constants.h
+++ b/libstdc++-v3/config/os/mingw32-w64/error_constants.h
@@ -49,7 +49,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       argument_out_of_domain = 			EDOM,
       bad_address = 				EFAULT,
       bad_file_descriptor = 			EBADF,
-#ifdef _GLIBCXX_HAVE_EBADMSG
+#ifdef EBADMSG
       bad_message = 				EBADMSG,
 #endif
       broken_pipe = 				EPIPE,
@@ -67,7 +67,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       filename_too_long = 			ENAMETOOLONG,
       function_not_supported = 			ENOSYS,
       host_unreachable = 			EHOSTUNREACH,
-#ifdef _GLIBCXX_HAVE_EIDRM
+#ifdef EIDRM
       identifier_removed = 			EIDRM,
 #endif
       illegal_byte_sequence = 			EILSEQ,
@@ -82,24 +82,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       network_reset = 				ENETRESET,
       network_unreachable = 			ENETUNREACH,
       no_buffer_space = 			ENOBUFS,
-#ifdef _GLIBCXX_HAVE_ECHILD
+#ifdef ECHILD
       no_child_process = 			ECHILD,
 #endif
-#ifdef _GLIBCXX_HAVE_ENOLINK
+#ifdef ENOLINK
       no_link = 				ENOLINK,
 #endif
       no_lock_available = 			ENOLCK,
-#ifdef _GLIBCXX_HAVE_ENODATA
+#ifdef ENODATA
       no_message_available = 			ENODATA,
 #endif
-#ifdef _GLIBCXX_HAVE_ENOMSG
+#ifdef ENOMSG
       no_message = 				ENOMSG,
 #endif
       no_protocol_option = 			ENOPROTOOPT,
-#ifdef _GLIBCXX_HAVE_ENOSPC
+#ifdef ENOSPC
       no_space_on_device = 			ENOSPC,
 #endif
-#ifdef _GLIBCXX_HAVE_ENOSR
+#ifdef ENOSR
       no_stream_resources = 			ENOSR,
 #endif
       no_such_device_or_address = 		ENXIO,
@@ -108,24 +108,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       no_such_process = 			ESRCH,
       not_a_directory = 			ENOTDIR,
       not_a_socket = 				ENOTSOCK,
-#ifdef _GLIBCXX_HAVE_ENOSTR
+#ifdef ENOSTR
       not_a_stream = 				ENOSTR,
 #endif
       not_connected = 				ENOTCONN,
       not_enough_memory = 			ENOMEM,
-#ifdef _GLIBCXX_HAVE_ENOTSUP
+#ifdef ENOTSUP
       not_supported = 				ENOTSUP,
 #endif
       operation_canceled = 			ECANCELED,
       operation_in_progress = 			EINPROGRESS,
-#ifdef _GLIBCXX_HAVE_EPERM
+#ifdef EPERM
       operation_not_permitted = 		EPERM,
 #endif
       operation_not_supported = 		EOPNOTSUPP,
-#ifdef _GLIBCXX_HAVE_EWOULDBLOCK
+#ifdef EWOULDBLOCK
       operation_would_block = 			EWOULDBLOCK,
 #endif
-#ifdef _GLIBCXX_HAVE_EOWNERDEAD
+#ifdef EOWNERDEAD
       owner_dead = 				EOWNERDEAD,
 #endif
       permission_denied = 			EACCES,
@@ -135,23 +135,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       resource_deadlock_would_occur = 		EDEADLK,
       resource_unavailable_try_again = 		EAGAIN,
       result_out_of_range = 			ERANGE,
-#ifdef _GLIBCXX_HAVE_ENOTRECOVERABLE
+#ifdef ENOTRECOVERABLE
       state_not_recoverable = 			ENOTRECOVERABLE,
 #endif
-#ifdef _GLIBCXX_HAVE_ETIME
+#ifdef ETIME
       stream_timeout = 				ETIME,
 #endif
-#ifdef _GLIBCXX_HAVE_ETXTBSY
+#ifdef ETXTBSY
       text_file_busy = 				ETXTBSY,
 #endif
-#ifdef _GLIBCXX_HAVE_ETIMEDOUT
+#ifdef ETIMEDOUT
       timed_out = 				ETIMEDOUT,
 #endif
       too_many_files_open_in_system = 		ENFILE,
       too_many_files_open = 			EMFILE,
       too_many_links = 				EMLINK,
       too_many_symbolic_link_levels = 		ELOOP,
-#ifdef _GLIBCXX_HAVE_EOVERFLOW
+#ifdef EOVERFLOW
       value_too_large = 			EOVERFLOW,
 #endif
       wrong_protocol_type = 			EPROTOTYPE
diff --git a/libstdc++-v3/config/os/mingw32/error_constants.h b/libstdc++-v3/config/os/mingw32/error_constants.h
index 974c94fa1b1..d8ea420e586 100644
--- a/libstdc++-v3/config/os/mingw32/error_constants.h
+++ b/libstdc++-v3/config/os/mingw32/error_constants.h
@@ -78,7 +78,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    network_reset = 				ENETRESET,
 //    network_unreachable = 			ENETUNREACH,
 //    no_buffer_space = 			ENOBUFS,
-#ifdef _GLIBCXX_HAVE_ECHILD
+#ifdef ECHILD
       no_child_process = 			ECHILD,
 #endif
 //    no_link = 				ENOLINK,
@@ -86,7 +86,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    no_message_available = 			ENODATA,
 //    no_message = 				ENOMSG,
 //    no_protocol_option = 			ENOPROTOOPT,
-#ifdef _GLIBCXX_HAVE_ENOSPC
+#ifdef ENOSPC
       no_space_on_device = 			ENOSPC,
 #endif
 //    no_stream_resources = 			ENOSR,
@@ -99,16 +99,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    not_a_stream = 				ENOSTR,
 //    not_connected = 				ENOTCONN,
       not_enough_memory = 			ENOMEM,
-#ifdef _GLIBCXX_HAVE_ENOTSUP
+#ifdef ENOTSUP
       not_supported = 				ENOTSUP,
 #endif
 //    operation_canceled = 			ECANCELED,
 //    operation_in_progress = 			EINPROGRESS,
-#ifdef _GLIBCXX_HAVE_EPERM
+#ifdef EPERM
       operation_not_permitted = 		EPERM,
 #endif
 //    operation_not_supported = 		EOPNOTSUPP,
-#ifdef _GLIBCXX_HAVE_EWOULDBLOCK
+#ifdef EWOULDBLOCK
       operation_would_block = 			EWOULDBLOCK,
 #endif
 //    owner_dead = 				EOWNERDEAD,
@@ -122,14 +122,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 //    state_not_recoverable = 			ENOTRECOVERABLE,
 //    stream_timeout = 				ETIME,
 //    text_file_busy = 				ETXTBSY,
-#ifdef _GLIBCXX_HAVE_ETIMEDOUT
+#ifdef ETIMEDOUT
       timed_out = 				ETIMEDOUT,
 #endif
       too_many_files_open_in_system = 		ENFILE,
       too_many_files_open = 			EMFILE,
       too_many_links = 				EMLINK
 //    too_many_symbolic_link_levels = 		ELOOP,
-#ifdef _GLIBCXX_HAVE_EOVERFLOW
+#ifdef EOVERFLOW
 	,
       value_too_large = 			EOVERFLOW
 #endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index ec6f7eb00b7..bd393d6e6d3 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -18942,637 +18942,6 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EOWNERDEAD" >&5
-$as_echo_n "checking for EOWNERDEAD... " >&6; }
-if ${glibcxx_cv_system_error1+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EOWNERDEAD;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error1=yes
-else
-  glibcxx_cv_system_error1=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error1" >&5
-$as_echo "$glibcxx_cv_system_error1" >&6; }
-if test x"$glibcxx_cv_system_error1" = x"yes"; then
-
-$as_echo "#define HAVE_EOWNERDEAD 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOTRECOVERABLE" >&5
-$as_echo_n "checking for ENOTRECOVERABLE... " >&6; }
-if ${glibcxx_cv_system_error2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOTRECOVERABLE;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error2=yes
-else
-  glibcxx_cv_system_error2=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error2" >&5
-$as_echo "$glibcxx_cv_system_error2" >&6; }
-if test x"$glibcxx_cv_system_error2" = x"yes"; then
-
-$as_echo "#define HAVE_ENOTRECOVERABLE 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOLINK" >&5
-$as_echo_n "checking for ENOLINK... " >&6; }
-if ${glibcxx_cv_system_error3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOLINK;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error3=yes
-else
-  glibcxx_cv_system_error3=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error3" >&5
-$as_echo "$glibcxx_cv_system_error3" >&6; }
-if test x"$glibcxx_cv_system_error3" = x"yes"; then
-
-$as_echo "#define HAVE_ENOLINK 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EPROTO" >&5
-$as_echo_n "checking for EPROTO... " >&6; }
-if ${glibcxx_cv_system_error4+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EPROTO;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error4=yes
-else
-  glibcxx_cv_system_error4=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error4" >&5
-$as_echo "$glibcxx_cv_system_error4" >&6; }
-if test x"$glibcxx_cv_system_error4" = x"yes"; then
-
-$as_echo "#define HAVE_EPROTO 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENODATA" >&5
-$as_echo_n "checking for ENODATA... " >&6; }
-if ${glibcxx_cv_system_error5+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENODATA;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error5=yes
-else
-  glibcxx_cv_system_error5=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error5" >&5
-$as_echo "$glibcxx_cv_system_error5" >&6; }
-if test x"$glibcxx_cv_system_error5" = x"yes"; then
-
-$as_echo "#define HAVE_ENODATA 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOSR" >&5
-$as_echo_n "checking for ENOSR... " >&6; }
-if ${glibcxx_cv_system_error6+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOSR;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error6=yes
-else
-  glibcxx_cv_system_error6=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error6" >&5
-$as_echo "$glibcxx_cv_system_error6" >&6; }
-if test x"$glibcxx_cv_system_error6" = x"yes"; then
-
-$as_echo "#define HAVE_ENOSR 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOSTR" >&5
-$as_echo_n "checking for ENOSTR... " >&6; }
-if ${glibcxx_cv_system_error7+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOSTR;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error7=yes
-else
-  glibcxx_cv_system_error7=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error7" >&5
-$as_echo "$glibcxx_cv_system_error7" >&6; }
-if test x"$glibcxx_cv_system_error7" = x"yes"; then
-
-$as_echo "#define HAVE_ENOSTR 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ETIME" >&5
-$as_echo_n "checking for ETIME... " >&6; }
-if ${glibcxx_cv_system_error8+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ETIME;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error8=yes
-else
-  glibcxx_cv_system_error8=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error8" >&5
-$as_echo "$glibcxx_cv_system_error8" >&6; }
-if test x"$glibcxx_cv_system_error8" = x"yes"; then
-
-$as_echo "#define HAVE_ETIME 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EBADMSG" >&5
-$as_echo_n "checking for EBADMSG... " >&6; }
-if ${glibcxx_cv_system_error9+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EBADMSG;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error9=yes
-else
-  glibcxx_cv_system_error9=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error9" >&5
-$as_echo "$glibcxx_cv_system_error9" >&6; }
-if test x"$glibcxx_cv_system_error9" = x"yes"; then
-
-$as_echo "#define HAVE_EBADMSG 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ECANCELED" >&5
-$as_echo_n "checking for ECANCELED... " >&6; }
-if ${glibcxx_cv_system_error10+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ECANCELED;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error10=yes
-else
-  glibcxx_cv_system_error10=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error10" >&5
-$as_echo "$glibcxx_cv_system_error10" >&6; }
-if test x"$glibcxx_cv_system_error10" = x"yes"; then
-
-$as_echo "#define HAVE_ECANCELED 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EOVERFLOW" >&5
-$as_echo_n "checking for EOVERFLOW... " >&6; }
-if ${glibcxx_cv_system_error11+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EOVERFLOW;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error11=yes
-else
-  glibcxx_cv_system_error11=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error11" >&5
-$as_echo "$glibcxx_cv_system_error11" >&6; }
-if test x"$glibcxx_cv_system_error11" = x"yes"; then
-
-$as_echo "#define HAVE_EOVERFLOW 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOTSUP" >&5
-$as_echo_n "checking for ENOTSUP... " >&6; }
-if ${glibcxx_cv_system_error12+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOTSUP;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error12=yes
-else
-  glibcxx_cv_system_error12=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error12" >&5
-$as_echo "$glibcxx_cv_system_error12" >&6; }
-if test x"$glibcxx_cv_system_error12" = x"yes"; then
-
-$as_echo "#define HAVE_ENOTSUP 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EIDRM" >&5
-$as_echo_n "checking for EIDRM... " >&6; }
-if ${glibcxx_cv_system_error13+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EIDRM;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error13=yes
-else
-  glibcxx_cv_system_error13=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error13" >&5
-$as_echo "$glibcxx_cv_system_error13" >&6; }
-if test x"$glibcxx_cv_system_error13" = x"yes"; then
-
-$as_echo "#define HAVE_EIDRM 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ETXTBSY" >&5
-$as_echo_n "checking for ETXTBSY... " >&6; }
-if ${glibcxx_cv_system_error14+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ETXTBSY;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error14=yes
-else
-  glibcxx_cv_system_error14=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error14" >&5
-$as_echo "$glibcxx_cv_system_error14" >&6; }
-if test x"$glibcxx_cv_system_error14" = x"yes"; then
-
-$as_echo "#define HAVE_ETXTBSY 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ECHILD" >&5
-$as_echo_n "checking for ECHILD... " >&6; }
-if ${glibcxx_cv_system_error15+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ECHILD;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error15=yes
-else
-  glibcxx_cv_system_error15=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error15" >&5
-$as_echo "$glibcxx_cv_system_error15" >&6; }
-if test x"$glibcxx_cv_system_error15" = x"yes"; then
-
-$as_echo "#define HAVE_ECHILD 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ENOSPC" >&5
-$as_echo_n "checking for ENOSPC... " >&6; }
-if ${glibcxx_cv_system_error16+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ENOSPC;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error16=yes
-else
-  glibcxx_cv_system_error16=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error16" >&5
-$as_echo "$glibcxx_cv_system_error16" >&6; }
-if test x"$glibcxx_cv_system_error16" = x"yes"; then
-
-$as_echo "#define HAVE_ENOSPC 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EPERM" >&5
-$as_echo_n "checking for EPERM... " >&6; }
-if ${glibcxx_cv_system_error17+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EPERM;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error17=yes
-else
-  glibcxx_cv_system_error17=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error17" >&5
-$as_echo "$glibcxx_cv_system_error17" >&6; }
-if test x"$glibcxx_cv_system_error17" = x"yes"; then
-
-$as_echo "#define HAVE_EPERM 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ETIMEDOUT" >&5
-$as_echo_n "checking for ETIMEDOUT... " >&6; }
-if ${glibcxx_cv_system_error18+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = ETIMEDOUT;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error18=yes
-else
-  glibcxx_cv_system_error18=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error18" >&5
-$as_echo "$glibcxx_cv_system_error18" >&6; }
-if test x"$glibcxx_cv_system_error18" = x"yes"; then
-
-$as_echo "#define HAVE_ETIMEDOUT 1" >>confdefs.h
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for EWOULDBLOCK" >&5
-$as_echo_n "checking for EWOULDBLOCK... " >&6; }
-if ${glibcxx_cv_system_error19+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = EWOULDBLOCK;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  glibcxx_cv_system_error19=yes
-else
-  glibcxx_cv_system_error19=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_system_error19" >&5
-$as_echo "$glibcxx_cv_system_error19" >&6; }
-if test x"$glibcxx_cv_system_error19" = x"yes"; then
-
-$as_echo "#define HAVE_EWOULDBLOCK 1" >>confdefs.h
-
-fi
-
-
-
-
   # Test uchar.h.
   for ac_header in uchar.h
 do :
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index d8455e41574..8365a647ffa 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -183,7 +183,6 @@ GLIBCXX_ENABLE_VTABLE_VERIFY([no])
 # Checks for operating systems support that doesn't require linking.
 GLIBCXX_CHECK_STDIO_PROTO
 GLIBCXX_CHECK_MATH11_PROTO
-GLIBCXX_CHECK_SYSTEM_ERROR
 GLIBCXX_CHECK_UCHAR_H
 
 # For the streamoff typedef.
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
index 18407225d7a..aa85d85db46 100644
--- a/libstdc++-v3/doc/html/faq.html
+++ b/libstdc++-v3/doc/html/faq.html
@@ -456,7 +456,7 @@
          <code class="varname">CPLUSPLUS_CPP_SPEC</code> in
          the gcc config headers for your target (and try changing them to
          see what happens when building complicated code).  You can also run
-         <span class="command"><strong>g++ -E -dM - &lt; /dev/null"</strong></span> to display
+         <span class="command"><strong>g++ -E -dM -x c++ /dev/null</strong></span> to display
          a list of predefined macros for any particular installation.
       </p><p>This has been discussed on the mailing lists
          <a class="link" href="http://gcc.gnu.org/cgi-bin/htsearch?method=and&amp;format=builtin-long&amp;sort=score&amp;words=_XOPEN_SOURCE+Solaris" target="_top">quite a bit</a>.
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
index cf8684e1cea..ef673ef4954 100644
--- a/libstdc++-v3/doc/xml/faq.xml
+++ b/libstdc++-v3/doc/xml/faq.xml
@@ -580,7 +580,7 @@
          <varname>CPLUSPLUS_CPP_SPEC</varname> in
          the gcc config headers for your target (and try changing them to
          see what happens when building complicated code).  You can also run
-         <command>g++ -E -dM - &lt; /dev/null"</command> to display
+         <command>g++ -E -dM -x c++ /dev/null</command> to display
          a list of predefined macros for any particular installation.
       </para>
       <para>This has been discussed on the mailing lists
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 518981559a0..c4c07e8c2f4 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -55,7 +55,7 @@
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr24733.xml">
     </xi:include>
 
-    <!-- Section 01.7 : Status C++ IS 24733 -->
+    <!-- Section 01.7 : Status C++ IS 29124 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxis29124.xml">
     </xi:include>
   </section>
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 7958f436242..cb4308365ca 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -1334,6 +1334,8 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \
 	    -e 's/VERSION/_GLIBCXX_VERSION/g' \
 	    -e 's/WORDS_/_GLIBCXX_WORDS_/g' \
+	    -e 's/LT_OBJDIR/_GLIBCXX_LT_OBJDIR/g' \
+	    -e 's/STDC_HEADERS/_GLIBCXX_STDC_HEADERS/g' \
 	    -e 's/_DARWIN_USE_64_BIT_INODE/_GLIBCXX_DARWIN_USE_64_BIT_INODE/g' \
 	    -e 's/_FILE_OFFSET_BITS/_GLIBCXX_FILE_OFFSET_BITS/g' \
 	    -e 's/_LARGE_FILES/_GLIBCXX_LARGE_FILES/g' \
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 631c77280b0..e18c771b16b 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -1816,6 +1816,8 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	    -e 's/PACKAGE/_GLIBCXX_PACKAGE/g' \
 	    -e 's/VERSION/_GLIBCXX_VERSION/g' \
 	    -e 's/WORDS_/_GLIBCXX_WORDS_/g' \
+	    -e 's/LT_OBJDIR/_GLIBCXX_LT_OBJDIR/g' \
+	    -e 's/STDC_HEADERS/_GLIBCXX_STDC_HEADERS/g' \
 	    -e 's/_DARWIN_USE_64_BIT_INODE/_GLIBCXX_DARWIN_USE_64_BIT_INODE/g' \
 	    -e 's/_FILE_OFFSET_BITS/_GLIBCXX_FILE_OFFSET_BITS/g' \
 	    -e 's/_LARGE_FILES/_GLIBCXX_LARGE_FILES/g' \
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 6c11135fa8c..5977b5cb7c0 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -528,7 +528,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 #endif
       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
       : _M_dataplus(_M_local_data(), __a)
-      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
+      {
+	const _CharT* __end = __s ? __s + traits_type::length(__s)
+	  // We just need a non-null pointer here to get an exception:
+	  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
+	_M_construct(__s, __end, random_access_iterator_tag());
+      }
 
       /**
        *  @brief  Construct string as multiple characters.
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index 50bd25eb2df..4c7b84e357f 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -227,7 +227,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_string_p(const _CharT* __s)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
@@ -250,7 +250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index 088111e3330..b74c56a173e 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -372,6 +372,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       forward_list<_Tp, _Alloc>::
       merge(forward_list&& __list, _Comp __comp)
       {
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3088. forward_list::merge behavior unclear when passed *this
+	if (std::__addressof(__list) == this)
+	  return;
+
 	_Node_base* __node = &this->_M_impl._M_head;
 	while (__node->_M_next && __list._M_impl._M_head._M_next)
 	  {
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 13eb18c0652..f4fa9f3719d 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void>
@@ -1274,7 +1274,7 @@ inline ptrdiff_t
 distance(filesystem::path::iterator __first, filesystem::path::iterator __last)
 { return __path_iter_distance(__first, __last); }
 
-template<typename _InputIterator, typename _Distance>
+template<typename _Distance>
   void
   advance(filesystem::path::iterator& __i, _Distance __n)
   { __path_iter_advance(__i, static_cast<ptrdiff_t>(__n)); }
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index 0a299baedc5..0f758671f69 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -1941,7 +1941,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool __saved_avail;
       if (__is >> __mean >> __stddev >> __saved_avail)
 	{
-	  if (__saved_avail && (__is >> __x._M_saved))
+	  if (!__saved_avail || (__is >> __x._M_saved))
 	    {
 	      __x._M_saved_available = __saved_avail;
 	      __x.param(typename normal_distribution<_RealType>::
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 8fb89071461..8fd13b2f071 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -35,7 +35,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename, typename>
     class basic_regex;
 
-  template<typename, typename>
+  template<typename _Bi_iter, typename _Alloc>
     class match_results;
 
 _GLIBCXX_END_NAMESPACE_CXX11
@@ -1707,7 +1707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       _GLIBCXX_NODISCARD bool
       empty() const noexcept
-      { return size() == 0; }
+      { return _Base_type::size() <= 3; }
 
       ///@}
 
@@ -1825,7 +1825,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       const_iterator
       end() const noexcept
-      { return _Base_type::end() - (empty() ? 0 : 3); }
+      { return _Base_type::end() - (_Base_type::empty() ? 0 : 3); }
 
       /**
        * @brief Gets an iterator to one-past-the-end of the collection.
@@ -1970,7 +1970,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       _M_suffix()
       { return _Base_type::operator[](_Base_type::size() - 1); }
 
-      _Bi_iter _M_begin;
+      _Bi_iter _M_begin {};
     };
 
   typedef match_results<const char*>		 cmatch;
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 281600b2901..4ddc52ae723 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -698,6 +698,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline shared_ptr<_Tp>
     allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 			     std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index 0367c2d51a5..8af6e9fb11c 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1822,6 +1822,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     __allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 				    std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/bits/vector.tcc b/libstdc++-v3/include/bits/vector.tcc
index 497d9f72247..7d56c63134a 100644
--- a/libstdc++-v3/include/bits/vector.tcc
+++ b/libstdc++-v3/include/bits/vector.tcc
@@ -944,7 +944,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	return false;
       __try
 	{
-	  _M_reallocate(size());
+	  if (size_type __n = size())
+	    _M_reallocate(__n);
+	  else
+	    {
+	      this->_M_deallocate();
+	      this->_M_impl._M_reset();
+	    }
 	  return true;
 	}
       __catch(...)
diff --git a/libstdc++-v3/include/c_global/cmath b/libstdc++-v3/include/c_global/cmath
index 01e56a559fe..11f0706e203 100644
--- a/libstdc++-v3/include/c_global/cmath
+++ b/libstdc++-v3/include/c_global/cmath
@@ -1844,7 +1844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // _GLIBCXX_USE_C99_MATH_TR1
 #endif // C++11
 
-#if __cplusplus > 201402L
+#if __cplusplus >= 201703L
 
   // [c.math.hypot3], three-dimensional hypotenuse
 #define __cpp_lib_hypot 201603
@@ -1877,10 +1877,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { return std::__hypot3<long double>(__x, __y, __z); }
 
   template<typename _Tp, typename _Up, typename _Vp>
-    typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
+    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
     hypot(_Tp __x, _Up __y, _Vp __z)
     {
-      using __type = typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type;
+      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
       return std::__hypot3<__type>(__x, __y, __z);
     }
 #endif // C++17
@@ -1918,6 +1918,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   constexpr long double
   lerp(long double __a, long double __b, long double __t) noexcept
   { return std::__lerp(__a, __b, __t); }
+
+  template<typename _Tp, typename _Up, typename _Vp>
+    constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
+    lerp(_Tp __x, _Up __y, _Vp __z) noexcept
+    {
+      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
+      return std::__lerp<__type>(__x, __y, __z);
+    }
 #endif // C++20
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/experimental/bits/fs_fwd.h b/libstdc++-v3/include/experimental/bits/fs_fwd.h
index 0da15ef4297..63cb6d15bec 100644
--- a/libstdc++-v3/include/experimental/bits/fs_fwd.h
+++ b/libstdc++-v3/include/experimental/bits/fs_fwd.h
@@ -263,7 +263,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
 
   bool copy_file(const path& __from, const path& __to, copy_options __option);
   bool copy_file(const path& __from, const path& __to, copy_options __option,
-		 error_code&) noexcept;
+		 error_code&);
 
   path current_path();
 
diff --git a/libstdc++-v3/include/experimental/bits/fs_ops.h b/libstdc++-v3/include/experimental/bits/fs_ops.h
index c92cb56bd75..e41f023da18 100644
--- a/libstdc++-v3/include/experimental/bits/fs_ops.h
+++ b/libstdc++-v3/include/experimental/bits/fs_ops.h
@@ -74,19 +74,19 @@ inline namespace v1
   { return copy_file(__from, __to, copy_options::none); }
 
   inline bool
-  copy_file(const path& __from, const path& __to, error_code& __ec) noexcept
+  copy_file(const path& __from, const path& __to, error_code& __ec)
   { return copy_file(__from, __to, copy_options::none, __ec); }
 
   bool copy_file(const path& __from, const path& __to, copy_options __option);
   bool copy_file(const path& __from, const path& __to, copy_options __option,
-		 error_code& __ec) noexcept;
+		 error_code& __ec);
 
   void copy_symlink(const path& __existing_symlink, const path& __new_symlink);
   void copy_symlink(const path& __existing_symlink, const path& __new_symlink,
 		    error_code& __ec) noexcept;
 
   bool create_directories(const path& __p);
-  bool create_directories(const path& __p, error_code& __ec) noexcept;
+  bool create_directories(const path& __p, error_code& __ec);
 
   bool create_directory(const path& __p);
   bool create_directory(const path& __p, error_code& __ec) noexcept;
@@ -262,7 +262,7 @@ inline namespace v1
   bool remove(const path& __p, error_code& __ec) noexcept;
 
   uintmax_t remove_all(const path& __p);
-  uintmax_t remove_all(const path& __p, error_code& __ec) noexcept;
+  uintmax_t remove_all(const path& __p, error_code& __ec);
 
   void rename(const path& __from, const path& __to);
   void rename(const path& __from, const path& __to, error_code& __ec) noexcept;
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 33a415645d9..8bc6abf155f 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -125,7 +125,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void,
@@ -398,8 +398,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     class iterator;
     typedef iterator const_iterator;
 
-    iterator begin() const;
-    iterator end() const;
+    iterator begin() const noexcept;
+    iterator end() const noexcept;
 
     // Create a basic_string by reading until a null character.
     template<typename _InputIterator,
diff --git a/libstdc++-v3/include/ext/bitmap_allocator.h b/libstdc++-v3/include/ext/bitmap_allocator.h
index 532bad295b6..f2f0a38650b 100644
--- a/libstdc++-v3/include/ext/bitmap_allocator.h
+++ b/libstdc++-v3/include/ext/bitmap_allocator.h
@@ -31,7 +31,7 @@
 
 #include <utility> // For std::pair.
 #include <bits/functexcept.h> // For __throw_bad_alloc().
-#include <functional> // For greater_equal, and less_equal.
+#include <bits/stl_function.h> // For greater_equal, and less_equal.
 #include <new> // For operator new.
 #include <debug/debug.h> // _GLIBCXX_DEBUG_ASSERT
 #include <ext/concurrence.h>
diff --git a/libstdc++-v3/include/ext/rope b/libstdc++-v3/include/ext/rope
index 127d113c349..44ff974eba7 100644
--- a/libstdc++-v3/include/ext/rope
+++ b/libstdc++-v3/include/ext/rope
@@ -2383,7 +2383,7 @@ protected:
       }
 
       // Erase, single character
-      void
+      _GLIBCXX_DEPRECATED void
       erase(size_t __p)
       { erase(__p, __p + 1); }
 
diff --git a/libstdc++-v3/include/ext/type_traits.h b/libstdc++-v3/include/ext/type_traits.h
index 97163911c29..49af656a7e8 100644
--- a/libstdc++-v3/include/ext/type_traits.h
+++ b/libstdc++-v3/include/ext/type_traits.h
@@ -163,7 +163,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { return true; }
 #endif
 
-  // For complex and cmath
+  // For arithmetic promotions in <complex> and <cmath>
+
   template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
     struct __promote
     { typedef double __type; };
@@ -187,6 +188,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     struct __promote<float>
     { typedef float __type; };
 
+#if __cpp_fold_expressions
+  template<typename... _Tp>
+    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));
+#endif
+
   template<typename _Tp, typename _Up,
            typename _Tp2 = typename __promote<_Tp>::__type,
            typename _Up2 = typename __promote<_Up>::__type>
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index 91c4c1a7cf1..4957144342c 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -105,8 +105,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 				     _Manager_internal<_Tp>,
 				     _Manager_external<_Tp>>;
 
-    template<typename _Tp, typename _Decayed = decay_t<_Tp>>
-      using _Decay = enable_if_t<!is_same<_Decayed, any>::value, _Decayed>;
+    template<typename _Tp, typename _VTp = decay_t<_Tp>>
+      using _Decay_if_not_any = enable_if_t<!is_same_v<_VTp, any>, _VTp>;
 
     /// Emplace with an object created from @p __args as the contained object.
     template <typename _Tp, typename... _Args,
@@ -125,10 +125,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void __do_emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	reset();
-        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
 	_M_manager = &_Mgr::_S_manage;
       }
 
+    template <typename _Res, typename _Tp, typename... _Args>
+      using __any_constructible
+	= enable_if<__and_<is_copy_constructible<_Tp>,
+			   is_constructible<_Tp, _Args...>>::value,
+		    _Res>;
+
+    template <typename _Tp, typename... _Args>
+      using __any_constructible_t
+	= typename __any_constructible<bool, _Tp, _Args...>::type;
+
+    template<typename _VTp, typename... _Args>
+      using __emplace_t
+	= typename __any_constructible<_VTp&, _VTp, _Args...>::type;
+
   public:
     // construct/destruct
 
@@ -165,65 +179,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	}
     }
 
-    template <typename _Res, typename _Tp, typename... _Args>
-    using __any_constructible =
-      enable_if<__and_<is_copy_constructible<_Tp>,
-			 is_constructible<_Tp, _Args...>>::value,
-		  _Res>;
-
-    template <typename _Tp, typename... _Args>
-    using __any_constructible_t =
-      typename __any_constructible<bool, _Tp, _Args...>::type;
-
     /// Construct with a copy of @p __value as the contained object.
-    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, _ValueType&&> = true,
-	      enable_if_t<!__is_in_place_type<_Tp>::value, bool> = true>
-      any(_ValueType&& __value)
+    template <typename _Tp, typename _VTp = _Decay_if_not_any<_Tp>,
+	      typename _Mgr = _Manager<_VTp>,
+	      enable_if_t<is_copy_constructible<_VTp>::value
+			  && !__is_in_place_type<_VTp>::value, bool> = true>
+      any(_Tp&& __value)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, std::forward<_ValueType>(__value));
-      }
-
-    /// Construct with a copy of @p __value as the contained object.
-    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              enable_if_t<__and_v<is_copy_constructible<_Tp>,
-				  __not_<is_constructible<_Tp, _ValueType&&>>,
-				  __not_<__is_in_place_type<_Tp>>>,
-			  bool> = false>
-      any(_ValueType&& __value)
-      : _M_manager(&_Mgr::_S_manage)
-      {
-        _Mgr::_S_create(_M_storage, __value);
+	_Mgr::_S_create(_M_storage, std::forward<_Tp>(__value));
       }
 
     /// Construct with an object created from @p __args as the contained object.
-    template <typename _ValueType, typename... _Args,
-	      typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, _Args&&...> = false>
+    template <typename _Tp, typename... _Args, typename _VTp = decay_t<_Tp>,
+	      typename _Mgr = _Manager<_VTp>,
+	      __any_constructible_t<_VTp, _Args&&...> = false>
       explicit
-      any(in_place_type_t<_ValueType>, _Args&&... __args)
+      any(in_place_type_t<_Tp>, _Args&&... __args)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
       }
 
     /// Construct with an object created from @p __il and @p __args as
     /// the contained object.
-    template <typename _ValueType, typename _Up, typename... _Args,
-	      typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, initializer_list<_Up>,
+    template <typename _Tp, typename _Up, typename... _Args,
+	      typename _VTp = decay_t<_Tp>, typename _Mgr = _Manager<_VTp>,
+	      __any_constructible_t<_VTp, initializer_list<_Up>&,
 				    _Args&&...> = false>
       explicit
-      any(in_place_type_t<_ValueType>,
-	  initializer_list<_Up> __il, _Args&&... __args)
+      any(in_place_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
       }
 
     /// Destructor, calls @c reset()
@@ -232,7 +220,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // assignments
 
     /// Copy the state of another object.
-    any& operator=(const any& __rhs)
+    any&
+    operator=(const any& __rhs)
     {
       *this = any(__rhs);
       return *this;
@@ -243,7 +232,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
      *
      * @post @c !__rhs.has_value() (not guaranteed for other implementations)
      */
-    any& operator=(any&& __rhs) noexcept
+    any&
+    operator=(any&& __rhs) noexcept
     {
       if (!__rhs.has_value())
 	reset();
@@ -258,40 +248,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
     /// Store a copy of @p __rhs as the contained object.
-    template<typename _ValueType>
-      enable_if_t<is_copy_constructible<_Decay<_ValueType>>::value, any&>
-      operator=(_ValueType&& __rhs)
+    template<typename _Tp>
+      enable_if_t<is_copy_constructible<_Decay_if_not_any<_Tp>>::value, any&>
+      operator=(_Tp&& __rhs)
       {
-	*this = any(std::forward<_ValueType>(__rhs));
+	*this = any(std::forward<_Tp>(__rhs));
 	return *this;
       }
 
     /// Emplace with an object created from @p __args as the contained object.
-    template <typename _ValueType, typename... _Args>
-      typename __any_constructible<_Decay<_ValueType>&,
-				   _Decay<_ValueType>, _Args&&...>::type
+    template <typename _Tp, typename... _Args>
+      __emplace_t<decay_t<_Tp>, _Args...>
       emplace(_Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>>(std::forward<_Args>(__args)...);
+	using _VTp = decay_t<_Tp>;
+	__do_emplace<_VTp>(std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
+	return *static_cast<_VTp*>(__arg._M_obj);
       }
 
     /// Emplace with an object created from @p __il and @p __args as
     /// the contained object.
-    template <typename _ValueType, typename _Up, typename... _Args>
-      typename __any_constructible<_Decay<_ValueType>&,
-				   _Decay<_ValueType>,
-				   initializer_list<_Up>,
-				   _Args&&...>::type
+    template <typename _Tp, typename _Up, typename... _Args>
+      __emplace_t<decay_t<_Tp>, initializer_list<_Up>&, _Args&&...>
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>, _Up>(__il,
-					      std::forward<_Args>(__args)...);
+	using _VTp = decay_t<_Tp>;
+	__do_emplace<_VTp, _Up>(__il, std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
+	return *static_cast<_VTp*>(__arg._M_obj);
       }
 
     // modifiers
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index 7f80d06cfbc..25fdfaf735f 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -261,9 +261,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
 	   _BinaryOperation __binary_op)
     {
-      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      using __ref = typename iterator_traits<_InputIterator>::reference;
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, __ref>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, _Tp&>);
       static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, _Tp&>);
-      static_assert(is_convertible_v<value_type, _Tp>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, __ref>);
       if constexpr (__is_random_access_iter<_InputIterator>::value)
 	{
 	  while ((__last - __first) >= 4)
diff --git a/libstdc++-v3/include/std/optional b/libstdc++-v3/include/std/optional
index 503d859bee6..0b264f49a2a 100644
--- a/libstdc++-v3/include/std/optional
+++ b/libstdc++-v3/include/std/optional
@@ -796,7 +796,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up>
 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 			    is_constructible<_Tp, const _Up&>,
-			    is_assignable<_Tp&, _Up>,
+			    is_assignable<_Tp&, const _Up&>,
 			    __not_<__converts_from_optional<_Tp, _Up>>,
 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 		    optional&>
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index 10b294ba012..25b534c27f3 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -1211,8 +1211,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    begin(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to the first element of
@@ -1221,8 +1221,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    begin(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(const valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1231,8 +1231,13 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    end(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1241,8 +1246,13 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    end(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(const valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 #endif // C++11
 
   /// @} group numeric_arrays
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index 321228753cd..99a35cc5915 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -1039,6 +1039,14 @@ namespace __variant
 			      std::index_sequence<__indices...>>
     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
 
+  template<size_t _Np, typename _Variant>
+    using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
+
+  // Return type of std::visit.
+  template<typename _Visitor, typename... _Variants>
+    using __visit_result_t
+      = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
+
 } // namespace __variant
 } // namespace __detail
 
@@ -1191,7 +1199,8 @@ namespace __variant
 #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
+    visit(_Visitor&&, _Variants&&...);
 
   template<typename... _Types>
     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
@@ -1638,7 +1647,7 @@ namespace __variant
     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       using _Deduced_type = std::invoke_result<_Visitor,
-	decltype(std::get<0>(std::declval<_Variants>()))...>;
+	__detail::__variant::__get_t<0, _Variants>...>;
 
       using _Result_type = typename std::conditional_t<__use_index,
 	__detail::__variant::__variant_idx_cookie,
@@ -1654,14 +1663,14 @@ namespace __variant
     }
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto)
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
     visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       if ((__variants.valueless_by_exception() || ...))
 	__throw_bad_variant_access("Unexpected index");
 
-      return __do_visit(std::forward<_Visitor>(__visitor),
-			std::forward<_Variants>(__variants)...);
+      return std::__do_visit(std::forward<_Visitor>(__visitor),
+			     std::forward<_Variants>(__variants)...);
     }
 
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index eec7b953514..efffc014847 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -48,6 +48,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -127,6 +128,9 @@ cp-demangle.lo: cp-demangle.c
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 5d8ac5ca0ba..b469f62a43d 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -152,13 +152,13 @@ am__installdirs = "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(bitsdir)" \
 LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libsupc___la_LIBADD =
 am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \
-	bad_alloc.lo bad_array_length.lo bad_array_new.lo bad_cast.lo \
-	bad_typeid.lo class_type_info.lo del_op.lo del_ops.lo \
-	del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo dyncast.lo \
-	eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \
-	eh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \
-	eh_term_handler.lo eh_terminate.lo eh_tm.lo eh_throw.lo \
-	eh_type.lo eh_unex_handler.lo enum_type_info.lo \
+	atomicity.lo bad_alloc.lo bad_array_length.lo bad_array_new.lo \
+	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
+	del_ops.lo del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo \
+	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+	eh_catch.lo eh_exception.lo eh_globals.lo eh_personality.lo \
+	eh_ptr.lo eh_term_handler.lo eh_terminate.lo eh_tm.lo \
+	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
 	function_type_info.lo fundamental_type_info.lo guard.lo \
 	guard_error.lo hash_bytes.lo nested_exception.lo \
 	new_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \
@@ -497,6 +497,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -563,6 +564,7 @@ sources = \
 
 libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
@@ -954,6 +956,8 @@ cp-demangle.lo: cp-demangle.c
 	$(LTCOMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
index bd2178b3a1a..9d641103141 100644
--- a/libstdc++-v3/libsupc++/exception_ptr.h
+++ b/libstdc++-v3/libsupc++/exception_ptr.h
@@ -39,6 +39,10 @@
 #include <typeinfo>
 #include <new>
 
+#if __cplusplus >= 201103L
+# include <bits/move.h>
+#endif
+
 extern "C++" {
 
 namespace std 
@@ -178,14 +182,16 @@ namespace std
     exception_ptr 
     make_exception_ptr(_Ex __ex) _GLIBCXX_USE_NOEXCEPT
     {
-#if __cpp_exceptions && __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
+#if __cpp_exceptions && __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI \
+      && __cplusplus >= 201103L
+      using _Ex2 = typename remove_reference<_Ex>::type;
       void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
       (void) __cxxabiv1::__cxa_init_primary_exception(
-	  __e, const_cast<std::type_info*>(&typeid(__ex)),
-	  __exception_ptr::__dest_thunk<_Ex>);
+	  __e, const_cast<std::type_info*>(&typeid(_Ex)),
+	  __exception_ptr::__dest_thunk<_Ex2>);
       try
 	{
-          ::new (__e) _Ex(__ex);
+	  ::new (__e) _Ex2(std::forward<_Ex>(__ex));
           return exception_ptr(__e);
 	}
       catch(...)
diff --git a/libstdc++-v3/python/Makefile.am b/libstdc++-v3/python/Makefile.am
index 44d0b3e7fb4..c3dd4e8b406 100644
--- a/libstdc++-v3/python/Makefile.am
+++ b/libstdc++-v3/python/Makefile.am
@@ -29,6 +29,12 @@ else
 pythondir = $(datadir)/gcc-$(gcc_version)/python
 endif
 
+if GLIBCXX_BUILD_DEBUG
+debug_gdb_py = YES
+else
+debug_gdb_py =
+endif
+
 all-local: gdb.py
 
 nobase_python_DATA = \
@@ -61,4 +67,8 @@ install-data-local: gdb.py
 	  done; \
 	cd $$here; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
index 7b51946c49a..22dfc703e49 100644
--- a/libstdc++-v3/python/Makefile.in
+++ b/libstdc++-v3/python/Makefile.in
@@ -397,6 +397,8 @@ WARN_CXXFLAGS = \
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
 @ENABLE_PYTHONDIR_FALSE@pythondir = $(datadir)/gcc-$(gcc_version)/python
 @ENABLE_PYTHONDIR_TRUE@pythondir = $(prefix)/$(python_mod_dir)
+@GLIBCXX_BUILD_DEBUG_FALSE@debug_gdb_py = 
+@GLIBCXX_BUILD_DEBUG_TRUE@debug_gdb_py = YES
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/xmethods.py \
@@ -614,7 +616,11 @@ install-data-local: gdb.py
 	  done; \
 	cd $$here; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 32b8210414a..25d9d2e1868 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -18,7 +18,7 @@
 import gdb
 import itertools
 import re
-import sys
+import sys, os, errno
 
 ### Python 2 + Python 3 compatibility code
 
@@ -85,8 +85,8 @@ except ImportError:
 def find_type(orig, name):
     typ = orig.strip_typedefs()
     while True:
-        # Strip cv-qualifiers.  PR 67440.
-        search = '%s::%s' % (typ.unqualified(), name)
+        # Use Type.tag to ignore cv-qualifiers.  PR 67440.
+        search = '%s::%s' % (typ.tag, name)
         try:
             return gdb.lookup_type(search)
         except RuntimeError:
@@ -1449,6 +1449,45 @@ class StdPairPrinter:
         return None
 
 
+class StdErrorCodePrinter:
+    "Print a std::error_code or std::error_condition"
+
+    _errno_categories = None # List of categories that use errno values
+
+    def __init__ (self, typename, val):
+        self.val = val
+        self.typename = typename
+        # Do this only once ...
+        if StdErrorCodePrinter._errno_categories is None:
+            StdErrorCodePrinter._errno_categories = ['generic']
+            try:
+                import posix
+                StdErrorCodePrinter._errno_categories.append('system')
+            except ImportError:
+                pass
+
+    @staticmethod
+    def _category_name(cat):
+        "Call the virtual function that overrides std::error_category::name()"
+        gdb.set_convenience_variable('__cat', cat)
+        return gdb.parse_and_eval('$__cat->name()').string()
+
+    def to_string (self):
+        value = self.val['_M_value']
+        category = self._category_name(self.val['_M_cat'])
+        strval = str(value)
+        if value == 0:
+            default_cats = {'error_code':'system', 'error_condition':'generic'}
+            unqualified = self.typename.split('::')[-1]
+            if category == default_cats[unqualified]:
+                return self.typename + ' = { }' # default-constructed value
+        if value > 0 and category in StdErrorCodePrinter._errno_categories:
+            try:
+                strval = errno.errorcode[int(value)]
+            except:
+                pass
+        return '%s = {"%s": %s}' % (self.typename, category, strval)
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1846,6 +1885,8 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_version('std::__cxx11::', 'basic_string', StdStringPrinter)
     libstdcxx_printer.add_container('std::', 'bitset', StdBitsetPrinter)
     libstdcxx_printer.add_container('std::', 'deque', StdDequePrinter)
+    libstdcxx_printer.add_version('std::', 'error_code', StdErrorCodePrinter)
+    libstdcxx_printer.add_version('std::', 'error_condition', StdErrorCodePrinter)
     libstdcxx_printer.add_container('std::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::__cxx11::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
diff --git a/libstdc++-v3/src/c++11/system_error.cc b/libstdc++-v3/src/c++11/system_error.cc
index d67e3a4f975..3c8f32d8eab 100644
--- a/libstdc++-v3/src/c++11/system_error.cc
+++ b/libstdc++-v3/src/c++11/system_error.cc
@@ -70,6 +70,8 @@ namespace
     virtual std::error_condition
     default_error_condition(int ev) const noexcept
     {
+      // Use generic category for all known POSIX errno values (including zero)
+      // and system category otherwise.
       switch (ev)
       {
       // List of errno macros from [cerrno.syn].
@@ -309,6 +311,7 @@ namespace
 #ifdef EXDEV
       case EXDEV:
 #endif
+      case 0:
         return std::error_condition(ev, std::generic_category());
 
       /* Additional system-dependent mappings from non-standard error codes
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index f744d2f7b56..f37d5497075 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -496,7 +496,7 @@ fs::create_directories(const path& p, error_code& ec)
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
@@ -577,8 +577,7 @@ namespace
   {
     bool created = false;
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
-    posix::mode_t mode
-      = static_cast<std::underlying_type_t<fs::perms>>(perm);
+    posix::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);
     if (posix::mkdir(p.c_str(), mode))
       {
 	const int err = errno;
@@ -1404,7 +1403,6 @@ fs::status(const fs::path& p, error_code& ec) noexcept
   auto str = p.c_str();
 
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
-#if ! defined __MINGW64_VERSION_MAJOR || __MINGW64_VERSION_MAJOR < 6
   // stat() fails if there's a trailing slash (PR 88881)
   path p2;
   if (p.has_relative_path() && !p.has_filename())
@@ -1421,7 +1419,6 @@ fs::status(const fs::path& p, error_code& ec) noexcept
 	}
       str = p2.c_str();
     }
-#endif
 #endif
 
   stat_type st;
@@ -1451,7 +1448,6 @@ fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
   auto str = p.c_str();
 
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
-#if ! defined __MINGW64_VERSION_MAJOR || __MINGW64_VERSION_MAJOR < 6
   // stat() fails if there's a trailing slash (PR 88881)
   path p2;
   if (p.has_relative_path() && !p.has_filename())
@@ -1468,7 +1464,6 @@ fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
 	}
       str = p2.c_str();
     }
-#endif
 #endif
 
   stat_type st;
diff --git a/libstdc++-v3/src/c++98/Makefile.am b/libstdc++-v3/src/c++98/Makefile.am
index ba88f002389..c215cf2376e 100644
--- a/libstdc++-v3/src/c++98/Makefile.am
+++ b/libstdc++-v3/src/c++98/Makefile.am
@@ -39,7 +39,6 @@ endif
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -65,10 +64,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
-
 if ENABLE_DUAL_ABI
 collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/c++98/Makefile.in b/libstdc++-v3/src/c++98/Makefile.in
index 7825b94b0ad..45a32ac7579 100644
--- a/libstdc++-v3/src/c++98/Makefile.in
+++ b/libstdc++-v3/src/c++98/Makefile.in
@@ -126,9 +126,9 @@ libc__98convenience_la_LIBADD =
 @ENABLE_DUAL_ABI_TRUE@	messages_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	monetary_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	numeric_members_cow.lo
-am__objects_3 = $(am__objects_2) atomicity.lo codecvt_members.lo \
-	collate_members.lo messages_members.lo monetary_members.lo \
-	numeric_members.lo time_members.lo
+am__objects_3 = $(am__objects_2) codecvt_members.lo collate_members.lo \
+	messages_members.lo monetary_members.lo numeric_members.lo \
+	time_members.lo
 @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = allocator-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	concept-inst.lo ext-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	misc-inst.lo
@@ -442,7 +442,6 @@ headers =
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -450,7 +449,6 @@ host_sources = \
 	numeric_members.cc \
 	time_members.cc
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # Source files linked in via configuration/make substitution for a
 # particular host, but with ad hoc naming rules.
@@ -841,8 +839,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 @ENABLE_DUAL_ABI_TRUE@collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 @ENABLE_DUAL_ABI_TRUE@	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 4859b6e7fa6..d920afeffb0 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -366,7 +366,7 @@ fs::copy_file(const path& from, const path& to, copy_options option)
 
 bool
 fs::copy_file(const path& from, const path& to, copy_options options,
-	      error_code& ec) noexcept
+	      error_code& ec)
 {
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
   return do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),
@@ -418,7 +418,7 @@ fs::create_directories(const path& p)
 }
 
 bool
-fs::create_directories(const path& p, error_code& ec) noexcept
+fs::create_directories(const path& p, error_code& ec)
 {
   if (p.empty())
     {
@@ -426,7 +426,7 @@ fs::create_directories(const path& p, error_code& ec) noexcept
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
@@ -1092,7 +1092,7 @@ fs::remove_all(const path& p)
 }
 
 std::uintmax_t
-fs::remove_all(const path& p, error_code& ec) noexcept
+fs::remove_all(const path& p, error_code& ec)
 {
   const auto s = symlink_status(p, ec);
   if (!status_known(s))
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++1998/103650.cc b/libstdc++-v3/testsuite/17_intro/headers/c++1998/103650.cc
new file mode 100644
index 00000000000..356ffa310bc
--- /dev/null
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++1998/103650.cc
@@ -0,0 +1,13 @@
+// { dg-do preprocess }
+
+// PR libstdc++/103650 libstdc++ headers defined LT_OBJDIR and STDC_HEADERS
+
+#define LT_OBJDIR 99
+#define STDC_HEADERS 99
+#include <utility>
+#if LT_OBJDIR != 99
+# error LT_OBJDIR redefined
+#endif
+#if STDC_HEADERS != 99
+# error STDC_HEADERS redefined
+#endif
diff --git a/libstdc++-v3/testsuite/18_support/exception_ptr/103630.cc b/libstdc++-v3/testsuite/18_support/exception_ptr/103630.cc
new file mode 100644
index 00000000000..58fb2abe4d2
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/exception_ptr/103630.cc
@@ -0,0 +1,39 @@
+// { dg-do run }
+
+#include <exception>
+#if __cplusplus < 201103L
+// std::make_exception_ptr is defined for C++98 as a GNU extension
+# include <bits/exception_ptr.h>
+#endif
+
+#include <testsuite_hooks.h>
+
+struct B
+{
+  virtual bool derived() const { return false; }
+};
+
+struct D : B
+{
+  virtual bool derived() const { return true; }
+};
+
+int main()
+{
+  D d;
+  std::exception_ptr p = std::make_exception_ptr<B&>(d); // PR libstdc++/103630
+#if __cpp_exceptions
+  try
+  {
+    std::rethrow_exception(p);
+  }
+  catch (const D& d)
+  {
+    VERIFY(d.derived()); // PR libstdc++/103630
+  }
+  catch (const B& b)
+  {
+    VERIFY(!b.derived());
+  }
+#endif
+}
diff --git a/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
new file mode 100644
index 00000000000..61572668385
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
@@ -0,0 +1,17 @@
+// { dg-options "-nodefaultlibs -lsupc++ -lgcc_s -lc" { target sparc*-*-linux-gnu } }
+// { dg-do link { target c++11 } }
+
+#include <exception>
+
+void
+test01()
+{
+  // PR libstdc++/96657 undefined references in libsupc++
+  std::make_exception_ptr(1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
new file mode 100644
index 00000000000..069b5e284e1
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
@@ -0,0 +1,18 @@
+// { dg-do run { target c++11 } }
+#include <system_error>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  // PR libstdc++/102425
+  VERIFY( std::error_code() == std::error_condition() );
+
+  auto zero = std::system_category().default_error_condition(0);
+  // This is the condition that the equality above relies on:
+  VERIFY( zero.category() == std::generic_category() );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/93151.cc b/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/93151.cc
new file mode 100644
index 00000000000..2d8efc76deb
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/93151.cc
@@ -0,0 +1,23 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/93151
+#undef _XOPEN_SOURCE
+#define _XOPEN_SOURCE 600
+#include <system_error>
diff --git a/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc b/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc
index c3e2f32a560..024d85ffebe 100644
--- a/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc
+++ b/libstdc++-v3/testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc
@@ -34,7 +34,7 @@ void test01()
   TEST_ERRC(bad_address);
   TEST_ERRC(bad_file_descriptor);
 
-#ifdef _GLIBCXX_HAVE_EBADMSG
+#ifdef EBADMSG
   TEST_ERRC(bad_message);
 #endif
 
@@ -54,7 +54,7 @@ void test01()
   TEST_ERRC(function_not_supported);
   TEST_ERRC(host_unreachable);
 
-#ifdef _GLIBCXX_HAVE_EIDRM
+#ifdef EIDRM
   TEST_ERRC(identifier_removed);
 #endif
 
@@ -72,23 +72,23 @@ void test01()
   TEST_ERRC(no_buffer_space);
   TEST_ERRC(no_child_process);
 
-#ifdef _GLIBCXX_HAVE_ENOLINK
+#ifdef ENOLINK
   TEST_ERRC(no_link);
 #endif
 
   TEST_ERRC(no_lock_available);
 
-#ifdef _GLIBCXX_HAVE_ENODATA
+#ifdef ENODATA
   TEST_ERRC(no_message_available);
 #endif
 
-#ifdef _GLIBCXX_HAVE_ENOMSG
+#ifdef ENOMSG
   TEST_ERRC(no_message);
 #endif
   TEST_ERRC(no_protocol_option);
   TEST_ERRC(no_space_on_device);
 
-#ifdef _GLIBCXX_HAVE_ENOSR
+#ifdef ENOSR
   TEST_ERRC(no_stream_resources);
 #endif
 
@@ -99,15 +99,15 @@ void test01()
   TEST_ERRC(not_a_directory);
   TEST_ERRC(not_a_socket);
 
-#ifdef _GLIBCXX_HAVE_ENOSTR
+#ifdef ENOSTR
   TEST_ERRC(not_a_stream);
 #endif
 
-  TEST_ERRC(not_connected); 
+  TEST_ERRC(not_connected);
   TEST_ERRC(not_enough_memory);
   TEST_ERRC(not_supported);
 
-#ifdef _GLIBCXX_HAVE_ECANCELED
+#ifdef ECANCELED
   TEST_ERRC(operation_canceled);
 #endif
 
@@ -116,31 +116,31 @@ void test01()
   TEST_ERRC(operation_not_supported);
   TEST_ERRC(operation_would_block);
 
-#ifdef _GLIBCXX_HAVE_EOWNERDEAD
+#ifdef EOWNERDEAD
   TEST_ERRC(owner_dead);
 #endif
 
   TEST_ERRC(permission_denied);
 
-#ifdef _GLIBCXX_HAVE_EPROTO
+#ifdef EPROTO
   TEST_ERRC(protocol_error);
 #endif
 
   TEST_ERRC(protocol_not_supported);
   TEST_ERRC(read_only_file_system);
   TEST_ERRC(resource_deadlock_would_occur);
-  TEST_ERRC(resource_unavailable_try_again); 
+  TEST_ERRC(resource_unavailable_try_again);
   TEST_ERRC(result_out_of_range);
 
-#ifdef _GLIBCXX_HAVE_ENOTRECOVERABLE
+#ifdef ENOTRECOVERABLE
   TEST_ERRC(state_not_recoverable);
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETIME
+#ifdef ETIME
   TEST_ERRC(stream_timeout);
 #endif
 
-#ifdef _GLIBCXX_HAVE_ETXTBSY
+#ifdef ETXTBSY
   TEST_ERRC(text_file_busy);
 #endif
 
@@ -150,7 +150,7 @@ void test01()
   TEST_ERRC(too_many_links);
   TEST_ERRC(too_many_symbolic_link_levels);
 
-#ifdef _GLIBCXX_HAVE_EOVERFLOW
+#ifdef EOVERFLOW
   TEST_ERRC(value_too_large);
 #endif
 
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/101034.cc b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
new file mode 100644
index 00000000000..55f550a839e
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
@@ -0,0 +1,11 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/101034 - wrong constraint in std::any's constructor
+
+#include <any>
+
+struct S {
+  S(std::initializer_list<int>&, int) {}
+};
+
+std::any a(std::in_place_type<S>, {0}, 0);
+S& s = a.emplace<S>({0}, 0);
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/90415.cc b/libstdc++-v3/testsuite/20_util/any/cons/90415.cc
new file mode 100644
index 00000000000..122262386d3
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/90415.cc
@@ -0,0 +1,64 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/90415
+  static_assert( std::is_copy_constructible<std::tuple<std::any>>::value );
+}
+
+struct wrapper
+{
+  wrapper() = default;
+
+  wrapper(const std::any& t);
+
+  wrapper(const wrapper& w);
+
+  auto& operator=(const std::any& t);
+
+  auto& operator=(const wrapper& w)
+  {
+    value = w.value;
+    return *this;
+  }
+
+  std::any value;
+};
+
+void
+test02()
+{
+  // PR libstdc++/91630
+  wrapper a, b;
+  a = b;
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/92156.cc b/libstdc++-v3/testsuite/20_util/any/cons/92156.cc
new file mode 100644
index 00000000000..d797473716d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/92156.cc
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  auto a = std::any(std::in_place_type<std::any>, 5);
+  VERIFY( std::any_cast<int>(std::any_cast<std::any>(a)) == 5 );
+
+  auto b = std::any(std::in_place_type<std::any>, {1});
+  (void) std::any_cast<std::initializer_list<int>>(std::any_cast<std::any>(b));
+}
+
+void
+test02()
+{
+  std::any p = std::pair<std::any, std::any>(1, 1);
+  auto pt = std::any_cast<std::pair<std::any, std::any>>(p);
+  VERIFY( std::any_cast<int>(pt.first) == 1 );
+  VERIFY( std::any_cast<int>(pt.second) == 1 );
+
+  std::any t = std::tuple<std::any>(1);
+  auto tt = std::any_cast<std::tuple<std::any>>(t);
+  VERIFY( std::any_cast<int>(std::get<0>(tt)) == 1 );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
index d8a52d719db..0c56fce963f 100644
--- a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
@@ -1,5 +1,5 @@
 // { dg-options "-std=gnu++17" }
-// { dg-do compile }
+// { dg-do compile { target c++17 } }
 
 // Copyright (C) 2014-2019 Free Software Foundation, Inc.
 //
@@ -26,20 +26,22 @@ using std::any_cast;
 void test01()
 {
   const any y(1);
-  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 461 }
-  // { dg-error "Template argument must be constructible from a const value" "" { target { *-*-* } } 457 }
+  any_cast<int&>(y); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from a const value" "" { target { *-*-* } } 0 }
 }
 
 void test02()
 {
   any y(1);
-  any_cast<int&&>(y);
-  // { dg-error "Template argument must be constructible from an lvalue" "" { target { *-*-* } } 483 }
+  any_cast<int&&>(y); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from an lvalue" "" { target { *-*-* } } 0 }
 }
 
 void test03()
 {
   any y(1);
-  any_cast<int&>(std::move(y));  // { dg-error "invalid static_cast" "" { target { *-*-* } } 501 }
-  // { dg-error "Template argument must be constructible from an rvalue" "" { target { *-*-* } } 497 }
+  any_cast<int&>(std::move(y)); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from an rvalue" "" { target { *-*-* } } 0 }
 }
+
+// { dg-prune-output "invalid static_cast" }
diff --git a/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc b/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc
new file mode 100644
index 00000000000..4a7bc97bb83
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc
@@ -0,0 +1,57 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::any a;
+  a.emplace<std::any>(5);
+  VERIFY( std::any_cast<int>(std::any_cast<std::any>(a)) == 5 );
+
+  std::any b;
+  b.emplace<std::any>({1});
+  (void) std::any_cast<std::initializer_list<int>>(std::any_cast<std::any>(b));
+}
+
+void
+test02()
+{
+  std::any p;
+  p.emplace<std::pair<std::any, std::any>>(1, 1);
+  auto pt = std::any_cast<std::pair<std::any, std::any>>(p);
+  VERIFY( std::any_cast<int>(pt.first) == 1 );
+  VERIFY( std::any_cast<int>(pt.second) == 1 );
+
+  std::any t;
+  t.emplace<std::tuple<std::any>>(1);
+  auto tt = std::any_cast<std::tuple<std::any>>(t);
+  VERIFY( std::any_cast<int>(std::get<0>(tt)) == 1 );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
new file mode 100644
index 00000000000..ae565250d68
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
@@ -0,0 +1,17 @@
+// { dg-do compile { target c++17 } }
+
+#include <optional>
+
+struct U {};
+
+struct T {
+  explicit T(const U&);
+  T& operator=(const U&);
+  T& operator=(U&&) = delete;
+};
+
+int main() {
+  std::optional<U> opt1;
+  std::optional<T> opt2;
+  opt2 = opt1; // PR libstdc++/100982
+}
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
new file mode 100644
index 00000000000..d5f7a5da5e9
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
@@ -0,0 +1,9 @@
+// FIXME: This should use { target { ! c++20 } }
+// { dg-do compile }
+
+#include <memory>
+
+auto p = std::make_shared<int[]>(2); // { dg-error "here" }
+auto q = std::make_shared<int[2]>(1, 2); // { dg-error "here" }
+
+// { dg-prune-output "static assertion failed" }
diff --git a/libstdc++-v3/testsuite/20_util/variant/100384.cc b/libstdc++-v3/testsuite/20_util/variant/100384.cc
new file mode 100644
index 00000000000..4866aa017ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/100384.cc
@@ -0,0 +1,9 @@
+// { dg-do compile { target c++17 } }
+
+#include <variant>
+
+int visit(int*, std::true_type) { return 0; }
+
+const std::true_type dat;
+
+int i = visit(nullptr, dat);
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
new file mode 100644
index 00000000000..0f6f520c33b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
@@ -0,0 +1,48 @@
+// { dg-do run { target c++11 } }
+// C++11 23.3.4.6 Operations [forwardlist.ops]
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test_stable()
+{
+  std::forward_list<double> a{1.5, 2.0, 3.5, 4.1};
+  std::forward_list<double> b{1.0, 2.5, 3.0, 4.3, 4.2, 5.0};
+
+  a.merge(b, std::less<int>{});
+
+  // result is sorted with respect to std::less<int>, so 1.0 and 1.5 are
+  // equivalent, and stability guarantee means the element from a comes first.
+  const std::forward_list<double> r { 1.5, 1.0,
+				      2.0, 2.5,
+				      3.5, 3.0,
+				      4.1, 4.3, 4.2,
+				      5.0};
+
+  VERIFY(a == r);
+}
+
+void
+test_lwg3088()
+{
+  // LWG 3088: forward_list::merge behavior unclear when passed *this
+  // PR libstdc++/103853
+  std::forward_list<int> c1{ 1, 2, 3 };
+  const std::forward_list<int> c2 = c1;
+  c1.merge(c1);
+  VERIFY( c1 == c2 );
+  c1.merge(c1, std::less<long>{});
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1));
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1), std::less<long>{});
+  VERIFY( c1 == c2 );
+}
+
+int
+main()
+{
+  test_stable();
+  test_lwg3088();
+}
diff --git a/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc b/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
index 51058fee606..57f94f87524 100644
--- a/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc
@@ -20,6 +20,7 @@
 // 25.2.12 [alg.is_permutation] Is permutation
 
 #include <algorithm>
+#include <iterator>
 #include <functional>
 #include <testsuite_hooks.h>
 
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp.cc b/libstdc++-v3/testsuite/26_numerics/lerp/1.cc
similarity index 100%
rename from libstdc++-v3/testsuite/26_numerics/lerp.cc
rename to libstdc++-v3/testsuite/26_numerics/lerp/1.cc
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc b/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc
new file mode 100644
index 00000000000..f1ab42b5a42
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lerp/constexpr.cc
@@ -0,0 +1,21 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <cmath>
+
+// Fails template argument deduction unless both arguments are the same type.
+template<typename T>
+constexpr bool
+eq(T result, T expected) { return result == expected; }
+
+static_assert( eq( std::lerp(-10.0, 10.0, 0.25), -5.0 ) );
+static_assert( eq( std::lerp(2.0f, 2.0f, 200.0f), 2.0f ) );
+static_assert( eq( std::lerp(2.0L, 4.0L, 200.0L), 402.0L ) );
+// at least one type is long double, so result is long double
+static_assert( eq( std::lerp(2.0L, 4.0f, -20.0), -38.0L ) );
+// at least one type is double, so result is double:
+static_assert( eq( std::lerp(-8.0f, 10.0, 0.5f), 1.0 ) );
+// int promotes to double, so result is double
+static_assert( eq( std::lerp(0, 1, 0), 0.0 ) );
+// int promotes to double, so result is double
+static_assert( eq( std::lerp(2.0f, -10.0f, 1), -10.0 ) );
diff --git a/libstdc++-v3/testsuite/26_numerics/lerp/version.cc b/libstdc++-v3/testsuite/26_numerics/lerp/version.cc
new file mode 100644
index 00000000000..3ccb032bc67
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lerp/version.cc
@@ -0,0 +1,10 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_interpolate
+# error "Feature-test macro for midpoint and lerp missing in <version>"
+#elif __cpp_lib_interpolate != 201902L
+# error "Feature-test macro for midpoint and lerp has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
index a65d4004161..8cc70886bc7 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
@@ -25,6 +25,7 @@
 
 #include <random>
 #include <sstream>
+#include <testsuite_hooks.h>
 
 void
 test01()
@@ -37,10 +38,43 @@ test01()
   str << u;
 
   str >> v;
+  VERIFY( u == v );
+}
+
+void
+test_pr105502()
+{
+  // PR libstdc++/105502 std::normal_distribution deserialization issue
+  std::stringstream str;
+  std::normal_distribution<> d{1, 2}, d2;
+  std::minstd_rand0 g;
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = true
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = false
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
 }
 
 int main()
 {
   test01();
-  return 0;
+  test_pr105502();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
new file mode 100644
index 00000000000..cf4644f53c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/95833 - Incorrect static_assert in std::reduce overload
+
+#include <numeric>
+
+struct A { };
+struct B { };
+
+struct binop
+{
+  template<typename T, typename U>
+    A operator()(T&&, U&&) const { return A{}; }
+};
+
+B b;
+A a = std::reduce(&b, &b + 1, A{}, binop{});
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
new file mode 100644
index 00000000000..d2e346760dd
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
@@ -0,0 +1,15 @@
+// { dg-options "-D_GLIBCXX_DEBUG" }
+// { dg-do compile { target c++11 } }
+
+#include <valarray>
+
+int main()
+{
+  // PR libstdc++/103022
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C b/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
similarity index 100%
rename from libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C
rename to libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
index 352f0e53c9f..e5791e04ffe 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 // Copyright (C) 2010-2019 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <valarray>
 
@@ -25,9 +25,42 @@ void
 test01()
 {
   std::valarray<double> va{1.0, 2.0, 3.0};
-  std::begin(va);
-  std::end(va);
+  (void) std::begin(va);
+  (void) std::end(va);
   const auto& cva = va;
-  std::begin(cva);
-  std::end(cva);
+  (void) std::begin(cva);
+  (void) std::end(cva);
+
+  using Iter = decltype(std::begin(va));
+  using IterTraits = std::iterator_traits<Iter>;
+  static_assert( std::is_same<Iter, decltype(std::end(va))>::value, "" );
+  static_assert( std::is_same<IterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<IterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<IterTraits::reference, double&>::value, "" );
+  using CIter = decltype(std::begin(cva));
+  using CIterTraits = std::iterator_traits<CIter>;
+  static_assert( std::is_same<CIter, decltype(std::end(cva))>::value, "" );
+  static_assert( std::is_same<CIterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<CIterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<CIterTraits::reference, const double&>::value, "" );
+}
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
index c0d87c68132..538a3864c05 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++14 } }
+// { dg-do run { target c++14 } }
 
 // Copyright (C) 2015-2019 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <iterator>
 #include <valarray>
@@ -33,3 +33,21 @@ test01()
   std::cbegin(cva);
   std::cend(cva);
 }
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::cbegin(va);
+  (void) std::cend(va);
+  const auto& cva = va;
+  (void) std::cbegin(cva);
+  (void) std::cend(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C b/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
similarity index 100%
rename from libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C
rename to libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
index c4411dfc1e7..7dd9c209b40 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
@@ -146,10 +146,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
index da78fb2de87..9555280e8c6 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
@@ -55,6 +55,37 @@ test01()
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = bad_ec;
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
index b0b176fc656..aef29cc71a0 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
@@ -169,6 +169,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write, fs::perm_options::add);
+  fs::remove_all(dir, ec);
+  f.path.clear();
 #endif
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..eb8473e600e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <filesystem>
+
+void f(bool) { }
+void f(const std::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/27_io/types/1.cc b/libstdc++-v3/testsuite/27_io/types/1.cc
index 19a42360b11..109cca55780 100644
--- a/libstdc++-v3/testsuite/27_io/types/1.cc
+++ b/libstdc++-v3/testsuite/27_io/types/1.cc
@@ -27,14 +27,14 @@
 // Annex D, deprecated.
 void test01()
 {
-  typedef std::ios_base::streampos streampos_type; // { dg-warning "is deprecated: use 'std::streampos' instead" }
-  typedef std::ios_base::streamoff streamoff_type; // { dg-warning "is deprecated: use 'std::streamoff' instead" }
+  typedef std::ios_base::streampos streampos_type; // { dg-warning "is deprecated: use 'std::streampos' instead" "" { target c++11 } }
+  typedef std::ios_base::streamoff streamoff_type; // { dg-warning "is deprecated: use 'std::streamoff' instead" "" { target c++11 } }
 }
 
 // Annex D, deprecated.
 void test02()
 {
-  typedef std::ios_base::io_state iostate_type; // { dg-warning "is deprecated: use 'std::iostate' instead" }
-  typedef std::ios_base::open_mode openmode_type; // { dg-warning "is deprecated: use 'std::openmode' instead" }
-  typedef std::ios_base::seek_dir seekdir_type; // { dg-warning "is deprecated: use 'std::seekdir' instead" }
+  typedef std::ios_base::io_state iostate_type; // { dg-warning "is deprecated: use 'std::iostate' instead" "" { target c++11 } }
+  typedef std::ios_base::open_mode openmode_type; // { dg-warning "is deprecated: use 'std::openmode' instead" "" { target c++11 } }
+  typedef std::ios_base::seek_dir seekdir_type; // { dg-warning "is deprecated: use 'std::seekdir' instead" "" { target c++11 } }
 }
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
new file mode 100644
index 00000000000..9e38c9edaa4
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
@@ -0,0 +1,39 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::cmatch sm;
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() );  // PR libstdc++/83600
+
+  bool matched = std::regex_match("a", sm, std::regex("b"));
+  VERIFY( ! matched );
+  VERIFY( sm.ready() );
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() ); // PR libstdc++/102667
+
+  matched = std::regex_match("a", sm, std::regex("a"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 1 );
+  VERIFY( (sm.end() - sm.begin()) == 1 );
+
+  matched = std::regex_search("abcd", sm, std::regex("(b)(c)"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 3 );
+  VERIFY( (sm.end() - sm.begin()) == 3 );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
index b6909b630d4..6cfa7800860 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
@@ -129,10 +129,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
index 3a79d6622b9..20701ae4fcc 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
@@ -46,12 +46,44 @@ test01()
   VERIFY( exists(p) );
 
   // Test existing path (libstdc++/71036).
+  ec = make_error_code(std::errc::invalid_argument);
   b = create_directory(p, ec);
   VERIFY( !ec );
   VERIFY( !b );
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = make_error_code(std::errc::invalid_argument);
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
index 9d51a66c71f..c233b60c550 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
@@ -137,6 +137,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write|fs::perms::add_perms);
+  fs::remove_all(dir, ec);
+  f.path.clear();
 #endif
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..b2428ff74cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+
+void f(bool) { }
+void f(const std::experimental::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/experimental/random/randint.cc b/libstdc++-v3/testsuite/experimental/random/randint.cc
index 2b7966901f4..67197d3db7a 100644
--- a/libstdc++-v3/testsuite/experimental/random/randint.cc
+++ b/libstdc++-v3/testsuite/experimental/random/randint.cc
@@ -34,7 +34,7 @@ test01()
   }
 
   std::experimental::reseed(99u);
-  const long n1[] = {
+  const int n1[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -42,7 +42,7 @@ test01()
     std::experimental::randint(0, 100)
   };
   std::experimental::reseed(99u);
-  const long n2[] = {
+  const int n2[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -52,13 +52,13 @@ test01()
   for (int i = 0; i < 5; ++i)
     VERIFY( n1[i] == n2[i] );
 
-  std::experimental::reseed();
-  const long n3[] = {
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100)
-  };
-  VERIFY( !(n3[0] == n1[0] && n3[1] == n1[1] && n3[2] == n1[2]) );
+  do
+  {
+    std::experimental::reseed();
+  }
+  while (std::experimental::randint(0, 100) == n1[0]
+      && std::experimental::randint(0, 100) == n1[1]
+      && std::experimental::randint(0, 100) == n1[2]);
 }
 
 void
diff --git a/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc b/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
index cd2a48845aa..f34c4fd107e 100644
--- a/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
+++ b/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
@@ -31,3 +31,6 @@
 // { dg-prune-output "tuple:993" }
 // PMR alias templates cause ambiguities between debug and profile containers:
 // { dg-prune-output "is ambiguous" }
+// C++20 uniform container erasure causes more errors
+// { dg-prune-output "expected nested-name-specifier before" }
+// { dg-prune-output "expected initializer before" }
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
index 71a50988924..bff9d1b27de 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
@@ -161,6 +161,25 @@ main()
 // { dg-final { note-test tpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
   ExTuple &rtpl = tpl;
 // { dg-final { note-test rtpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
+
+  std::error_code e0;
+  // { dg-final { note-test e0 {std::error_code = { }} } }
+  std::error_condition ec0;
+  // { dg-final { note-test ec0 {std::error_condition = { }} } }
+  std::error_code einval = std::make_error_code(std::errc::invalid_argument);
+  // { dg-final { note-test einval {std::error_code = {"generic": EINVAL}} } }
+  std::error_condition ecinval = std::make_error_condition(std::errc::invalid_argument);
+  // { dg-final { note-test ecinval {std::error_condition = {"generic": EINVAL}} } }
+
+  struct custom_cat : std::error_category {
+    const char* name() const noexcept { return "miaow"; }
+    std::string message(int) const { return ""; }
+  } cat;
+  std::error_code emiaow(42, cat);
+  // { dg-final { note-test emiaow {std::error_code = {"miaow": 42}} } }
+  std::error_condition ecmiaow(42, cat);
+  // { dg-final { note-test ecmiaow {std::error_condition = {"miaow": 42}} } }
+
   placeholder(""); // Mark SPOT
   use(efl);
   use(fl);
