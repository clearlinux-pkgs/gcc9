Andrew Pinski (1):
      [GCC 10 branch] tree-optimization: [PR102622]: wrong code due to signed one bit integer and "a?-1:0"

Bill Schmidt (3):
      rs6000: Don't let swaps pass break multiply low-part (PR101129)
      rs6000: Add int128 target check to pr101129.c (PR101531)
      rs6000: Fix vec_cpsgn parameter order (PR101985)

Christophe Lyon (1):
      arm: Fix pr69245.c testcase for reorder assembler architecture directives [PR101723]

Diane Meirowitz (1):
      doc: improve -fsanitize=undefined description

Eric Botcazou (5):
      Fix internal error on pointer-to-pointer binding in LTO mode
      Fix inaccurate bounds in debug info for vector array types
      Fix PR rtl-optimization/102306
      Update documentation of %X spec
      Properly enable -freorder-blocks-and-partition on 64-bit Windows

GCC Administrator (228):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

H.J. Lu (1):
      x86: Document -fcf-protection requires i686 or newer

Harald Anlauf (14):
      Fortran - ICE in inline_matmul_assign
      Fortran - ICE in gfc_conv_expr_present initializing non-dummy class variable
      Fortran - fix handling of optional allocatable DT arguments with INTENT(OUT)
      Fortran - fix handling of substring start and end indices
      Fortran - ensure simplification of bounds of array-valued named constants
      Fortran - out of bounds in array constructor with implied do loop
      Fortran - improve error recovery determining array element from constructor
      Fortran: do not attempt simplification of [LU]BOUND for pointer/allocatable
      Fortran: perform array subscript checks only for valid INTEGER bounds
      Fortran: prevent NULL pointer dereference in check of passed do-loop variable
      Fortran: fix checking of elemental functions of type CLASS
      Fortran: dimensions of an array have to be non-negative
      Fortran: catch failed simplification of bad stride expression
      Fortran: PACK intrinsic should not try to read from zero-sized array

Iain Buclaw (16):
      d: Fix ICE in gimplify_var_or_parm_decl, at gimplify.c:2755 (PR100882)
      d: Respect explicit align(N) type alignment (PR100935)
      d: TypeInfo error when using slice copy on Structs (PR100964)
      PR d/90651 (ICE in FuncDeclaration::semantic3, at d/dmd/func.c:1524)
      d: Fix ICE in TypeInfoDeclaration, at dmd/declaration.c (PR100967)
      d: Compile-time reflection for supported built-ins (PR101127)
      d: __FUNCTION__ doesn't work in core.stdc.stdio functions without cast (PR101441)
      d: fix ICE at convert_expr(tree_node*, Type*, Type*) (PR101490)
      d: Wrong evaluation order of binary expressions (PR101640)
      d: Ensure casting from bool results in either 0 or 1 (PR96435)
      d: gdc driver ignores -static-libstdc++ when automatically linking libstdc++ library
      d: Use HOST_WIDE_INT for type size temporaries.
      libphobos: Don't call __gthread_key_delete in the emutls destroy function.
      libphobos: Increase size of defaultStackPages on OSX X86_64 targets.
      d: Align methods to MINIMUM_METHOD_BOUNDARY.
      libphobos: Fix definition of stat_t for MIPS64 (PR103604)

Jan Hubicka (1):
      Fix looping flag discovery in ipa-pure-const

John David Anglin (5):
      Add support for 32-bit hppa targets in muldi3 expander
      Fix TARGET_SOFT_FLOAT patterns in pa.md
      Consistently use "rG" constraint for copy instruction in move patterns
      Don't use 'G' constraint in integer move patterns
      Fix warnings building linux-atomic.c and fptr.c on hppa64-linux

Jonathan Wakely (28):
      libstdc++: Fix find_type helper to work consistently
      libstdc++: Simplify constexpr checks in std::char_traits [PR 91488]
      libstdc++: Reject std::make_shared<T[]> [PR 99006]
      libstdc++: Do not use deduced return type for std::visit [PR 100384]
      libstdc++: Fix filesystem::path constraints for volatile [PR 100630]
      libstdc++: Replace incorrect static assertion in std::reduce [PR95833]
      libstdc++: Fix constraint on std::optional assignment [PR 100982]
      libstdc++: Fix constructor constraints for std::any  (PR 90415)
      libstdc++: Fix std::any constraints [PR101034]
      libstdc++: Move atomic functions to libsupc++ [PR 96657]
      libstdc++: Fix test failure in C++20 mode
      libstdc++: Re-enable workaround for _wstat64 bug [PR 88881]
      libstdc++: Re-enable workaround for _wstat64 bug, again [PR 88881]
      libstdc++: Add more tests for filesystem::create_directory [PR101510]
      libstdc++: Fix create_directories to resolve symlinks [PR101510]
      libstdc++: Fix test that fails randomly [PR101866]
      c++: Fix docs on assignment of virtual bases [PR60318]
      libstdc++: Fix std::match_results::end() for failed matches [PR102667]
      libstdc++: Clear up directories created by tests
      libstdc++: Install GDB pretty printers for debug library
      libstdc++: Add pretty printer for std::error_code and std::error_condition
      libstdc++: std::system_category should know meaning of zero [PR102425]
      libstdc++: Remove non-deducible parameter for std::advance overload
      libstdc++: Rename tests with incorrect extension
      libstdc++: Rename file with the wrong extension
      libstdc++: Fix range access for empty std::valarray [PR103022]
      libstdc++: Fix circular dependency for bitmap_allocator [PR103381]
      aarch64: Fix mismatched extern "C" block [PR100985]

Kewen Lin (3):
      ipa-fnsummary: Remove inconsistent bp_pack_value
      vect: Don't update inits for simd_lane_access DRs [PR102789]
      rs6000: Remove builtin mask check from builtin_decl [PR102347]

Marius Hillenbrand (1):
      IBM Z: Fix vector intrinsics vec_double and vec_floate

Martin Jambor (1):
      ipa-sra: Check also ECF_LOOPING_CONST_OR_PURE when evaluating calls

Martin Liska (7):
      contrib: add git-commit-mklog wrapper
      Add mklog.py.
      sanitizer: cherry pick 414482751452e54710f16bae58458c66298aaf69
      gcc-changelog: sync from master
      jit: Initialize function::m_blocks in ctor
      git-backport: support renamed .cc files in commit message.
      git scripts: sync from master.

Martin Storsjö (1):
      mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags variables

Paul Thomas (9):
      Fortran: Allow pointer deferred length associate selectors. [PR93794]
      Fortran: Fix ICE due to elemental procedure pointers [PR93924/5].
      Fortran: Fix for class defined operators [PR99125].
      Fortran: Assumed and explicit size class arrays [PR46691/99819].
      Fortran: Fix host associated PDT entity initialization
      Fortran: Fix ICE due to elemental procedure pointers [PR98472].
      Fortran: Improve resolution of associate variables. [PR93701].
      Fortran: Fix for class functions as associated target [PR98565].
      Fortran: Correct missing structure constructor comps. [PR97612].

Piotr Kubaj (1):
      gcc/configure: Check for powerpc64le*-*-freebsd*

Richard Biener (10):
      Bump BASE-VER to 9.4.1
      middle-end/100509 - avoid folding constant to aggregate type
      tree-optimization/100934 - properly mark irreducible regions for DOM
      tree-optimization/101105 - fix runtime alias test optimization
      tree-optimization/101394 - fix PRE full redundancy wrt abnormals
      tree-optimization/101173 - fix interchange dependence checking
      middle-end/101824 - properly handle volatiles in nested fn lowering
      tree-optimization/101868 - avoid PRE of trapping mems across calls
      middle-end/100672 - fix bogus right shift folding
      tree-optimization/97953 - fix bougs range recorded by EVRP

Richard Earnshaw (5):
      arm: Remove use of opts_set in arm_configure_build_target [PR100767]
      arm: Fix an incorrect warning when -mcpu=cortex-a55 is used with -mfloat-abi=soft
      arm: ensure the arch_name is always set for the build target
      arm: Don't reconfigure globals in arm_configure_build_target
      arm: reorder assembler architecture directives [PR101723]

Richard Sandiford (2):
      aarch64: Add -mtune=neoverse-512tvb
      libgcc: Add missing runtime exception notices

Segher Boessenkool (1):
      combine: Don't create REG_UNUSED notes if the reg already died (PR99927)

Stefan Schulze Frielinghaus (1):
      IBM Z: Fix load-and-test peephole2 condition

Thomas Koenig (1):
      Do not replace variable op variable in I/O implied DO loop replacement.

Thomas Schwinge (3):
      Restore 'gcc.dg/pr78213.c' testing
      Fix up 'gcc.dg/pr78213.c' for '--enable-checking=release' etc.
      Fix 'OMP_CLAUSE_TILE' operands handling in 'gcc/tree.c:walk_tree_1'

Uros Bizjak (2):
      i386: Prevent unwanted combine from LZCNT to BSR [PR101175]
      i386: Remove atomic_storedi_fpu and atomic_loaddi_fpu peepholes [PR100182]

Xi Ruoyao (1):
      mips: Fix up mips_atomic_assign_expand_fenv [PR94780]

konglin1 (1):
      i386: Fix _mm512_fpclass_ps_mask in O0 [PR 101471]

diff --git a/config/ChangeLog b/config/ChangeLog
index debc7381143..07d1a887900 100644
--- a/config/ChangeLog
+++ b/config/ChangeLog
@@ -1,3 +1,11 @@
+2021-12-16  Martin Storsjö  <martin@martin.st>
+
+	Backported from master:
+	2021-04-13  Martin Storsjö  <martin@martin.st>
+
+	* mh-mingw: Set __USE_MINGW_ACCESS in missed C++ flags
+	variables
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/config/mh-mingw b/config/mh-mingw
index a795096f038..e91367a7112 100644
--- a/config/mh-mingw
+++ b/config/mh-mingw
@@ -1,7 +1,9 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
 BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
+BOOT_CXXFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
 CFLAGS += -D__USE_MINGW_ACCESS
+CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE1_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE2_CXXFLAGS += -D__USE_MINGW_ACCESS
 STAGE3_CXXFLAGS += -D__USE_MINGW_ACCESS
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 7ab95a2466e..96ec8313721 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,28 @@
+2022-01-17  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-01-17  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: Support renaming of .cc files.
+
+2021-11-08  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_check_commit.py: Sync from master.
+	* gcc-changelog/git_commit.py: Likewise.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_update_version.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* mklog.py: New file.
+	* test_mklog.py: New file.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* git-commit-mklog.py: New file.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/contrib/gcc-changelog/git_check_commit.py b/contrib/gcc-changelog/git_check_commit.py
index 9a4c5d448fb..d6aff3cef91 100755
--- a/contrib/gcc-changelog/git_check_commit.py
+++ b/contrib/gcc-changelog/git_check_commit.py
@@ -29,6 +29,8 @@ parser.add_argument('-g', '--git-path', default='.',
                     help='Path to git repository')
 parser.add_argument('-p', '--print-changelog', action='store_true',
                     help='Print final changelog entires')
+parser.add_argument('-v', '--verbose', action='store_true',
+                    help='Print verbose information')
 args = parser.parse_args()
 
 retval = 0
@@ -41,6 +43,8 @@ for git_commit in parse_git_revisions(args.git_path, args.revisions):
     else:
         for error in git_commit.errors:
             print('ERR: %s' % error)
+            if args.verbose and error.details:
+                print(error.details)
         retval = 1
 
 exit(retval)
diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py
index 4958ab9c159..27a1d59b211 100755
--- a/contrib/gcc-changelog/git_commit.py
+++ b/contrib/gcc-changelog/git_commit.py
@@ -134,6 +134,7 @@ ignored_prefixes = {
     'gcc/go/gofrontend/',
     'gcc/testsuite/gdc.test/',
     'gcc/testsuite/go.test/test/',
+    'libffi/',
     'libgo/',
     'libphobos/libdruntime/',
     'libphobos/src/',
@@ -156,7 +157,9 @@ author_line_regex = \
         re.compile(r'^(?P<datetime>\d{4}-\d{2}-\d{2})\ {2}(?P<name>.*  <.*>)')
 additional_author_regex = re.compile(r'^\t(?P<spaces>\ *)?(?P<name>.*  <.*>)')
 changelog_regex = re.compile(r'^(?:[fF]or +)?([a-z0-9+-/]*)ChangeLog:?')
-pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?([0-9]+)$')
+subject_pr_regex = re.compile(r'(^|\W)PR\s+(?P<component>[a-zA-Z+-]+)/(?P<pr>\d{4,7})')
+subject_pr2_regex = re.compile(r'[(\[]PR\s*(?P<pr>\d{4,7})[)\]]')
+pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?(?P<pr>[0-9]+)$')
 dr_regex = re.compile(r'\tDR ([0-9]+)$')
 star_prefix_regex = re.compile(r'\t\*(?P<spaces>\ *)(?P<content>.*)')
 end_of_location_regex = re.compile(r'[\[<(:]')
@@ -194,9 +197,10 @@ def decode_path(path):
 
 
 class Error:
-    def __init__(self, message, line=None):
+    def __init__(self, message, line=None, details=None):
         self.message = message
         self.line = line
+        self.details = details
 
     def __repr__(self):
         s = self.message
@@ -215,7 +219,7 @@ class ChangeLogEntry:
         self.lines = []
         self.files = []
         self.file_patterns = []
-        self.opened_parentheses = 0
+        self.parentheses_stack = []
 
     def parse_file_names(self):
         # Whether the content currently processed is between a star prefix the
@@ -298,6 +302,7 @@ class GitCommit:
         self.top_level_authors = []
         self.co_authors = []
         self.top_level_prs = []
+        self.subject_prs = set()
         self.cherry_pick_commit = None
         self.revert_commit = None
         self.commit_to_info_hook = commit_to_info_hook
@@ -307,6 +312,9 @@ class GitCommit:
         if self.info.lines and self.info.lines[0] == 'Update copyright years.':
             return
 
+        if self.info.lines and len(self.info.lines) > 1 and self.info.lines[1]:
+            self.errors.append(Error('Expected empty second line in commit message', info.lines[0]))
+
         # Identify first if the commit is a Revert commit
         for line in self.info.lines:
             m = revert_regex.match(line)
@@ -316,6 +324,21 @@ class GitCommit:
         if self.revert_commit:
             self.info = self.commit_to_info_hook(self.revert_commit)
 
+        # The following happens for get_email.py:
+        if not self.info:
+            return
+
+        self.check_commit_email()
+
+        # Extract PR numbers form the subject line
+        # Match either [PRnnnn] / (PRnnnn) or PR component/nnnn
+        if self.info.lines and not self.revert_commit:
+            self.subject_prs = {m.group('pr') for m in subject_pr2_regex.finditer(info.lines[0])}
+            for m in subject_pr_regex.finditer(info.lines[0]):
+                if not m.group('component') in bug_components:
+                    self.errors.append(Error('invalid PR component in subject', info.lines[0]))
+                self.subject_prs.add(m.group('pr'))
+
         # Allow complete deletion of ChangeLog files in a commit
         project_files = [f for f in self.info.modified_files
                          if (self.is_changelog_filename(f[0], allow_suffix=True) and f[1] != 'D')
@@ -326,9 +349,11 @@ class GitCommit:
             # All modified files are only MISC files
             return
         elif project_files:
-            self.errors.append(Error('ChangeLog, DATESTAMP, BASE-VER and '
-                                     'DEV-PHASE updates should be done '
-                                     'separately from normal commits'))
+            err = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates ' \
+                  'should be done separately from normal commits\n' \
+                  '(note: ChangeLog entries will be automatically ' \
+                  'added by a cron job)'
+            self.errors.append(Error(err))
             return
 
         all_are_ignored = (len(project_files) + len(ignored_files)
@@ -344,6 +369,9 @@ class GitCommit:
             if not self.errors:
                 self.check_mentioned_files()
                 self.check_for_correct_changelog()
+        if self.subject_prs:
+            self.errors.append(Error('PR %s in subject but not in changelog' %
+                                     ', '.join(self.subject_prs), self.info.lines[0]))
 
     @property
     def success(self):
@@ -458,7 +486,9 @@ class GitCommit:
                     else:
                         author_tuple = (m.group('name'), None)
                 elif pr_regex.match(line):
-                    component = pr_regex.match(line).group('component')
+                    m = pr_regex.match(line)
+                    component = m.group('component')
+                    pr = m.group('pr')
                     if not component:
                         self.errors.append(Error('missing PR component', line))
                         continue
@@ -467,6 +497,8 @@ class GitCommit:
                         continue
                     else:
                         pr_line = line.lstrip()
+                    if pr in self.subject_prs:
+                        self.subject_prs.remove(pr)
                 elif dr_regex.match(line):
                     pr_line = line.lstrip()
 
@@ -521,7 +553,7 @@ class GitCommit:
                     m = star_prefix_regex.match(line)
                     if m:
                         if (len(m.group('spaces')) != 1 and
-                                last_entry.opened_parentheses == 0):
+                                not last_entry.parentheses_stack):
                             msg = 'one space should follow asterisk'
                             self.errors.append(Error(msg, line))
                         else:
@@ -546,13 +578,13 @@ class GitCommit:
     def process_parentheses(self, last_entry, line):
         for c in line:
             if c == '(':
-                last_entry.opened_parentheses += 1
+                last_entry.parentheses_stack.append(line)
             elif c == ')':
-                if last_entry.opened_parentheses == 0:
+                if not last_entry.parentheses_stack:
                     msg = 'bad wrapping of parenthesis'
                     self.errors.append(Error(msg, line))
                 else:
-                    last_entry.opened_parentheses -= 1
+                    del last_entry.parentheses_stack[-1]
 
     def parse_file_names(self):
         for entry in self.changelog_entries:
@@ -578,9 +610,9 @@ class GitCommit:
 
     def check_for_broken_parentheses(self):
         for entry in self.changelog_entries:
-            if entry.opened_parentheses != 0:
+            if entry.parentheses_stack:
                 msg = 'bad parentheses wrapping'
-                self.errors.append(Error(msg, entry.lines[0]))
+                self.errors.append(Error(msg, entry.parentheses_stack[-1]))
 
     def get_file_changelog_location(self, changelog_file):
         for file in self.info.modified_files:
@@ -656,9 +688,11 @@ class GitCommit:
         for file in sorted(mentioned_files - changed_files):
             msg = 'unchanged file mentioned in a ChangeLog'
             candidates = difflib.get_close_matches(file, changed_files, 1)
+            details = None
             if candidates:
                 msg += f' (did you mean "{candidates[0]}"?)'
-            self.errors.append(Error(msg, file))
+                details = '\n'.join(difflib.Differ().compare([file], [candidates[0]])).rstrip()
+            self.errors.append(Error(msg, file, details))
         for file in sorted(changed_files - mentioned_files):
             if not self.in_ignored_location(file):
                 if file in self.new_files:
@@ -775,3 +809,12 @@ class GitCommit:
         print('Errors:')
         for error in self.errors:
             print(error)
+
+    def check_commit_email(self):
+        # Parse 'Martin Liska  <mliska@suse.cz>'
+        email = self.info.author.split(' ')[-1].strip('<>')
+
+        # Verify that all characters are ASCII
+        # TODO: Python 3.7 provides a nicer function: isascii
+        if len(email) != len(email.encode()):
+            self.errors.append(Error(f'non-ASCII characters in git commit email address ({email})'))
diff --git a/contrib/gcc-changelog/git_email.py b/contrib/gcc-changelog/git_email.py
index fa62e3ad2f7..87b419cae5d 100755
--- a/contrib/gcc-changelog/git_email.py
+++ b/contrib/gcc-changelog/git_email.py
@@ -17,6 +17,7 @@
 # <http://www.gnu.org/licenses/>.  */
 
 import os
+import re
 import sys
 from itertools import takewhile
 
@@ -28,6 +29,8 @@ from unidiff import PatchSet, PatchedFile
 
 DATE_PREFIX = 'Date: '
 FROM_PREFIX = 'From: '
+SUBJECT_PREFIX = 'Subject: '
+subject_patch_regex = re.compile(r'^\[PATCH( \d+/\d+)?\] ')
 unidiff_supports_renaming = hasattr(PatchedFile(), 'is_rename')
 
 
@@ -37,7 +40,9 @@ class GitEmail(GitCommit):
         diff = PatchSet.from_filename(filename)
         date = None
         author = None
+        subject = ''
 
+        subject_last = False
         with open(self.filename, 'r') as f:
             lines = f.read().splitlines()
         lines = list(takewhile(lambda line: line != '---', lines))
@@ -46,8 +51,21 @@ class GitEmail(GitCommit):
                 date = parse(line[len(DATE_PREFIX):])
             elif line.startswith(FROM_PREFIX):
                 author = GitCommit.format_git_author(line[len(FROM_PREFIX):])
+            elif line.startswith(SUBJECT_PREFIX):
+                subject = line[len(SUBJECT_PREFIX):]
+                subject_last = True
+            elif subject_last and line.startswith(' '):
+                subject += line
+            elif line == '':
+                break
+            else:
+                subject_last = False
+
+        if subject:
+            subject = subject_patch_regex.sub('', subject)
         header = list(takewhile(lambda line: line != '', lines))
-        body = lines[len(header) + 1:]
+        # Note: commit message consists of email subject, empty line, email body
+        message = [subject] + lines[len(header):]
 
         modified_files = []
         for f in diff:
@@ -67,7 +85,7 @@ class GitEmail(GitCommit):
             else:
                 t = 'M'
             modified_files.append((target if t != 'D' else source, t))
-        git_info = GitInfo(None, date, author, body, modified_files)
+        git_info = GitInfo(None, date, author, message, modified_files)
         super().__init__(git_info,
                          commit_to_info_hook=lambda x: None)
 
diff --git a/contrib/gcc-changelog/git_update_version.py b/contrib/gcc-changelog/git_update_version.py
index 0508f194084..1837c1a8d7f 100755
--- a/contrib/gcc-changelog/git_update_version.py
+++ b/contrib/gcc-changelog/git_update_version.py
@@ -27,7 +27,10 @@ from git_repository import parse_git_revisions
 current_timestamp = datetime.datetime.now().strftime('%Y%m%d\n')
 
 # Skip the following commits, they cannot be correctly processed
-IGNORED_COMMITS = ('c2be82058fb40f3ae891c68d185ff53e07f14f45')
+IGNORED_COMMITS = (
+        'c2be82058fb40f3ae891c68d185ff53e07f14f45',
+        '04a040d907a83af54e0a98bdba5bfabc0ef4f700',
+        '2e96b5f14e4025691b57d2301d71aa6092ed44bc')
 
 
 def read_timestamp(path):
diff --git a/contrib/gcc-changelog/test_email.py b/contrib/gcc-changelog/test_email.py
index 7472762e66d..a4796dbbe94 100755
--- a/contrib/gcc-changelog/test_email.py
+++ b/contrib/gcc-changelog/test_email.py
@@ -258,7 +258,7 @@ class TestGccChangelog(unittest.TestCase):
         email = self.from_patch_glob('0001-Add-patch_are')
         msg = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates should ' \
               'be done separately from normal commits'
-        assert email.errors[0].message == msg
+        assert email.errors[0].message.startswith(msg)
 
     def test_strict_mode_normal_patch(self):
         email = self.get_git_email('0001-Just-test-it.patch')
@@ -415,6 +415,7 @@ class TestGccChangelog(unittest.TestCase):
     def test_multiline_bad_parentheses(self):
         email = self.from_patch_glob('0002-Wrong-macro-changelog.patch')
         assert email.errors[0].message == 'bad parentheses wrapping'
+        assert email.errors[0].line == '	* config/i386/i386.md (*fix_trunc<mode>_i387_1,'
 
     def test_changelog_removal(self):
         email = self.from_patch_glob('0001-ChangeLog-removal.patch')
@@ -427,3 +428,21 @@ class TestGccChangelog(unittest.TestCase):
     def test_multi_same_file(self):
         email = self.from_patch_glob('0001-OpenMP-Fix-SIMT')
         assert email.errors[0].message == 'same file specified multiple times'
+
+    def test_pr_only_in_subject(self):
+        email = self.from_patch_glob('0001-rs6000-Support-doubleword')
+        assert (email.errors[0].message ==
+                'PR 100085 in subject but not in changelog')
+
+    def test_wrong_pr_comp_in_subject(self):
+        email = self.from_patch_glob('pr-wrong-comp.patch')
+        assert email.errors[0].message == 'invalid PR component in subject'
+
+    def test_copyright_years(self):
+        email = self.from_patch_glob('copyright-years.patch')
+        assert not email.errors
+
+    def test_non_ascii_email(self):
+        email = self.from_patch_glob('non-ascii-email.patch')
+        assert (email.errors[0].message ==
+                'non-ASCII characters in git commit email address (jbglaw@ług-owl.de)')
diff --git a/contrib/gcc-changelog/test_patches.txt b/contrib/gcc-changelog/test_patches.txt
index 39d40b88618..98a0d3f1ee0 100644
--- a/contrib/gcc-changelog/test_patches.txt
+++ b/contrib/gcc-changelog/test_patches.txt
@@ -1461,6 +1461,7 @@ Subject: [PATCH 0030/2034] 	PR c++/92746 - ICE with noexcept of function
 Another place that needs to specially handle Concepts TS function-style
 concepts.
 
+	PR c++/92746
 	* except.c (check_noexcept_r): Handle concept-check.
 ---
  gcc/cp/ChangeLog                            | 3 +++
@@ -1977,7 +1978,7 @@ index aac31d02b6c..56c470f6ecf 100644
 From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
 From: Jason Merrill <jason@redhat.com>
 Date: Thu, 16 Jan 2020 16:55:39 -0500
-Subject: [PATCH 0121/2034] PR c++/93286 - ICE with __is_constructible and
+Subject: [PATCH 0121/2034] PR c++/12345 - ICE with __is_constructible and
  variadic template.
 
 Here we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST
@@ -3406,3 +3407,85 @@ index 00000000000..21540512e23
 +
 -- 
 2.25.1
+=== 0001-rs6000-Support-doubleword ===
+From f700e4b0ee3ef53b48975cf89be26b9177e3a3f3 Mon Sep 17 00:00:00 2001
+From: Xionghu Luo <luoxhu@linux.ibm.com>
+Date: Tue, 8 Jun 2021 21:48:12 -0500
+Subject: [PATCH] rs6000: Support doubleword swaps removal in rot64 load store
+ [PR100085]
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+=== pr-wrong-comp.patch ===
+From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Thu, 16 Jan 2020 16:55:39 -0500
+Subject: [PATCH 0121/2034] PR some/93286 - ICE with __is_constructible and
+ variadic template.
+
+gcc/testsuite/ChangeLog:
+
+	PR c++/93286
+	* gcc.target/powerpc/pr100085.c: New test.
+---
+diff --git a/gcc/testsuite/gcc.target/powerpc/pr100085.c b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+new file mode 100644
+index 00000000000..7d8b147b127
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr100085.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+==== copyright-years.patch ===
+From 99dee82307f1e163e150c9c810452979994047ce Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Mon, 4 Jan 2021 10:26:59 +0100
+Subject: [PATCH] Update copyright years.
+
+---
+diff --git a/lto-plugin/lto-plugin.c b/lto-plugin/lto-plugin.c
+new file mode 100644
+index 6f67552d075..32478f070e8 100644
+--- a/lto-plugin/lto-plugin.c
++++ b/lto-plugin/lto-plugin.c
+@@ -0,0 +1,1 @@
++
+-- 
+2.25.1
+
+=== non-ascii-email.patch ===
+From f42e95a830ab48e59389065ce79a013a519646f1 Mon Sep 17 00:00:00 2001
+From: Jan-Benedict Glaw <jbglaw@ług-owl.de>
+Date: Mon, 13 Sep 2021 12:08:25 +0200
+Subject: [PATCH] Fix multi-statment macro
+
+INIT_CUMULATIVE_ARGS() expands to multiple statements, which will break right
+after an `if` statement. Wrap it into a block.
+
+gcc/ChangeLog:
+
+	* config/alpha/vms.h (INIT_CUMULATIVE_ARGS): Wrap multi-statment
+	define into a block.
+---
+ gcc/config/alpha/vms.h | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/gcc/config/alpha/vms.h b/gcc/config/alpha/vms.h
+index 2a9917cde62..0033b0004b3 100644
+--- a/gcc/config/alpha/vms.h
++++ b/gcc/config/alpha/vms.h
+@@ -0,0 +1,1 @@
++
+-- 
diff --git a/contrib/git-backport.py b/contrib/git-backport.py
index 2b8e4686719..fc369d97754 100755
--- a/contrib/git-backport.py
+++ b/contrib/git-backport.py
@@ -20,46 +20,16 @@
 # Boston, MA 02110-1301, USA.
 
 import argparse
+import os
 import subprocess
 
+script_folder = os.path.dirname(os.path.abspath(__file__))
+fixup_script = os.path.join(script_folder, 'git-fix-changelog.py')
+
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Backport a git revision and '
-                                     'stash all ChangeLog files.')
+    parser = argparse.ArgumentParser(description='Backport a git revision.')
     parser.add_argument('revision', help='Revision')
     args = parser.parse_args()
 
-    r = subprocess.run('git cherry-pick -x %s' % args.revision, shell=True)
-    if r.returncode == 0:
-        cmd = 'git show --name-only --pretty="" -- "*ChangeLog"'
-        changelogs = subprocess.check_output(cmd, shell=True, encoding='utf8')
-        changelogs = changelogs.strip()
-        if changelogs:
-            for changelog in changelogs.split('\n'):
-                subprocess.check_output('git checkout HEAD~ %s' % changelog,
-                                        shell=True)
-        subprocess.check_output('git commit --amend --no-edit', shell=True)
-    else:
-        # 1) remove all ChangeLog files from conflicts
-        out = subprocess.check_output('git diff --name-only --diff-filter=U',
-                                      shell=True,
-                                      encoding='utf8')
-        conflicts = out.strip().split('\n')
-        changelogs = [c for c in conflicts if c.endswith('ChangeLog')]
-        if changelogs:
-            cmd = 'git checkout --theirs %s' % ' '.join(changelogs)
-            subprocess.check_output(cmd, shell=True)
-        # 2) remove all ChangeLog files from index
-        cmd = 'git diff --name-only --diff-filter=M HEAD'
-        out = subprocess.check_output(cmd, shell=True, encoding='utf8')
-        out = out.strip().split('\n')
-        modified = [c for c in out if c.endswith('ChangeLog')]
-        for m in modified:
-            subprocess.check_output('git reset %s' % m, shell=True)
-            subprocess.check_output('git checkout %s' % m, shell=True)
-
-        # try to continue
-        if len(conflicts) == len(changelogs):
-            cmd = 'git -c core.editor=true cherry-pick --continue'
-            subprocess.check_output(cmd, shell=True)
-        else:
-            print('Please resolve all remaining file conflicts.')
+    subprocess.run('git cherry-pick -x %s' % args.revision, shell=True)
+    subprocess.run(fixup_script, shell=True)
diff --git a/contrib/git-commit-mklog.py b/contrib/git-commit-mklog.py
new file mode 100755
index 00000000000..eda3fc4a892
--- /dev/null
+++ b/contrib/git-commit-mklog.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script is wrapper for git commit-mklog alias where it parses
+# -b/--pr-numbers argument and passes it via environment variable
+# to mklog.py script.
+
+import argparse
+import os
+import subprocess
+
+if __name__ == '__main__':
+    children_args = []
+    myenv = os.environ.copy()
+
+    parser = argparse.ArgumentParser(description='git-commit-mklog wrapped')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('--co',
+                        help='Add Co-Authored-By trailer (comma separated)')
+    args, unknown_args = parser.parse_known_args()
+
+    myenv['GCC_FORCE_MKLOG'] = '1'
+    mklog_args = []
+    if args.pr_numbers:
+        mklog_args.append(f'-b {",".join(args.pr_numbers)}')
+    if args.fill_up_bug_titles:
+        mklog_args.append('-p')
+
+    if mklog_args:
+        myenv['GCC_MKLOG_ARGS'] = ' '.join(mklog_args)
+
+    if args.co:
+        for author in args.co.split(','):
+            unknown_args.append(f'--trailer "Co-Authored-By: {author}"')
+
+    commit_args = ' '.join(unknown_args)
+    subprocess.run(f'git commit {commit_args}', shell=True, env=myenv)
diff --git a/contrib/git-fix-changelog.py b/contrib/git-fix-changelog.py
new file mode 100755
index 00000000000..c15e45c11fa
--- /dev/null
+++ b/contrib/git-fix-changelog.py
@@ -0,0 +1,92 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script tries to fix commit message where ChangeLog entries
+# can point to .cc renamed files.
+
+import argparse
+import os
+import subprocess
+import tempfile
+
+DESCRIPTION = 'Fix up ChangeLog of the current commit.'
+
+script_folder = os.path.dirname(os.path.abspath(__file__))
+verify_script = os.path.join(script_folder,
+                             'gcc-changelog/git_check_commit.py')
+
+
+def replace_file_in_changelog(lines, filename, fixed):
+    # consider all componenets of a path: gcc/ipa-icf.cc
+    while filename:
+        for i, line in enumerate(lines):
+            if filename in line:
+                lines[i] = line.replace(filename, fixed)
+                return
+
+        parts = filename.split('/')
+        if len(parts) == 1:
+            return
+        filename = '/'.join(parts[1:])
+        fixed = '/'.join(fixed.split('/')[1:])
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=DESCRIPTION)
+    args = parser.parse_args()
+
+    # Update commit message if change for a .cc file was taken
+    r = subprocess.run(f'{verify_script} HEAD', shell=True, encoding='utf8',
+                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    if r.returncode != 0:
+        lines = r.stdout.splitlines()
+        cmd = 'git show -s --format=%B'
+        commit_message = subprocess.check_output(cmd, shell=True,
+                                                 encoding='utf8').strip()
+        commit_message = commit_message.splitlines()
+
+        # Parse the following lines:
+        # ERR: unchanged file mentioned in a ChangeLog \
+        # (did you mean "gcc/ipa-icf.cc"?): "gcc/ipa-icf.c"
+        replaced = 0
+        for line in lines:
+            if ('unchanged file mentioned' in line and
+                    'did you mean' in line):
+                filename = line.split()[-1].strip('"')
+                fixed = line[line.index('did you mean'):]
+                fixed = fixed[fixed.index('"') + 1:]
+                fixed = fixed[:fixed.index('"')]
+
+                if filename.count('/') == fixed.count('/'):
+                    replace_file_in_changelog(commit_message, filename, fixed)
+                    replaced += 1
+
+        if replaced:
+            with tempfile.NamedTemporaryFile('w', encoding='utf8',
+                                             delete=False) as w:
+                w.write('\n'.join(commit_message))
+                w.close()
+                subprocess.check_output(f'git commit --amend -F {w.name}',
+                                        shell=True, encoding='utf8')
+                os.unlink(w.name)
+                print(f'Commit message updated: {replaced} file(s) renamed.')
+        else:
+            print('Commit message has not been updated.')
diff --git a/contrib/mklog.py b/contrib/mklog.py
new file mode 100755
index 00000000000..674c1dcd78b
--- /dev/null
+++ b/contrib/mklog.py
@@ -0,0 +1,356 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import argparse
+import datetime
+import os
+import re
+import subprocess
+import sys
+from itertools import takewhile
+
+import requests
+
+from unidiff import PatchSet
+
+pr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<pr>PR [a-z+-]+\/[0-9]+)')
+prnum_regex = re.compile(r'PR (?P<comp>[a-z+-]+)/(?P<num>[0-9]+)')
+dr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<dr>DR [0-9]+)')
+dg_regex = re.compile(r'{\s+dg-(error|warning)')
+pr_filename_regex = re.compile(r'(^|[\W_])[Pp][Rr](?P<pr>\d{4,})')
+identifier_regex = re.compile(r'^([a-zA-Z0-9_#].*)')
+comment_regex = re.compile(r'^\/\*')
+struct_regex = re.compile(r'^(class|struct|union|enum)\s+'
+                          r'(GTY\(.*\)\s+)?([a-zA-Z0-9_]+)')
+macro_regex = re.compile(r'#\s*(define|undef)\s+([a-zA-Z0-9_]+)')
+super_macro_regex = re.compile(r'^DEF[A-Z0-9_]+\s*\(([a-zA-Z0-9_]+)')
+fn_regex = re.compile(r'([a-zA-Z_][^()\s]*)\s*\([^*]')
+template_and_param_regex = re.compile(r'<[^<>]*>')
+md_def_regex = re.compile(r'\(define.*\s+"(.*)"')
+bugzilla_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/bug?id=%s&' \
+               'include_fields=summary,component'
+
+function_extensions = {'.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def', '.md'}
+
+# NB: Makefile.in isn't listed as it's not always generated.
+generated_files = {'aclocal.m4', 'config.h.in', 'configure'}
+
+help_message = """\
+Generate ChangeLog template for PATCH.
+PATCH must be generated using diff(1)'s -up or -cp options
+(or their equivalent in git).
+"""
+
+script_folder = os.path.realpath(__file__)
+root = os.path.dirname(os.path.dirname(script_folder))
+
+firstpr = ''
+
+
+def find_changelog(path):
+    folder = os.path.split(path)[0]
+    while True:
+        if os.path.exists(os.path.join(root, folder, 'ChangeLog')):
+            return folder
+        folder = os.path.dirname(folder)
+        if folder == '':
+            return folder
+    raise AssertionError()
+
+
+def extract_function_name(line):
+    if comment_regex.match(line):
+        return None
+    m = struct_regex.search(line)
+    if m:
+        # Struct declaration
+        return m.group(1) + ' ' + m.group(3)
+    m = macro_regex.search(line)
+    if m:
+        # Macro definition
+        return m.group(2)
+    m = super_macro_regex.search(line)
+    if m:
+        # Supermacro
+        return m.group(1)
+    m = fn_regex.search(line)
+    if m:
+        # Discard template and function parameters.
+        fn = m.group(1)
+        fn = re.sub(template_and_param_regex, '', fn)
+        return fn.rstrip()
+    return None
+
+
+def try_add_function(functions, line):
+    fn = extract_function_name(line)
+    if fn and fn not in functions:
+        functions.append(fn)
+    return bool(fn)
+
+
+def sort_changelog_files(changed_file):
+    return (changed_file.is_added_file, changed_file.is_removed_file)
+
+
+def get_pr_titles(prs):
+    output = []
+    for idx, pr in enumerate(prs):
+        pr_id = pr.split('/')[-1]
+        r = requests.get(bugzilla_url % pr_id)
+        bugs = r.json()['bugs']
+        if len(bugs) == 1:
+            prs[idx] = 'PR %s/%s' % (bugs[0]['component'], pr_id)
+            out = '%s - %s\n' % (prs[idx], bugs[0]['summary'])
+            if out not in output:
+                output.append(out)
+    if output:
+        output.append('')
+    return '\n'.join(output)
+
+
+def generate_changelog(data, no_functions=False, fill_pr_titles=False,
+                       additional_prs=None):
+    changelogs = {}
+    changelog_list = []
+    prs = []
+    out = ''
+    diff = PatchSet(data)
+    global firstpr
+
+    if additional_prs:
+        prs = [pr for pr in additional_prs if pr not in prs]
+    for file in diff:
+        # skip files that can't be parsed
+        if file.path == '/dev/null':
+            continue
+        changelog = find_changelog(file.path)
+        if changelog not in changelogs:
+            changelogs[changelog] = []
+            changelog_list.append(changelog)
+        changelogs[changelog].append(file)
+
+        # Extract PR entries from newly added tests
+        if 'testsuite' in file.path and file.is_added_file:
+            # Only search first ten lines as later lines may
+            # contains commented code which a note that it
+            # has not been tested due to a certain PR or DR.
+            this_file_prs = []
+            for line in list(file)[0][0:10]:
+                m = pr_regex.search(line.value)
+                if m:
+                    pr = m.group('pr')
+                    if pr not in prs:
+                        prs.append(pr)
+                        this_file_prs.append(pr.split('/')[-1])
+                else:
+                    m = dr_regex.search(line.value)
+                    if m:
+                        dr = m.group('dr')
+                        if dr not in prs:
+                            prs.append(dr)
+                            this_file_prs.append(dr.split('/')[-1])
+                    elif dg_regex.search(line.value):
+                        # Found dg-warning/dg-error line
+                        break
+            # PR number in the file name
+            fname = os.path.basename(file.path)
+            m = pr_filename_regex.search(fname)
+            if m:
+                pr = m.group('pr')
+                pr2 = 'PR ' + pr
+                if pr not in this_file_prs and pr2 not in prs:
+                    prs.append(pr2)
+
+    if prs:
+        firstpr = prs[0]
+
+    if fill_pr_titles:
+        out += get_pr_titles(prs)
+
+    # print list of PR entries before ChangeLog entries
+    if prs:
+        if not out:
+            out += '\n'
+        for pr in prs:
+            out += '\t%s\n' % pr
+        out += '\n'
+
+    # sort ChangeLog so that 'testsuite' is at the end
+    for changelog in sorted(changelog_list, key=lambda x: 'testsuite' in x):
+        files = changelogs[changelog]
+        out += '%s:\n' % os.path.join(changelog, 'ChangeLog')
+        out += '\n'
+        # new and deleted files should be at the end
+        for file in sorted(files, key=sort_changelog_files):
+            assert file.path.startswith(changelog)
+            in_tests = 'testsuite' in changelog or 'testsuite' in file.path
+            relative_path = file.path[len(changelog):].lstrip('/')
+            functions = []
+            if file.is_added_file:
+                msg = 'New test' if in_tests else 'New file'
+                out += '\t* %s: %s.\n' % (relative_path, msg)
+            elif file.is_removed_file:
+                out += '\t* %s: Removed.\n' % (relative_path)
+            elif hasattr(file, 'is_rename') and file.is_rename:
+                out += '\t* %s: Moved to...\n' % (relative_path)
+                new_path = file.target_file[2:]
+                # A file can be theoretically moved to a location that
+                # belongs to a different ChangeLog.  Let user fix it.
+                if new_path.startswith(changelog):
+                    new_path = new_path[len(changelog):].lstrip('/')
+                out += '\t* %s: ...here.\n' % (new_path)
+            elif os.path.basename(file.path) in generated_files:
+                out += '\t* %s: Regenerate.\n' % (relative_path)
+            else:
+                if not no_functions:
+                    for hunk in file:
+                        # Do not add function names for testsuite files
+                        extension = os.path.splitext(relative_path)[1]
+                        if not in_tests and extension in function_extensions:
+                            last_fn = None
+                            modified_visited = False
+                            success = False
+                            for line in hunk:
+                                m = identifier_regex.match(line.value)
+                                if line.is_added or line.is_removed:
+                                    # special-case definition in .md files
+                                    m2 = md_def_regex.match(line.value)
+                                    if extension == '.md' and m2:
+                                        fn = m2.group(1)
+                                        if fn not in functions:
+                                            functions.append(fn)
+                                            last_fn = None
+                                            success = True
+
+                                    if not line.value.strip():
+                                        continue
+                                    modified_visited = True
+                                    if m and try_add_function(functions,
+                                                              m.group(1)):
+                                        last_fn = None
+                                        success = True
+                                elif line.is_context:
+                                    if last_fn and modified_visited:
+                                        try_add_function(functions, last_fn)
+                                        last_fn = None
+                                        modified_visited = False
+                                        success = True
+                                    elif m:
+                                        last_fn = m.group(1)
+                                        modified_visited = False
+                            if not success:
+                                try_add_function(functions,
+                                                 hunk.section_header)
+                if functions:
+                    out += '\t* %s (%s):\n' % (relative_path, functions[0])
+                    for fn in functions[1:]:
+                        out += '\t(%s):\n' % fn
+                else:
+                    out += '\t* %s:\n' % relative_path
+        out += '\n'
+    return out
+
+
+def update_copyright(data):
+    current_timestamp = datetime.datetime.now().strftime('%Y-%m-%d')
+    username = subprocess.check_output('git config user.name', shell=True,
+                                       encoding='utf8').strip()
+    email = subprocess.check_output('git config user.email', shell=True,
+                                    encoding='utf8').strip()
+
+    changelogs = set()
+    diff = PatchSet(data)
+
+    for file in diff:
+        changelog = os.path.join(find_changelog(file.path), 'ChangeLog')
+        if changelog not in changelogs:
+            changelogs.add(changelog)
+            with open(changelog) as f:
+                content = f.read()
+            with open(changelog, 'w+') as f:
+                f.write(f'{current_timestamp}  {username}  <{email}>\n\n')
+                f.write('\tUpdate copyright years.\n\n')
+                f.write(content)
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=help_message)
+    parser.add_argument('input', nargs='?',
+                        help='Patch file (or missing, read standard input)')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-s', '--no-functions', action='store_true',
+                        help='Do not generate function names in ChangeLogs')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('-d', '--directory',
+                        help='Root directory where to search for ChangeLog '
+                        'files')
+    parser.add_argument('-c', '--changelog',
+                        help='Append the ChangeLog to a git commit message '
+                             'file')
+    parser.add_argument('--update-copyright', action='store_true',
+                        help='Update copyright in ChangeLog files')
+    args = parser.parse_args()
+    if args.input == '-':
+        args.input = None
+    if args.directory:
+        root = args.directory
+
+    data = open(args.input) if args.input else sys.stdin
+    if args.update_copyright:
+        update_copyright(data)
+    else:
+        output = generate_changelog(data, args.no_functions,
+                                    args.fill_up_bug_titles, args.pr_numbers)
+        if args.changelog:
+            lines = open(args.changelog).read().split('\n')
+            start = list(takewhile(lambda l: not l.startswith('#'), lines))
+            end = lines[len(start):]
+            with open(args.changelog, 'w') as f:
+                if not start or not start[0]:
+                    # initial commit subject line 'component: [PRnnnnn]'
+                    m = prnum_regex.match(firstpr)
+                    if m:
+                        title = f'{m.group("comp")}: [PR{m.group("num")}]'
+                        start.insert(0, title)
+                if start:
+                    # append empty line
+                    if start[-1] != '':
+                        start.append('')
+                else:
+                    # append 2 empty lines
+                    start = 2 * ['']
+                f.write('\n'.join(start))
+                f.write('\n')
+                f.write(output)
+                f.write('\n'.join(end))
+        else:
+            print(output, end='')
diff --git a/contrib/test_mklog.py b/contrib/test_mklog.py
new file mode 100755
index 00000000000..f5e9ecd577c
--- /dev/null
+++ b/contrib/test_mklog.py
@@ -0,0 +1,487 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import unittest
+
+from mklog import generate_changelog
+
+import unidiff
+
+unidiff_supports_renaming = hasattr(unidiff.PatchedFile(), 'is_rename')
+
+
+PATCH1 = '''\
+diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
+index 567c23380fe..e6209ede9d6 100644
+--- a/gcc/config/riscv/riscv.h
++++ b/gcc/config/riscv/riscv.h
+@@ -920,6 +920,7 @@ extern unsigned riscv_stack_boundary;
+ #define SHIFT_RS1 15
+ #define SHIFT_IMM 20
+ #define IMM_BITS 12
++#define C_S_BITS 5
+ #define C_SxSP_BITS 6
+ 
+ #define IMM_REACH (1LL << IMM_BITS)
+@@ -929,6 +930,10 @@ extern unsigned riscv_stack_boundary;
+ #define SWSP_REACH (4LL << C_SxSP_BITS)
+ #define SDSP_REACH (8LL << C_SxSP_BITS)
+ 
++/* This is the maximum value that can be represented in a compressed load/store
++   offset (an unsigned 5-bit value scaled by 4).  */
++#define CSW_MAX_OFFSET ((4LL << C_S_BITS) - 1) & ~3
++
+ /* Called from RISCV_REORG, this is defined in riscv-sr.c.  */
+ 
+ extern void riscv_remove_unneeded_save_restore_calls (void);
+
+'''
+
+EXPECTED1 = '''\
+gcc/ChangeLog:
+
+	* config/riscv/riscv.h (C_S_BITS):
+	(CSW_MAX_OFFSET):
+
+'''
+
+PATCH2 = '''\
+diff --git a/gcc/targhooks.h b/gcc/targhooks.h
+index 9704d23f1db..b572a36e8cf 100644
+--- a/gcc/targhooks.h
++++ b/gcc/targhooks.h
+@@ -120,7 +120,7 @@ extern bool default_empty_mask_is_expensive (unsigned);
+ extern void *default_init_cost (class loop *);
+ extern unsigned default_add_stmt_cost (class vec_info *, void *, int,
+ 				       enum vect_cost_for_stmt,
+-				       class _stmt_vec_info *, int,
++				       class _stmt_vec_info *, tree, int,
+ 				       enum vect_cost_model_location);
+ extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);
+ extern void default_destroy_cost_data (void *);
+@@ -186,6 +186,7 @@ extern tree default_emutls_var_init (tree, tree, tree);
+ extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);
+ extern bool default_hard_regno_scratch_ok (unsigned int);
+ extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);
++extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);
+ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);
+ extern bool default_target_option_pragma_parse (tree, tree);
+ extern bool default_target_can_inline_p (tree, tree);
+
+'''
+
+EXPECTED2 = '''\
+gcc/ChangeLog:
+
+	* targhooks.h (default_add_stmt_cost):
+	(default_new_address_profitable_p):
+
+'''
+
+PATCH3 = '''\
+diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
+index 2b1e33f94ae..7f47402f9b9 100644
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -173,7 +173,7 @@ enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_GNUC11, CLK_GNUC17, CLK_GNUC2X,
+ 	     CLK_STDC2X,
+ 	     CLK_GNUCXX, CLK_CXX98, CLK_GNUCXX11, CLK_CXX11,
+ 	     CLK_GNUCXX14, CLK_CXX14, CLK_GNUCXX17, CLK_CXX17,
+-	     CLK_GNUCXX2A, CLK_CXX2A, CLK_ASM};
++	     CLK_GNUCXX20, CLK_CXX20, CLK_ASM};
+ 
+ /* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */
+ struct GTY(()) cpp_string {
+@@ -484,7 +484,7 @@ struct cpp_options
+   /* Nonzero for C2X decimal floating-point constants.  */
+   unsigned char dfp_constants;
+ 
+-  /* Nonzero for C++2a __VA_OPT__ feature.  */
++  /* Nonzero for C++20 __VA_OPT__ feature.  */
+   unsigned char va_opt;
+ 
+   /* Nonzero for the '::' token.  */
+
+'''
+
+EXPECTED3 = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h (enum c_lang):
+	(struct cpp_options):
+
+'''
+
+EXPECTED3B = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h:
+
+'''
+
+PATCH4 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index aab79492357..f0df1002488 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -1,5 +1,7 @@
+ 
+ 
++
++
+ /* Interprocedural Identical Code Folding pass
+    Copyright (C) 2014-2020 Free Software Foundation, Inc.
+ 
+diff --git a/gcc/testsuite/gcc.dg/pr32374.c b/gcc/testsuite/gcc.dg/pr32374.c
+deleted file mode 100644
+index de15d559f5b..00000000000
+--- a/gcc/testsuite/gcc.dg/pr32374.c
++++ /dev/null
+@@ -1,20 +0,0 @@
+-/* { dg-do compile } */
+-/* { dg-options "-O2" } */
+-
+-extern int *stderr;
+-
+-void f (int *, const char *, ...);
+-
+-void g (const char *conf_name)
+-{
+-  typedef struct
+-  {
+-    const char *label;
+-    const int value;
+-  } Section;
+-
+-  const Section sections[2] = { {"", 0}, {"", 1} };
+-
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-}
+diff --git a/gcc/testsuite/gcc.dg/pr40209.c b/gcc/testsuite/gcc.dg/pr40209.c
+index 4e77df5c2e6..c23d69d1f1b 100644
+--- a/gcc/testsuite/gcc.dg/pr40209.c
++++ b/gcc/testsuite/gcc.dg/pr40209.c
+@@ -1,6 +1,8 @@
+ /* { dg-do compile } */
+ /* { dg-options "-O2 -fprofile-use -fopt-info -Wno-missing-profile" } */
+ 
++
++
+ void process(const char *s);
+ 
+ struct BaseHolder {
+diff --git a/gcc/testsuite/gcc.dg/pr50209.c b/gcc/testsuite/gcc.dg/pr50209.c
+new file mode 100644
+index 00000000000..b28b04f6431
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/pr50209.c
+@@ -0,0 +1,3 @@
++
++
++
+diff --git a/gcc/testsuite/gcc.dg/pr63567-1.c b/gcc/testsuite/gcc.dg/pr63567-1.c
+index 97da171563e..00c5ecc11fa 100644
+--- a/gcc/testsuite/gcc.dg/pr63567-1.c
++++ b/gcc/testsuite/gcc.dg/pr63567-1.c
+@@ -1,3 +1,4 @@
++
+ /* PR c/63567 */
+ /* { dg-do compile } */
+ /* { dg-options "" } */
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index f062e48071f..fd3c7ca8cf3 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1,3 +1,5 @@
++
++
+ /* Output variables, constants and external declarations, for GNU compiler.
+    Copyright (C) 1987-2020 Free Software Foundation, Inc.
+ 
+diff --git a/libssp/gets-chk.c b/libssp/gets-chk.c
+index 4ad78c1f77b..6687b368038 100644
+--- a/libssp/gets-chk.c
++++ b/libssp/gets-chk.c
+@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ 
++
++
+ #include "config.h"
+ #include <ssp/ssp.h>
+ #include <stdarg.h>
+'''
+
+EXPECTED4 = '''\
+
+	PR 50209
+
+gcc/ChangeLog:
+
+	* ipa-icf.c:
+	* varasm.c:
+
+libssp/ChangeLog:
+
+	* gets-chk.c:
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.dg/pr40209.c:
+	* gcc.dg/pr63567-1.c:
+	* gcc.dg/pr32374.c: Removed.
+	* gcc.dg/pr50209.c: New test.
+
+'''
+
+PATCH5 = '''\
+diff --git a/gcc/testsuite/gcc.target/i386/pr95046-6.c b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+new file mode 100644
+index 00000000000..dcc8999c446
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+@@ -0,0 +1,44 @@
++/* PR target/95046 */
++/* { dg-do compile { target { ! ia32 } } } */
++/* { dg-options "-O3 -mavx512vl" } */
++
++
++double r[2];
++int s[2];
++unsigned int u[2];
++
++void
++test_float (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = s[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtdq2pd" } } */
++
++void
++test_ufloat (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = u[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtudq2pd" } } */
++
++void
++test_fix (void)
++{
++  for (int i = 0; i < 2; i++)
++    s[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2dqx" } } */
++
++void
++test_ufix (void)
++{
++  for (int i = 0; i < 2; i++)
++    u[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2udqx" } } */
+-- 
+2.26.2
+
+'''
+
+EXPECTED5 = '''\
+PR target/95046 - Vectorize V2SFmode operations
+
+	PR target/95046
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/i386/pr95046-6.c: New test.
+
+'''
+
+PATCH6 = '''\
+diff --git a/gcc/cgraph.h b/gcc/cgraph.h
+index 5ddeb65269b..cfae6e91da9 100644
+--- a/gcc/cgraph.h
++++ b/gcc/cgraph.h
+@@ -937,7 +937,8 @@ struct GTY((tag ("SYMTAB_FUNCTION"))) cgraph_node : public symtab_node
+       split_part (false), indirect_call_target (false), local (false),
+       versionable (false), can_change_signature (false),
+       redefined_extern_inline (false), tm_may_enter_irr (false),
+-      ipcp_clone (false), m_uid (uid), m_summary_id (-1)
++      ipcp_clone (false), declare_variant_alt (false),
++      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)
+   {}
+ 
+   /* Remove the node from cgraph and all inline clones inlined into it.
+
+'''
+
+EXPECTED6 = '''\
+gcc/ChangeLog:
+
+	* cgraph.h (struct cgraph_node):
+
+'''
+
+PATCH7 = '''\
+diff --git a/gcc/testsuite/g++.dg/DRs/dr2237.C b/gcc/testsuite/g++.dg/DRs/dr2237.C
+new file mode 100644
+index 00000000000..f3d6d11e61e
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/DRs/dr2237.C
+@@ -0,0 +1,18 @@
++// DR 2237 - Can a template-id name a constructor?
++
++template<class T>
++struct X {
++  X<T>(); // { dg-error "expected" "" { target c++20 } }
++  X(int); // OK, injected-class-name used
++  ~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
++
++// ill-formed since DR1435
++template<typename T> X<T>::X<T>() {} // { dg-error "names the constructor|as no template constructors" }
++template<typename T> X<T>::~X<T>() {} // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++
++struct Q {
++  // ill-formed since DR1435
++  template<typename T> friend X<T>::X<T>(); // { dg-error "names the constructor|as no template constructors" }
++  template<typename T> friend X<T>::~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
+'''
+
+EXPECTED7 = '''\
+
+	DR 2237
+
+gcc/testsuite/ChangeLog:
+
+	* g++.dg/DRs/dr2237.C: New test.
+
+'''
+
+PATCH8 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf2.c
+similarity index 100%
+rename from gcc/ipa-icf.c
+rename to gcc/ipa-icf2.c
+'''
+
+EXPECTED8 = '''\
+gcc/ChangeLog:
+
+	* ipa-icf.c: Moved to...
+	* ipa-icf2.c: ...here.
+
+'''
+
+PATCH9 = '''\
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 2a260c1cfbd..7f03fc491c3 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -17611,6 +17611,23 @@ (define_insn "avx2_<code>v16qiv16hi2<mask_name>"
+    (set_attr "prefix" "maybe_evex")
+    (set_attr "mode" "OI")])
+ 
++(define_insn_and_split "*avx2_zero_extendv16qiv16hi2_1"
++  [(set (match_operand:V32QI 0 "register_operand" "=v")
++	(vec_select:V32QI
++	  (vec_concat:V64QI
++	    (match_operand:V32QI 1 "nonimmediate_operand" "vm")
++	    (match_operand:V32QI 2 "const0_operand" "C"))
++	  (match_parallel 3 "pmovzx_parallel"
++	    [(match_operand 4 "const_int_operand" "n")])))]
++  "TARGET_AVX2"
++  "#"
++  "&& reload_completed"
++  [(set (match_dup 0) (zero_extend:V16HI (match_dup 1)))]
++{
++  operands[0] = lowpart_subreg (V16HImode, operands[0], V32QImode);
++  operands[1] = lowpart_subreg (V16QImode, operands[1], V32QImode);
++})
++
+ (define_expand "<insn>v16qiv16hi2"
+   [(set (match_operand:V16HI 0 "register_operand")
+ 	(any_extend:V16HI
+'''
+
+EXPECTED9 = '''\
+gcc/ChangeLog:
+
+	* config/i386/sse.md (*avx2_zero_extendv16qiv16hi2_1):
+
+'''
+
+class TestMklog(unittest.TestCase):
+    def test_macro_definition(self):
+        changelog = generate_changelog(PATCH1)
+        assert changelog == EXPECTED1
+
+    def test_changed_argument(self):
+        changelog = generate_changelog(PATCH2)
+        assert changelog == EXPECTED2
+
+    def test_enum_and_struct(self):
+        changelog = generate_changelog(PATCH3)
+        assert changelog == EXPECTED3
+
+    def test_no_function(self):
+        changelog = generate_changelog(PATCH3, True)
+        assert changelog == EXPECTED3B
+
+    def test_sorting(self):
+        changelog = generate_changelog(PATCH4)
+        assert changelog == EXPECTED4
+
+    def test_pr_bugzilla_download(self):
+        changelog = generate_changelog(PATCH5, fill_pr_titles=True)
+        assert changelog == EXPECTED5
+
+    def test_gty_in_struct(self):
+        changelog = generate_changelog(PATCH6, fill_pr_titles=True)
+        assert changelog == EXPECTED6
+
+    def test_dr_detection_in_test_case(self):
+        changelog = generate_changelog(PATCH7)
+        assert changelog == EXPECTED7
+
+    @unittest.skipIf(not unidiff_supports_renaming,
+                     'Newer version of unidiff is needed (0.6.0+)')
+    def test_renaming(self):
+        changelog = generate_changelog(PATCH8)
+        assert changelog == EXPECTED8
+
+    def test_define_macro_parsing(self):
+        changelog = generate_changelog(PATCH9)
+        assert changelog == EXPECTED9
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 8148c559489..ccfb75e5120 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.4.0
+9.4.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 7558c0a369e..a6f18eee4f6 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,381 @@
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gimple-ssa-evrp-analyze.c
+	(evrp_range_analyzer::record_ranges_from_incoming_edge): Make
+	sure the condition post-dominates the SSA definition before
+	recording into SSA_NAME_RANGE_INFO.
+
+2022-01-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/103465
+	* coretypes.h (unwind_info_type): Swap UI_SEH and UI_TARGET.
+
+2022-01-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (%X): Remove obsolete reference to -Wl.
+
+2021-12-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR target/100985
+	* config/aarch64/arm_acle.h: Remove unclosed extern "C" block.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* config/rs6000/rs6000.c (rs6000_builtin_decl): Remove builtin mask
+	check.
+
+2021-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/103267
+	* tree-sra.c (scan_function): Also check ECF_LOOPING_CONST_OR_PURE
+	flag.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* ipa-pure-const.c (propagate_pure_const): Fix merging of loping flag.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* config/rs6000/altivec.h (vec_cpsgn): Swap operand order.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config/s390/s390.md (define_peephole2): Variable insn points
+	to the first matched insn.  Use peep2_next_insn(1) to refer to
+	the second matched insn.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* fold-const.c (fold_negate_expr_1): Use element_precision.
+	(negate_expr_p): Likewise.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* tree-ssa-pre.c (prune_clobbered_mems): Also prune trapping
+	references when the BB may not return.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* tree-nested.c (get_frame_field): Mark the COMPONENT_REF as
+	volatile in case the variable was.
+
+2021-11-08  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-10-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR tree-optimization/102789
+	* tree-vect-loop-manip.c (vect_update_inits_of_drs): Do not
+	update inits of simd_lane_access.
+
+2021-10-26  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	Backported from master:
+	2021-10-16  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	* configure.ac: Treat powerpc64*-*-freebsd* the same as
+	powerpc64-*-freebsd*.
+	* configure: Regenerate.
+
+2021-10-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Don't use 'G' constraint in integer move patterns.
+
+2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2021-10-21  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/98667
+	* doc/invoke.texi: Document -fcf-protection requires i686 or
+	new.
+
+2021-10-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md: Consistently use "rG" constraint for copy
+	instruction in move patterns.
+
+2021-10-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (cbranchsf4): Disable if TARGET_SOFT_FLOAT.
+	(cbranchdf4): Likewise.
+	Add missing move patterns for TARGET_SOFT_FLOAT.
+
+2021-10-13  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (muldi3): Add support for inlining 64-bit
+	multiplication on 32-bit PA 1.1 and 2.0 targets.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gimple-loop-interchange.cc
+	(tree_loop_interchange::valid_data_dependences): Properly
+	guard all dependence checks with DDR_REVERSED_P or its
+	inverse.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* tree-ssa-pre.c (do_pre_regular_insertion): Avoid inserting
+	copies from abnormals for a full redundancy.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):
+	Only ignore steps when they are equal or scalar order is preserved.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* tree-ssa-dom.c (pass_dominator::execute): Properly
+	mark irreducible regions.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gimple-fold.c (fold_gimple_assign): Only call
+	get_symbol_constant_value on register type symbols.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* tree-ssa-phiopt.c (conditional_replacement): Set neg
+	to false for one bit signed types.
+
+2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	Backported from master:
+	2021-10-11  Diane Meirowitz  <diane.meirowitz@oracle.com>
+
+	* doc/invoke.texi: Add link to UndefinedBehaviorSanitizer
+	documentation, mention UBSAN_OPTIONS, similar to what is done
+	for AddressSanitizer.
+
+2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-09-22  Kewen Lin  <linkw@linux.ibm.com>
+
+	* ipa-fnsummary.c (inline_read_section): Unpack a dummy bit
+	to keep consistent with the side of streaming out.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/102306
+	* combine.c (try_combine): Abort the combination if we are about to
+	duplicate volatile references.
+
+2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/60318
+	* doc/trouble.texi (Copy Assignment): Fix description of
+	behaviour and fix code in example.
+
+2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-31  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* tree.c (walk_tree_1) <OMP_CLAUSE_TILE>: Handle three operands.
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* config/i386/avx512dqintrin.h (_mm512_fpclass_ps_mask): Fix
+	macro define in O0.
+	(_mm512_mask_fpclass_ps_mask): Ditto.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* config/arm/arm-cpus.in (quirk_no_asmcpu): New feature bit.
+	(ALL_QUIRKS): Add it.
+	(generic-armv7-a): Add quirk to suppress writing .cpu directive in
+	asm output.
+	* config/arm/arm.c (arm_identify_fpu_from_isa): New variable.
+	(arm_last_printed_arch_string): Delete.
+	(arm_last-printed_fpu_string): Delete.
+	(arm_configure_build_target): If use of floating-point/SIMD is
+	disabled, remove all fp/simd related features from the target ISA.
+	(last_arm_targ_options): New variable.
+	(arm_print_asm_arch_directives): Add new parameters.  Change order
+	of emitted directives and handle all cases here.
+	(arm_file_start): Always call arm_print_asm_arch_directives, move
+	all generation of .arch/.arch_extension here.
+	(arm_file_end): Call arm_print_asm_arch.
+	(arm_declare_function_name): Call arm_print_asm_arch_directives
+	instead of printing .arch/.fpu directives directly.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Don't call
+	arm_option_reconfigure_globals.
+	(arm_option_restore): Call arm_option_reconfigure_globals after
+	reconfiguring the target.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm.c (arm_configure_build_target): Ensure the target's
+	arch_name is always set.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2019-12-11  Richard Earnshaw  <rearnsha@arm.com>
+
+	* config/arm/arm-cpus.in (ALL_SIMD_EXTERNAL): New fgroup.
+	(ALL_SIMD): Use it.
+	(ALL_FPU_EXTERNAL): New fgroup.
+	(ALL_FP): Use it.
+	(cortex-a55, cortex-a75, cortex-a76): Remove redundant
+	+simd from architecture specification.
+	(neoverse-n1, cortex-a75.cortex-a55): Likewise.
+	* config/arm/arm.c (isa_all_fpubits, fpu_bitlist): Rename to ...
+	(isa_all_fpubits_internal, fpu_bitlist_internal): ... these.
+	(isa_all_fpbits): New bitmap.
+	(arm_option_override): Initialize it.
+	(arm_configure_build_target): If the target isa does not have any
+	FP enabled, do not warn about mismatches in FP-related feature bits.
+
+2021-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-05-27  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/100767
+	* config/arm/arm.c (arm_configure_build_target): Remove parameter
+	opts_set, directly check opts parameters for being non-null.
+	(arm_option_restore): Update call to arm_configure_build_target.
+	(arm_option_override): Likewise.
+	(arm_can_inline_p): Likewise.
+	(arm_valid_target_attribute_tree): Likewise.
+	* config/arm/arm-c.c (arm_pragma_target_parse): Likewise.
+	* config/arm/arm-protos.h (arm_configure_build_target): Adjust
+	prototype.
+
+2021-08-17  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-03  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* doc/invoke.texi: Document -mtune=neoverse-512tvb and
+	-mcpu=neoverse-512tvb.
+	* config/aarch64/aarch64-cores.def (neoverse-512tvb): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+
+2021-07-31  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	Backported from master:
+	2021-07-30  Xi Ruoyao  <xry111@mengyan1223.wang>
+
+	PR target/94780
+	* config/mips/mips.c (mips_atomic_assign_expand_fenv): Use
+	  TARGET_EXPR instead of MODIFY_EXPR.
+
+2021-07-20  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* config/i386/sync.md (define_peephole2 atomic_storedi_fpu):
+	Remove.
+	(define_peephole2 atomic_loaddi_fpu): Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* config/rs6000/rs6000-p8swap.c (has_part_mult): New.
+	(rs6000_analyze_swaps): Insns containing a subreg of a mult are
+	not swappable.
+
+2021-07-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2021-04-18  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/99927
+	* combine.c (distribute_notes) [REG_UNUSED]: If the register already
+	is dead, just drop it.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* config/i386/i386.md (bsr_rex64): Add zero-flag setting RTX.
+	(bsr): Ditto.
+	(*bsrhi): Remove.
+	(clz<mode>2): Update RTX pattern for additions.
+
+2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	Backported from master:
+	2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	PR target/100871
+	* config/s390/vecintrin.h (vec_doublee): Fix to use
+	  __builtin_s390_vflls.
+	(vec_floate): Fix to use __builtin_s390_vflrd.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 75713e9bfba..9c6ac5447f5 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,13 @@
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): For vector types, make
+	the representative array the debug type.
+
+2021-09-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (update_pointer_to): Set TYPE_CANONICAL on
+	pointer and reference types.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index de43c66b77c..0af1c7112ed 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -4646,6 +4646,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
       else
 	gnu_decl = create_type_decl (gnu_entity_name, gnu_type, artificial_p,
 				     debug_info_p, gnat_entity);
+
+      /* For vector types, make the representative array the debug type.  */
+      if (VECTOR_TYPE_P (gnu_type))
+	{
+	  tree rep = TYPE_REPRESENTATIVE_ARRAY (gnu_type);
+	  TYPE_NAME (rep) = DECL_NAME (gnu_decl);
+	  SET_TYPE_DEBUG_TYPE (gnu_type, rep);
+	}
     }
 
   /* Otherwise, for a type reusing an existing DECL, back-annotate values.  */
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
index 882802a19e4..acfb60c3e37 100644
--- a/gcc/ada/gcc-interface/utils.c
+++ b/gcc/ada/gcc-interface/utils.c
@@ -4144,6 +4144,7 @@ update_pointer_to (tree old_type, tree new_type)
 	    TREE_TYPE (t) = new_type;
 	    if (TYPE_NULL_BOUNDS (t))
 	      TREE_TYPE (TREE_OPERAND (TYPE_NULL_BOUNDS (t), 0)) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_POINTER_TO (new_type));
 	  }
 
       /* Chain REF and its variants at the end.  */
@@ -4160,7 +4161,10 @@ update_pointer_to (tree old_type, tree new_type)
       /* Now adjust them.  */
       for (; ref; ref = TYPE_NEXT_REF_TO (ref))
 	for (t = TYPE_MAIN_VARIANT (ref); t; t = TYPE_NEXT_VARIANT (t))
-	  TREE_TYPE (t) = new_type;
+	  {
+	    TREE_TYPE (t) = new_type;
+	    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_REFERENCE_TO (new_type));
+	  }
 
       TYPE_POINTER_TO (old_type) = NULL_TREE;
       TYPE_REFERENCE_TO (old_type) = NULL_TREE;
diff --git a/gcc/combine.c b/gcc/combine.c
index d82161e5161..9fc3c8d5e00 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -3222,6 +3222,16 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
       return 0;
     }
 
+  /* We cannot safely duplicate volatile references in any case.  */
+
+  if ((added_sets_2 && volatile_refs_p (PATTERN (i2)))
+      || (added_sets_1 && volatile_refs_p (PATTERN (i1)))
+      || (added_sets_0 && volatile_refs_p (PATTERN (i0))))
+    {
+      undo_all ();
+      return 0;
+    }
+
   /* Count how many auto_inc expressions there were in the original insns;
      we need to have the same number in the resulting patterns.  */
 
@@ -14392,6 +14402,11 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,
 	     we keep notes from i2 or i1 if they will turn into REG_DEAD
 	     notes.  */
 
+	  /* If this register is set or clobbered between FROM_INSN and I3,
+	     we should not create a note for it.  */
+	  if (reg_set_between_p (XEXP (note, 0), from_insn, i3))
+	    break;
+
 	  /* If this register is set or clobbered in I3, put the note there
 	     unless there is one already.  */
 	  if (reg_set_p (XEXP (note, 0), PATTERN (i3)))
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 3cd7db88b77..fb2faa44e06 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -115,7 +115,7 @@ AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_
 /* ARM ('A') cores. */
 AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
 AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
-
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
 AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 0a73e105e08..e4ae7d9b16b 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,a64fx,tsv110,zeus,neoversev1,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
+	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,a64fx,tsv110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/arm_acle.h b/gcc/config/aarch64/arm_acle.h
index 56147352c23..8c622a3985b 100644
--- a/gcc/config/aarch64/arm_acle.h
+++ b/gcc/config/aarch64/arm_acle.h
@@ -98,10 +98,6 @@ __rint64x (double __a)
 
 #pragma GCC target ("+nothing+crc")
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
 {
diff --git a/gcc/config/arm/arm-c.c b/gcc/config/arm/arm-c.c
index 6e256ee0a12..8cb08646ce5 100644
--- a/gcc/config/arm/arm-c.c
+++ b/gcc/config/arm/arm-c.c
@@ -266,8 +266,8 @@ arm_pragma_target_parse (tree args, tree pop_target)
        target_option_current_node, but not handle_pragma_target.  */
       target_option_current_node = cur_tree;
       arm_configure_build_target (&arm_active_target,
-				  TREE_TARGET_OPTION (cur_tree),
-				  &global_options_set, false);
+				  TREE_TARGET_OPTION (cur_tree), false);
+      arm_option_reconfigure_globals ();
     }
 
   /* Update macros if target_node changes. The global state will be restored
diff --git a/gcc/config/arm/arm-cpus.in b/gcc/config/arm/arm-cpus.in
index f87044fd25c..de2caec5497 100644
--- a/gcc/config/arm/arm-cpus.in
+++ b/gcc/config/arm/arm-cpus.in
@@ -180,6 +180,9 @@ define feature quirk_armv6kz
 # Cortex-M3 LDRD quirk.
 define feature quirk_cm3_ldrd
 
+# Don't use .cpu assembly directive
+define feature quirk_no_asmcpu
+
 # (Very) slow multiply operations.  Should probably be a tuning bit.
 define feature smallmul
 
@@ -213,15 +216,18 @@ define fgroup ALL_CRYPTO	crypto
 # strip off 32 D-registers, but does not remove support for
 # double-precision FP.
 define fgroup ALL_SIMD_INTERNAL	fp_d32 neon ALL_CRYPTO
-define fgroup ALL_SIMD	ALL_SIMD_INTERNAL dotprod fp16fml
+define fgroup ALL_SIMD_EXTERNAL dotprod fp16fml
+define fgroup ALL_SIMD	ALL_SIMD_INTERNAL ALL_SIMD_EXTERNAL
 
 # List of all FPU bits to strip out if -mfpu is used to override the
 # default.  fp16 is deliberately missing from this list.
 define fgroup ALL_FPU_INTERNAL	vfpv2 vfpv3 vfpv4 fpv5 fp16conv fp_dbl ALL_SIMD_INTERNAL
-
 # Similarly, but including fp16 and other extensions that aren't part of
 # -mfpu support.
-define fgroup ALL_FP	fp16 ALL_FPU_INTERNAL
+define fgroup ALL_FPU_EXTERNAL fp16
+
+# Everything related to the FPU extensions (FP or SIMD).
+define fgroup ALL_FP	ALL_FPU_EXTERNAL ALL_FPU_INTERNAL ALL_SIMD
 
 define fgroup ARMv4       armv4 notm
 define fgroup ARMv4t      ARMv4 thumb
@@ -274,7 +280,7 @@ define fgroup DOTPROD	NEON dotprod
 # architectures.
 # xscale isn't really a 'quirk', but it isn't an architecture either and we
 # need to ignore it for matching purposes.
-define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd xscale
+define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd xscale quirk_no_asmcpu
 
 # Architecture entries
 # format:
@@ -976,6 +982,7 @@ begin cpu generic-armv7-a
  cname genericv7a
  tune flags LDSCHED
  architecture armv7-a+fp
+ isa quirk_no_asmcpu
  option mp add mp
  option sec add sec
  option vfpv3-d16 add VFPv3 FP_DBL
@@ -1301,7 +1308,7 @@ begin cpu cortex-a55
  cname cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  option nofp remove ALL_FP
  costs cortex_a53
@@ -1313,7 +1320,7 @@ begin cpu cortex-a75
  cname cortexa75
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a73
  vendor 41
@@ -1324,7 +1331,7 @@ begin cpu cortex-a76
  cname cortexa76
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
  vendor 41
@@ -1336,7 +1343,7 @@ begin cpu neoverse-n1
  alias !ares
  tune for cortex-a57
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
  vendor 41
@@ -1348,7 +1355,7 @@ begin cpu cortex-a75.cortex-a55
  cname cortexa75cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a73
 end cpu cortex-a75.cortex-a55
@@ -1357,7 +1364,7 @@ begin cpu cortex-a76.cortex-a55
  cname cortexa76cortexa55
  tune for cortex-a53
  tune flags LDSCHED
- architecture armv8.2-a+fp16+dotprod+simd
+ architecture armv8.2-a+fp16+dotprod
  option crypto add FP_ARMv8 CRYPTO
  costs cortex_a57
 end cpu cortex-a76.cortex-a55
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 3e8bba5caea..cd16c3c35f9 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -229,8 +229,7 @@ extern bool arm_change_mode_p (tree);
 extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,
 					     struct gcc_options *);
 extern void arm_configure_build_target (struct arm_build_target *,
-					struct cl_target_option *,
-					struct gcc_options *, bool);
+					struct cl_target_option *, bool);
 extern void arm_option_reconfigure_globals (void);
 extern void arm_options_perform_arch_sanity_checks (void);
 extern void arm_pr_long_calls (struct cpp_reader *);
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 4679da75dd8..58afc4a2647 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -78,10 +78,6 @@
 typedef struct minipool_node    Mnode;
 typedef struct minipool_fixup   Mfix;
 
-/* The last .arch and .fpu assembly strings that we printed.  */
-static std::string arm_last_printed_arch_string;
-static std::string arm_last_printed_fpu_string;
-
 void (*arm_lang_output_object_attributes_hook)(void);
 
 struct four_ints
@@ -325,6 +321,7 @@ static unsigned int arm_hard_regno_nregs (unsigned int, machine_mode);
 static bool arm_hard_regno_mode_ok (unsigned int, machine_mode);
 static bool arm_modes_tieable_p (machine_mode, machine_mode);
 static HOST_WIDE_INT arm_constant_alignment (const_tree, HOST_WIDE_INT);
+static const char *arm_identify_fpu_from_isa (sbitmap);
 
 /* Table of machine attributes.  */
 static const struct attribute_spec arm_attribute_table[] =
@@ -2985,7 +2982,7 @@ arm_override_options_after_change (void)
 {
   arm_configure_build_target (&arm_active_target,
 			      TREE_TARGET_OPTION (target_option_default_node),
-			      &global_options_set, false);
+			      false);
 
   arm_override_options_after_change_1 (&global_options);
 }
@@ -3006,8 +3003,8 @@ arm_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)
   opts->x_arm_arch_string = ptr->x_arm_arch_string;
   opts->x_arm_cpu_string = ptr->x_arm_cpu_string;
   opts->x_arm_tune_string = ptr->x_arm_tune_string;
-  arm_configure_build_target (&arm_active_target, ptr, &global_options_set,
-			      false);
+  arm_configure_build_target (&arm_active_target, ptr, false);
+  arm_option_reconfigure_globals ();
 }
 
 /* Reset options between modes that the user has specified.  */
@@ -3115,7 +3112,8 @@ arm_option_override_internal (struct gcc_options *opts,
 #endif
 }
 
-static sbitmap isa_all_fpubits;
+static sbitmap isa_all_fpubits_internal;
+static sbitmap isa_all_fpbits;
 static sbitmap isa_quirkbits;
 
 /* Configure a build target TARGET from the user-specified options OPTS and
@@ -3124,7 +3122,6 @@ static sbitmap isa_quirkbits;
 void
 arm_configure_build_target (struct arm_build_target *target,
 			    struct cl_target_option *opts,
-			    struct gcc_options *opts_set,
 			    bool warn_compatible)
 {
   const cpu_option *arm_selected_tune = NULL;
@@ -3139,7 +3136,7 @@ arm_configure_build_target (struct arm_build_target *target,
   target->core_name = NULL;
   target->arch_name = NULL;
 
-  if (opts_set->x_arm_arch_string)
+  if (opts->x_arm_arch_string)
     {
       arm_selected_arch = arm_parse_arch_option_name (all_architectures,
 						      "-march",
@@ -3147,7 +3144,7 @@ arm_configure_build_target (struct arm_build_target *target,
       arch_opts = strchr (opts->x_arm_arch_string, '+');
     }
 
-  if (opts_set->x_arm_cpu_string)
+  if (opts->x_arm_cpu_string)
     {
       arm_selected_cpu = arm_parse_cpu_option_name (all_cores, "-mcpu",
 						    opts->x_arm_cpu_string);
@@ -3157,7 +3154,7 @@ arm_configure_build_target (struct arm_build_target *target,
 	 options for tuning.  */
     }
 
-  if (opts_set->x_arm_tune_string)
+  if (opts->x_arm_tune_string)
     {
       arm_selected_tune = arm_parse_cpu_option_name (all_cores, "-mtune",
 						     opts->x_arm_tune_string);
@@ -3182,7 +3179,12 @@ arm_configure_build_target (struct arm_build_target *target,
 	  /* Ignore any bits that are quirk bits.  */
 	  bitmap_and_compl (isa_delta, isa_delta, isa_quirkbits);
 	  /* Ignore (for now) any bits that might be set by -mfpu.  */
-	  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits);
+	  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits_internal);
+
+	  /* And if the target ISA lacks floating point, ignore any
+	     extensions that depend on that.  */
+	  if (!bitmap_bit_p (target->isa, isa_bit_vfpv2))
+	    bitmap_and_compl (isa_delta, isa_delta, isa_all_fpbits);
 
 	  if (!bitmap_empty_p (isa_delta))
 	    {
@@ -3341,10 +3343,15 @@ arm_configure_build_target (struct arm_build_target *target,
       auto_sbitmap fpu_bits (isa_num_bits);
 
       arm_initialize_isa (fpu_bits, arm_selected_fpu->isa_bits);
-      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits);
+      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits_internal);
       bitmap_ior (target->isa, target->isa, fpu_bits);
     }
 
+  /* If we have the soft-float ABI, clear any feature bits relating to use of
+     floating-point operations.  They'll just confuse things later on.  */
+  if (arm_float_abi == ARM_FLOAT_ABI_SOFT)
+    bitmap_and_compl (target->isa, target->isa, isa_all_fpbits);
+
   if (!arm_selected_tune)
     arm_selected_tune = arm_selected_cpu;
   else /* Validate the features passed to -mtune.  */
@@ -3353,6 +3360,8 @@ arm_configure_build_target (struct arm_build_target *target,
   const cpu_tune *tune_data = &all_tunes[arm_selected_tune - all_cores];
 
   /* Finish initializing the target structure.  */
+  if (!target->arch_name)
+    target->arch_name = arm_selected_arch->common.name;
   target->arch_pp_name = arm_selected_arch->arch;
   target->base_arch = arm_selected_arch->base_arch;
   target->profile = arm_selected_arch->profile;
@@ -3360,23 +3369,26 @@ arm_configure_build_target (struct arm_build_target *target,
   target->tune_flags = tune_data->tune_flags;
   target->tune = tune_data->tune;
   target->tune_core = tune_data->scheduler;
-  arm_option_reconfigure_globals ();
 }
 
 /* Fix up any incompatible options that the user has specified.  */
 static void
 arm_option_override (void)
 {
-  static const enum isa_feature fpu_bitlist[]
+  static const enum isa_feature fpu_bitlist_internal[]
     = { ISA_ALL_FPU_INTERNAL, isa_nobit };
+  static const enum isa_feature fp_bitlist[]
+    = { ISA_ALL_FP, isa_nobit };
   static const enum isa_feature quirk_bitlist[] = { ISA_ALL_QUIRKS, isa_nobit};
   cl_target_option opts;
 
   isa_quirkbits = sbitmap_alloc (isa_num_bits);
   arm_initialize_isa (isa_quirkbits, quirk_bitlist);
 
-  isa_all_fpubits = sbitmap_alloc (isa_num_bits);
-  arm_initialize_isa (isa_all_fpubits, fpu_bitlist);
+  isa_all_fpubits_internal = sbitmap_alloc (isa_num_bits);
+  isa_all_fpbits = sbitmap_alloc (isa_num_bits);
+  arm_initialize_isa (isa_all_fpubits_internal, fpu_bitlist_internal);
+  arm_initialize_isa (isa_all_fpbits, fp_bitlist);
 
   arm_active_target.isa = sbitmap_alloc (isa_num_bits);
 
@@ -3392,8 +3404,7 @@ arm_option_override (void)
     }
 
   cl_target_option_save (&opts, &global_options);
-  arm_configure_build_target (&arm_active_target, &opts, &global_options_set,
-			      true);
+  arm_configure_build_target (&arm_active_target, &opts, true);
 
 #ifdef SUBTARGET_OVERRIDE_OPTIONS
   SUBTARGET_OVERRIDE_OPTIONS;
@@ -26654,20 +26665,65 @@ arm_print_tune_info (void)
 	       (int) current_tune->sched_autopref);
 }
 
+/* The last set of target options used to emit .arch directives, etc.  This
+   could be a function-local static if it were not required to expose it as a
+   root to the garbage collector.  */
+static GTY(()) cl_target_option *last_asm_targ_options = NULL;
+
 /* Print .arch and .arch_extension directives corresponding to the
    current architecture configuration.  */
 static void
-arm_print_asm_arch_directives ()
+arm_print_asm_arch_directives (FILE *stream, cl_target_option *targ_options)
 {
+  arm_build_target build_target;
+  /* If the target options haven't changed since the last time we were called
+     there is nothing to do.  This should be sufficient to suppress the
+     majority of redundant work.  */
+  if (last_asm_targ_options == targ_options)
+    return;
+
+  last_asm_targ_options = targ_options;
+
+  build_target.isa = sbitmap_alloc (isa_num_bits);
+  arm_configure_build_target (&build_target, targ_options, false);
+
+  if (build_target.core_name
+      && !bitmap_bit_p (build_target.isa, isa_bit_quirk_no_asmcpu))
+    {
+      const char* truncated_name
+	= arm_rewrite_selected_cpu (build_target.core_name);
+      asm_fprintf (stream, "\t.cpu %s\n", truncated_name);
+    }
+
   const arch_option *arch
     = arm_parse_arch_option_name (all_architectures, "-march",
-				  arm_active_target.arch_name);
+				  build_target.arch_name);
   auto_sbitmap opt_bits (isa_num_bits);
 
   gcc_assert (arch);
 
-  asm_fprintf (asm_out_file, "\t.arch %s\n", arm_active_target.arch_name);
-  arm_last_printed_arch_string = arm_active_target.arch_name;
+  if (strcmp (build_target.arch_name, "armv7ve") == 0)
+    {
+      /* Keep backward compatability for assemblers which don't support
+	 armv7ve.  Fortunately, none of the following extensions are reset
+	 by a .fpu directive.  */
+      asm_fprintf (stream, "\t.arch armv7-a\n");
+      asm_fprintf (stream, "\t.arch_extension virt\n");
+      asm_fprintf (stream, "\t.arch_extension idiv\n");
+      asm_fprintf (stream, "\t.arch_extension sec\n");
+      asm_fprintf (stream, "\t.arch_extension mp\n");
+    }
+  else
+    asm_fprintf (stream, "\t.arch %s\n", build_target.arch_name);
+
+  /* The .fpu directive will reset any architecture extensions from the
+     assembler that relate to the fp/vector extensions.  So put this out before
+     any .arch_extension directives.  */
+  const char *fpu_name = (TARGET_SOFT_FLOAT
+			  ? "softvfp"
+			  : arm_identify_fpu_from_isa (build_target.isa));
+  asm_fprintf (stream, "\t.fpu %s\n", fpu_name);
+
   if (!arch->common.extensions)
     return;
 
@@ -26679,13 +26735,12 @@ arm_print_asm_arch_directives ()
 	{
 	  arm_initialize_isa (opt_bits, opt->isa_bits);
 
-	  /* If every feature bit of this option is set in the target
-	     ISA specification, print out the option name.  However,
-	     don't print anything if all the bits are part of the
-	     FPU specification.  */
-	  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
-	      && !bitmap_subset_p (opt_bits, isa_all_fpubits))
-	    asm_fprintf (asm_out_file, "\t.arch_extension %s\n", opt->name);
+	  /* If every feature bit of this option is set in the target ISA
+	     specification, print out the option name.  However, don't print
+	     anything if all the bits are part of the FPU specification.  */
+	  if (bitmap_subset_p (opt_bits, build_target.isa)
+	      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))
+	    asm_fprintf (stream, "\t.arch_extension %s\n", opt->name);
 	}
     }
 }
@@ -26695,42 +26750,23 @@ arm_file_start (void)
 {
   int val;
 
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (TARGET_BPABI)
     {
-      /* We don't have a specified CPU.  Use the architecture to
-	 generate the tags.
-
-	 Note: it might be better to do this unconditionally, then the
-	 assembler would not need to know about all new CPU names as
-	 they are added.  */
-      if (!arm_active_target.core_name)
-	{
-	  /* armv7ve doesn't support any extensions.  */
-	  if (strcmp (arm_active_target.arch_name, "armv7ve") == 0)
-	    {
-	      /* Keep backward compatability for assemblers
-		 which don't support armv7ve.  */
-	      asm_fprintf (asm_out_file, "\t.arch armv7-a\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension virt\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension idiv\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension sec\n");
-	      asm_fprintf (asm_out_file, "\t.arch_extension mp\n");
-	      arm_last_printed_arch_string = "armv7ve";
-	    }
-	  else
-	    arm_print_asm_arch_directives ();
-	}
-      else if (strncmp (arm_active_target.core_name, "generic", 7) == 0)
-	{
-	  asm_fprintf (asm_out_file, "\t.arch %s\n",
-		       arm_active_target.core_name + 8);
-	  arm_last_printed_arch_string = arm_active_target.core_name + 8;
-	}
-      else
+      /* If we have a named cpu, but we the assembler does not support that
+	 name via .cpu, put out a cpu name attribute; but don't do this if the
+	 name starts with the fictitious prefix, 'generic'.  */
+      if (arm_active_target.core_name
+	  && bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu)
+	  && strncmp (arm_active_target.core_name, "generic", 7) != 0)
 	{
 	  const char* truncated_name
 	    = arm_rewrite_selected_cpu (arm_active_target.core_name);
-	  asm_fprintf (asm_out_file, "\t.cpu %s\n", truncated_name);
+	  if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_asmcpu))
+	    asm_fprintf (asm_out_file, "\t.eabi_attribute 5, \"%s\"\n",
+			 truncated_name);
 	}
 
       if (print_tune_info)
@@ -26798,6 +26834,13 @@ arm_file_end (void)
 {
   int regno;
 
+  /* Just in case the last function output in the assembler had non-default
+     architecture directives, we force the assembler state back to the default
+     set, so that any 'calculated' build attributes are based on the default
+     options rather than the special options for that function.  */
+  arm_print_asm_arch_directives
+    (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));
+
   if (NEED_INDICATE_EXEC_STACK)
     /* Add .note.GNU-stack.  */
     file_end_indicate_exec_stack ();
@@ -30938,10 +30981,8 @@ arm_can_inline_p (tree caller, tree callee)
   caller_target.isa = sbitmap_alloc (isa_num_bits);
   callee_target.isa = sbitmap_alloc (isa_num_bits);
 
-  arm_configure_build_target (&caller_target, caller_opts, &global_options_set,
-			      false);
-  arm_configure_build_target (&callee_target, callee_opts, &global_options_set,
-			      false);
+  arm_configure_build_target (&caller_target, caller_opts, false);
+  arm_configure_build_target (&callee_target, callee_opts, false);
   if (!bitmap_subset_p (callee_target.isa, caller_target.isa))
     can_inline = false;
 
@@ -31073,7 +31114,7 @@ arm_valid_target_attribute_tree (tree args, struct gcc_options *opts,
     return NULL_TREE;
 
   cl_target_option_save (&cl_opts, opts);
-  arm_configure_build_target (&arm_active_target, &cl_opts, opts_set, false);
+  arm_configure_build_target (&arm_active_target, &cl_opts, false);
   arm_option_check_internal (opts);
   /* Do any overrides, such as global options arch=xxx.
      We do this since arm_active_target was overridden.  */
@@ -31188,7 +31229,7 @@ arm_identify_fpu_from_isa (sbitmap isa)
   auto_sbitmap fpubits (isa_num_bits);
   auto_sbitmap cand_fpubits (isa_num_bits);
 
-  bitmap_and (fpubits, isa, isa_all_fpubits);
+  bitmap_and (fpubits, isa, isa_all_fpubits_internal);
 
   /* If there are no ISA feature bits relating to the FPU, we must be
      doing soft-float.  */
@@ -31219,44 +31260,7 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
     targ_options = TREE_TARGET_OPTION (target_option_current_node);
   gcc_assert (targ_options);
 
-  /* Only update the assembler .arch string if it is distinct from the last
-     such string we printed. arch_to_print is set conditionally in case
-     targ_options->x_arm_arch_string is NULL which can be the case
-     when cc1 is invoked directly without passing -march option.  */
-  std::string arch_to_print;
-  if (targ_options->x_arm_arch_string)
-    arch_to_print = targ_options->x_arm_arch_string;
-
-  if (arch_to_print != arm_last_printed_arch_string)
-    {
-      std::string arch_name
-	= arch_to_print.substr (0, arch_to_print.find ("+"));
-      asm_fprintf (asm_out_file, "\t.arch %s\n", arch_name.c_str ());
-      const arch_option *arch
-	= arm_parse_arch_option_name (all_architectures, "-march",
-				      targ_options->x_arm_arch_string);
-      auto_sbitmap opt_bits (isa_num_bits);
-
-      gcc_assert (arch);
-      if (arch->common.extensions)
-	{
-	  for (const struct cpu_arch_extension *opt = arch->common.extensions;
-	       opt->name != NULL;
-	       opt++)
-	    {
-	      if (!opt->remove)
-		{
-		  arm_initialize_isa (opt_bits, opt->isa_bits);
-		  if (bitmap_subset_p (opt_bits, arm_active_target.isa)
-		      && !bitmap_subset_p (opt_bits, isa_all_fpubits))
-		    asm_fprintf (asm_out_file, "\t.arch_extension %s\n",
-				 opt->name);
-		}
-	     }
-	}
-
-      arm_last_printed_arch_string = arch_to_print;
-    }
+  arm_print_asm_arch_directives (stream, targ_options);
 
   fprintf (stream, "\t.syntax unified\n");
 
@@ -31274,16 +31278,6 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)
   else
     fprintf (stream, "\t.arm\n");
 
-  std::string fpu_to_print
-    = TARGET_SOFT_FLOAT
-	? "softvfp" : arm_identify_fpu_from_isa (arm_active_target.isa);
-
-  if (fpu_to_print != arm_last_printed_arch_string)
-    {
-      asm_fprintf (asm_out_file, "\t.fpu %s\n", fpu_to_print.c_str ());
-      arm_last_printed_fpu_string = fpu_to_print;
-    }
-
   if (TARGET_POKE_FUNCTION_NAME)
     arm_poke_function_name (stream, (const char *) name);
 }
@@ -31934,28 +31928,28 @@ arm_test_cpu_arch_data (void)
 static void
 arm_test_fpu_data (void)
 {
-  auto_sbitmap isa_all_fpubits (isa_num_bits);
+  auto_sbitmap isa_all_fpubits_internal (isa_num_bits);
   auto_sbitmap fpubits (isa_num_bits);
   auto_sbitmap tmpset (isa_num_bits);
 
-  static const enum isa_feature fpu_bitlist[]
+  static const enum isa_feature fpu_bitlist_internal[]
     = { ISA_ALL_FPU_INTERNAL, isa_nobit };
-  arm_initialize_isa (isa_all_fpubits, fpu_bitlist);
+  arm_initialize_isa (isa_all_fpubits_internal, fpu_bitlist_internal);
 
   for (unsigned int i = 0; i < TARGET_FPU_auto; i++)
   {
     arm_initialize_isa (fpubits, all_fpus[i].isa_bits);
-    bitmap_and_compl (tmpset, isa_all_fpubits, fpubits);
-    bitmap_clear (isa_all_fpubits);
-    bitmap_copy (isa_all_fpubits, tmpset);
+    bitmap_and_compl (tmpset, isa_all_fpubits_internal, fpubits);
+    bitmap_clear (isa_all_fpubits_internal);
+    bitmap_copy (isa_all_fpubits_internal, tmpset);
   }
 
-  if (!bitmap_empty_p (isa_all_fpubits))
+  if (!bitmap_empty_p (isa_all_fpubits_internal))
     {
 	fprintf (stderr, "Error: found feature bits in the ALL_FPU_INTERAL"
 			 " group that are not defined by any FPU.\n"
 			 "       Check your arm-cpus.in.\n");
-	ASSERT_TRUE (bitmap_empty_p (isa_all_fpubits));
+	ASSERT_TRUE (bitmap_empty_p (isa_all_fpubits_internal));
     }
 }
 
diff --git a/gcc/config/i386/avx512dqintrin.h b/gcc/config/i386/avx512dqintrin.h
index f0c18fb45fb..c080c2041fa 100644
--- a/gcc/config/i386/avx512dqintrin.h
+++ b/gcc/config/i386/avx512dqintrin.h
@@ -2629,7 +2629,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_mask_fpclass_ps_mask(u, x, c)				\
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)(u)))
+						 (int) (c),(__mmask16)(u)))
 
 #define _mm512_fpclass_pd_mask(X, C)                                    \
   ((__mmask8) __builtin_ia32_fpclasspd512_mask ((__v8df) (__m512d) (X), \
@@ -2637,7 +2637,7 @@ _mm512_fpclass_ps_mask (__m512 __A, const int __imm)
 
 #define _mm512_fpclass_ps_mask(x, c)                                    \
   ((__mmask16) __builtin_ia32_fpclassps512_mask ((__v16sf) (__m512) (x),\
-						 (int) (c),(__mmask8)-1))
+						 (int) (c),(__mmask16)-1))
 
 #define _mm_reduce_sd(A, B, C)						\
   ((__m128d) __builtin_ia32_reducesd_mask ((__v2df)(__m128d)(A),	\
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 8ae7ea68c16..5d76d36e1c0 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -13451,10 +13451,12 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "bsr_rex64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:DI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:DI 0 "register_operand" "=r")
 	(minus:DI (const_int 63)
-		  (clz:DI (match_operand:DI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:DI (match_dup 1))))]
   "TARGET_64BIT"
   "bsr{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13463,10 +13465,12 @@
    (set_attr "mode" "DI")])
 
 (define_insn "bsr"
-  [(set (match_operand:SI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
 	(minus:SI (const_int 31)
-		  (clz:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:SI (match_dup 1))))]
   ""
   "bsr{l}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13474,25 +13478,15 @@
    (set_attr "znver1_decode" "vector")
    (set_attr "mode" "SI")])
 
-(define_insn "*bsrhi"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(minus:HI (const_int 15)
-		  (clz:HI (match_operand:HI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
-  ""
-  "bsr{w}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")
-   (set_attr "prefix_0f" "1")
-   (set_attr "znver1_decode" "vector")
-   (set_attr "mode" "HI")])
-
 (define_expand "clz<mode>2"
   [(parallel
-     [(set (match_operand:SWI48 0 "register_operand")
+     [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SWI48 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+      (set (match_operand:SWI48 0 "register_operand")
 	   (minus:SWI48
 	     (match_dup 2)
-	     (clz:SWI48 (match_operand:SWI48 1 "nonimmediate_operand"))))
-      (clobber (reg:CC FLAGS_REG))])
+	     (clz:SWI48 (match_dup 1))))])
    (parallel
      [(set (match_dup 0) (xor:SWI48 (match_dup 0) (match_dup 2)))
       (clobber (reg:CC FLAGS_REG))])]
diff --git a/gcc/config/i386/sync.md b/gcc/config/i386/sync.md
index 08149006876..bbf91c46c4d 100644
--- a/gcc/config/i386/sync.md
+++ b/gcc/config/i386/sync.md
@@ -212,82 +212,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))
-   (set (match_dup 4) (match_dup 3))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_FIST_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_move_insn (operands[4], operands[3]);
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(set (match_dup 3) (match_dup 5))
-   (set (match_dup 4) (match_dup 3))]
-  "operands[5] = gen_lowpart (DFmode, operands[1]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 1 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 2 "memory_operand")
-	(unspec:DI [(match_dup 0)]
-		   UNSPEC_STX_ATOMIC))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 3 "sse_reg_operand")
-	(match_operand:DF 4 "memory_operand"))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (2, operands[0])
-   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));
-  emit_move_insn (operands[4], operands[3]);
-  emit_insn (gen_memory_blockage ());
-  DONE;
-})
-
 (define_expand "atomic_store<mode>"
   [(set (match_operand:ATOMIC 0 "memory_operand")
 	(unspec:ATOMIC [(match_operand:ATOMIC 1 "nonimmediate_operand")
@@ -375,82 +299,6 @@
   DONE;
 })
 
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 0) (match_dup 1))
-   (set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "fp_register_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_FILD_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_FIST_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[0], operands[1]);
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (3, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(set (match_dup 0) (match_dup 1))
-   (set (match_dup 5) (match_dup 1))]
-  "operands[5] = gen_lowpart (DFmode, operands[4]);")
-
-(define_peephole2
-  [(set (match_operand:DF 0 "memory_operand")
-	(match_operand:DF 1 "any_fp_register_operand"))
-   (set (mem:BLK (scratch:SI))
-	(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))
-   (set (match_operand:DF 2 "sse_reg_operand")
-	(unspec:DF [(match_operand:DI 3 "memory_operand")]
-		   UNSPEC_LDX_ATOMIC))
-   (set (match_operand:DI 4 "memory_operand")
-	(unspec:DI [(match_dup 2)]
-		   UNSPEC_STX_ATOMIC))]
-  "!TARGET_64BIT
-   && peep2_reg_dead_p (4, operands[2])
-   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))"
-  [(const_int 0)]
-{
-  emit_move_insn (operands[0], operands[1]);
-  emit_insn (gen_memory_blockage ());
-  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);
-  DONE;
-})
-
 ;; ??? You'd think that we'd be able to perform this via FLOAT + FIX_TRUNC
 ;; operations.  But the fix_trunc patterns want way more setup than we want
 ;; to provide.  Note that the scratch is DFmode instead of XFmode in order
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index d758fbf1be6..1e3ea6b5f43 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -22370,12 +22370,12 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   tree get_fcsr = mips_builtin_decls[MIPS_GET_FCSR];
   tree set_fcsr = mips_builtin_decls[MIPS_SET_FCSR];
   tree get_fcsr_hold_call = build_call_expr (get_fcsr, 0);
-  tree hold_assign_orig = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				  fcsr_orig_var, get_fcsr_hold_call);
+  tree hold_assign_orig = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				  fcsr_orig_var, get_fcsr_hold_call, NULL, NULL);
   tree hold_mod_val = build2 (BIT_AND_EXPR, MIPS_ATYPE_USI, fcsr_orig_var,
 			      build_int_cst (MIPS_ATYPE_USI, 0xfffff003));
-  tree hold_assign_mod = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-				 fcsr_mod_var, hold_mod_val);
+  tree hold_assign_mod = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+				 fcsr_mod_var, hold_mod_val, NULL, NULL);
   tree set_fcsr_hold_call = build_call_expr (set_fcsr, 1, fcsr_mod_var);
   tree hold_all = build2 (COMPOUND_EXPR, MIPS_ATYPE_USI,
 			  hold_assign_orig, hold_assign_mod);
@@ -22385,8 +22385,8 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   *clear = build_call_expr (set_fcsr, 1, fcsr_mod_var);
 
   tree get_fcsr_update_call = build_call_expr (get_fcsr, 0);
-  *update = build2 (MODIFY_EXPR, MIPS_ATYPE_USI,
-		    exceptions_var, get_fcsr_update_call);
+  *update = build4 (TARGET_EXPR, MIPS_ATYPE_USI,
+		    exceptions_var, get_fcsr_update_call, NULL, NULL);
   tree set_fcsr_update_call = build_call_expr (set_fcsr, 1, fcsr_orig_var);
   *update = build2 (COMPOUND_EXPR, void_type_node, *update,
 		    set_fcsr_update_call);
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 18f8e127d3d..e0ed18c73fc 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -1383,7 +1383,7 @@
                         (match_operand:SF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -1398,7 +1398,7 @@
                         (match_operand:DF 2 "reg_or_0_operand" "")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
-  ""
+  "! TARGET_SOFT_FLOAT"
   "
 {
   pa_emit_bcond_fp (operands);
@@ -2236,6 +2236,29 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:SI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], SImode)
+    || reg_or_0_operand (operands[1], SImode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   ldw RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   {zdepi|depwi,z} %Z1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SI 0 "indexed_memory_operand" "=R")
 	(match_operand:SI 1 "register_operand" "f"))]
@@ -4024,12 +4047,12 @@
   [(set (match_operand:DF 0 "move_dest_operand"
 			  "=!*r,*r,*r,*r,*r,Q,f,f,T")
 	(match_operand:DF 1 "move_src_operand"
-			  "!*r,J,N,K,RQ,*rG,fG,RT,f"))]
+			  "!*rG,J,N,K,RQ,*rG,fG,RT,f"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !TARGET_SOFT_FLOAT && TARGET_64BIT"
   "@
-   copy %1,%0
+   copy %r1,%0
    ldi %1,%0
    ldil L'%1,%0
    depdi,z %z1,%0
@@ -4042,6 +4065,25 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "move_dest_operand"
+			  "=!*r,*r,*r,*r,*r,Q")
+	(match_operand:DF 1 "move_src_operand"
+			  "!*rG,J,N,K,RQ,*rG"))]
+  "(register_operand (operands[0], DFmode)
+    || reg_or_0_operand (operands[1], DFmode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0"
+  [(set_attr "type" "move,move,move,shift,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4")])
+
 
 (define_expand "movdi"
   [(set (match_operand:DI 0 "general_operand" "")
@@ -4200,6 +4242,28 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4,4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:DI 0 "move_dest_operand"
+			  "=r,r,r,r,r,r,Q,!*q,!r")
+	(match_operand:DI 1 "move_src_operand"
+			  "A,r,J,N,K,RQ,rM,!rM,!*q"))]
+  "(register_operand (operands[0], DImode)
+    || reg_or_0_operand (operands[1], DImode))
+   && TARGET_SOFT_FLOAT && TARGET_64BIT"
+  "@
+   ldd RT'%A1,%0
+   copy %1,%0
+   ldi %1,%0
+   ldil L'%1,%0
+   depdi,z %z1,%0
+   ldd%M1 %1,%0
+   std%M0 %r1,%0
+   mtsar %r1
+   {mfctl|mfctl,w} %%sar,%0"
+  [(set_attr "type" "load,move,move,move,shift,load,store,move,move")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4,4,4,4,4,4,4")])
+
 (define_insn ""
   [(set (match_operand:DI 0 "indexed_memory_operand" "=R")
 	(match_operand:DI 1 "register_operand" "f"))]
@@ -4405,6 +4469,23 @@
    (set_attr "pa_combine_type" "addmove")
    (set_attr "length" "4,4,4,4,4,4")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "move_dest_operand"
+			  "=!*r,*r,Q")
+	(match_operand:SF 1 "reg_or_0_or_nonsymb_mem_operand"
+			  "!*rG,RQ,*rG"))]
+  "(register_operand (operands[0], SFmode)
+    || reg_or_0_operand (operands[1], SFmode))
+   && TARGET_SOFT_FLOAT
+   && TARGET_64BIT"
+  "@
+   copy %r1,%0
+   ldw%M1 %1,%0
+   stw%M0 %r1,%0"
+  [(set_attr "type" "move,load,store")
+   (set_attr "pa_combine_type" "addmove")
+   (set_attr "length" "4,4,4")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "indexed_memory_operand" "=R")
 	(match_operand:SF 1 "register_operand" "f"))]
@@ -5374,32 +5455,38 @@
   [(set (match_operand:DI 0 "register_operand" "")
         (mult:DI (match_operand:DI 1 "register_operand" "")
 		 (match_operand:DI 2 "register_operand" "")))]
-  "TARGET_64BIT && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
+  "! optimize_size
+   && TARGET_PA_11
+   && ! TARGET_DISABLE_FPREGS
+   && ! TARGET_SOFT_FLOAT"
   "
 {
   rtx low_product = gen_reg_rtx (DImode);
   rtx cross_product1 = gen_reg_rtx (DImode);
   rtx cross_product2 = gen_reg_rtx (DImode);
-  rtx cross_scratch = gen_reg_rtx (DImode);
-  rtx cross_product = gen_reg_rtx (DImode);
   rtx op1l, op1r, op2l, op2r;
-  rtx op1shifted, op2shifted;
-
-  op1shifted = gen_reg_rtx (DImode);
-  op2shifted = gen_reg_rtx (DImode);
-  op1l = gen_reg_rtx (SImode);
-  op1r = gen_reg_rtx (SImode);
-  op2l = gen_reg_rtx (SImode);
-  op2r = gen_reg_rtx (SImode);
-
-  emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
-						GEN_INT (32)));
-  emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
-						GEN_INT (32)));
-  op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
-  op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
-  op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
-  op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+
+  if (TARGET_64BIT)
+    {
+      rtx op1shifted = gen_reg_rtx (DImode);
+      rtx op2shifted = gen_reg_rtx (DImode);
+
+      emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],
+						    GEN_INT (32)));
+      emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],
+						    GEN_INT (32)));
+      op1r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[1], 4));
+      op2r = force_reg (SImode, gen_rtx_SUBREG (SImode, operands[2], 4));
+      op1l = force_reg (SImode, gen_rtx_SUBREG (SImode, op1shifted, 4));
+      op2l = force_reg (SImode, gen_rtx_SUBREG (SImode, op2shifted, 4));
+    }
+  else
+    {
+      op1r = force_reg (SImode, gen_lowpart (SImode, operands[1]));
+      op2r = force_reg (SImode, gen_lowpart (SImode, operands[2]));
+      op1l = force_reg (SImode, gen_highpart (SImode, operands[1]));
+      op2l = force_reg (SImode, gen_highpart (SImode, operands[2]));
+    }
 
   /* Emit multiplies for the cross products.  */
   emit_insn (gen_umulsidi3 (cross_product1, op2r, op1l));
@@ -5408,13 +5495,35 @@
   /* Emit a multiply for the low sub-word.  */
   emit_insn (gen_umulsidi3 (low_product, copy_rtx (op2r), copy_rtx (op1r)));
 
-  /* Sum the cross products and shift them into proper position.  */
-  emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
-  emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+  if (TARGET_64BIT)
+    {
+      rtx cross_scratch = gen_reg_rtx (DImode);
+      rtx cross_product = gen_reg_rtx (DImode);
 
-  /* Add the cross product to the low product and store the result
-     into the output operand .  */
-  emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+      /* Sum the cross products and shift them into proper position.  */
+      emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));
+      emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));
+
+      /* Add the cross product to the low product and store the result
+	 into the output operand .  */
+      emit_insn (gen_adddi3 (operands[0], cross_product, low_product));
+    }
+  else
+    {
+      rtx cross_scratch = gen_reg_rtx (SImode);
+
+      /* Sum cross products.  */
+      emit_move_insn (cross_scratch,
+		      gen_rtx_PLUS (SImode,
+				    gen_lowpart (SImode, cross_product1),
+				    gen_lowpart (SImode, cross_product2)));
+      emit_move_insn (gen_lowpart (SImode, operands[0]),
+		      gen_lowpart (SImode, low_product));
+      emit_move_insn (gen_highpart (SImode, operands[0]),
+		      gen_rtx_PLUS (SImode,
+				    gen_highpart (SImode, low_product),
+				    cross_scratch));
+    }
   DONE;
 }")
 
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index cb887eba521..beb3f0d0952 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -127,7 +127,7 @@
 #define vec_vcfux __builtin_vec_vcfux
 #define vec_cts __builtin_vec_cts
 #define vec_ctu __builtin_vec_ctu
-#define vec_cpsgn __builtin_vec_copysign
+#define vec_cpsgn(x,y) __builtin_vec_copysign(y,x)
 #define vec_double __builtin_vec_double
 #define vec_doublee __builtin_vec_doublee
 #define vec_doubleo __builtin_vec_doubleo
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index d30e5dec980..d8fc8a74e77 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -1501,6 +1501,22 @@ replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)
   insn->set_deleted ();
 }
 
+/* INSN is known to contain a SUBREG, which we can normally handle,
+   but if the SUBREG itself contains a MULT then we need to leave it alone
+   to avoid turning a mult_hipart into a mult_lopart, for example.  */
+static bool
+has_part_mult (rtx_insn *insn)
+{
+  rtx body = PATTERN (insn);
+  if (GET_CODE (body) != SET)
+    return false;
+  rtx src = SET_SRC (body);
+  if (GET_CODE (src) != SUBREG)
+    return false;
+  rtx inner = XEXP (src, 0);
+  return (GET_CODE (inner) == MULT);
+}
+
 /* Make NEW_MEM_EXP's attributes and flags resemble those of
    ORIGINAL_MEM_EXP.  */
 static void
@@ -2437,6 +2453,9 @@ rs6000_analyze_swaps (function *fun)
 		    insn_entry[uid].is_swappable = 0;
 		  else if (special != SH_NONE)
 		    insn_entry[uid].special_handling = special;
+		  else if (insn_entry[uid].contains_subreg
+			   && has_part_mult (insn))
+		    insn_entry[uid].is_swappable = 0;
 		  else if (insn_entry[uid].contains_subreg)
 		    insn_entry[uid].special_handling = SH_SUBREG;
 		}
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 62250433c16..a6e683fe2df 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -17110,23 +17110,17 @@ rs6000_init_builtins (void)
 #endif
 }
 
-/* Returns the rs6000 builtin decl for CODE.  */
+/* Returns the rs6000 builtin decl for CODE.  Note that we don't check
+   the builtin mask here since there could be some #pragma/attribute
+   target functions and the rs6000_builtin_mask could be wrong when
+   this checking happens, though it will be updated properly later.  */
 
 static tree
 rs6000_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)
 {
-  HOST_WIDE_INT fnmask;
-
   if (code >= RS6000_BUILTIN_COUNT)
     return error_mark_node;
 
-  fnmask = rs6000_builtin_info[code].mask;
-  if ((fnmask & rs6000_builtin_mask) != fnmask)
-    {
-      rs6000_invalid_builtin ((enum rs6000_builtins)code);
-      return error_mark_node;
-    }
-
   return rs6000_builtin_decls[code];
 }
 
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 5a3496ac92e..68392da4acd 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -973,7 +973,7 @@
 	(match_operand:GPR 2 "memory_operand"))
    (set (reg CC_REGNUM)
 	(compare (match_dup 0) (match_operand:GPR 1 "const0_operand")))]
-  "s390_match_ccmode(insn, CCSmode) && TARGET_EXTIMM
+  "s390_match_ccmode (peep2_next_insn (1), CCSmode) && TARGET_EXTIMM
    && GENERAL_REG_P (operands[0])
    && satisfies_constraint_T (operands[2])
    && !contains_constant_pool_address_p (operands[2])"
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index d7a4ae64c36..788175e1543 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -109,8 +109,8 @@ __lcbb(const void *ptr, int bndry)
 #define vec_rint(X)   __builtin_s390_vfi((X), 0, 0)
 #define vec_roundc(X) __builtin_s390_vfi((X), 4, 0)
 #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)
-#define vec_doublee(X) __builtin_s390_vfll((X))
-#define vec_floate(X) __builtin_s390_vflr((X), 0, 0)
+#define vec_doublee(X) __builtin_s390_vflls((X))
+#define vec_floate(X) __builtin_s390_vflrd((X), 0, 0)
 #define vec_load_len_r(X,L)				\
   (__vector unsigned char)__builtin_s390_vlrlr((L),(X))
 #define vec_store_len_r(X,Y,L) \
diff --git a/gcc/configure b/gcc/configure
index 9e4c8693966..8c25a18fa08 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -28944,7 +28944,7 @@ $as_echo "#define HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE 1" >>confdefs.h
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/configure.ac b/gcc/configure.ac
index ec10dbeb3e9..d67f72df8a2 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5671,7 +5671,7 @@ EOF
 esac
 
 case "$target:$tm_file" in
-  powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
+  powerpc64*-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)
   case "$target" in
      *le-*-linux*)
      emul_name="-melf64lppc"
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index 2f6b8599d7c..eb0bda3a835 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -202,15 +202,17 @@ enum profile_update {
   PROFILE_UPDATE_PREFER_ATOMIC
 };
 
-/* Types of unwind/exception handling info that can be generated.  */
+/* Types of unwind/exception handling info that can be generated.
+   Note that a UI_TARGET (or larger) setting is considered to be
+   incompatible with -freorder-blocks-and-partition.  */
 
 enum unwind_info_type
 {
   UI_NONE,
   UI_SJLJ,
   UI_DWARF2,
-  UI_TARGET,
-  UI_SEH
+  UI_SEH,
+  UI_TARGET
 };
 
 /* Callgraph node profile representation.  */
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index b0e68a99a73..9a3c98f19d6 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,144 @@
+2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (get_symbol_decl): Align methods to MINIMUM_METHOD_BOUNDARY.
+
+2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (d_finish_decl): Use HOST_WIDE_INT for type size
+	temporaries.
+
+2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-10-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/102574
+	* d-spec.cc (lang_specific_driver): Link libstdc++ statically if
+	-static-libstdc++ was given on command-line.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* d-convert.cc (convert_for_rvalue): New function.
+	* d-tree.h (convert_for_rvalue): Declare.
+	* expr.cc (ExprVisitor::visit (CastExp *)): Use convert_for_rvalue.
+	(build_return_dtor): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* expr.cc (binary_op): Use build2 instead of fold_build2.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* d-codegen.cc (build_array_index): Handle void arrays same as byte.
+	* d-convert.cc (convert_expr): Handle converting to zero-sized arrays.
+	* dmd/dcast.c (castTo): Handle casting to zero-sized arrays.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* dmd/expression.c (FuncInitExp::resolveLoc): Set type as `string'.
+	(PrettyFuncInitExp::resolveLoc): Likewise.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* d-builtins.cc (d_builtin_function_ext_scope): New function.
+	* d-lang.cc (LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE): Define.
+	* d-tree.h (d_builtin_function_ext_scope): Declare.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* d-frontend.cc (getTypeInfoType): Move TypeInfo checks to
+	check_typeinfo_type and call new function.
+	* d-tree.h (check_typeinfo_type): Declare.
+	* typeinfo.cc: Include dmd/scope.h.
+	(create_frontend_tinfo_types): Generate front-end types even if Object
+	is missing.
+	(build_typeinfo): Move TypeInfo checks to check_typeinfo_type and call
+	new function.
+	(check_typeinfo_type): New function.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit (TypeidExp)):
+	Error when TypeInfo doesn't exist.
+	* dmd/func.c (FuncDeclaration::semantic3): Likewise.
+	* dmd/mtype.c (TypeClass::dotExp): Likewise.
+	* typeinfo.cc (object_module): New variable.
+	(make_frontend_typeinfo): Update signature.  Set temporary on
+	generated TypeInfo classes.
+	(create_tinfo_types): Set object_module.  Move generation of front-end
+	typeinfo into ...
+	(create_frontend_tinfo_types): ... New function.
+	(layout_typeinfo): Call create_frontend_tinfo_types.
+	(layout_classinfo): Likewise.
+	(layout_cpp_typeinfo): Likewise.
+	(create_typeinfo): Likewise.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* dmd/expression.c (Expression::checkPostblit): Don't generate
+	TypeInfo when RTTI is disabled.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* dmd/mtype.c (Type::getProperty): Prefer explicit alignment over
+	natural alignment for alignof property.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* d-codegen.cc (build_assign): Construct initializations inside
+	TARGET_EXPR_INITIAL.
+	(compound_expr): Remove intermediate expressions that have no
+	side-effects.
+	(return_expr): Construct returns inside TARGET_EXPR_INITIAL.
+	* expr.cc (ExprVisitor::visit (CallExp *)): Remove useless assignment
+	to TARGET_EXPR_SLOT.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/d/d-builtins.cc b/gcc/d/d-builtins.cc
index 3dbdafb492a..333c4930318 100644
--- a/gcc/d/d-builtins.cc
+++ b/gcc/d/d-builtins.cc
@@ -1175,5 +1175,20 @@ d_builtin_function (tree decl)
   return decl;
 }
 
+/* Same as d_builtin_function, but used to delay putting in back-end builtin
+   functions until the ISA that defines the builtin has been declared.
+   However in D, there is no global namespace.  All builtins get pushed into the
+   `gcc.builtins' module, which is constructed during the semantic analysis
+   pass, which has already finished by the time target attributes are evaluated.
+   So builtins are not pushed because they would be ultimately ignored.
+   The purpose of having this function then is to improve compile-time
+   reflection support to allow user-code to determine whether a given back end
+   function is enabled by the ISA.  */
+
+tree
+d_builtin_function_ext_scope (tree decl)
+{
+  return decl;
+}
 
 #include "gt-d-d-builtins.h"
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index 17f624b5a4f..fb83770d64a 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -1304,6 +1304,7 @@ component_ref (tree object, tree field)
 tree
 build_assign (tree_code code, tree lhs, tree rhs)
 {
+  tree result;
   tree init = stabilize_expr (&lhs);
   init = compound_expr (init, stabilize_expr (&rhs));
 
@@ -1322,19 +1323,27 @@ build_assign (tree_code code, tree lhs, tree rhs)
   if (TREE_CODE (rhs) == TARGET_EXPR)
     {
       /* If CODE is not INIT_EXPR, can't initialize LHS directly,
-	 since that would cause the LHS to be constructed twice.
-	 So we force the TARGET_EXPR to be expanded without a target.  */
+	 since that would cause the LHS to be constructed twice.  */
       if (code != INIT_EXPR)
-	rhs = compound_expr (rhs, TARGET_EXPR_SLOT (rhs));
+	{
+	  init = compound_expr (init, rhs);
+	  result = build_assign (code, lhs, TARGET_EXPR_SLOT (rhs));
+	}
       else
 	{
 	  d_mark_addressable (lhs);
-	  rhs = TARGET_EXPR_INITIAL (rhs);
+	  TARGET_EXPR_INITIAL (rhs) = build_assign (code, lhs,
+						    TARGET_EXPR_INITIAL (rhs));
+	  result = rhs;
 	}
     }
+  else
+    {
+      /* Simple assignment.  */
+      result = fold_build2_loc (input_location, code,
+				TREE_TYPE (lhs), lhs, rhs);
+    }
 
-  tree result = fold_build2_loc (input_location, code,
-				 TREE_TYPE (lhs), lhs, rhs);
   return compound_expr (init, result);
 }
 
@@ -1456,6 +1465,11 @@ compound_expr (tree arg0, tree arg1)
   if (arg0 == NULL_TREE || !TREE_SIDE_EFFECTS (arg0))
     return arg1;
 
+  /* Remove intermediate expressions that have no side-effects.  */
+  while (TREE_CODE (arg0) == COMPOUND_EXPR
+	 && !TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
+    arg0 = TREE_OPERAND (arg0, 0);
+
   if (TREE_CODE (arg1) == TARGET_EXPR)
     {
       /* If the rhs is a TARGET_EXPR, then build the compound expression
@@ -1476,6 +1490,19 @@ compound_expr (tree arg0, tree arg1)
 tree
 return_expr (tree ret)
 {
+  /* Same as build_assign, the DECL_RESULT assignment replaces the temporary
+     in TARGET_EXPR_SLOT.  */
+  if (ret != NULL_TREE && TREE_CODE (ret) == TARGET_EXPR)
+    {
+      tree exp = TARGET_EXPR_INITIAL (ret);
+      tree init = stabilize_expr (&exp);
+
+      exp = fold_build1_loc (input_location, RETURN_EXPR, void_type_node, exp);
+      TARGET_EXPR_INITIAL (ret) = compound_expr (init, exp);
+
+      return ret;
+    }
+
   return fold_build1_loc (input_location, RETURN_EXPR,
 			  void_type_node, ret);
 }
@@ -1579,21 +1606,9 @@ build_array_index (tree ptr, tree index)
   /* Array element size.  */
   tree size_exp = size_in_bytes (target_type);
 
-  if (integer_zerop (size_exp))
-    {
-      /* Test for array of void.  */
-      if (TYPE_MODE (target_type) == TYPE_MODE (void_type_node))
-	index = fold_convert (type, index);
-      else
-	{
-	  /* Should catch this earlier.  */
-	  error ("invalid use of incomplete type %qD", TYPE_NAME (target_type));
-	  ptr_type = error_mark_node;
-	}
-    }
-  else if (integer_onep (size_exp))
+  if (integer_zerop (size_exp) || integer_onep (size_exp))
     {
-      /* Array of bytes -- No need to multiply.  */
+      /* Array of void or bytes -- No need to multiply.  */
       index = fold_convert (type, index);
     }
   else
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index 761ab3c5435..537324ddb35 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -473,13 +473,18 @@ convert_expr (tree exp, Type *etype, Type *totype)
 
 	  tree ptrtype = build_ctype (tbtype->nextOf ()->pointerTo ());
 
-	  if ((dim * esize) % tsize != 0)
+	  if (esize != tsize)
 	    {
-	      error ("cannot cast %qs to %qs since sizes don't line up",
-		     etype->toChars (), totype->toChars ());
-	      return error_mark_node;
+	      /* Array element sizes do not match, so we must adjust the
+		 dimensions.  */
+	      if (tsize == 0 || (dim * esize) % tsize != 0)
+		{
+		  error ("cannot cast %qs to %qs since sizes don't line up",
+			 etype->toChars (), totype->toChars ());
+		  return error_mark_node;
+		}
+	      dim = (dim * esize) / tsize;
 	    }
-	  dim = (dim * esize) / tsize;
 
 	  /* Assumes casting to dynamic array of same type or void.  */
 	  return d_array_value (build_ctype (totype), size_int (dim),
@@ -596,6 +601,42 @@ convert_expr (tree exp, Type *etype, Type *totype)
   return result ? result : convert (build_ctype (totype), exp);
 }
 
+/* Return a TREE represenwation of EXPR, whose type has been converted from
+ * ETYPE to TOTYPE, and is being used in an rvalue context.  */
+
+tree
+convert_for_rvalue (tree expr, Type *etype, Type *totype)
+{
+  tree result = NULL_TREE;
+
+  Type *ebtype = etype->toBasetype ();
+  Type *tbtype = totype->toBasetype ();
+
+  switch (ebtype->ty)
+    {
+    case Tbool:
+      /* If casting from bool, the result is either 0 or 1, any other value
+	 violates @safe code, so enforce that it is never invalid.  */
+      if (CONSTANT_CLASS_P (expr))
+	result = d_truthvalue_conversion (expr);
+      else
+	{
+	  /* Reinterpret the boolean as an integer and test the first bit.
+	     The generated code should end up being equivalent to:
+		*cast(ubyte *)&expr & 1;  */
+	  machine_mode bool_mode = TYPE_MODE (TREE_TYPE (expr));
+	  tree mtype = lang_hooks.types.type_for_mode (bool_mode, 1);
+	  result = fold_build2 (BIT_AND_EXPR, mtype,
+				build_vconvert (mtype, expr),
+				build_one_cst (mtype));
+	}
+
+      result = convert (build_ctype (tbtype), result);
+      break;
+    }
+
+  return result ? result : convert_expr (expr, etype, totype);
+}
 
 /* Apply semantics of assignment to a value of type TOTYPE to EXPR
    (e.g., pointer = array -> pointer = &array[0])
diff --git a/gcc/d/d-frontend.cc b/gcc/d/d-frontend.cc
index ccd5f50130f..563696bdf9f 100644
--- a/gcc/d/d-frontend.cc
+++ b/gcc/d/d-frontend.cc
@@ -614,39 +614,8 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)
 Type *
 getTypeInfoType (Loc loc, Type *type, Scope *sc)
 {
-  if (!global.params.useTypeInfo)
-    {
-      /* Even when compiling without RTTI we should still be able to evaluate
-	 TypeInfo at compile-time, just not at run-time.  */
-      if (!sc || !(sc->flags & SCOPEctfe))
-	{
-	  static int warned = 0;
-
-	  if (!warned)
-	    {
-	      error_at (make_location_t (loc),
-			"%<object.TypeInfo%> cannot be used with -fno-rtti");
-	      warned = 1;
-	    }
-	}
-    }
-
-  if (Type::dtypeinfo == NULL
-      || (Type::dtypeinfo->storage_class & STCtemp))
-    {
-      /* If TypeInfo has not been declared, warn about each location once.  */
-      static Loc warnloc;
-
-      if (!loc.equals (warnloc))
-	{
-	  error_at (make_location_t (loc),
-		    "%<object.TypeInfo%> could not be found, "
-		    "but is implicitly used");
-	  warnloc = loc;
-	}
-    }
-
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, sc);
   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);
   return type->vtinfo->type;
 }
diff --git a/gcc/d/d-lang.cc b/gcc/d/d-lang.cc
index 62a8ddd69b2..322a93ee139 100644
--- a/gcc/d/d-lang.cc
+++ b/gcc/d/d-lang.cc
@@ -1783,6 +1783,7 @@ d_build_eh_runtime_type (tree type)
 #undef LANG_HOOKS_GET_ALIAS_SET
 #undef LANG_HOOKS_TYPES_COMPATIBLE_P
 #undef LANG_HOOKS_BUILTIN_FUNCTION
+#undef LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE
 #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE
 #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL
 #undef LANG_HOOKS_GIMPLIFY_EXPR
@@ -1813,6 +1814,7 @@ d_build_eh_runtime_type (tree type)
 #define LANG_HOOKS_GET_ALIAS_SET	    d_get_alias_set
 #define LANG_HOOKS_TYPES_COMPATIBLE_P	    d_types_compatible_p
 #define LANG_HOOKS_BUILTIN_FUNCTION	    d_builtin_function
+#define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE d_builtin_function_ext_scope
 #define LANG_HOOKS_REGISTER_BUILTIN_TYPE    d_register_builtin_type
 #define LANG_HOOKS_FINISH_INCOMPLETE_DECL   d_finish_incomplete_decl
 #define LANG_HOOKS_GIMPLIFY_EXPR	    d_gimplify_expr
diff --git a/gcc/d/d-spec.cc b/gcc/d/d-spec.cc
index 9eba6902bb9..cf55c76250c 100644
--- a/gcc/d/d-spec.cc
+++ b/gcc/d/d-spec.cc
@@ -94,6 +94,9 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
   /* "-lstdc++" if it appears on the command line.  */
   const cl_decoded_option *saw_libcxx = 0;
 
+  /* True if we saw `-static-libstdc++'.  */
+  bool saw_static_libcxx = false;
+
   /* Whether we need the C++ STD library.  */
   bool need_stdcxx = false;
 
@@ -259,6 +262,11 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 	  shared_libgcc = false;
 	  break;
 
+	case OPT_static_libstdc__:
+	  saw_static_libcxx = true;
+	  args[i] |= SKIPOPT;
+	  break;
+
 	case OPT_static_libphobos:
 	  if (phobos_library != PHOBOS_NOLINK)
 	    phobos_library = PHOBOS_STATIC;
@@ -476,16 +484,33 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
       added_libraries++;
     }
 
-  if (saw_libcxx)
-    new_decoded_options[j++] = *saw_libcxx;
-  else if (need_stdcxx)
+  if (saw_libcxx || need_stdcxx)
     {
-      generate_option (OPT_l,
-		       (saw_profile_flag
-			? LIBSTDCXX_PROFILE
-			: LIBSTDCXX),
-		       1, CL_DRIVER, &new_decoded_options[j++]);
-      added_libraries++;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#endif
+      if (saw_libcxx)
+	new_decoded_options[j++] = *saw_libcxx;
+      else if (need_stdcxx)
+	{
+	  generate_option (OPT_l,
+			   (saw_profile_flag
+			    ? LIBSTDCXX_PROFILE
+			    : LIBSTDCXX),
+			   1, CL_DRIVER, &new_decoded_options[j++]);
+	  added_libraries++;
+	}
+#ifdef HAVE_LD_STATIC_DYNAMIC
+      if (saw_static_libcxx && !static_link)
+	{
+	  generate_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1, CL_DRIVER,
+			   &new_decoded_options[j++]);
+	}
+#endif
     }
 
   if (shared_libgcc && !static_link)
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index 7a54dfbc59e..ad8e25fa45d 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -488,6 +488,7 @@ extern const attribute_spec d_langhook_attribute_table[];
 extern const attribute_spec d_langhook_common_attribute_table[];
 
 extern tree d_builtin_function (tree);
+extern tree d_builtin_function_ext_scope (tree);
 extern void d_init_builtins (void);
 extern void d_register_builtin_type (tree, const char *);
 extern void d_build_builtins_module (Module *);
@@ -577,6 +578,7 @@ extern bool decl_with_nonnull_addr_p (const_tree);
 extern tree d_truthvalue_conversion (tree);
 extern tree d_convert (tree, tree);
 extern tree convert_expr (tree, Type *, Type *);
+extern tree convert_for_rvalue (tree, Type *, Type *);
 extern tree convert_for_assignment (tree, Type *, Type *);
 extern tree convert_for_argument (tree, Parameter *);
 extern tree convert_for_condition (tree, Type *);
@@ -650,6 +652,7 @@ extern tree layout_typeinfo (TypeInfoDeclaration *);
 extern tree layout_classinfo (ClassDeclaration *);
 extern tree get_typeinfo_decl (TypeInfoDeclaration *);
 extern tree get_classinfo_decl (ClassDeclaration *);
+extern void check_typeinfo_type (const Loc &, Scope *);
 extern tree build_typeinfo (const Loc &, Type *);
 extern void create_typeinfo (Type *, Module *);
 extern void create_tinfo_types (Module *);
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index d24f5dcd958..7aaaf49f02f 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -1233,6 +1233,9 @@ get_symbol_decl (Declaration *decl)
 	      DECL_VINDEX (decl->csym) = size_int (fd->vtblIndex);
 	      DECL_VIRTUAL_P (decl->csym) = 1;
 	    }
+
+	  /* Align method to the minimum boundary for target.  */
+	  SET_DECL_ALIGN (decl->csym, MINIMUM_METHOD_BOUNDARY);
 	}
       else if (fd->isMain () || fd->isCMain ())
 	{
@@ -1559,8 +1562,9 @@ d_finish_decl (tree decl)
   if (flag_checking && DECL_INITIAL (decl))
     {
       /* Initializer must never be bigger than symbol size.  */
-      dinteger_t tsize = int_size_in_bytes (TREE_TYPE (decl));
-      dinteger_t dtsize = int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
+      HOST_WIDE_INT tsize = int_size_in_bytes (TREE_TYPE (decl));
+      HOST_WIDE_INT dtsize =
+	int_size_in_bytes (TREE_TYPE (DECL_INITIAL (decl)));
 
       if (tsize < dtsize)
 	{
diff --git a/gcc/d/dmd/dcast.c b/gcc/d/dmd/dcast.c
index a3df701c341..905aed72625 100644
--- a/gcc/d/dmd/dcast.c
+++ b/gcc/d/dmd/dcast.c
@@ -1494,13 +1494,16 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)
                     // cast(U[])sa; // ==> cast(U[])sa[];
                     d_uns64 fsize = t1b->nextOf()->size();
                     d_uns64 tsize = tob->nextOf()->size();
-                    if ((((TypeSArray *)t1b)->dim->toInteger() * fsize) % tsize != 0)
+                    if (fsize != tsize)
                     {
-                        // copied from sarray_toDarray() in e2ir.c
-                        e->error("cannot cast expression %s of type %s to %s since sizes don't line up",
-                            e->toChars(), e->type->toChars(), t->toChars());
-                        result = new ErrorExp();
-                        return;
+                        dinteger_t dim = ((TypeSArray *)t1b)->dim->toInteger();
+                        if (tsize == 0 || (dim * fsize) % tsize != 0)
+                        {
+                            e->error("cannot cast expression `%s` of type `%s` to `%s` since sizes don't line up",
+                                     e->toChars(), e->type->toChars(), t->toChars());
+                            result = new ErrorExp();
+                            return;
+                        }
                     }
                     goto Lok;
                 }
diff --git a/gcc/d/dmd/expression.c b/gcc/d/dmd/expression.c
index af762eb3c66..e59c5b114dd 100644
--- a/gcc/d/dmd/expression.c
+++ b/gcc/d/dmd/expression.c
@@ -2647,8 +2647,11 @@ bool Expression::checkPostblit(Scope *sc, Type *t)
     t = t->baseElemOf();
     if (t->ty == Tstruct)
     {
-        // Bugzilla 11395: Require TypeInfo generation for array concatenation
-        semanticTypeInfo(sc, t);
+        if (global.params.useTypeInfo)
+        {
+            // Bugzilla 11395: Require TypeInfo generation for array concatenation
+            semanticTypeInfo(sc, t);
+        }
 
         StructDeclaration *sd = ((TypeStruct *)t)->sym;
         if (sd->postblit)
@@ -6714,7 +6717,7 @@ Expression *FuncInitExp::resolveLoc(Loc loc, Scope *sc)
         s = "";
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
@@ -6748,7 +6751,7 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)
 
     Expression *e = new StringExp(loc, const_cast<char *>(s));
     e = semantic(e, sc);
-    e = e->castTo(sc, type);
+    e->type = Type::tstring;
     return e;
 }
 
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 75794a03285..847a0796792 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -1806,11 +1806,19 @@ public:
         Expression *e;
         if (ea && ta->toBasetype()->ty == Tclass)
         {
-            /* Get the dynamic type, which is .classinfo
-            */
-            ea = semantic(ea, sc);
-            e = new TypeidExp(ea->loc, ea);
-            e->type = Type::typeinfoclass->type;
+            if (!Type::typeinfoclass)
+            {
+                error(exp->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                e = new ErrorExp();
+            }
+            else
+            {
+                /* Get the dynamic type, which is .classinfo
+                */
+                ea = semantic(ea, sc);
+                e = new TypeidExp(ea->loc, ea);
+                e->type = Type::typeinfoclass->type;
+            }
         }
         else if (ta->ty == Terror)
         {
diff --git a/gcc/d/dmd/func.c b/gcc/d/dmd/func.c
index 568decc8cee..04c70cf3b7b 100644
--- a/gcc/d/dmd/func.c
+++ b/gcc/d/dmd/func.c
@@ -1520,6 +1520,18 @@ void FuncDeclaration::semantic3(Scope *sc)
         {
             if (f->linkage == LINKd)
             {
+                // Variadic arguments depend on Typeinfo being defined
+                if (!global.params.useTypeInfo || !Type::dtypeinfo || !Type::typeinfotypelist)
+                {
+                    if (!global.params.useTypeInfo)
+                        error("D-style variadic functions cannot be used with -betterC");
+                    else if (!Type::typeinfotypelist)
+                        error("`object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions");
+                    else
+                        error("`object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions");
+                    fatal();
+                }
+
                 // Declare _arguments[]
                 v_arguments = new VarDeclaration(Loc(), Type::typeinfotypelist->type, Id::_arguments_typeinfo, NULL);
                 v_arguments->storage_class |= STCtemp | STCparameter;
diff --git a/gcc/d/dmd/mtype.c b/gcc/d/dmd/mtype.c
index d0e73967d45..0204860fec3 100644
--- a/gcc/d/dmd/mtype.c
+++ b/gcc/d/dmd/mtype.c
@@ -2059,7 +2059,10 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)
     }
     else if (ident == Id::__xalignof)
     {
-        e = new IntegerExp(loc, alignsize(), Type::tsize_t);
+        unsigned explicitAlignment = alignment();
+        unsigned naturalAlignment = alignsize();
+        unsigned actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);
+        e = new IntegerExp(loc, actualAlignment, Type::tsize_t);
     }
     else if (ident == Id::_init)
     {
@@ -8344,7 +8347,12 @@ L1:
 
         if (ident == Id::classinfo)
         {
-            assert(Type::typeinfoclass);
+            if (!Type::typeinfoclass)
+            {
+                error(e->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                return new ErrorExp();
+            }
+
             Type *t = Type::typeinfoclass->type;
             if (e->op == TOKtype || e->op == TOKdottype)
             {
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 3a2823d6e46..244dd860b7f 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -162,7 +162,7 @@ class ExprVisitor : public Visitor
 	    eptype = type;
 	  }
 
-	ret = fold_build2 (code, eptype, arg0, arg1);
+	ret = build2 (code, eptype, arg0, arg1);
       }
 
     return d_convert (type, ret);
@@ -1435,7 +1435,7 @@ public:
     if (tbtype->ty == Tvoid)
       this->result_ = build_nop (build_ctype (tbtype), result);
     else
-      this->result_ = convert_expr (result, ebtype, tbtype);
+      this->result_ = convert_for_rvalue (result, ebtype, tbtype);
   }
 
   /* Build a delete expression.  */
@@ -1837,15 +1837,10 @@ public:
       exp = d_convert (build_ctype (e->type), exp);
 
     /* If this call was found to be a constructor for a temporary with a
-       cleanup, then move the call inside the TARGET_EXPR.  The original
-       initializer is turned into an assignment, to keep its side effect.  */
+       cleanup, then move the call inside the TARGET_EXPR.  */
     if (cleanup != NULL_TREE)
       {
 	tree init = TARGET_EXPR_INITIAL (cleanup);
-	tree slot = TARGET_EXPR_SLOT (cleanup);
-	d_mark_addressable (slot);
-	init = build_assign (INIT_EXPR, slot, init);
-
 	TARGET_EXPR_INITIAL (cleanup) = compound_expr (init, exp);
 	exp = cleanup;
       }
@@ -3111,11 +3106,14 @@ build_return_dtor (Expression *e, Type *type, TypeFunction *tf)
   tree result = build_expr (e);
 
   /* Convert for initializing the DECL_RESULT.  */
-  result = convert_expr (result, e->type, type);
-
-  /* If we are returning a reference, take the address.  */
   if (tf->isref)
-    result = build_address (result);
+    {
+      /* If we are returning a reference, take the address.  */
+      result = convert_expr (result, e->type, type);
+      result = build_address (result);
+    }
+  else
+    result = convert_for_rvalue (result, e->type, type);
 
   /* The decl to store the return expression.  */
   tree decl = DECL_RESULT (cfun->decl);
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 0b19bcf7f34..117a5bd1592 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dmd/identifier.h"
 #include "dmd/module.h"
 #include "dmd/mtype.h"
+#include "dmd/scope.h"
 #include "dmd/template.h"
 #include "dmd/target.h"
 
@@ -185,28 +186,36 @@ make_internal_typeinfo (tinfo_kind tk, Identifier *ident, ...)
   va_end (ap);
 }
 
-/* Helper for create_tinfo_types.  Creates a typeinfo class declaration
-   incase one wasn't supplied by reading `object.d'.  */
+/* Reference to the `object` module, where all TypeInfo is defined.  */
+
+static Module *object_module;
+
+/* Helper for create_frontend_tinfo_types.  Creates a typeinfo class
+   declaration incase one wasn't supplied by reading `object.d'.  */
 
 static void
-make_frontend_typeinfo (Module *mod, Identifier *ident,
-			ClassDeclaration *base = NULL)
+make_frontend_typeinfo (Identifier *ident, ClassDeclaration *base = NULL)
 {
   if (!base)
     base = Type::dtypeinfo;
 
+  gcc_assert (object_module);
+
   /* Create object module in order to complete the semantic.  */
-  if (!mod->_scope)
-    mod->importAll (NULL);
+  if (!object_module->_scope)
+    object_module->importAll (NULL);
 
   /* Assignment of global typeinfo variables is managed by the ClassDeclaration
      constructor, so only need to new the declaration here.  */
-  Loc loc = (mod->md) ? mod->md->loc : mod->loc;
+  Loc loc = (object_module->md) ? object_module->md->loc : object_module->loc;
   ClassDeclaration *tinfo = ClassDeclaration::create (loc, ident, NULL, NULL,
 						      true);
-  tinfo->parent = mod;
-  tinfo->semantic (mod->_scope);
+  tinfo->parent = object_module;
+  tinfo->semantic (object_module->_scope);
   tinfo->baseClass = base;
+  /* This is a compiler generated class, and shouldn't be mistaken for being
+     the type declared in the runtime library.  */
+  tinfo->storage_class |= STCtemp;
 }
 
 /* Make sure the required builtin types exist for generating the TypeInfo
@@ -227,69 +236,78 @@ create_tinfo_types (Module *mod)
 			  ptr_type_node, d_uint_type, ptr_type_node,
 			  array_type_node, ptr_type_node, ptr_type_node, NULL);
 
-  /* If there's no Object class defined, then neither can TypeInfo be.  */
-  if (ClassDeclaration::object == NULL)
+  object_module = mod;
+}
+
+/* Same as create_tinfo_types, but builds all front-end TypeInfo variable
+   definitions.  */
+
+static void
+create_frontend_tinfo_types (void)
+{
+  /* If there's no object module, then neither can there be TypeInfo.  */
+  if (object_module == NULL)
     return;
 
   /* Create all frontend TypeInfo classes declarations.  We rely on all
      existing, even if only just as stubs.  */
   if (!Type::dtypeinfo)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo"),
 			    ClassDeclaration::object);
 
   if (!Type::typeinfoclass)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Class"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Class"));
 
   if (!Type::typeinfointerface)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Interface"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Interface"));
 
   if (!Type::typeinfostruct)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Struct"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Struct"));
 
   if (!Type::typeinfopointer)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Pointer"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Pointer"));
 
   if (!Type::typeinfoarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Array"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Array"));
 
   if (!Type::typeinfostaticarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_StaticArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_StaticArray"));
 
   if (!Type::typeinfoassociativearray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_AssociativeArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_AssociativeArray"));
 
   if (!Type::typeinfoenum)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Enum"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Enum"));
 
   if (!Type::typeinfofunction)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Function"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Function"));
 
   if (!Type::typeinfodelegate)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Delegate"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Delegate"));
 
   if (!Type::typeinfotypelist)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Tuple"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Tuple"));
 
   if (!Type::typeinfoconst)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Const"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Const"));
 
   if (!Type::typeinfoinvariant)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Invariant"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Invariant"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfoshared)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Shared"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Shared"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfowild)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Wild"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Wild"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfovector)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Vector"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Vector"));
 
   if (!ClassDeclaration::cpp_type_info_ptr)
-    make_frontend_typeinfo (mod, Identifier::idPool ("__cpp_type_info_ptr"),
+    make_frontend_typeinfo (Identifier::idPool ("__cpp_type_info_ptr"),
 			    ClassDeclaration::object);
 }
 
@@ -1143,6 +1161,9 @@ public:
 tree
 layout_typeinfo (TypeInfoDeclaration *d)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoVisitor v = TypeInfoVisitor (get_typeinfo_decl (d));
   d->accept (&v);
   return v.result ();
@@ -1154,6 +1175,9 @@ layout_typeinfo (TypeInfoDeclaration *d)
 tree
 layout_classinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoClassDeclaration *d = TypeInfoClassDeclaration::create (cd->type);
   TypeInfoVisitor v = TypeInfoVisitor (get_classinfo_decl (cd));
   d->accept (&v);
@@ -1347,16 +1371,19 @@ get_classinfo_decl (ClassDeclaration *decl)
   return decl->csym;
 }
 
-/* Returns typeinfo reference for TYPE.  */
+/* Performs sanity checks on the `object.TypeInfo' type, raising an error if
+   RTTI is disabled, or the type is missing.  */
 
-tree
-build_typeinfo (const Loc &loc, Type *type)
+void
+check_typeinfo_type (const Loc &loc, Scope *sc)
 {
   if (!global.params.useTypeInfo)
     {
       static int warned = 0;
 
-      if (!warned)
+      /* Even when compiling without RTTI we should still be able to evaluate
+	 TypeInfo at compile-time, just not at run-time.  */
+      if (!warned && (!sc || !(sc->flags & SCOPEctfe)))
 	{
 	  error_at (make_location_t (loc),
 		    "%<object.TypeInfo%> cannot be used with -fno-rtti");
@@ -1364,7 +1391,29 @@ build_typeinfo (const Loc &loc, Type *type)
 	}
     }
 
+  if (Type::dtypeinfo == NULL
+      || (Type::dtypeinfo->storage_class & STCtemp))
+    {
+      /* If TypeInfo has not been declared, warn about each location once.  */
+      static Loc warnloc;
+
+      if (!warnloc.equals (loc))
+	{
+	  error_at (make_location_t (loc),
+		    "%<object.TypeInfo%> could not be found, "
+		    "but is implicitly used");
+	  warnloc = loc;
+	}
+    }
+}
+
+/* Returns typeinfo reference for TYPE.  */
+
+tree
+build_typeinfo (const Loc &loc, Type *type)
+{
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, NULL);
   create_typeinfo (type, NULL);
   return build_address (get_typeinfo_decl (type->vtinfo));
 }
@@ -1375,6 +1424,9 @@ build_typeinfo (const Loc &loc, Type *type)
 void
 layout_cpp_typeinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   gcc_assert (cd->isCPPclass ());
 
   tree decl = get_cpp_typeinfo_decl (cd);
@@ -1443,6 +1495,9 @@ get_cpp_typeinfo_decl (ClassDeclaration *decl)
 void
 create_typeinfo (Type *type, Module *mod)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   /* Do this since not all Type's are merged.  */
   Type *t = type->merge2 ();
   Identifier *ident;
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 7b5f6e03d9f..f61f8c541e0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -12484,7 +12484,8 @@ The option cannot be combined with @option{-fsanitize=thread}.
 @opindex fsanitize=undefined
 Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector.
 Various computations are instrumented to detect undefined behavior
-at runtime.  Current suboptions are:
+at runtime.  See @uref{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html} for more details.   The run-time behavior can be influenced using the
+@env{UBSAN_OPTIONS} environment variable.  Current suboptions are:
 
 @table @gcctabopt
 
@@ -12764,7 +12765,8 @@ which functions and calls should be skipped from instrumentation
 (@pxref{Function Attributes}).
 
 Currently the x86 GNU/Linux target provides an implementation based
-on Intel Control-flow Enforcement Technology (CET).
+on Intel Control-flow Enforcement Technology (CET) which works for
+i686 processor or newer.
 
 @item -fstack-protector
 @opindex fstack-protector
@@ -15858,6 +15860,7 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
 @samp{cortex-a76}, @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
 @samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1},
+@samp{neoverse-512tvb},
 @samp{qdf24xx}, @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
 @samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
 @samp{a64fx},
@@ -15874,6 +15877,15 @@ The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55} specify that GCC
 should tune for a big.LITTLE system.
 
+The value @samp{neoverse-512tvb} specifies that GCC should tune
+for Neoverse cores that (a) implement SVE and (b) have a total vector
+bandwidth of 512 bits per cycle.  In other words, the option tells GCC to
+tune for Neoverse cores that can execute 4 128-bit Advanced SIMD arithmetic
+instructions a cycle and that can execute an equivalent number of SVE
+arithmetic instructions per cycle (2 for 256-bit SVE, 4 for 128-bit SVE).
+This is more general than tuning for a specific core like Neoverse V1
+but is more specific than the default tuning described below.
+
 Additionally on native AArch64 GNU/Linux systems the value
 @samp{native} tunes performance to the host system.  This option has no effect
 if the compiler is unable to recognize the processor of the host system.
@@ -15903,6 +15915,16 @@ by @option{-mtune}).  Where this option is used in conjunction
 with @option{-march} or @option{-mtune}, those options take precedence
 over the appropriate part of this option.
 
+@option{-mcpu=neoverse-512tvb} is special in that it does not refer
+to a specific core, but instead refers to all Neoverse cores that
+(a) implement SVE and (b) have a total vector bandwidth of 512 bits
+a cycle.  Unless overridden by @option{-march},
+@option{-mcpu=neoverse-512tvb} generates code that can run on a
+Neoverse V1 core, since Neoverse V1 is the first Neoverse core with
+these properties.  Unless overridden by @option{-mtune},
+@option{-mcpu=neoverse-512tvb} tunes code in the same way as for
+@option{-mtune=neoverse-512tvb}.
+
 @item -moverride=@var{string}
 @opindex moverride
 Override tuning decisions made by the back-end in response to a
@@ -29379,8 +29401,7 @@ Substitute the contents of spec string @var{name} at this point.
 Accumulate an option for @samp{%X}.
 
 @item %X
-Output the accumulated linker options specified by @option{-Wl} or a @samp{%x}
-spec string.
+Output the accumulated linker options specified by a @samp{%x} spec string.
 
 @item %Y
 Output the accumulated assembler options specified by @option{-Wa}.
diff --git a/gcc/doc/trouble.texi b/gcc/doc/trouble.texi
index 693912ea355..aaee8fba6bb 100644
--- a/gcc/doc/trouble.texi
+++ b/gcc/doc/trouble.texi
@@ -865,10 +865,11 @@ objects behave unspecified when being assigned.  For example:
 @smallexample
 struct Base@{
   char *name;
-  Base(char *n) : name(strdup(n))@{@}
+  Base(const char *n) : name(strdup(n))@{@}
   Base& operator= (const Base& other)@{
    free (name);
    name = strdup (other.name);
+   return *this;
   @}
 @};
 
@@ -901,8 +902,8 @@ inside @samp{func} in the example).
 G++ implements the ``intuitive'' algorithm for copy-assignment: assign all
 direct bases, then assign all members.  In that algorithm, the virtual
 base subobject can be encountered more than once.  In the example, copying
-proceeds in the following order: @samp{val}, @samp{name} (via
-@code{strdup}), @samp{bval}, and @samp{name} again.
+proceeds in the following order: @samp{name} (via @code{strdup}),
+@samp{val}, @samp{name} again, and @samp{bval}.
 
 If application code relies on copy-assignment, a user-defined
 copy-assignment operator removes any uncertainties.  With such an
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index a7eff832ff6..04087938276 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -510,7 +510,7 @@ negate_expr_p (tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    return true;
 	}
       break;
@@ -703,7 +703,7 @@ fold_negate_expr_1 (location_t loc, tree t)
       if (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)
 	{
 	  tree op1 = TREE_OPERAND (t, 1);
-	  if (wi::to_wide (op1) == TYPE_PRECISION (type) - 1)
+	  if (wi::to_wide (op1) == element_precision (type) - 1)
 	    {
 	      tree ntype = TYPE_UNSIGNED (type)
 			   ? signed_type_for (type)
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index f1d66e38980..89b7ea88d9a 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,240 @@
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* array.c (gfc_ref_dimen_size): Do not generate internal error on
+	failed simplification of stride expression; just return failure.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* array.c (spec_dimen_size): Fix simplification of SHAPE:
+	dimensions must be non-negative.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* resolve.c (resolve_fl_procedure): Do not access CLASS components
+	before class container has been built.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* frontend-passes.c (doloop_code): Prevent NULL pointer
+	dereference when checking for passing a do-loop variable to a
+	contained procedure with an interface mismatch.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* frontend-passes.c (do_subscript): Ensure that array bounds are
+	of type INTEGER before performing checks on array subscripts.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* simplify.c (simplify_bound): Do not try to simplify
+	LBOUND/UBOUND for arrays with POINTER or ALLOCATABLE attribute.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* expr.c (find_array_element): When bounds cannot be determined as
+	constant, return error instead of aborting.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* trans-expr.c (gfc_conv_substring): Do not generate substring
+	bounds check for implied do loop index variable before it actually
+	becomes defined.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* decl.c (add_init_expr_to_sym): For proper initialization of
+	array-valued named constants the array bounds need to be
+	simplified before adding the initializer.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* expr.c (find_substring_ref): Handle given substring start and
+	end indices as signed integers, not unsigned.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* trans-expr.c (gfc_conv_procedure_call): Wrap deallocation of
+	allocatable components of optional allocatable derived type
+	procedure arguments with INTENT(OUT) into a presence check.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* primary.c (build_actual_constructor): Missing allocatable
+	components are set unallocated using EXPR_NULL. Then missing
+	components are tested for a default initializer.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* trans-intrinsic.c (gfc_conv_associated): Do not add a _data
+	component for scalar class function targets. Instead, fix the
+	function result and access the _data from that.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* resolve.c (find_array_spec): Put static prototype for
+	resolve_assoc_var before this function and call for associate
+	variables.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* trans-array.c (gfc_conv_expr_descriptor): Include elemental
+	procedure pointers in the assert under the comment 'elemental
+	function' and eliminate the second, spurious assert.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* trans-decl.c (gfc_get_symbol_decl): Replace test for host
+	association with a check that the current and symbol namespaces
+	are the same.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* class.c (gfc_build_class_symbol): Remove the error that
+	disables assumed size class arrays. Class array types that are
+	not deferred shape or assumed rank are given a unique name and
+	placed in the procedure namespace.
+	* trans-array.c (gfc_trans_g77_array): Obtain the data pointer
+	for class arrays.
+	(gfc_trans_dummy_array_bias): Suppress the runtime error for
+	extent violations in explicit shape class arrays because it
+	always fails.
+	* trans-expr.c (gfc_conv_procedure_call): Handle assumed size
+	class actual arguments passed to non-descriptor formal args by
+	using the data pointer, stored as the symbol's backend decl.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* trans-array.c (gfc_conv_expr_descriptor): For deferred length
+	length components use the ss_info string length instead of
+	gfc_get_expr_charlen. Make sure that the deferred string length
+	is a variable before assigning to it. Otherwise use the expr.
+	* trans-expr.c (gfc_conv_string_length): Make sure that the
+	deferred string length is a variable before assigning to it.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* trans-expr.c (gfc_conv_procedure_call): Suppress the call to
+	gfc_conv_intrinsic_to_class for unlimited polymorphic procedure
+	pointers.
+	(gfc_trans_assignment_1): Similarly suppress class assignment
+	for class valued procedure pointers.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* trans-expr.c (gfc_conv_component_ref): Remove the condition
+	that deferred character length components only be allocatable.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* trans-expr.c (gfc_trans_class_init_assign): Call
+	gfc_conv_expr_present only for dummy variables.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* frontend-passes.c (traverse_io_block): Adjust test for
+	when a variable is eligible for the transformation to
+	array slice.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* frontend-passes.c (inline_matmul_assign): Do not inline matmul
+	if the assignment to the resulting array if it is not of canonical
+	type (real/integer/complex/logical).
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 017334839ed..c5d813a2dc3 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -2224,8 +2224,7 @@ gfc_copy_iterator (gfc_iterator *src)
 /********* Subroutines for determining the size of an array *********/
 
 /* These are needed just to accommodate RESHAPE().  There are no
-   diagnostics here, we just return a negative number if something
-   goes wrong.  */
+   diagnostics here, we just return false if something goes wrong.  */
 
 
 /* Get the size of single dimension of an array specification.  The
@@ -2254,6 +2253,9 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)
 
   mpz_add_ui (*result, *result, 1);
 
+  if (mpz_cmp_si (*result, 0) < 0)
+    mpz_set_si (*result, 0);
+
   return true;
 }
 
@@ -2327,12 +2329,11 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)
 	{
 	  stride_expr = gfc_copy_expr(ar->stride[dimen]); 
 
-	  if(!gfc_simplify_expr(stride_expr, 1))
-	    gfc_internal_error("Simplification error");
-
-	  if (stride_expr->expr_type != EXPR_CONSTANT
-	      || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
+	  if (!gfc_simplify_expr (stride_expr, 1)
+	     || stride_expr->expr_type != EXPR_CONSTANT
+	     || mpz_cmp_ui (stride_expr->value.integer, 0) == 0)
 	    {
+	      gfc_free_expr (stride_expr);
 	      mpz_clear (stride);
 	      return false;
 	    }
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 1a5bcfae3c0..928a50a6cd1 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -613,6 +613,7 @@ gfc_get_len_component (gfc_expr *e, int k)
    component '_vptr' which determines the dynamic type.  When this CLASS
    entity is unlimited polymorphic, then also add a component '_len' to
    store the length of string when that is stored in it.  */
+static int ctr = 0;
 
 bool
 gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
@@ -628,13 +629,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
 
   gcc_assert (as);
 
-  if (*as && (*as)->type == AS_ASSUMED_SIZE)
-    {
-      gfc_error ("Assumed size polymorphic objects or components, such "
-		 "as that at %C, have not yet been implemented");
-      return false;
-    }
-
   if (attr->class_ok)
     /* Class container has already been built.  */
     return true;
@@ -672,7 +666,30 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,
   else
     ns = ts->u.derived->ns;
 
-  gfc_find_symbol (name, ns, 0, &fclass);
+  /* Although this might seem to be counterintuitive, we can build separate
+     class types with different array specs because the TKR interface checks
+     work on the declared type. All array type other than deferred shape or
+     assumed rank are added to the function namespace to ensure that they
+     are properly distinguished.  */
+  if (attr->dummy && !attr->codimension && (*as)
+      && !((*as)->type == AS_DEFERRED || (*as)->type == AS_ASSUMED_RANK))
+    {
+      char *sname;
+      ns = gfc_current_ns;
+      gfc_find_symbol (name, ns, 0, &fclass);
+      /* If a local class type with this name already exists, update the
+	 name with an index.  */
+      if (fclass)
+	{
+	  fclass = NULL;
+	  sname = xasprintf ("%s_%d", name, ++ctr);
+	  free (name);
+	  name = sname;
+	}
+    }
+  else
+    gfc_find_symbol (name, ns, 0, &fclass);
+
   if (fclass == NULL)
     {
       gfc_symtree *st;
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 00321da827e..51238e49fb1 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -2043,6 +2043,24 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	  sym->as->type = AS_EXPLICIT;
 	}
 
+      /* Ensure that explicit bounds are simplified.  */
+      if (sym->attr.flavor == FL_PARAMETER && sym->attr.dimension
+	  && sym->as->type == AS_EXPLICIT)
+	{
+	  for (int dim = 0; dim < sym->as->rank; ++dim)
+	    {
+	      gfc_expr *e;
+
+	      e = sym->as->lower[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+
+	      e = sym->as->upper[dim];
+	      if (e->expr_type != EXPR_CONSTANT)
+		gfc_reduce_init_expr (e);
+	    }
+	}
+
       /* Need to check if the expression we initialized this
 	 to was one of the iso_c_binding named constants.  If so,
 	 and we're a parameter (constant), let it be iso_c.
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 019245a3ab8..f099da98ab0 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1330,7 +1330,9 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
   for (i = 0; i < ar->dimen; i++)
     {
       if (!gfc_reduce_init_expr (ar->as->lower[i])
-	  || !gfc_reduce_init_expr (ar->as->upper[i]))
+	  || !gfc_reduce_init_expr (ar->as->upper[i])
+	  || ar->as->upper[i]->expr_type != EXPR_CONSTANT
+	  || ar->as->lower[i]->expr_type != EXPR_CONSTANT)
 	{
 	  t = false;
 	  cons = NULL;
@@ -1344,9 +1346,6 @@ find_array_element (gfc_constructor_base base, gfc_array_ref *ar,
 	  goto depart;
 	}
 
-      gcc_assert (ar->as->upper[i]->expr_type == EXPR_CONSTANT
-		  && ar->as->lower[i]->expr_type == EXPR_CONSTANT);
-
       /* Check the bounds.  */
       if ((ar->as->upper[i]
 	   && mpz_cmp (e->value.integer,
@@ -1718,8 +1717,8 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)
   *newp = gfc_copy_expr (p);
   free ((*newp)->value.character.string);
 
-  end = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.end->value.integer);
-  start = (gfc_charlen_t) mpz_get_ui (p->ref->u.ss.start->value.integer);
+  end = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.end->value.integer);
+  start = (gfc_charlen_t) mpz_get_si (p->ref->u.ss.start->value.integer);
   if (end >= start)
     length = end - start + 1;
   else
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index ff71b44b409..7b0428d27f2 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1301,8 +1301,8 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)
 		std::swap (start->value.op.op1, start->value.op.op2);
 	      gcc_fallthrough ();
 	    case INTRINSIC_MINUS:
-	      if ((start->value.op.op1->expr_type!= EXPR_VARIABLE
-		   && start->value.op.op2->expr_type != EXPR_CONSTANT)
+	      if (start->value.op.op1->expr_type!= EXPR_VARIABLE
+		  || start->value.op.op2->expr_type != EXPR_CONSTANT
 		  || start->value.op.op1->ref)
 		return false;
 	      if (!stack_top || !stack_top->iter
@@ -2416,7 +2416,7 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
 
 	      do_sym = cl->ext.iterator->var->symtree->n.sym;
 
-	      if (a->expr && a->expr->symtree
+	      if (a->expr && a->expr->symtree && f->sym
 		  && a->expr->symtree->n.sym == do_sym)
 		{
 		  if (f->sym->attr.intent == INTENT_OUT)
@@ -2679,6 +2679,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2688,6 +2689,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			    gfc_warning (warn, "Array reference at %L out of bounds "
 					 "(%ld > %ld) in loop beginning at %L",
@@ -2703,6 +2705,7 @@ do_subscript (gfc_expr **e)
 		    {
 		      if (ar->as->lower[i]
 			  && ar->as->lower[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->lower[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->lower[i]->value.integer) < 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld < %ld) in loop beginning at %L",
@@ -2712,6 +2715,7 @@ do_subscript (gfc_expr **e)
 
 		      if (ar->as->upper[i]
 			  && ar->as->upper[i]->expr_type == EXPR_CONSTANT
+			  && ar->as->upper[i]->ts.type == BT_INTEGER
 			  && mpz_cmp (val, ar->as->upper[i]->value.integer) > 0)
 			gfc_warning (warn, "Array reference at %L out of bounds "
 				     "(%ld > %ld) in loop beginning at %L",
@@ -3921,6 +3925,19 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,
   if (m_case == none)
     return 0;
 
+  /* We only handle assignment to numeric or logical variables.  */
+  switch(expr1->ts.type)
+    {
+    case BT_INTEGER:
+    case BT_LOGICAL:
+    case BT_REAL:
+    case BT_COMPLEX:
+      break;
+
+    default:
+      return 0;
+    }
+
   ns = insert_block ();
 
   /* Assign the type of the zero expression for initializing the resulting
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index cbd84bb0abc..1e1f16ebacf 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -3023,26 +3023,36 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,
 	  continue;
 	}
 
-      /* If it was not found, try the default initializer if there's any;
+      /* If it was not found, apply NULL expression to set the component as
+	 unallocated. Then try the default initializer if there's any;
 	 otherwise, it's an error unless this is a deferred parameter.  */
       if (!comp_iter)
 	{
-	  if (comp->initializer)
-	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
-				   "with missing optional arguments at %C"))
-		return false;
-	      value = gfc_copy_expr (comp->initializer);
-	    }
-	  else if (comp->attr.allocatable
-		   || (comp->ts.type == BT_CLASS
-		       && CLASS_DATA (comp)->attr.allocatable))
+	  /* F2018 7.5.10: If an allocatable component has no corresponding
+	     component-data-source, then that component has an allocation
+	     status of unallocated....  */
+	  if (comp->attr.allocatable
+	      || (comp->ts.type == BT_CLASS
+		  && CLASS_DATA (comp)->attr.allocatable))
 	    {
 	      if (!gfc_notify_std (GFC_STD_F2008, "No initializer for "
 				   "allocatable component %qs given in the "
 				   "structure constructor at %C", comp->name))
 		return false;
+	      value = gfc_get_null_expr (&gfc_current_locus);
+	    }
+	  /* ....(Preceeding sentence) If a component with default
+	     initialization has no corresponding component-data-source, then
+	     the default initialization is applied to that component.  */
+	  else if (comp->initializer)
+	    {
+	      if (!gfc_notify_std (GFC_STD_F2003, "Structure constructor "
+				   "with missing optional arguments at %C"))
+		return false;
+	      value = gfc_copy_expr (comp->initializer);
 	    }
+	  /* Do not trap components such as the string length for deferred
+	     length character components.  */
 	  else if (!comp->attr.artificial)
 	    {
 	      gfc_error ("No initializer for component %qs given in the"
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 1c72e0db9ea..189eac82e5a 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -4736,6 +4736,8 @@ gfc_resolve_dim_arg (gfc_expr *dim)
    base symbol.  We traverse the list of reference structures, setting
    the stored reference to references.  Component references can
    provide an additional array specification.  */
+static void
+resolve_assoc_var (gfc_symbol* sym, bool resolve_target);
 
 static void
 find_array_spec (gfc_expr *e)
@@ -4745,6 +4747,13 @@ find_array_spec (gfc_expr *e)
   gfc_ref *ref;
   bool class_as = false;
 
+  if (e->symtree->n.sym->assoc)
+    {
+      if (e->symtree->n.sym->assoc->target)
+	gfc_resolve_expr (e->symtree->n.sym->assoc->target);
+      resolve_assoc_var (e->symtree->n.sym, false);
+    }
+
   if (e->symtree->n.sym->ts.type == BT_CLASS)
     {
       as = CLASS_DATA (e->symtree->n.sym)->as;
@@ -12735,7 +12744,8 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 
   /* An elemental function is required to return a scalar 12.7.1  */
   if (sym->attr.elemental && sym->attr.function
-      && (sym->as || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)))
+      && (sym->as || (sym->ts.type == BT_CLASS && sym->attr.class_ok
+		      && CLASS_DATA (sym)->as)))
     {
       gfc_error ("ELEMENTAL function %qs at %L must have a scalar "
 		 "result", sym->name, &sym->declared_at);
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 2004895fbe3..db74925badc 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -4197,6 +4197,12 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)
 	     || (as->type == AS_ASSUMED_SHAPE && upper)))
     return NULL;
 
+  /* 'array' shall not be an unallocated allocatable variable or a pointer that
+     is not associated.  */
+  if (array->expr_type == EXPR_VARIABLE
+      && (gfc_expr_attr (array).allocatable || gfc_expr_attr (array).pointer))
+    return NULL;
+
   gcc_assert (!as
 	      || (as->type != AS_DEFERRED
 		  && array->expr_type == EXPR_VARIABLE
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index c6efe95e236..d6315624f2c 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -6609,7 +6609,14 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)
   /* Set the pointer itself if we aren't using the parameter directly.  */
   if (TREE_CODE (parm) != PARM_DECL)
     {
-      tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));
+      tmp = GFC_DECL_SAVED_DESCRIPTOR (parm);
+      if (sym->ts.type == BT_CLASS)
+	{
+	  tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	  tmp = gfc_class_data_get (tmp);
+	  tmp = gfc_conv_descriptor_data_get (tmp);
+	}
+      tmp = convert (TREE_TYPE (parm), tmp);
       gfc_add_modify (&init, parm, tmp);
     }
   stmt = gfc_finish_block (&init);
@@ -6705,7 +6712,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,
       && VAR_P (sym->ts.u.cl->backend_decl))
     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);
 
-  checkparm = (as->type == AS_EXPLICIT
+  /* TODO: Fix the exclusion of class arrays from extent checking.  */
+  checkparm = (as->type == AS_EXPLICIT && !is_classarray
 	       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));
 
   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)
@@ -7521,9 +7529,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
 			 && expr->value.function.esym->attr.elemental)
 			|| (expr->value.function.isym != NULL
 			    && expr->value.function.isym->elemental)
+			|| (gfc_expr_attr (expr).proc_pointer
+			    && gfc_expr_attr (expr).elemental)
 			|| gfc_inline_intrinsic_function_p (expr));
-	  else
-	    gcc_assert (ss_type == GFC_SS_INTRINSIC);
 
 	  need_tmp = 1;
 	  if (expr->ts.type == BT_CHARACTER
@@ -7712,15 +7720,21 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
       /* Set the string_length for a character array.  */
       if (expr->ts.type == BT_CHARACTER)
 	{
-	  se->string_length =  gfc_get_expr_charlen (expr);
+	  if (deferred_array_component)
+	    se->string_length = ss_info->string_length;
+	  else
+	    se->string_length =  gfc_get_expr_charlen (expr);
+
 	  if (VAR_P (se->string_length)
 	      && expr->ts.u.cl->backend_decl == se->string_length)
 	    tmp = ss_info->string_length;
 	  else
 	    tmp = se->string_length;
 
-	  if (expr->ts.deferred)
+	  if (expr->ts.deferred && VAR_P (expr->ts.u.cl->backend_decl))
 	    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl, tmp);
+	  else
+	    expr->ts.u.cl->backend_decl = tmp;
 	}
 
       /* If we have an array section or are assigning make sure that
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index fb957d187d3..99772db9ca1 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1506,7 +1506,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)
      declaration of the entity and memory allocated/deallocated.  */
   if ((sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
       && sym->param_list != NULL
-      && !(sym->attr.host_assoc || sym->attr.use_assoc || sym->attr.dummy))
+      && gfc_current_ns == sym->ns
+      && !(sym->attr.use_assoc || sym->attr.dummy))
     gfc_defer_symbol_init (sym);
 
   /* Dummy PDT 'len' parameters should be checked when they are explicit.  */
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index 9be8dd185bf..e240441ac2c 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1655,8 +1655,9 @@ gfc_trans_class_init_assign (gfc_code *code)
 	}
     }
 
-  if (code->expr1->symtree->n.sym->attr.optional
-      || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master)
+  if (code->expr1->symtree->n.sym->attr.dummy
+      && (code->expr1->symtree->n.sym->attr.optional
+	  || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master))
     {
       tree present = gfc_conv_expr_present (code->expr1->symtree->n.sym);
       tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),
@@ -2470,7 +2471,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)
 			     se.expr, build_zero_cst (TREE_TYPE (se.expr)));
   gfc_add_block_to_block (pblock, &se.pre);
 
-  if (cl->backend_decl)
+  if (cl->backend_decl && VAR_P (cl->backend_decl))
     gfc_add_modify (pblock, cl->backend_decl, se.expr);
   else
     cl->backend_decl = gfc_evaluate_now (se.expr, pblock);
@@ -2530,7 +2531,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,
   if (!CONSTANT_CLASS_P (tmp) && !DECL_P (tmp))
     end.expr = gfc_evaluate_now (end.expr, &se->pre);
 
-  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+  if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
+      && (ref->u.ss.start->symtree
+	  && !ref->u.ss.start->symtree->n.sym->attr.implied_index))
     {
       tree nonempty = fold_build2_loc (input_location, LE_EXPR,
 				       logical_type_node, start.expr,
@@ -2663,7 +2666,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   /* Allocatable deferred char arrays are to be handled by the gfc_deferred_
      strlen () conditional below.  */
   if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-      && !(c->attr.allocatable && c->ts.deferred)
+      && !c->ts.deferred
       && !c->attr.pdt_string)
     {
       tmp = c->ts.u.cl->backend_decl;
@@ -5566,7 +5569,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				     CLASS_DATA (fsym)->attr.class_pointer
 				     || CLASS_DATA (fsym)->attr.allocatable);
 	}
-      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS)
+      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS
+	       && gfc_expr_attr (e).flavor != FL_PROCEDURE)
 	{
 	  /* The intrinsic type needs to be converted to a temporary
 	     CLASS object for the unlimited polymorphic formal.  */
@@ -6159,6 +6163,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
+	      else if (e->ts.type == BT_CLASS && CLASS_DATA (e)->as
+		       && CLASS_DATA (e)->as->type == AS_ASSUMED_SIZE
+		       && nodesc_arg && fsym->ts.type == BT_DERIVED)
+		/* An assumed size class actual argument being passed to
+		   a 'no descriptor' formal argument just requires the
+		   data pointer to be passed. For class dummy arguments
+		   this is stored in the symbol backend decl..  */
+		parmse.expr = e->symtree->n.sym->backend_decl;
+
 	      else if (gfc_is_class_array_ref (e, NULL)
 		       && fsym && fsym->ts.type == BT_DERIVED)
 		/* The actual argument is a component reference to an
@@ -6229,6 +6242,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    // deallocate the components first
 		    tmp = gfc_deallocate_alloc_comp (fsym->ts.u.derived,
 						     parmse.expr, e->rank);
+		    /* But check whether dummy argument is optional.  */
+		    if (tmp != NULL_TREE
+			&& fsym->attr.optional
+			&& e->expr_type == EXPR_VARIABLE
+			&& e->symtree->n.sym->attr.optional)
+		      {
+			tree present;
+			present = gfc_conv_expr_present (e->symtree->n.sym);
+			tmp = build3_v (COND_EXPR, present, tmp,
+					build_empty_stmt (input_location));
+		      }
 		    if (tmp != NULL_TREE)
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		  }
@@ -10806,7 +10830,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 		       || gfc_is_class_array_ref (expr1, NULL)
 		       || gfc_is_class_scalar_expr (expr1)
 		       || gfc_is_class_array_ref (expr2, NULL)
-		       || gfc_is_class_scalar_expr (expr2));
+		       || gfc_is_class_scalar_expr (expr2))
+		   && lhs_attr.flavor != FL_PROCEDURE;
 
   realloc_flag = flag_realloc_lhs
 		 && gfc_is_reallocatable_lhs (expr1)
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 1b51e870f04..729f933ac11 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -8473,7 +8473,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
   else
     {
       /* An optional target.  */
-      if (arg2->expr->ts.type == BT_CLASS)
+      if (arg2->expr->ts.type == BT_CLASS
+	  && arg2->expr->expr_type != EXPR_FUNCTION)
 	gfc_add_data_component (arg2->expr);
 
       nonzero_charlen = NULL_TREE;
@@ -8501,6 +8502,11 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)
 	      && arg2->expr->symtree->n.sym->attr.dummy)
 	    arg2se.expr = build_fold_indirect_ref_loc (input_location,
 						       arg2se.expr);
+	  if (arg2->expr->ts.type == BT_CLASS)
+	    {
+	      arg2se.expr = gfc_evaluate_now (arg2se.expr, &arg2se.pre);
+	      arg2se.expr = gfc_class_data_get (arg2se.expr);
+	    }
 	  gfc_add_block_to_block (&se->pre, &arg1se.pre);
 	  gfc_add_block_to_block (&se->post, &arg1se.post);
 	  gfc_add_block_to_block (&se->pre, &arg2se.pre);
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index 408b93b2200..aea4ea0c6e8 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -434,7 +434,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)
 					   CONSTRUCTOR_ELTS (rhs));
 	  }
 
-	else if (DECL_P (rhs))
+	else if (DECL_P (rhs)
+		 && is_gimple_reg_type (TREE_TYPE (rhs)))
 	  return get_symbol_constant_value (rhs);
       }
       break;
diff --git a/gcc/gimple-loop-interchange.cc b/gcc/gimple-loop-interchange.cc
index b188ce86d5e..d10089b8c22 100644
--- a/gcc/gimple-loop-interchange.cc
+++ b/gcc/gimple-loop-interchange.cc
@@ -1042,7 +1042,10 @@ tree_loop_interchange::valid_data_dependences (unsigned i_idx, unsigned o_idx,
 
 	  /* Be conservative, skip case if either direction at i_idx/o_idx
 	     levels is not '=' or '<'.  */
-	  if (dist_vect[i_idx] < 0 || dist_vect[o_idx] < 0)
+	  if ((!DDR_REVERSED_P (ddr) && dist_vect[i_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[i_idx] > 0)
+	      || (!DDR_REVERSED_P (ddr) && dist_vect[o_idx] < 0)
+	      || (DDR_REVERSED_P (ddr) && dist_vect[o_idx] > 0))
 	    return false;
 	}
     }
diff --git a/gcc/gimple-ssa-evrp-analyze.c b/gcc/gimple-ssa-evrp-analyze.c
index bb4e2d6e798..3a6956c59c6 100644
--- a/gcc/gimple-ssa-evrp-analyze.c
+++ b/gcc/gimple-ssa-evrp-analyze.c
@@ -217,7 +217,11 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)
 	      push_value_range (vrs[i].first, vrs[i].second);
 	      if (is_fallthru
 		  && m_update_global_ranges
-		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt))
+		  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt)
+		  /* The condition must post-dominate the definition point.  */
+		  && (SSA_NAME_IS_DEFAULT_DEF (vrs[i].first)
+		      || (gimple_bb (SSA_NAME_DEF_STMT (vrs[i].first))
+			  == pred_e->src)))
 		{
 		  set_ssa_range_info (vrs[i].first, vrs[i].second);
 		  maybe_set_nonzero_bits (pred_e, vrs[i].first);
diff --git a/gcc/ipa-fnsummary.c b/gcc/ipa-fnsummary.c
index 7c5562ad801..2b8c21ddd4f 100644
--- a/gcc/ipa-fnsummary.c
+++ b/gcc/ipa-fnsummary.c
@@ -3319,13 +3319,20 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,
       bp = streamer_read_bitpack (&ib);
       if (info)
 	{
-          info->inlinable = bp_unpack_value (&bp, 1);
-          info->fp_expressions = bp_unpack_value (&bp, 1);
+	  info->inlinable = bp_unpack_value (&bp, 1);
+	  /* On the side of streaming out, there is still one bit
+	     streamed out between inlinable and fp_expressions bits,
+	     which was used for cilk+ before but now always false.
+	     To remove the bit packing need to bump LTO minor version,
+	     so unpack a dummy bit here to keep consistent instead.  */
+	  bp_unpack_value (&bp, 1);
+	  info->fp_expressions = bp_unpack_value (&bp, 1);
 	}
       else
 	{
-          bp_unpack_value (&bp, 1);
-          bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
+	  bp_unpack_value (&bp, 1);
 	}
 
       count2 = streamer_read_uhwi (&ib);
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index 0c6f84ff72d..1cc69cd05d7 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -1654,9 +1654,9 @@ propagate_pure_const (void)
 	  if (w_l->state_previously_known != IPA_NEITHER
 	      && this_state > w_l->state_previously_known)
 	    {
-              this_state = w_l->state_previously_known;
 	      if (this_state == IPA_NEITHER)
-	        this_looping = w_l->looping_previously_known;
+		this_looping = w_l->looping_previously_known;
+	      this_state = w_l->state_previously_known;
 	    }
 	  if (!this_looping && self_recursive_p (w))
 	    this_looping = true;
diff --git a/gcc/jit/ChangeLog b/gcc/jit/ChangeLog
index 56168ba677a..61067c2ff13 100644
--- a/gcc/jit/ChangeLog
+++ b/gcc/jit/ChangeLog
@@ -1,3 +1,10 @@
+2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-11-24  Martin Liska  <mliska@suse.cz>
+
+	* jit-playback.c (function): Initialize m_blocks vector.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/jit/jit-playback.c b/gcc/jit/jit-playback.c
index b74495c58b2..ebdb56cbc6d 100644
--- a/gcc/jit/jit-playback.c
+++ b/gcc/jit/jit-playback.c
@@ -1287,7 +1287,8 @@ function (context *ctxt,
 : m_ctxt(ctxt),
   m_inner_fndecl (fndecl),
   m_inner_bind_expr (NULL),
-  m_kind (kind)
+  m_kind (kind),
+  m_blocks ()
 {
   if (m_kind != GCC_JIT_FUNCTION_IMPORTED)
     {
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 47eac19a1f6..7b08b2935f3 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,476 @@
+2022-01-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97953
+	* gcc.dg/pr97953.c: New testcase.
+
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* gfortran.dg/intrinsic_pack_6.f90: New test.
+
+2021-12-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103588
+	* gfortran.dg/pr103588.f90: New test.
+
+2021-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103610
+	* gfortran.dg/shape_11.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103606
+	* gfortran.dg/pr103606.f90: New test.
+
+2021-12-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103717
+	* gfortran.dg/do_check_19.f90: New test.
+
+2021-12-15  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2021-11-30  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/102347
+	* gcc.target/powerpc/pr102347.c: New test.
+
+2021-12-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103607
+	* gfortran.dg/pr103607.f90: New test.
+
+2021-11-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-11-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103392
+	* gfortran.dg/bound_simplification_7.f90: New test.
+
+2021-11-25  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-20  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/103052
+	* gcc.c-torture/execute/pr103052.c: New test.
+
+2021-11-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101985
+	* gcc.target/powerpc/pr101985-1.c: New.
+	* gcc.target/powerpc/pr101985-2.c: New.
+
+2021-11-22  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2021-11-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/20211119.c: New test.
+
+2021-11-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100672
+	* gcc.dg/torture/pr100672.c: New testcase.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101373
+	PR tree-optimization/101868
+	* gcc.dg/lto/pr101868_0.c: New testcase.
+	* gcc.dg/lto/pr101868_1.c: Likewise.
+	* gcc.dg/lto/pr101868_2.c: Likewise.
+	* gcc.dg/lto/pr101868_3.c: Likewise.
+
+2021-11-08  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/101824
+	* gcc.dg/tree-ssa/pr101824.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101173
+	PR tree-optimization/101280
+	* gcc.dg/torture/pr101173.c: New testcase.
+	* gcc.dg/tree-ssa/loop-interchange-16.c: New file.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101394
+	* gcc.dg/torture/pr101394.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/101105
+	* gcc.dg/torture/pr101105.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/100934
+	* gcc.dg/torture/pr100934.c: New testcase.
+
+2021-10-13  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/100509
+	* gcc.dg/pr100509.c: New testcase.
+
+2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2021-10-11  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/102622
+	* gcc.c-torture/execute/bitfld-10.c: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/101327
+	* gfortran.dg/pr101327.f90: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98490
+	* gfortran.dg/bounds_check_23.f90: New test.
+
+2021-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82314
+	* gfortran.dg/pr82314.f90: New test.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-13  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85130
+	* gfortran.dg/substr_6.f90: Revert commit r8-7574, adding again
+	test that was erroneously considered as illegal.
+
+2021-09-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/102287
+	* gfortran.dg/intent_out_14.f90: New test.
+
+2021-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20210917-1.c: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/97612
+	* gfortran.dg/structure_constructor_17.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-22  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98565
+	* gfortran.dg/associated_target_7.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93701
+	* gfortran.dg/associate_54.f90: New test.
+	* gfortran.dg/associate_55.f90: New test.
+	* gfortran.dg/associate_56.f90: New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98472
+	* gfortran.dg/elemental_function_5.f90 : New test.
+
+2021-09-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-04-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/100110
+	* gfortran.dg/pdt_31.f03: New test.
+	* gfortran.dg/pdt_26.f03: Reduce 'builtin_malloc' count from 9
+	to 8.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-05-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/46691
+	PR fortran/99819
+	* gfortran.dg/class_dummy_6.f90: New test.
+	* gfortran.dg/class_dummy_7.f90: New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99125
+	* gfortran.dg/alloc_deferred_comp_1.f90: New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93924
+	PR fortran/93925
+	* gfortran.dg/proc_ptr_52.f90 : New test.
+
+2021-09-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93794
+	* gfortran.dg/deferred_character_35.f90 : New test.
+
+2021-08-25  konglin1  <lingling.kong@intel.com>
+
+	PR target/101471
+	* gcc.target/i386/avx512f-pr101471.c: New test.
+
+2021-08-23  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	Backported from master:
+	2021-08-06  Christophe Lyon  <christophe.lyon@foss.st.com>
+
+	PR target/101723
+	* gcc.target/arm/pr69245.c: Make sure to emit code for fn1, fix
+	typo.
+
+2021-08-23  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2021-08-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/101723
+	* gcc.target/arm/attr-neon.c: Tighten scan-assembler tests.
+	* gcc.target/arm/attr-neon2.c: Likewise.
+	* gcc.target/arm/attr-neon3.c: Likewise.
+	* gcc.target/arm/pr69245.c: Tighten scan-assembler match, but allow
+	multiple instances.
+	* gcc.target/arm/pragma_fpu_attribute.c: Likewise.
+	* gcc.target/arm/pragma_fpu_attribute_2.c: Likewise.
+
+2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/101969
+	* gcc.dg/pr78213.c: Fix up for '--enable-checking=release' etc.
+
+2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-08-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* gcc.dg/pr78213.c: Restore testing.
+
+2021-07-29  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101531
+	* gcc.target/powerpc/pr101129.c: Adjust.
+
+2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96435
+	* gdc.dg/pr96435.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101640
+	* gdc.dg/pr101640.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101490
+	* gdc.dg/pr101490.d: New test.
+	* gdc.test/fail_compilation/fail22144.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101441
+	* gdc.test/compilable/b19002.d: New test.
+
+2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-07-28  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/101127
+	* gdc.dg/pr101127a.d: New test.
+	* gdc.dg/pr101127b.d: New test.
+
+2021-07-20  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/100182
+	* gcc.target/i386/pr71245-1.c: Remove.
+	* gcc.target/i386/pr71245-2.c: Ditto.
+
+2021-07-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/101129
+	* gcc.target/powerpc/pr101129.c: New.
+
+2021-07-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/100949
+	* gfortran.dg/pr100949.f90: New test.
+
+2021-07-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2021-07-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/100227
+	* gfortran.dg/implied_do_io_7.f90: New test.
+
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* gcc.target/i386/pr101175.c: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* gdc.dg/pr100967.d: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* gdc.test/fail_compilation/extra-files/minimal/object.d: New file.
+	* gdc.test/fail_compilation/fail19911a.d: New test.
+	* gdc.test/fail_compilation/fail19911b.d: New test.
+	* gdc.test/fail_compilation/fail19911c.d: New test.
+	* gdc.test/fail_compilation/fail19922.d: New test.
+	* gdc.test/fail_compilation/fail19923.d: New test.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* gdc.test/compilable/betterCarray.d: Add test cases.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* gdc.test/compilable/aggr_alignment.d: Add test cases.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* gdc.dg/pr100882a.d: New test.
+	* gdc.dg/pr100882b.d: New test.
+	* gdc.dg/pr100882c.d: New test.
+	* gdc.dg/pr100882d.d: New test.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* gfortran.dg/inline_matmul_25.f90: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
new file mode 100644
index 00000000000..bdbf5733ce7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bitfld-10.c
@@ -0,0 +1,24 @@
+/* PR tree-optimization/102622 */
+/* Wrong code introduced due to phi-opt
+   introducing undefined signed interger overflow
+   with one bit signed integer negation. */
+
+struct f{signed t:1;};
+int g(struct f *a, int t) __attribute__((noipa));
+int g(struct f *a, int t)
+{
+    if (t)
+      a->t = -1;
+    else
+      a->t = 0;
+    int t1 = a->t;
+    if (t1) return 1;
+    return t1;
+}
+
+int main(void)
+{
+    struct f a;
+    if (!g(&a, 1))  __builtin_abort();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr103052.c b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
new file mode 100644
index 00000000000..bef8674a43c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr103052.c
@@ -0,0 +1,35 @@
+static void js_error(void);
+static int top;
+static void js_throw(void)
+{
+	__builtin_exit(0);
+}
+
+// LOCATION A -- if js_pop is here, the bug is present
+static void js_pop(void)
+{
+	if (++top > 100)
+		js_error();
+}
+
+static void jsC_error(const char *v)
+{
+	if (v[0] == 0)
+		js_error();
+	js_throw();
+}
+static void checkfutureword(const char *exp)
+{
+	if (!__builtin_strcmp(exp, "const"))
+		jsC_error("boom");
+}
+static void js_error(void) {
+	checkfutureword("foo");
+	checkfutureword("bar");
+	js_pop();
+}
+int main(void)
+{
+	checkfutureword("const");
+	__builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_0.c b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
new file mode 100644
index 00000000000..c84d19b0267
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_0.c
@@ -0,0 +1,33 @@
+/* { dg-lto-do run } */
+/* { dg-lto-options { "-O2 -fno-strict-aliasing -flto" } } */
+
+typedef unsigned long VALUE;
+
+__attribute__ ((cold))
+void rb_check_type(VALUE, int);
+
+static VALUE
+repro(VALUE dummy, VALUE hash)
+{
+    if (hash == 0) {
+        rb_check_type(hash, 1);
+    }
+    else if (*(long *)hash) {
+        rb_check_type(hash, 1);
+    }
+
+
+    return *(long *)hash;
+}
+
+static VALUE (*that)(VALUE dummy, VALUE hash) = repro;
+
+int
+main(int argc, char **argv)
+{
+        argc--;
+        that(0, argc);
+
+        rb_check_type(argc, argc);
+
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_1.c b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
new file mode 100644
index 00000000000..146c14abc76
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_1.c
@@ -0,0 +1,23 @@
+typedef unsigned long VALUE;
+
+
+__attribute__ ((noreturn)) void rexc_raise(VALUE mesg);
+
+VALUE rb_donothing(VALUE klass);
+
+static void
+funexpected_type(VALUE x, int xt, int t)
+{
+    rexc_raise(rb_donothing(0));
+}
+
+__attribute__ ((cold))
+void
+rb_check_type(VALUE x, int t)
+{
+    int xt;
+
+    if (x == 0) {
+        funexpected_type(x, xt, t);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_2.c b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
new file mode 100644
index 00000000000..e6f01b23f45
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_2.c
@@ -0,0 +1,11 @@
+typedef unsigned long VALUE;
+
+static void thing(void) {}
+static void (*ptr)(void) = &thing;
+
+VALUE
+rb_donothing(VALUE klass)
+{
+        ptr();
+        return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr101868_3.c b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
new file mode 100644
index 00000000000..61217625be7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr101868_3.c
@@ -0,0 +1,8 @@
+typedef unsigned long VALUE;
+
+__attribute__((noreturn))
+void
+rexc_raise(VALUE mesg)
+{
+        __builtin_exit(0);
+}
diff --git a/gcc/testsuite/gcc.dg/pr100509.c b/gcc/testsuite/gcc.dg/pr100509.c
new file mode 100644
index 00000000000..9405e2a27df
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr100509.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct X {
+  int a;
+};
+const int a = 0;
+static struct X A __attribute__((alias("a")));
+void foo() { struct X b = A; }
diff --git a/gcc/testsuite/gcc.dg/pr78213.c b/gcc/testsuite/gcc.dg/pr78213.c
index ebc2cce78f4..04bf0381f76 100644
--- a/gcc/testsuite/gcc.dg/pr78213.c
+++ b/gcc/testsuite/gcc.dg/pr78213.c
@@ -1,12 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-fself-test" } */
-
-/* When this test was written -fself-test took no argument, but it
-   has subsequently gained a mandatory argument, giving the path
-   to selftest support files (within the srcdir).
-   It's not clear how to provide this path sanely from
-   within DejaGnu, so for now, this test is disabled.  */
-/* { dg-skip-if "" { *-*-* } } */
+/* { dg-options "-fself-test=$srcdir/selftests" } */
 
 /* Verify that -fself-test does not fail on a non empty source.  */
 
@@ -15,4 +8,5 @@ int i;
   while (i--)
     bar();
 }
-/* { dg-message "fself\-test: " "-fself-test" { target *-*-* } 0 } */
+
+/* { dg-regexp {^-fself-test: [0-9]+ pass\(es\) in [.0-9]+ seconds$|.*: note: self-tests are not enabled in this build$} } */
diff --git a/gcc/testsuite/gcc.dg/pr97953.c b/gcc/testsuite/gcc.dg/pr97953.c
new file mode 100644
index 00000000000..6219619d67b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr97953.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-fre" } */
+
+int __attribute__((noipa))
+foo (int flag, int *p)
+{
+  int val = *p;
+  if (flag)
+    {
+      if (val != 1)
+        __builtin_unreachable ();
+      return 0;
+    }
+  int val2 = *p;
+  return val2 == 2;
+}
+
+int main()
+{
+  int i = 2;
+  if (foo (0, &i) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100672.c b/gcc/testsuite/gcc.dg/torture/pr100672.c
new file mode 100644
index 00000000000..cc62e71f9a3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100672.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-w -Wno-psabi" } */
+
+typedef long long __attribute__((__vector_size__ (4 * sizeof (long long)))) V;
+
+V
+foo (V v)
+{
+  return -(v >> 1);
+}
+
+int
+main (void)
+{
+  V v = foo ((V) { -2, -4, -6, -8 });
+  if (v[0] != 1 || v[1] != 2 || v[2] != 3 || v[3] != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr100934.c b/gcc/testsuite/gcc.dg/torture/pr100934.c
new file mode 100644
index 00000000000..43b78849895
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr100934.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+
+int a, b, c, d, e;
+int main()
+{
+  int f = 0, g = 0;
+  for (; f < 2; f++)
+    {
+      int h, i;
+      for (h = 0; h < 2; h++)
+	{
+	  b = e = g ? a % g : 0;
+	  c = d;
+	  for (i = 0; i < 1; i++)
+	    g = 0;
+	  for (; g < 2; g++)
+	    ;
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101105.c b/gcc/testsuite/gcc.dg/torture/pr101105.c
new file mode 100644
index 00000000000..9222351683d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101105.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+short a;
+int b[5][4] = {2, 2};
+int d;
+short e(int f) { return f == 0 || a && f == 1 ? 0 : a; }
+int main() {
+  int g, h;
+  g = 3;
+  for (; g >= 0; g--) {
+    h = 3;
+    for (; h >= 0; h--)
+      b[g][h] = b[0][1] && e(1);
+  }
+  d = b[0][1];
+  if (d != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101173.c b/gcc/testsuite/gcc.dg/torture/pr101173.c
new file mode 100644
index 00000000000..0c9090d6686
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101173.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-additional-options "-floop-interchange" } */
+
+int a[6][9];
+int main()
+{
+  a[1][3] = 8;
+  for (int b = 1; b <= 5; b++)
+    for (int d = 0; d <= 5; d++)
+#pragma GCC unroll 0
+      for (int c = 0; c <= 5; c++)
+        a[b][c] = a[b][c + 2] & 216;
+  for (int e = 0; e < 6; e++)
+    for (int f = 0; f < 9; f++)
+      if (a[e][f] != 0)
+        __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr101394.c b/gcc/testsuite/gcc.dg/torture/pr101394.c
new file mode 100644
index 00000000000..87fbdadc152
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr101394.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+
+int a, b, c, d;
+void h();
+int e() __attribute__((returns_twice));
+void f() {
+  int *g = (int *)(__INTPTR_TYPE__)c;
+  if (b) {
+    h();
+    g--;
+    if (a)
+      if (d)
+        h();
+  }
+  if (g++)
+    e();
+  c = (__INTPTR_TYPE__)g;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
new file mode 100644
index 00000000000..781555e085d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/loop-interchange-16.c
@@ -0,0 +1,22 @@
+/* PR/101280 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-linterchange-details" } */
+
+void dummy (double *, double *);
+#define LEN_2D 32
+double aa[LEN_2D][LEN_2D], bb[LEN_2D][LEN_2D];
+double s231(int iterations)
+{
+//    loop interchange
+//    loop with data dependency
+    for (int nl = 0; nl < 100*(iterations/LEN_2D); nl++) {
+        for (int i = 0; i < LEN_2D; ++i) {
+            for (int j = 1; j < LEN_2D; j++) {
+                aa[j][i] = aa[j - 1][i] + bb[j][i];
+            }
+        }
+        dummy(aa[0],bb[0]);
+    }
+}
+
+/* { dg-final { scan-tree-dump "loops interchanged" "linterchange" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
new file mode 100644
index 00000000000..d5987e14360
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr101824.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-pcom-details -fdump-tree-optimized" } */
+
+int main()
+{
+  volatile int y;
+  void bar()
+    {
+      __builtin_printf ("%d", y);
+    }
+  while (y)
+    ;
+  return 0;
+}
+
+/* Make sure the load from y is correctly interpreted as volatile, even
+   when going through FRAME.  */
+/* { dg-final { scan-tree-dump-not "Executing predictive commoning" "pcom" } } */
+/* { dg-final { scan-tree-dump " ={v} FRAME" "optimized" } } */
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon.c b/gcc/testsuite/gcc.target/arm/attr-neon.c
index 225fb8dc3db..e8e3086247d 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon.c
@@ -1,7 +1,10 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
 /* { dg-options "-O2 -ftree-vectorize" } */
-/* { dg-add-options arm_neon arm_v8_vfp } */ /* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any -mfpu= option set by arm_neon, thus ensuring that the attributes below really are checked for correct fpu selection.  */
+/* { dg-add-options arm_neon arm_v8_vfp } */
+/* The arm_v8_vfp adds -mfpu=fp-armv8 to the command line, overriding any
+   -mfpu= option set by arm_neon, thus ensuring that the attributes below
+   really are checked for correct fpu selection.  */
 
 /* Verify that neon instructions are emitted once.  */
 void __attribute__ ((target("fpu=neon")))
@@ -18,6 +21,6 @@ f3(int n, int x[], int y[]) {
     y[i] = x[i] << 3;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+vfp\n" 1 } } */
+/* { dg-final { scan-assembler-times "\.fpu\\s+neon\n" 1 } } */
 /* { dg-final { scan-assembler-times "vshl" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon2.c b/gcc/testsuite/gcc.target/arm/attr-neon2.c
index 29668256cf5..91cf4dde8db 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon2.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon2.c
@@ -27,8 +27,8 @@ my1 (int8x8_t __a, int8x8_t __b)
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfp\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+neon\n} } } */
 /* { dg-final { scan-assembler "vadd" } } */
 
 
diff --git a/gcc/testsuite/gcc.target/arm/attr-neon3.c b/gcc/testsuite/gcc.target/arm/attr-neon3.c
index 17e429ad739..0acb7f98dc6 100644
--- a/gcc/testsuite/gcc.target/arm/attr-neon3.c
+++ b/gcc/testsuite/gcc.target/arm/attr-neon3.c
@@ -31,8 +31,8 @@ my1 (int8x8_t __a, int8x8_t __b)
   return __a + __b;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu neon" 1 } } */
-/* { dg-final { scan-assembler-times "\.fpu crypto-neon-fp-armv8" 1 } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfp\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+neon\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+crypto-neon-fp-armv8\n} } } */
 /* { dg-final { scan-assembler-times "vld1" 1 } } */
 /* { dg-final { scan-assembler-times "vadd" 1} } */
diff --git a/gcc/testsuite/gcc.target/arm/pr69245.c b/gcc/testsuite/gcc.target/arm/pr69245.c
index bd505187728..58a6104e8f6 100644
--- a/gcc/testsuite/gcc.target/arm/pr69245.c
+++ b/gcc/testsuite/gcc.target/arm/pr69245.c
@@ -12,7 +12,7 @@
 #pragma GCC target "fpu=neon-vfpv4"
 int a, c, d;
 float b;
-static int fn1 ()
+ int fn1 ()
 {
   return 0;
 }
@@ -23,4 +23,8 @@ void fn2 ()
   d = b * c + a;
 }
 
-/* { dg-final { scan-assembler-times "\.fpu vfp" 1 } } */
+/* Because we don't know the exact command-line options used to invoke the test
+   we cannot expect these tests to match exactly once.  But they must appear at
+   least once.  */
+/* { dg-final { scan-assembler "\.fpu\\s+vfp\n" } } */
+/* { dg-final { scan-assembler "\.fpu\\s+neon-vfpv4\n" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
index 174be85f3f7..7e63cf53013 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute.c
@@ -22,5 +22,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
index add40ddc6b8..398d8fff35c 100644
--- a/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
+++ b/gcc/testsuite/gcc.target/arm/pragma_fpu_attribute_2.c
@@ -25,5 +25,8 @@ uint32_t restored ()
   return bar();
 }
 
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv4} 1 } } */
-/* { dg-final { scan-assembler-times {\.fpu\s+vfpv3-d16} 1 } } */
+/* We can't tell exactly how many times the following tests will match because
+   command-line options may cause additional instances to be generated, but
+   each must be present at least once.  */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv4\n} } } */
+/* { dg-final { scan-assembler {\.fpu\s+vfpv3-d16\n} } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
new file mode 100644
index 00000000000..4a0057b241e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr101471.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-mavx512dq -O0" } */
+/* { dg-require-effective-target avx512dq } */
+
+#include "avx512f-check.h"
+
+static void
+avx512f_test (void)
+{
+  __m512 x = {
+      1, 1, 1, 1,
+      1, 1, 1, 1,
+      0, 0, 0, 0,
+      0, 0, 0, 0,  };
+  int ret = _mm512_fpclass_ps_mask(x, 0x26);
+  if (ret != 65280)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr101175.c b/gcc/testsuite/gcc.target/i386/pr101175.c
new file mode 100644
index 00000000000..ed7a08110a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr101175.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mlzcnt" } */
+/* { dg-require-effective-target lzcnt } */
+
+#include "lzcnt-check.h"
+
+static int
+foo (unsigned int v)
+{
+  return v ? __builtin_clz (v) : 32;
+}
+
+/* returns -1 if x == 0 */
+int
+__attribute__ ((noinline, noclone))
+bar (unsigned int x)
+{
+  return 31 - foo (x);
+}
+
+static void
+lzcnt_test ()
+{
+  int r = bar (0);
+
+  if (r != -1)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-1.c b/gcc/testsuite/gcc.target/i386/pr71245-1.c
deleted file mode 100644
index 02c0dcb80b6..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-1.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -mno-sse -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "(fistp|fild)" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr71245-2.c b/gcc/testsuite/gcc.target/i386/pr71245-2.c
deleted file mode 100644
index bf37a8cbb71..00000000000
--- a/gcc/testsuite/gcc.target/i386/pr71245-2.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/* PR target/71245 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=pentium -msse -mno-sse2 -mfpmath=387" } */
-
-typedef union
-{
-  unsigned long long ll;
-  double d;
-} u_t;
-
-u_t d = { .d = 5.0 };
-
-void foo_d (void)
-{
-  u_t tmp;
-  
-  tmp.ll = __atomic_load_n (&d.ll, __ATOMIC_SEQ_CST);
-  tmp.d += 1.0;
-  __atomic_store_n (&d.ll, tmp.ll, __ATOMIC_SEQ_CST);
-}
-
-/* { dg-final { scan-assembler-not "movlps" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101129.c b/gcc/testsuite/gcc.target/powerpc/pr101129.c
new file mode 100644
index 00000000000..6b8e5a9b597
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101129.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-mdejagnu-cpu=power8 -O " } */
+
+/* PR101129: The swaps pass was turning a mult-lopart into a mult-hipart.
+   Make sure we aren't doing that anymore.  */
+
+typedef unsigned char u8;
+typedef unsigned char __attribute__((__vector_size__ (8))) U;
+typedef unsigned char __attribute__((__vector_size__ (16))) V;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef __int128 u128;
+
+u8 g;
+U u;
+
+void
+foo0 (u32 u32_0, U *ret)
+{
+  u128 u128_2 = u32_0 * (u128)((V){ 5 } > (u32_0 & 4));
+  u64 u64_r = u128_2 >> 64;
+  u8 u8_r = u64_r + g;
+  *ret = u + u8_r;
+}
+
+int
+main (void)
+{
+  U x;
+  foo0 (7, &x);
+  for (unsigned i = 0; i < sizeof (x); i++)
+    if (x[i] != 0) __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-1.c b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
new file mode 100644
index 00000000000..b4753ab83d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-1.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector float a = {  1,  2, - 3, - 4};
+  vector float b = {-10, 20, -30,  40};
+  vector float c = { 10, 20, -30, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr101985-2.c b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
new file mode 100644
index 00000000000..148ad657366
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr101985-2.c
@@ -0,0 +1,18 @@
+/* PR target/101985 */
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#include <altivec.h>
+
+int
+main (void)
+{
+  vector double a = {   1,  -4};
+  vector double b = { -10,  40};
+  vector double c = {  10, -40};
+  a = vec_cpsgn (a, b);
+  if (! vec_all_eq (a, c))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102347.c b/gcc/testsuite/gcc.target/powerpc/pr102347.c
new file mode 100644
index 00000000000..55e5374bfac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102347.c
@@ -0,0 +1,19 @@
+/* { dg-do link } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* { dg-require-effective-target lto } */
+/* { dg-options "-flto -mdejagnu-cpu=power8" } */
+
+/* Verify there are no error messages in LTO mode.  */
+
+#pragma GCC target "cpu=power9"
+int main ()
+{
+  int res;
+#ifdef __LP64__
+  res = (int) __builtin_darn ();
+#else
+  res = __builtin_darn_32 ();
+#endif
+  return res;
+}
diff --git a/gcc/testsuite/gcc.target/s390/20211119.c b/gcc/testsuite/gcc.target/s390/20211119.c
new file mode 100644
index 00000000000..b9d216389f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/20211119.c
@@ -0,0 +1,12 @@
+/* { dg-do run { target { s390_useable_hw } } } */
+/* { dg-options "-Os -march=z10" } */
+signed char a;
+int b = -925974181, c;
+unsigned *d = &b;
+int *e = &c;
+int main() {
+  *e = ((217 ^ a) > 585) < *d;
+  if (c != 1)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20210917-1.c b/gcc/testsuite/gcc.target/sparc/20210917-1.c
new file mode 100644
index 00000000000..03e8bc58db9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20210917-1.c
@@ -0,0 +1,19 @@
+/* PR rtl-optimization/102306 */
+/* Reported by Daniel Cederman <cederman@gaisler.com> */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O -mcpu=v8" } */
+
+extern void foo (void);
+
+void test (volatile unsigned char *a) 
+{ 
+  char b = *a;
+  if (!b)
+    return;
+  if (b & 2)
+    foo ();
+}
+
+/* { dg-final { scan-assembler-times "ldub" 1 } } */
diff --git a/gcc/testsuite/gdc.dg/pr100882a.d b/gcc/testsuite/gdc.dg/pr100882a.d
new file mode 100644
index 00000000000..d94baff97ac
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882a.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-additional-options "-fmain" }
+// { dg-do run }
+
+__gshared int counter = 0;
+struct S100882
+{
+    this(int) { counter++; }
+    ~this() { counter++; }
+}
+static S100882 s;
+static this()
+{
+    s = cast(shared) S100882(0);
+    assert(counter == 2);
+}
+
+auto test100882()
+{
+    return cast(shared) S100882(0);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882b.d b/gcc/testsuite/gdc.dg/pr100882b.d
new file mode 100644
index 00000000000..de92ab3bef1
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882b.d
@@ -0,0 +1,35 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct AllocatorList(Factory)
+{
+    Factory factory;
+    auto make(size_t n) { return factory(n); }
+    this(Factory plant)
+    {
+        factory = plant;
+    }
+}
+
+struct Region
+{
+    ~this()
+    {
+    }
+}
+
+auto mmapRegionList()
+{
+    struct Factory
+    {
+        this(size_t )
+        {
+        }
+        auto opCall(size_t )
+        {
+            return Region();
+        }
+    }
+    auto shop = Factory();
+    AllocatorList!Factory(shop);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882c.d b/gcc/testsuite/gdc.dg/pr100882c.d
new file mode 100644
index 00000000000..deaa4b44a16
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882c.d
@@ -0,0 +1,19 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+auto iota(int, int)
+{
+    struct Result
+    {
+        this(int)
+        {
+        }
+    }
+    return Result();
+}
+
+auto iota(int end)
+{
+    int begin;
+    return iota(begin, end);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882d.d b/gcc/testsuite/gdc.dg/pr100882d.d
new file mode 100644
index 00000000000..f4e6e4d3651
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882d.d
@@ -0,0 +1,25 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct CowArray
+{
+    this(this)
+    {
+    }
+}
+
+struct Tuple
+{
+    CowArray expand;
+}
+
+auto tuple(CowArray)
+{
+    return Tuple();
+}
+
+auto parseCharTerm()
+{
+    CowArray set;
+    return tuple(set);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100967.d b/gcc/testsuite/gdc.dg/pr100967.d
new file mode 100644
index 00000000000..582ad582676
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100967.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100967
+// { dg-do compile }
+
+module object; // { dg-error "class object.TypeInfo missing or corrupt object.d" }
+
+extern(C) int main()
+{
+    int[int] aa;
+    aa[0] = 1;  // { dg-error ".object.TypeInfo. could not be found, but is implicitly used" }
+    return 0;
+}
diff --git a/gcc/testsuite/gdc.dg/pr101127a.d b/gcc/testsuite/gdc.dg/pr101127a.d
new file mode 100644
index 00000000000..b56398e1929
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127a.d
@@ -0,0 +1,8 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+// { dg-additional-options "-mavx" }
+
+import gcc.builtins;
+
+static assert(__traits(compiles, __builtin_ia32_andps256));
+static assert(__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101127b.d b/gcc/testsuite/gdc.dg/pr101127b.d
new file mode 100644
index 00000000000..b462d75c424
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101127b.d
@@ -0,0 +1,7 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101127
+// { dg-do compile { target i?86*-*-* x86_64-*-* } }
+
+import gcc.builtins;
+
+static assert(!__traits(compiles, __builtin_ia32_andps256));
+static assert(!__traits(compiles, __builtin_ia32_pmulhrsw128));
diff --git a/gcc/testsuite/gdc.dg/pr101490.d b/gcc/testsuite/gdc.dg/pr101490.d
new file mode 100644
index 00000000000..6929d406863
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101490.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101490
+// { dg-do compile }
+
+struct S101490
+{
+    int[0] arr;
+}
+
+void main()
+{
+    S101490* t;
+    auto a = cast(typeof(t.arr)[0])t.arr;
+    write(a);
+}
+
+void write(S)(S args)
+{
+    foreach (arg; args)
+    {
+    }
+}
diff --git a/gcc/testsuite/gdc.dg/pr101640.d b/gcc/testsuite/gdc.dg/pr101640.d
new file mode 100644
index 00000000000..68de4088512
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr101640.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101640
+// { dg-do compile }
+// { dg-options "-fdump-tree-original" }
+
+int fun101640(ref int);
+
+int test101640(int val)
+{
+    // { dg-final { scan-tree-dump "= val \\\+ fun101640 \\\(\\\(int &\\\) &val\\\);" "original" } }
+    return val + fun101640(val);
+}
diff --git a/gcc/testsuite/gdc.dg/pr96435.d b/gcc/testsuite/gdc.dg/pr96435.d
new file mode 100644
index 00000000000..c6d8785ec5b
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr96435.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96435
+// { dg-do run }
+
+@safe bool test96435()
+{
+    int[2] array = [16, 678];
+    union U { int i; bool b; }
+    U u;
+    u.i = 0xDEADBEEF;
+    assert(array[u.b] == 678);
+    return u.b;
+}
+
+@safe void main()
+{
+    auto b = test96435();
+    if (b)
+        assert(true);
+    if (!b)
+        assert(false);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
index 3a80a039e26..5b3542828dd 100644
--- a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
+++ b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
@@ -26,3 +26,24 @@ enum payloadOffset = C2.bytes.offsetof;
 static assert(C2.int1.offsetof == payloadOffset + 8);
 static assert(C2.alignof == size_t.sizeof);
 static assert(__traits(classInstanceSize, C2) == payloadOffset + 12);
+
+align(8) struct PaddedStruct
+{
+    bool flag;
+    align(2) S1 s1;
+}
+
+static assert(PaddedStruct.s1.offsetof == 2);
+static assert(PaddedStruct.alignof == 8);
+static assert(PaddedStruct.sizeof == 16);
+
+align(1) struct UglyStruct
+{
+    bool flag;
+    int i;
+    ubyte u;
+}
+
+static assert(UglyStruct.i.offsetof == 4);
+static assert(UglyStruct.alignof == 1);
+static assert(UglyStruct.sizeof == 9);
diff --git a/gcc/testsuite/gdc.test/compilable/b19002.d b/gcc/testsuite/gdc.test/compilable/b19002.d
new file mode 100644
index 00000000000..fd8e6d18b37
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/b19002.d
@@ -0,0 +1,12 @@
+module b19002;
+
+void printf(scope const char* format){}
+
+void main()
+{
+    printf(__FILE__);
+    printf(__FILE_FULL_PATH__);
+    printf(__FUNCTION__);
+    printf(__PRETTY_FUNCTION__);
+    printf(__MODULE__);
+}
diff --git a/gcc/testsuite/gdc.test/compilable/betterCarray.d b/gcc/testsuite/gdc.test/compilable/betterCarray.d
index 74c80be3b95..3f48b042bde 100644
--- a/gcc/testsuite/gdc.test/compilable/betterCarray.d
+++ b/gcc/testsuite/gdc.test/compilable/betterCarray.d
@@ -15,3 +15,13 @@ int foo(int[] a, int i)
 {
     return a[i];
 }
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=19234
+void issue19234()
+{
+    static struct A {}
+    A[10] a;
+    A[10] b;
+    b[] = a[];
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
new file mode 100644
index 00000000000..c7060b0d96c
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
@@ -0,0 +1 @@
+module object;
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
new file mode 100644
index 00000000000..672db305223
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
@@ -0,0 +1,11 @@
+/*
+REQUIRED_ARGS: -betterC
+TEST_OUTPUT:
+---
+fail_compilation/fail19911a.d(9): Error: function `fail19911a.fun` D-style variadic functions cannot be used with -betterC
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
new file mode 100644
index 00000000000..b4ad22b0896
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
@@ -0,0 +1,13 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+EXTRA_SOURCES: extra-files/minimal/object.d
+TEST_OUTPUT:
+---
+fail_compilation/fail19911b.d(10): Error: function `fail19911b.fun` `object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
new file mode 100644
index 00000000000..d1e954ed394
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
@@ -0,0 +1,17 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19911c.d(15): Error: function `object.fun` `object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+module object;
+
+class Object { }
+class TypeInfo_Tuple { }
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19922.d b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
new file mode 100644
index 00000000000..5c9e2bbe0ab
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19922.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = typeid(o);
+}
+
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19923.d b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
new file mode 100644
index 00000000000..042cf8af11a
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19923.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = o.classinfo;
+}
+
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail22144.d b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
new file mode 100644
index 00000000000..e0fd5b19225
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail22144.d
@@ -0,0 +1,14 @@
+// https://issues.dlang.org/show_bug.cgi?id=22144
+/* TEST_OUTPUT
+---
+fail_compilation/fail22144.d(12): Error: cannot cast expression `zarray1` of type `int[0]` to `int[0][]` since sizes don't line up
+---
+*/
+void main()
+{
+  int[0] zarray1;
+  int[0][0] zarray2;
+
+  auto zslice1 = cast(int[0][])zarray1; // ICE -> Error
+  auto zslice2 = cast(int[0][])zarray2; // ICE -> OK
+}
diff --git a/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90 b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
new file mode 100644
index 00000000000..0fc54d5331c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/alloc_deferred_comp_1.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+!
+! Test the fix for PR99125, where the array reference in the print
+! statement caused an ICE because the gimplifier complained about '0'
+! being used as an lvalue.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), allocatable :: a(:)
+   end type
+   type(t) :: x
+   character(8) :: c(3) = ['12 45 78','23 56 89','34 67 90']
+   x%a = c
+   if (any (x%a(2:3) .ne. ['23 56 89','34 67 90'])) stop 1
+   if (any (x%a(2:3)(4:5) .ne. ['56','67'])) stop 2 ! Bizarrely this worked.
+end
diff --git a/gcc/testsuite/gfortran.dg/associate_54.f90 b/gcc/testsuite/gfortran.dg/associate_54.f90
new file mode 100644
index 00000000000..003175a47fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_54.f90
@@ -0,0 +1,34 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+  subroutine test_alter_state1 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "is used as array" }
+!      state = a
+      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state1
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_55.f90 b/gcc/testsuite/gfortran.dg/associate_55.f90
new file mode 100644
index 00000000000..2b9e8c727f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_55.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    associate (state => obj%state(TEST_STATES)) ! { dg-error "no IMPLICIT type" }
+      state = a                                 ! { dg-error "vector-indexed target" }
+!      state(TEST_STATE) = a
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associate_56.f90 b/gcc/testsuite/gfortran.dg/associate_56.f90
new file mode 100644
index 00000000000..429f129da6e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_56.f90
@@ -0,0 +1,36 @@
+! { dg-do compile }
+!
+! Test the fix for PR93701.
+!
+! Contributed by Simon Brass  <simon.brass@desy.de>
+!
+module test
+  implicit none
+
+  integer, parameter :: N_STATE = 1, &
+       TEST_STATE = 1
+
+  type :: test_t
+     integer, dimension(:), allocatable :: state
+  end type test_t
+
+contains
+
+  subroutine test_allocate (obj)
+    class(test_t), intent(out) :: obj
+    allocate (obj%state(N_STATE))
+  end subroutine test_allocate
+
+
+  subroutine test_alter_state2 (obj, a)
+    class(test_t), intent(inout) :: obj
+    integer, intent(in) :: a
+    integer, dimension(2) :: TEST_STATES = [1,2]
+    associate (state => obj%state(TEST_STATES))
+      state = a                                 ! { dg-error "vector-indexed target" }
+      state(TEST_STATE) = a                     ! { dg-error "vector-indexed target" }
+    end associate
+  end subroutine test_alter_state2
+
+end module test
+
diff --git a/gcc/testsuite/gfortran.dg/associated_target_7.f90 b/gcc/testsuite/gfortran.dg/associated_target_7.f90
new file mode 100644
index 00000000000..97f93b3c742
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associated_target_7.f90
@@ -0,0 +1,87 @@
+! { dg-do run }
+!
+! associated_target_7.f90: Test the fix for PR98565.
+!
+! Contributed by Yves Secretan  <yves.secretan@ete.inrs.ca>
+!
+MODULE PS_SN0N_M
+
+   IMPLICIT NONE
+   PRIVATE
+
+   TYPE, PUBLIC :: DT_GRID_T
+       INTEGER :: NNT
+   CONTAINS
+       ! PASS
+   END TYPE DT_GRID_T
+
+   TYPE, PUBLIC :: LM_ELEM_T
+       CLASS(DT_GRID_T), POINTER :: PGRID
+   CONTAINS
+       PROCEDURE, PUBLIC :: REQPGRID => LM_ELEM_REGPGRID
+   END TYPE LM_ELEM_T
+
+   TYPE, PUBLIC :: PS_SN0N_T
+      CLASS(DT_GRID_T), POINTER :: PGRID
+
+   CONTAINS
+      PROCEDURE, PUBLIC :: ASGOELE  => PS_SN0N_ASGOELE
+   END TYPE PS_SN0N_T
+
+
+CONTAINS
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION LM_ELEM_REGPGRID(SELF) RESULT(PGRID)
+   CLASS(DT_GRID_T), POINTER :: PGRID
+   CLASS(LM_ELEM_T), INTENT(IN) :: SELF
+   PGRID => SELF%PGRID
+   RETURN
+   END FUNCTION LM_ELEM_REGPGRID
+
+   !------------------------------------------------------------------------
+   !------------------------------------------------------------------------
+   FUNCTION PS_SN0N_ASGOELE(SELF, OELE) RESULT(ERMSG)
+
+   INTEGER :: ERMSG
+   CLASS(PS_SN0N_T), INTENT(IN) :: SELF
+   CLASS(LM_ELEM_T), INTENT(IN) :: OELE
+
+   !CLASS(DT_GRID_T), POINTER :: PGRID
+   LOGICAL :: ISOK
+   !------------------------------------------------------------------------
+
+   ! ASSOCIATED with temp variable compiles
+   !PGRID => OELE%REQPGRID()
+   !ISOK = ASSOCIATED(SELF%PGRID, PGRID)
+
+   ! ASSOCIATE without temp variable crashes with ICE
+   ISOK = ASSOCIATED(SELF%PGRID, OELE%REQPGRID())
+   ERMSG = 0
+   IF (ISOK) ERMSG = 1
+
+   RETURN
+   END FUNCTION PS_SN0N_ASGOELE
+
+END MODULE PS_SN0N_M
+
+
+   USE PS_SN0N_M
+   CLASS(PS_SN0N_T), ALLOCATABLE :: SELF
+   CLASS(LM_ELEM_T), ALLOCATABLE :: OELE
+   TYPE (DT_GRID_T), TARGET :: GRID1 = DT_GRID_T (42)
+   TYPE (DT_GRID_T), TARGET :: GRID2 = DT_GRID_T (84)
+
+   ALLOCATE (PS_SN0N_T :: SELF)
+   ALLOCATE (LM_ELEM_T :: OELE)
+   SELF%PGRID => GRID1
+
+   OELE%PGRID => NULL ()
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 1
+
+   OELE%PGRID => GRID2
+   IF (SELF%ASGOELE (OELE) .NE. 0) STOP 2
+
+   OELE%PGRID => GRID1
+   IF (SELF%ASGOELE (OELE) .NE. 1) STOP 3
+END
diff --git a/gcc/testsuite/gfortran.dg/bound_simplification_7.f90 b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
new file mode 100644
index 00000000000..3efecdff769
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bound_simplification_7.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/103392 - ICE in simplify_bound
+
+program p
+  integer, allocatable :: a(1:1) ! { dg-error "deferred shape or assumed rank" }
+  integer :: b(1) = lbound(a)    ! { dg-error "does not reduce" }
+  integer :: c(1) = ubound(a)    ! { dg-error "does not reduce" }
+end
+
+subroutine s(x, y)
+  type t
+     integer :: i(3)
+  end type t
+  type(t), pointer     :: x(:)
+  type(t), allocatable :: y(:)
+  integer, parameter   :: m(1) = ubound (x(1)% i)
+  integer              :: n(1) = ubound (y(1)% i)
+end subroutine s
diff --git a/gcc/testsuite/gfortran.dg/bounds_check_23.f90 b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
new file mode 100644
index 00000000000..8de90c77c01
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bounds_check_23.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+! { dg-options "-fcheck=bounds -fdump-tree-original" }
+! PR fortran/98490 - out of bounds in array constructor with implied do loop
+
+program test
+  implicit none
+  call sub('Lorem ipsum')
+contains
+  subroutine sub( text )
+    character(len=*), intent(in)  :: text
+    character(len=1), allocatable :: c(:)
+    integer :: i
+    c = [ ( text(i:i), i = 1, len(text) ) ]
+    if (c(1) /= 'L') stop 1
+  end subroutine sub
+end program test
+
+! { dg-final { scan-tree-dump-times "Substring out of bounds:" 2 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_6.f90 b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
new file mode 100644
index 00000000000..79f6e86daa7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_6.f90
@@ -0,0 +1,65 @@
+! { dg-do run }
+!
+! Test the fix for PR99819 - explicit shape class arrays in different
+! procedures caused an ICE.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      integer :: i
+   end type
+   class(t), allocatable :: dum1(:), dum2(:), dum3(:,:)
+
+   allocate (t :: dum1(3), dum2(10), dum3(2,5))
+   dum2%i = [1,2,3,4,5,6,7,8,9,10]
+   dum3%i = reshape ([1,2,3,4,5,6,7,8,9,10],[2,5])
+
+! Somewhat elaborated versions of the PR procedures.
+   if (f (dum1, dum2, dum3) .ne. 10) stop 1
+   if (g (dum1) .ne. 3) stop 2
+
+! Test the original versions of the procedures.
+   if (f_original (dum1, dum2) .ne. 3) stop 3
+   if (g_original (dum2) .ne. 10) stop 4
+
+contains
+   integer function f(x, y, z)
+      class(t) :: x(:)
+      class(t) :: y(size( x))
+      class(t) :: z(2,*)
+      if (size (y) .ne. 3) stop 5
+      if (size (z) .ne. 0) stop 6
+      select type (y)
+        type is (t)
+          f = 1
+          if (any (y%i .ne. [1,2,3])) stop 7
+        class default
+          f = 0
+      end select
+      select type (z)
+        type is (t)
+          f = f*10
+          if (any (z(1,1:4)%i .ne. [1,3,5,7])) stop 8
+        class default
+          f = 0
+      end select
+   end
+   integer function g(z)
+      class(t) :: z(:)
+      type(t) :: u(size(z))
+      g = size (u)
+   end
+
+   integer function f_original(x, y)
+      class(t) :: x(:)
+      class(*) :: y(size (x))
+      f_original = size (y)
+   end
+
+   integer function g_original(z)
+      class(*) :: z(:)
+      type(t) :: u(size(z))
+      g_original = size (u)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/class_dummy_7.f90 b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
new file mode 100644
index 00000000000..913426804f3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_dummy_7.f90
@@ -0,0 +1,60 @@
+! { dg-do run }
+!
+! Test the fix for PR46691 - enable class assumed size arrays
+!
+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>
+! from http://j3-fortran.org/pipermail/j3/2010-December/004084.html
+! submitted by Robert Corbett.
+!
+       MODULE TYPES
+         PRIVATE
+         PUBLIC REC, REC2
+
+         TYPE REC
+           INTEGER A
+         END TYPE
+
+         TYPE, EXTENDS(REC) :: REC2
+           INTEGER B
+         END TYPE
+       END
+
+       SUBROUTINE SUB1(A, N)
+         USE TYPES
+         CLASS(REC), INTENT(IN) :: A(*)
+         INTERFACE
+           SUBROUTINE SUB2(A, N, IARRAY)
+             USE TYPES
+             TYPE(REC) A(*)
+             INTEGER :: N, IARRAY(N)
+           END
+         END INTERFACE
+
+         CALL SUB2(A, N,[1,2,2,3,3,4,4,5,5,6])
+         select type (B => A(1:N))
+             type is (REC2)
+                 call SUB2(B%REC,N,[1,2,3,4,5,6,7,8,9,10])
+         end select
+
+       END
+
+       SUBROUTINE SUB2(A, N, IARRAY)
+         USE TYPES
+         TYPE(REC) A(*)
+         INTEGER :: N, IARRAY(N)
+         if (any (A(:N)%A .ne. IARRAY(:N))) stop 1
+       END
+
+       PROGRAM MAIN
+         USE TYPES
+         CLASS(REC), ALLOCATABLE :: A(:)
+         INTERFACE
+           SUBROUTINE SUB1(A, N)
+             USE TYPES
+             CLASS(REC), INTENT(IN) :: A(*)
+           END SUBROUTINE
+         END INTERFACE
+
+         A = [ (REC2(I, I+1), I = 1, 10) ]
+         CALL SUB1(A, 10)
+       END
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_35.f90 b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
new file mode 100644
index 00000000000..c28f52f79ff
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_35.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+!
+! Test the fix for PR93794, where the ASSOCIATE statement ICED on the
+! deferred character length, pointer component.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), pointer :: a
+   end type
+   type(t) :: z
+   character(4), target :: c = 'abcd'
+   z%a => c
+   associate (y => z%a)
+      print *, y
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/do_check_19.f90 b/gcc/testsuite/gfortran.dg/do_check_19.f90
new file mode 100644
index 00000000000..1373a7374ce
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/do_check_19.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! { dg-prune-output "Obsolescent feature: Alternate-return argument" }
+! PR fortran/103717 - ICE in doloop_code
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+contains
+  subroutine s(*)
+  end
+end
+
+recursive subroutine s(*)
+  integer :: i
+  do i = 1, 2
+     call s(i) ! { dg-error "Missing alternate return specifier" }
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/elemental_function_5.f90 b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
new file mode 100644
index 00000000000..315ff9162b3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/elemental_function_5.f90
@@ -0,0 +1,46 @@
+! { dg-do compile }
+!
+! Test the fix for PR98472.
+!
+! Contributed by Rui Coelho  <ruicoelhopedro@hotmail.com>
+!
+module a
+        type, abstract :: base
+        contains
+                procedure(elem_func), deferred, nopass :: add
+        end type base
+
+        type, extends(base) :: derived
+        contains
+                procedure, nopass :: add => add_derived
+        end type derived
+
+        abstract interface
+                elemental function elem_func(x, y) result(out)
+                        integer, intent(in) :: x, y
+                        integer :: out
+                end function elem_func
+        end interface
+
+contains
+        elemental function add_derived(x, y) result(out)
+                integer, intent(in) :: x, y
+                integer :: out
+                out = x + y
+        end function add_derived
+end module a
+
+program main
+        use a
+        call foo
+contains
+        subroutine foo
+               integer, dimension(:), allocatable :: vec
+               class(base), allocatable :: instance
+               allocate(derived :: instance)
+               allocate(vec, source=instance%add([1, 2], [1, 2])) ! ICE here
+               if (any (vec .ne. [2, 4])) stop 1
+        end
+end program main
+
+
diff --git a/gcc/testsuite/gfortran.dg/implied_do_io_7.f90 b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
new file mode 100644
index 00000000000..63927aafea9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implied_do_io_7.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR 100227 - this was falsely optimized, leading to nonsense  results.
+! Original test case by "Mathieu".
+
+program p
+  implicit none
+  integer, parameter :: nbmode = 3
+  integer :: k
+  real    :: mass(nbmode*2)
+  character (len=80) :: line
+  do k = 1, nbmode*2
+     mass(k) = k
+  end do
+  write (unit=line,fmt='(*(F6.2))') (mass(k+k), k=1,nbmode)
+  if (line /= '  2.00  4.00  6.00') stop 1
+end program
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_25.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
new file mode 100644
index 00000000000..df8ad06c123
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/99839 - ICE in inline_matmul_assign
+
+program p
+  real :: x(3, 3) = 1.0
+  class(*), allocatable :: z(:, :)
+  z = matmul(x, x)
+end
diff --git a/gcc/testsuite/gfortran.dg/intent_out_14.f90 b/gcc/testsuite/gfortran.dg/intent_out_14.f90
new file mode 100644
index 00000000000..e5994635008
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_14.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+! PR fortran/102287 - optional allocatable DT array arguments (intent out)
+
+module m
+  type t
+     integer, allocatable :: a
+  end type t
+contains
+  subroutine a (x, v)
+    type(t), optional, allocatable, intent(out) :: x(:)
+    type(t), optional,              intent(out) :: v(:)
+    call b (x, v)
+  end subroutine a
+
+  subroutine b (y, w)
+    type(t), optional, allocatable, intent(out) :: y(:)
+    type(t), optional,              intent(out) :: w(:)
+  end subroutine b
+end module m
+
+program p
+  use m
+  call a ()
+end
diff --git a/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90 b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
new file mode 100644
index 00000000000..917944d8846
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intrinsic_pack_6.f90
@@ -0,0 +1,57 @@
+! { dg-do run }
+! PR libfortran/103634 - Runtime crash with PACK on zero-sized arrays
+! Exercise PACK intrinsic for cases when it calls pack_internal
+
+program p
+  implicit none
+  type t
+     real :: r(24) = -99.
+  end type
+  type(t), allocatable :: new(:), old(:), vec(:)
+  logical, allocatable :: mask(:)
+  integer              :: n, m
+! m = 1    ! works
+  m = 0    ! failed with SIGSEGV in pack_internal
+  do m = 0, 2
+     print *, m
+     allocate (old(m), mask(m), vec(m))
+     if (m > 0) vec(m)% r(1) = 42
+     mask(:) = .true.
+     n = count (mask)
+     allocate (new(n))
+
+     mask(:) = .false.
+     if (size (pack (old, mask)) /= 0) stop 1
+     mask(:) = .true.
+     if (size (pack (old, mask)) /= m) stop 2
+     new(:) = pack (old, mask)              ! this used to segfault for m=0
+
+     mask(:) = .false.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 3
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (     new( m  )% r(1) /=  42)  stop 4
+        if (any (new(:m-1)% r(1) /= -99)) stop 5
+     end if
+
+     if (m > 0) mask(m) = .true.
+     if (size (pack (old, mask, vector=vec)) /= m) stop 6
+     new(:) = t()
+     new(:) = pack (old, mask, vector=vec)  ! this used to segfault for m=0
+     if (m > 0) then
+        if (new(1)% r(1) /= -99) stop 7
+     end if
+     if (m > 1) then
+        if (new(m)% r(1) /=  42) stop 8
+     end if
+
+     if (size (pack (old(:0), mask(:0), vector=vec)) /= m) stop 9
+     new(:) = t()
+     new(:) = pack (old(:0), mask(:0), vector=vec) ! did segfault for m=0
+     if (m > 0) then
+        if (new(m)% r(1) /= 42) stop 10
+     end if
+     deallocate (old, mask, new, vec)
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/pdt_26.f03 b/gcc/testsuite/gfortran.dg/pdt_26.f03
index bf1273743d3..59ddcfb6cc4 100644
--- a/gcc/testsuite/gfortran.dg/pdt_26.f03
+++ b/gcc/testsuite/gfortran.dg/pdt_26.f03
@@ -2,7 +2,7 @@
 ! { dg-options "-fdump-tree-original" }
 !
 ! Test the fix for PR83567 in which the parameterized component 'foo' was
-! being deallocated before return from 'addw', with consequent segfault in 
+! being deallocated before return from 'addw', with consequent segfault in
 ! the main program.
 !
 ! Contributed by Berke Durak  <berke.durak@gmail.com>
@@ -43,4 +43,4 @@ program test_pdt
   if (any (c(1)%foo .ne. [13,15,17])) STOP 2
 end program test_pdt
 ! { dg-final { scan-tree-dump-times "__builtin_free" 8 "original" } }
-! { dg-final { scan-tree-dump-times "__builtin_malloc" 9 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 8 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pdt_31.f03 b/gcc/testsuite/gfortran.dg/pdt_31.f03
new file mode 100644
index 00000000000..708c9454217
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pdt_31.f03
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! Test the fix for PR100110, in which 'obj' was not being initialized.
+!
+! Contributed by Xiao Liu  <xiao.liu@compiler-dev.com>
+!
+program p
+  implicit none
+  type t(n)
+    integer, len :: n
+    integer :: arr(n, n)
+  end type
+
+  type(t(2)) :: obj
+
+  obj%arr = reshape ([1,2,3,4],[2,2])
+  if (obj%n .ne. 2) stop 1
+  if (any (shape(obj%arr) .ne. [2,2])) stop 2
+  call test()
+contains
+  subroutine test()
+    if (obj%n .ne. 2) stop 3
+    if (any (shape(obj%arr) .ne. [2,2])) stop 4
+    if (any (reshape (obj%arr, [4]) .ne. [1,2,3,4])) stop 5
+  end subroutine
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr100949.f90 b/gcc/testsuite/gfortran.dg/pr100949.f90
new file mode 100644
index 00000000000..6c736fd7f72
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr100949.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/100949 - ICE in gfc_conv_expr_present, at fortran/trans-expr.c:1975
+
+subroutine s
+entry f
+  type t
+  end type
+  class(t), allocatable :: y, z
+  allocate (z, mold=y)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr101327.f90 b/gcc/testsuite/gfortran.dg/pr101327.f90
new file mode 100644
index 00000000000..f4377aabe7a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr101327.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/101327 - ICE in find_array_element, at fortran/expr.c:1355
+
+subroutine s
+  integer, parameter :: n([2]) = [1, 2] ! { dg-error "must be scalar" }
+  type t
+     integer :: a(n(1):n(2))
+  end type
+end
+
+! { dg-error "cannot be automatic or of deferred shape" " " { target *-*-* } 5 }
diff --git a/gcc/testsuite/gfortran.dg/pr103588.f90 b/gcc/testsuite/gfortran.dg/pr103588.f90
new file mode 100644
index 00000000000..198e1766cd2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103588.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/103588 - ICE: Simplification error in gfc_ref_dimen_size
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "cannot be automatic or of deferred shape" }
+  integer :: b(2) = a(::a(1))        ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103606.f90 b/gcc/testsuite/gfortran.dg/pr103606.f90
new file mode 100644
index 00000000000..43283184e89
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103606.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103606 -  ICE in resolve_fl_procedure
+! Contributed by G.Steinmetz
+
+program p
+  type t
+  end type
+contains
+  elemental function f() result(z) ! { dg-error "CLASS variable" }
+    class(t) :: z
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103607.f90 b/gcc/testsuite/gfortran.dg/pr103607.f90
new file mode 100644
index 00000000000..a6a2c4fdfd0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103607.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/103607 - ICE in do_subscript, at fortran/frontend-passes.c:2927
+! Contributed by G.Steinmetz
+
+program p
+  integer :: i, x(abs(2.)) ! { dg-error "must be of INTEGER type" }
+  do i = 1, 2
+     x(i) = 0
+  end do
+end
+
+! { dg-prune-output "must have constant shape" }
diff --git a/gcc/testsuite/gfortran.dg/pr82314.f90 b/gcc/testsuite/gfortran.dg/pr82314.f90
new file mode 100644
index 00000000000..3a147e22711
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr82314.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR fortran/82314 - ICE in gfc_conv_expr_descriptor
+
+program p
+  implicit none
+  integer, parameter :: karray(merge(3,7,.true.):merge(3,7,.false.)) = 1
+  integer, parameter :: i = size   (karray)
+  integer, parameter :: l = lbound (karray,1)
+  integer, parameter :: u = ubound (karray,1)
+  if (l /= 3 .or. u /= 7 .or. i /= 5) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_52.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
new file mode 100644
index 00000000000..cb7cf7040a9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_52.f90
@@ -0,0 +1,72 @@
+! { dg-do run }
+!
+! Test the fix for PRs93924 & 93925.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+module cs
+
+implicit none
+
+integer, target :: integer_target
+
+abstract interface
+   function classStar_map_ifc(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+   end function classStar_map_ifc
+end interface
+
+contains
+
+   function fun(x) result(y)
+      class(*), pointer            :: y
+      class(*), target, intent(in) :: x
+      select type (x)
+      type is (integer)
+         integer_target = x        ! Deals with dangling target.
+         y => integer_target
+      class default
+         y => null()
+      end select
+   end function fun
+
+   function apply(f, x) result(y)
+      procedure(classStar_map_ifc) :: f
+      integer, intent(in) :: x
+      integer :: y
+      class(*), pointer :: p
+      y = 0                        ! Get rid of 'y' undefined warning
+      p => f (x)
+      select type (p)
+      type is (integer)
+         y = p
+      end select
+   end function apply
+
+   function selector() result(f)
+      procedure(classStar_map_ifc), pointer :: f
+      f => fun
+   end function selector
+
+end module cs
+
+
+program classStar_map
+
+use cs
+implicit none
+
+integer :: x, y
+procedure(classStar_map_ifc), pointer :: f
+
+x = 123654
+f => selector ()               ! Fixed by second chunk in patch
+y = apply (f, x)               ! Fixed by first chunk in patch
+if (x .ne. y) stop 1
+
+x = 2 * x
+y = apply (fun, x)             ! PR93925; fixed as above
+if (x .ne. y) stop 2
+
+end program classStar_map
diff --git a/gcc/testsuite/gfortran.dg/shape_11.f90 b/gcc/testsuite/gfortran.dg/shape_11.f90
new file mode 100644
index 00000000000..127d221e710
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_11.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/103610 - ICE while simplifying SHAPE
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(-1) = 1
+  integer, parameter :: b(1)  = maskl(shape(a))
+  integer, parameter :: c(1)  = shape(a)
+  integer, parameter :: d(1)  = maskr(shape(a))
+  if (b(1) /= 0) stop 1
+  if (c(1) /= 0) stop 2
+  if (d(1) /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/structure_constructor_17.f90 b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
new file mode 100644
index 00000000000..8b8230c6f7e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/structure_constructor_17.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Test the fix for PR97612.
+!
+! Contributed by Martin Stein  <mscfd@gmx.net>
+!
+program constructor_allocatable
+  implicit none
+
+  type :: s
+    integer, dimension(:), allocatable :: u
+  end type s
+
+  type :: t
+    type(s), dimension(:), allocatable :: x
+  end type t
+
+  type(t) :: a = t()
+  if (allocated (a%x)) stop 1
+
+end program constructor_allocatable
diff --git a/gcc/testsuite/gfortran.dg/substr_6.f90 b/gcc/testsuite/gfortran.dg/substr_6.f90
index 0d5e3d75e88..83e788a55a6 100644
--- a/gcc/testsuite/gfortran.dg/substr_6.f90
+++ b/gcc/testsuite/gfortran.dg/substr_6.f90
@@ -6,6 +6,8 @@ CHARACTER(5), parameter :: c0(1) = (/ "123" // ACHAR(0) // "5" /)
 CHARACTER*5 c(1)
 CHARACTER(1), parameter :: c1(5) = (/ "1", "2", "3", ACHAR(0), "5" /)
 
+c = c0(1)(-5:-8)
+if (c(1) /= "     ") STOP 1
 c = (/ c0(1)(1:5) /)
 do i=1,5
    if (c(1)(i:i) /= c1(i)) STOP 2
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index dc0cfe27142..a2ae3aefe4a 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -923,6 +923,7 @@ get_frame_field (struct nesting_info *info, tree target_context,
     }
 
   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);
+  TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (field);
   return x;
 }
 
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 909b4fef9a8..252953b7512 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -1530,7 +1530,8 @@ scan_function (void)
 		    }
 
 		  if (final_bbs
-		      && (flags & (ECF_CONST | ECF_PURE)) == 0)
+		      && ((flags & (ECF_CONST | ECF_PURE)) == 0
+			  || (flags & ECF_LOOPING_CONST_OR_PURE)))
 		    bitmap_set_bit (final_bbs, bb->index);
 		}
 
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index b0d56fcf3e3..5bb337b5417 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -695,7 +695,8 @@ pass_dominator::execute (function *fun)
      gcc.dg/tree-ssa/pr21417.c can't be threaded if loop preheader is
      missing.  We should improve jump threading in future then
      LOOPS_HAVE_PREHEADERS won't be needed here.  */
-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES
+		       | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS);
 
   /* Initialize the value-handle array.  */
   threadedge_initialize_values ();
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
index e5a47c6614b..ca1003361bb 100644
--- a/gcc/tree-ssa-phiopt.c
+++ b/gcc/tree-ssa-phiopt.c
@@ -753,9 +753,12 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,
   if ((integer_zerop (arg0) && integer_onep (arg1))
       || (integer_zerop (arg1) && integer_onep (arg0)))
     neg = false;
+  /* For signed one bit types, the negation is not needed and
+     should be avoided and is the same as 1 case for non-signed
+     one bit types.  */
   else if ((integer_zerop (arg0) && integer_all_onesp (arg1))
 	   || (integer_zerop (arg1) && integer_all_onesp (arg0)))
-    neg = true;
+    neg = TYPE_PRECISION (TREE_TYPE (arg0)) != 1;
   else
     return false;
 
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index c163c3823c2..5583db6db50 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -1972,6 +1972,13 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)
 			  && value_dies_in_block_x (expr, block))))
 		to_remove = i;
 	    }
+	  /* If the REFERENCE may trap make sure the block does not contain
+	     a possible exit point.
+	     ???  This is overly conservative if we translate AVAIL_OUT
+	     as the available expression might be after the exit point.  */
+	  if (BB_MAY_NOTRETURN (block)
+	      && vn_reference_may_trap (ref))
+	    to_remove = i;
 	}
       else if (expr->kind == NARY)
 	{
@@ -3302,7 +3309,11 @@ do_pre_regular_insertion (basic_block block, basic_block dom)
 	  /* If all edges produce the same value and that value is
 	     an invariant, then the PHI has the same value on all
 	     edges.  Note this.  */
-	  else if (!cant_insert && all_same)
+	  else if (!cant_insert
+		   && all_same
+		   && (edoubleprime->kind != NAME
+		       || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI
+			     (PRE_EXPR_NAME (edoubleprime))))
 	    {
 	      gcc_assert (edoubleprime->kind == CONSTANT
 			  || edoubleprime->kind == NAME);
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index f2e1766432b..151bffa7714 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -3424,9 +3424,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
   /* Step values are irrelevant for aliasing if the number of vector
      iterations is equal to the number of scalar iterations (which can
      happen for fully-SLP loops).  */
-  bool ignore_step_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
+  bool vf_one_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);
 
-  if (!ignore_step_p)
+  if (!vf_one_p)
     {
       /* Convert the checks for nonzero steps into bound tests.  */
       tree value;
@@ -3478,10 +3478,18 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)
       dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (DDR_B (ddr));
       stmt_vec_info stmt_info_b = dr_info_b->stmt;
 
+      bool preserves_scalar_order_p
+	= vect_preserves_scalar_order_p (dr_info_a, dr_info_b);
+      bool ignore_step_p
+	  = (vf_one_p
+	     && (preserves_scalar_order_p
+		 || operand_equal_p (DR_STEP (dr_info_a->dr),
+				     DR_STEP (dr_info_b->dr), 0)));
+
       /* Skip the pair if inter-iteration dependencies are irrelevant
 	 and intra-iteration dependencies are guaranteed to be honored.  */
       if (ignore_step_p
-	  && (vect_preserves_scalar_order_p (dr_info_a, dr_info_b)
+	  && (preserves_scalar_order_p
 	      || vectorizable_with_step_bound_p (dr_info_a, dr_info_b,
 						 &lower_bound)))
 	{
diff --git a/gcc/tree-vect-loop-manip.c b/gcc/tree-vect-loop-manip.c
index 030effcd79d..4951e1d505f 100644
--- a/gcc/tree-vect-loop-manip.c
+++ b/gcc/tree-vect-loop-manip.c
@@ -1774,7 +1774,8 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,
   FOR_EACH_VEC_ELT (datarefs, i, dr)
     {
       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);
-      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt))
+      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt)
+	  && !STMT_VINFO_SIMD_LANE_ACCESS_P (dr_info->stmt))
 	vect_update_init_of_dr (dr, niters, code);
     }
 }
diff --git a/gcc/tree.c b/gcc/tree.c
index be311754393..99f4318306a 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -12340,7 +12340,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	case OMP_CLAUSE_DEFAULTMAP:
 	case OMP_CLAUSE_AUTO:
 	case OMP_CLAUSE_SEQ:
-	case OMP_CLAUSE_TILE:
 	case OMP_CLAUSE__SIMT_:
 	case OMP_CLAUSE_IF_PRESENT:
 	case OMP_CLAUSE_FINALIZE:
@@ -12352,6 +12351,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));
 
 	case OMP_CLAUSE_COLLAPSE:
+	case OMP_CLAUSE_TILE:
 	  {
 	    int i;
 	    for (i = 0; i < 3; i++)
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 399ab06f58b..252af8fd3db 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,25 @@
+2021-10-27  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config.host (hppa*64*-*-linux*): Don't add pa/t-linux to
+	tmake_file.
+	* config/pa/linux-atomic.c: Define u8, u16 and u64 types.
+	Use them in FETCH_AND_OP_2, OP_AND_FETCH_2, COMPARE_AND_SWAP_2,
+	SYNC_LOCK_TEST_AND_SET_2 and SYNC_LOCK_RELEASE_1 macros.
+	* config/pa/t-linux64 (LIB1ASMSRC): New define.
+	(LIB1ASMFUNCS): Revise.
+	(HOST_LIBGCC2_CFLAGS): Add "-DLINUX=1".
+
+2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2021-08-31  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/value-unwind.h: Add missing runtime exception
+	paragraph.
+	* config/frv/frv-abi.h: Likewise.
+	* config/i386/value-unwind.h: Likewise.
+	* config/pa/pa64-hpux-lib.h: Likewise.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index bdbf77a3e62..0486a0135e8 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -566,7 +566,7 @@ h8300-*-linux*)
 	tm_file="$tm_file h8300/h8300-lib.h"
 	;;
 hppa*64*-*-linux*)
-	tmake_file="$tmake_file pa/t-linux pa/t-linux64"
+	tmake_file="$tmake_file pa/t-linux64"
 	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
 	;;
 hppa*-*-linux*)
diff --git a/libgcc/config/aarch64/value-unwind.h b/libgcc/config/aarch64/value-unwind.h
index 8e99d8e12ae..fb40f639fa9 100644
--- a/libgcc/config/aarch64/value-unwind.h
+++ b/libgcc/config/aarch64/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/frv/frv-abi.h b/libgcc/config/frv/frv-abi.h
index 45ad606e785..45ac387b054 100644
--- a/libgcc/config/frv/frv-abi.h
+++ b/libgcc/config/frv/frv-abi.h
@@ -14,6 +14,10 @@
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/i386/value-unwind.h b/libgcc/config/i386/value-unwind.h
index 5c1157d00e8..e3c8b6356b3 100644
--- a/libgcc/config/i386/value-unwind.h
+++ b/libgcc/config/i386/value-unwind.h
@@ -13,6 +13,10 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
    You should have received a copy of the GNU General Public License and
    a copy of the GCC Runtime Library Exception along with this program;
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
index 4cd69f74cd2..0e7e83c8586 100644
--- a/libgcc/config/pa/linux-atomic.c
+++ b/libgcc/config/pa/linux-atomic.c
@@ -28,6 +28,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define EBUSY   16
 #define ENOSYS 251 
 
+typedef unsigned char u8;
+typedef short unsigned int u16;
+#ifdef __LP64__
+typedef long unsigned int u64;
+#else
+typedef long long unsigned int u64;
+#endif
+
 /* PA-RISC 2.0 supports out-of-order execution for loads and stores.
    Thus, we need to synchonize memory accesses.  For more info, see:
    "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
@@ -117,26 +125,26 @@ __kernel_cmpxchg2 (volatile void *mem, const void *oldval, const void *newval,
     return tmp;								\
   }
 
-FETCH_AND_OP_2 (add,   , +, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (sub,   , -, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (or,    , |, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (and,   , &, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (xor,   , ^, long long unsigned int, 8, 3)
-FETCH_AND_OP_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-FETCH_AND_OP_2 (add,   , +, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (sub,   , -, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (or,    , |, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (and,   , &, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (xor,   , ^, short unsigned int, 2, 1)
-FETCH_AND_OP_2 (nand, ~, &, short unsigned int, 2, 1)
-
-FETCH_AND_OP_2 (add,   , +, unsigned char, 1, 0)
-FETCH_AND_OP_2 (sub,   , -, unsigned char, 1, 0)
-FETCH_AND_OP_2 (or,    , |, unsigned char, 1, 0)
-FETCH_AND_OP_2 (and,   , &, unsigned char, 1, 0)
-FETCH_AND_OP_2 (xor,   , ^, unsigned char, 1, 0)
-FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
+FETCH_AND_OP_2 (add,   , +, u64, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, u64, 8, 3)
+FETCH_AND_OP_2 (or,    , |, u64, 8, 3)
+FETCH_AND_OP_2 (and,   , &, u64, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, u64, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, u64, 8, 3)
+
+FETCH_AND_OP_2 (add,   , +, u16, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, u16, 2, 1)
+FETCH_AND_OP_2 (or,    , |, u16, 2, 1)
+FETCH_AND_OP_2 (and,   , &, u16, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, u16, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, u16, 2, 1)
+
+FETCH_AND_OP_2 (add,   , +, u8, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, u8, 1, 0)
+FETCH_AND_OP_2 (or,    , |, u8, 1, 0)
+FETCH_AND_OP_2 (and,   , &, u8, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, u8, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, u8, 1, 0)
 
 #define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
@@ -154,26 +162,26 @@ FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
     return PFX_OP (tmp INF_OP val);					\
   }
 
-OP_AND_FETCH_2 (add,   , +, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (sub,   , -, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (or,    , |, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (and,   , &, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (xor,   , ^, long long unsigned int, 8, 3)
-OP_AND_FETCH_2 (nand, ~, &, long long unsigned int, 8, 3)
-
-OP_AND_FETCH_2 (add,   , +, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (sub,   , -, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (or,    , |, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (and,   , &, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (xor,   , ^, short unsigned int, 2, 1)
-OP_AND_FETCH_2 (nand, ~, &, short unsigned int, 2, 1)
-
-OP_AND_FETCH_2 (add,   , +, unsigned char, 1, 0)
-OP_AND_FETCH_2 (sub,   , -, unsigned char, 1, 0)
-OP_AND_FETCH_2 (or,    , |, unsigned char, 1, 0)
-OP_AND_FETCH_2 (and,   , &, unsigned char, 1, 0)
-OP_AND_FETCH_2 (xor,   , ^, unsigned char, 1, 0)
-OP_AND_FETCH_2 (nand, ~, &, unsigned char, 1, 0)
+OP_AND_FETCH_2 (add,   , +, u64, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, u64, 8, 3)
+OP_AND_FETCH_2 (or,    , |, u64, 8, 3)
+OP_AND_FETCH_2 (and,   , &, u64, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, u64, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, u64, 8, 3)
+
+OP_AND_FETCH_2 (add,   , +, u16, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, u16, 2, 1)
+OP_AND_FETCH_2 (or,    , |, u16, 2, 1)
+OP_AND_FETCH_2 (and,   , &, u16, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, u16, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, u16, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, u8, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, u8, 1, 0)
+OP_AND_FETCH_2 (or,    , |, u8, 1, 0)
+OP_AND_FETCH_2 (and,   , &, u8, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, u8, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, u8, 1, 0)
 
 #define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
   unsigned int HIDDEN							\
@@ -254,9 +262,9 @@ typedef unsigned char bool;
     return (failure == 0);						\
   }
 
-COMPARE_AND_SWAP_2 (long long unsigned int, 8, 3)
-COMPARE_AND_SWAP_2 (short unsigned int, 2, 1)
-COMPARE_AND_SWAP_2 (unsigned char, 1, 0)
+COMPARE_AND_SWAP_2 (u64, 8, 3)
+COMPARE_AND_SWAP_2 (u16, 2, 1)
+COMPARE_AND_SWAP_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_val_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
@@ -304,9 +312,9 @@ TYPE HIDDEN								\
     return oldval;							\
   }
 
-SYNC_LOCK_TEST_AND_SET_2 (long long unsigned int, 8, 3)
-SYNC_LOCK_TEST_AND_SET_2 (short unsigned int, 2, 1)
-SYNC_LOCK_TEST_AND_SET_2 (unsigned char, 1, 0)
+SYNC_LOCK_TEST_AND_SET_2 (u64, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (u16, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (u8, 1, 0)
 
 unsigned int HIDDEN
 __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
@@ -336,9 +344,9 @@ __sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
     } while (failure != 0);					\
   }
 
-SYNC_LOCK_RELEASE_1 (long long unsigned int, 8, 3)
-SYNC_LOCK_RELEASE_1 (short unsigned int, 2, 1)
-SYNC_LOCK_RELEASE_1 (unsigned char, 1, 0)
+SYNC_LOCK_RELEASE_1 (u64, 8, 3)
+SYNC_LOCK_RELEASE_1 (u16, 2, 1)
+SYNC_LOCK_RELEASE_1 (u8, 1, 0)
 
 void HIDDEN
 __sync_lock_release_4 (volatile void *ptr)
diff --git a/libgcc/config/pa/pa64-hpux-lib.h b/libgcc/config/pa/pa64-hpux-lib.h
index 7112014d1e1..96441502497 100644
--- a/libgcc/config/pa/pa64-hpux-lib.h
+++ b/libgcc/config/pa/pa64-hpux-lib.h
@@ -14,8 +14,13 @@ but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
 /* We use DTOR_LIST_BEGIN to carry a bunch of hacks to allow us to use
diff --git a/libgcc/config/pa/t-linux64 b/libgcc/config/pa/t-linux64
index 1d0a6ada1a1..026b48b02e5 100644
--- a/libgcc/config/pa/t-linux64
+++ b/libgcc/config/pa/t-linux64
@@ -1,8 +1,8 @@
 # Plug millicode routines into libgcc.a  We want these on both native and
 # cross compiles.
-# FIXME: Explain.
-LIB1ASMFUNCS := $(filter-out _dyncall, $(LIB1ASMFUNCS))
+LIB1ASMSRC = pa/milli64.S
+LIB1ASMFUNCS = _divI _divU _remI _remU _div_const _mulI
 
-LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
+HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1 -DLINUX=1
 
-HOST_LIBGCC2_CFLAGS += -Dpa64=1 -DELF=1
+LIB2ADD_ST = $(srcdir)/config/pa/linux-atomic.c
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index c24f0cc8546..66a6d996c07 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,13 @@
+2021-12-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-12-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/103634
+	* intrinsics/pack_generic.c (pack_internal): Handle case when the
+	array argument of PACK has one or more extents of size zero to
+	avoid invalid reads.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libgfortran/intrinsics/pack_generic.c b/libgfortran/intrinsics/pack_generic.c
index 69306747e9c..2b7c955da54 100644
--- a/libgfortran/intrinsics/pack_generic.c
+++ b/libgfortran/intrinsics/pack_generic.c
@@ -85,6 +85,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
 
   index_type count[GFC_MAX_DIMENSIONS];
   index_type extent[GFC_MAX_DIMENSIONS];
+  bool zero_sized;
   index_type n;
   index_type dim;
   index_type nelem;
@@ -114,10 +115,13 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   else
     runtime_error ("Funny sized logical array");
 
+  zero_sized = false;
   for (n = 0; n < dim; n++)
     {
       count[n] = 0;
       extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);
+      if (extent[n] <= 0)
+	zero_sized = true;
       sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);
       mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);
     }
@@ -126,6 +130,11 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,
   if (mstride[0] == 0)
     mstride[0] = mask_kind;
 
+  if (zero_sized)
+    sptr = NULL;
+  else
+    sptr = array->base_addr;
+
   if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))
     {
       /* Count the elements, either for allocating memory or
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index 22d7711bb98..156378b7f0b 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,11 @@
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* testsuite/libitm.c++/libstdc++-pr91488.C: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libitm/testsuite/libitm.c++/libstdc++-pr91488.C b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
new file mode 100644
index 00000000000..e9e82bd1ce2
--- /dev/null
+++ b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
@@ -0,0 +1,9 @@
+// PR libstdc++/91488 "inlining failed in call to always_inline"
+// { dg-do run }
+// { dg-additional-options "-O1" }
+
+#include <string>
+
+int main() {
+    return std::char_traits<char>::length("");
+}
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 5c09737a6c2..bd2253f9105 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,29 @@
+2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-21  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/103604
+	* libdruntime/core/sys/posix/sys/stat.d (struct stat_t): Fix
+	definition for MIPS64.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/thread.d (defaultStackPages): New constant.
+	(Fiber.this): Set stack size to be a multiple of defaultStackPages.
+
+2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-11-19  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Don't remove entry
+	from global array.
+	(_d_emutls_destroy): Don't call __gthread_key_delete.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libphobos/libdruntime/core/sys/posix/sys/stat.d b/libphobos/libdruntime/core/sys/posix/sys/stat.d
index f394823767d..6c25bb45c9b 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/stat.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/stat.d
@@ -337,26 +337,23 @@ version (CRuntime_Glibc)
             }
             c_long[14]  st_pad5;
         }
+        static if (!__USE_FILE_OFFSET64)
+            static assert(stat_t.sizeof == 144);
+        else
+            static assert(stat_t.sizeof == 160);
     }
     else version (MIPS64)
     {
         struct stat_t
         {
-            c_ulong     st_dev;
+            dev_t       st_dev;
             int[3]      st_pad1;
-            static if (!__USE_FILE_OFFSET64)
-            {
-                ino_t       st_ino;
-            }
-            else
-            {
-                c_ulong     st_ino;
-            }
+            ino_t       st_ino;
             mode_t      st_mode;
             nlink_t     st_nlink;
             uid_t       st_uid;
             gid_t       st_gid;
-            c_ulong     st_rdev;
+            dev_t       st_rdev;
             static if (!__USE_FILE_OFFSET64)
             {
                 uint[2]     st_pad2;
@@ -365,8 +362,8 @@ version (CRuntime_Glibc)
             }
             else
             {
-                c_long[3]   st_pad2;
-                c_long      st_size;
+                uint[3]     st_pad2;
+                off_t       st_size;
             }
             static if (__USE_MISC || __USE_XOPEN2K8)
             {
@@ -391,15 +388,26 @@ version (CRuntime_Glibc)
             }
             blksize_t   st_blksize;
             uint        st_pad4;
+            blkcnt_t    st_blocks;
+            int[14]     st_pad5;
+        }
+        version (MIPS_N32)
+        {
             static if (!__USE_FILE_OFFSET64)
-            {
-                blkcnt_t    st_blocks;
-            }
+                static assert(stat_t.sizeof == 160);
             else
-            {
-                c_long  st_blocks;
-            }
-            c_long[14]  st_pad5;
+                static assert(stat_t.sizeof == 176);
+        }
+        else version (MIPS_O64)
+        {
+            static if (!__USE_FILE_OFFSET64)
+                static assert(stat_t.sizeof == 160);
+            else
+                static assert(stat_t.sizeof == 176);
+        }
+        else
+        {
+            static assert(stat_t.sizeof == 216);
         }
     }
     else version (PPC)
diff --git a/libphobos/libdruntime/core/thread.d b/libphobos/libdruntime/core/thread.d
index 3d2cd287a2e..feac50eb7f2 100644
--- a/libphobos/libdruntime/core/thread.d
+++ b/libphobos/libdruntime/core/thread.d
@@ -4144,6 +4144,24 @@ class Fiber
     // Initialization
     ///////////////////////////////////////////////////////////////////////////
 
+    version (Windows)
+        // exception handling walks the stack, invoking DbgHelp.dll which
+        // needs up to 16k of stack space depending on the version of DbgHelp.dll,
+        // the existence of debug symbols and other conditions. Avoid causing
+        // stack overflows by defaulting to a larger stack size
+        enum defaultStackPages = 8;
+    else version (OSX)
+    {
+        version (X86_64)
+            // libunwind on macOS 11 now requires more stack space than 16k, so
+            // default to a larger stack size. This is only applied to X86 as
+            // the PAGESIZE is still 4k, however on AArch64 it is 16k.
+            enum defaultStackPages = 8;
+        else
+            enum defaultStackPages = 4;
+    }
+    else
+        enum defaultStackPages = 4;
 
     /**
      * Initializes a fiber object which is associated with a static
@@ -4158,7 +4176,7 @@ class Fiber
      * In:
      *  fn must not be null.
      */
-    this( void function() fn, size_t sz = PAGESIZE*4,
+    this( void function() fn, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
@@ -4184,7 +4202,7 @@ class Fiber
      * In:
      *  dg must not be null.
      */
-    this( void delegate() dg, size_t sz = PAGESIZE*4,
+    this( void delegate() dg, size_t sz = PAGESIZE * defaultStackPages,
           size_t guardPageSize = PAGESIZE ) nothrow
     in
     {
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 461f20d9e28..72376ecda0f 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -229,9 +229,6 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
     auto arr = cast(TlsArray*) ptr;
-    emutlsMutex.lock_nothrow();
-    emutlsArrays.remove(arr);
-    emutlsMutex.unlock_nothrow();
 
     foreach (entry; *arr)
     {
@@ -308,9 +305,6 @@ void _d_emutls_scan(scope void delegate(void* pbeg, void* pend) nothrow cb) noth
 // Call this after druntime has been unloaded
 void _d_emutls_destroy() nothrow @nogc
 {
-    if (__gthread_key_delete(emutlsKey) != 0)
-        abort();
-
     (cast(Mutex) _emutlsMutex.ptr).__dtor();
     destroy(emutlsArrays);
 }
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index d8c2f6b863a..a82ac090821 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,10 @@
+2021-08-05  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/101749
+	* sanitizer_common/sanitizer_posix_libcdep.cc: Prevent
+	generation of dependency on _cxa_guard for static
+	initialization.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
index 1917e29ced2..8c8aa75004e 100644
--- a/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc
@@ -170,9 +170,10 @@ bool SupportsColoredOutput(fd_t fd) {
 #if !SANITIZER_GO
 // TODO(glider): different tools may require different altstack size.
 static uptr GetAltStackSize() {
-  // SIGSTKSZ is not enough.
-  static const uptr kAltStackSize = SIGSTKSZ * 4;
-  return kAltStackSize;
+  // Note: since GLIBC_2.31, SIGSTKSZ may be a function call, so this may be
+  // more costly that you think. However GetAltStackSize is only call 2-3 times
+  // per thread so don't cache the evaluation.
+  return SIGSTKSZ * 4;
 }
 
 void SetAlternateSignalStack() {
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 4a898cd27d7..3cf67c719cf 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,284 @@
+2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103381
+	* include/ext/bitmap_allocator.h: Include <bits/stl_function.h>
+	instead of <functional>.
+
+2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103022
+	* include/std/valarray (begin, end): Do not dereference an empty
+	valarray. Add noexcept.
+	* testsuite/26_numerics/valarray/range_access.cc: Check empty
+	valarray. Check iterator properties. Run as well as compiling.
+	* testsuite/26_numerics/valarray/range_access2.cc: Likewise.
+	* testsuite/26_numerics/valarray/103022.cc: New test.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/28_regex/match_results/102667.C: Moved to...
+	* testsuite/28_regex/match_results/102667.cc: ...here.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/26_numerics/valarray/dr630-3.C: Moved to...
+	* testsuite/26_numerics/valarray/dr630-3.cc: ...here.
+	* testsuite/27_io/basic_iostream/cons/16251.C: Moved to...
+	* testsuite/27_io/basic_iostream/cons/16251.cc: ...here.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (advance): Remove non-deducible
+	template parameter.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102425
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): Add 0 to
+	switch.
+	* testsuite/19_diagnostics/error_category/102425.cc: New test.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (StdErrorCodePrinter): Define.
+	(build_libstdcxx_dictionary): Register printer for
+	std::error_code and std::error_condition.
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Test it.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/Makefile.am [GLIBCXX_BUILD_DEBUG] (install-data-local):
+	Install another copy of the GDB hook.
+	* python/Makefile.in: Regenerate.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/remove_all.cc: Remove
+	test directory after making it writable again.
+	* testsuite/experimental/filesystem/operations/remove_all.cc:
+	Likewise.
+
+2021-10-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102667
+	* include/bits/regex.h (match_result::empty()): Optimize by
+	calling the base function directly.
+	(match_results::end()): Check _Base_type::empty() not empty().
+	* testsuite/28_regex/match_results/102667.C: New test.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101866
+	* testsuite/experimental/random/randint.cc: Loop and retry if
+	reseed() produces the same sequence.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (fs::create_directories): Use status
+	instead of symlink_status.
+	* src/filesystem/ops.cc (fs::create_directories): Likewise.
+	* testsuite/27_io/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/27_io/filesystem/operations/create_directory.cc: Do
+	not test with symlinks on Windows.
+	* testsuite/experimental/filesystem/operations/create_directories.cc:
+	Check symlink to existing directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Do not test with symlinks on Windows.
+
+2021-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101510
+	* src/c++17/fs_ops.cc (create_dir): Adjust whitespace.
+	* testsuite/27_io/filesystem/operations/create_directory.cc:
+	Test creating directory with name of existing symlink to
+	directory.
+	* testsuite/experimental/filesystem/operations/create_directory.cc:
+	Likewise.
+
+2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-02-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/c++17/fs_ops.cc (fs::symlink_status): Re-enable workaround.
+
+2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-02-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/c++17/fs_ops.cc (fs::status): Re-enable workaround.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/profile/mutex_extensions_neg.cc: Prune
+	additional errors in C++20 mode.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96657
+	* libsupc++/Makefile.am: Add atomicity.cc here.
+	* src/c++98/Makefile.am: Remove it from here.
+	* libsupc++/Makefile.in: Regenerate.
+	* src/c++98/Makefile.in: Regenerate.
+	* testsuite/18_support/exception_ptr/96657.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101034
+	* include/std/any (any(in_place_t<T>, initializer_list<U>, A&&...))
+	(any::emplace<T>(initializer_list<U>, A&&...)): Fix constraint
+	to use lvalue.
+	* testsuite/20_util/any/cons/101034.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-04-23  Kamlesh Kumar  <kamleshbhalui@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90415
+	PR libstdc++/92156
+	* include/std/any (any): Rename template parameters for consistency
+	with the standard.
+	(any::_Decay): Rename to _Decay_if_not_any.
+	(any::any(T&&)): Remove is_constructible from constraints. Remove
+	non-standard overload.
+	(any::any(in_place_type_t<T>, Args&&...))
+	(any::any(in_place_type_t<T>, initializer_list<U>, Args&&...))
+	(any::emplace(Args&&...))
+	(any::emplace(initializer_list<U>, Args&&...)):
+	Use decay_t instead of _Decay.
+	* testsuite/20_util/any/cons/90415.cc: New test.
+	* testsuite/20_util/any/cons/92156.cc: New Test.
+	* testsuite/20_util/any/misc/any_cast_neg.cc: Make dg-error directives
+	more robust.
+	* testsuite/20_util/any/modifiers/92156.cc: New test.
+
+2021-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100982
+	* include/std/optional (optional::operator=(const optional<U>&)):
+	Fix value category used in is_assignable check.
+	* testsuite/20_util/optional/assignment/100982.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95833
+	* include/std/numeric (reduce(Iter, Iter, T, BinaryOp)): Replace
+	incorrect static_assert with ones matching the 'Mandates'
+	conditions in the standard.
+	* testsuite/26_numerics/reduce/95833.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100630
+	* include/bits/fs_path.h (__is_constructible_from): Test
+	construction from a const lvalue, not an rvalue.
+	* include/experimental/bits/fs_path.h (__is_constructible_from):
+	Likewise.
+	* testsuite/27_io/filesystem/path/construct/100630.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/100630.cc:
+	New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100384
+	* include/std/variant (__get_t): New alias template yielding the
+	return type of std::get<N> on a variant.
+	(__visit_result_t): New alias template yielding the result of
+	std::visit.
+	(__do_visit): Use __get_t.
+	(visit): Use __visit_result_t for return type.
+	* testsuite/20_util/variant/100384.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99006
+	* include/bits/shared_ptr.h (allocate_shared): Assert that _Tp
+	is not an array type.
+	* include/bits/shared_ptr_base.h (__allocate_shared): Likewise.
+	* testsuite/20_util/shared_ptr/creation/99006.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* include/bits/char_traits.h (__constant_string_p)
+	(__constant_array_p): Give external linkage.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (find_type): Use tag attribute
+	instead of unqualified() method.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index 50bd25eb2df..4c7b84e357f 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -227,7 +227,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_string_p(const _CharT* __s)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
@@ -250,7 +250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 13eb18c0652..f4fa9f3719d 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void>
@@ -1274,7 +1274,7 @@ inline ptrdiff_t
 distance(filesystem::path::iterator __first, filesystem::path::iterator __last)
 { return __path_iter_distance(__first, __last); }
 
-template<typename _InputIterator, typename _Distance>
+template<typename _Distance>
   void
   advance(filesystem::path::iterator& __i, _Distance __n)
   { __path_iter_advance(__i, static_cast<ptrdiff_t>(__n)); }
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 8fb89071461..9ca4cf8a815 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -1707,7 +1707,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       _GLIBCXX_NODISCARD bool
       empty() const noexcept
-      { return size() == 0; }
+      { return _Base_type::size() <= 3; }
 
       ///@}
 
@@ -1825,7 +1825,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       const_iterator
       end() const noexcept
-      { return _Base_type::end() - (empty() ? 0 : 3); }
+      { return _Base_type::end() - (_Base_type::empty() ? 0 : 3); }
 
       /**
        * @brief Gets an iterator to one-past-the-end of the collection.
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 281600b2901..4ddc52ae723 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -698,6 +698,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline shared_ptr<_Tp>
     allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 			     std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index 0367c2d51a5..8af6e9fb11c 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1822,6 +1822,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     __allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 				    std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 33a415645d9..ba12b2f1734 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -125,7 +125,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void,
diff --git a/libstdc++-v3/include/ext/bitmap_allocator.h b/libstdc++-v3/include/ext/bitmap_allocator.h
index 532bad295b6..f2f0a38650b 100644
--- a/libstdc++-v3/include/ext/bitmap_allocator.h
+++ b/libstdc++-v3/include/ext/bitmap_allocator.h
@@ -31,7 +31,7 @@
 
 #include <utility> // For std::pair.
 #include <bits/functexcept.h> // For __throw_bad_alloc().
-#include <functional> // For greater_equal, and less_equal.
+#include <bits/stl_function.h> // For greater_equal, and less_equal.
 #include <new> // For operator new.
 #include <debug/debug.h> // _GLIBCXX_DEBUG_ASSERT
 #include <ext/concurrence.h>
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index 91c4c1a7cf1..4957144342c 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -105,8 +105,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 				     _Manager_internal<_Tp>,
 				     _Manager_external<_Tp>>;
 
-    template<typename _Tp, typename _Decayed = decay_t<_Tp>>
-      using _Decay = enable_if_t<!is_same<_Decayed, any>::value, _Decayed>;
+    template<typename _Tp, typename _VTp = decay_t<_Tp>>
+      using _Decay_if_not_any = enable_if_t<!is_same_v<_VTp, any>, _VTp>;
 
     /// Emplace with an object created from @p __args as the contained object.
     template <typename _Tp, typename... _Args,
@@ -125,10 +125,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void __do_emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	reset();
-        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
 	_M_manager = &_Mgr::_S_manage;
       }
 
+    template <typename _Res, typename _Tp, typename... _Args>
+      using __any_constructible
+	= enable_if<__and_<is_copy_constructible<_Tp>,
+			   is_constructible<_Tp, _Args...>>::value,
+		    _Res>;
+
+    template <typename _Tp, typename... _Args>
+      using __any_constructible_t
+	= typename __any_constructible<bool, _Tp, _Args...>::type;
+
+    template<typename _VTp, typename... _Args>
+      using __emplace_t
+	= typename __any_constructible<_VTp&, _VTp, _Args...>::type;
+
   public:
     // construct/destruct
 
@@ -165,65 +179,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	}
     }
 
-    template <typename _Res, typename _Tp, typename... _Args>
-    using __any_constructible =
-      enable_if<__and_<is_copy_constructible<_Tp>,
-			 is_constructible<_Tp, _Args...>>::value,
-		  _Res>;
-
-    template <typename _Tp, typename... _Args>
-    using __any_constructible_t =
-      typename __any_constructible<bool, _Tp, _Args...>::type;
-
     /// Construct with a copy of @p __value as the contained object.
-    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, _ValueType&&> = true,
-	      enable_if_t<!__is_in_place_type<_Tp>::value, bool> = true>
-      any(_ValueType&& __value)
+    template <typename _Tp, typename _VTp = _Decay_if_not_any<_Tp>,
+	      typename _Mgr = _Manager<_VTp>,
+	      enable_if_t<is_copy_constructible<_VTp>::value
+			  && !__is_in_place_type<_VTp>::value, bool> = true>
+      any(_Tp&& __value)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, std::forward<_ValueType>(__value));
-      }
-
-    /// Construct with a copy of @p __value as the contained object.
-    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              enable_if_t<__and_v<is_copy_constructible<_Tp>,
-				  __not_<is_constructible<_Tp, _ValueType&&>>,
-				  __not_<__is_in_place_type<_Tp>>>,
-			  bool> = false>
-      any(_ValueType&& __value)
-      : _M_manager(&_Mgr::_S_manage)
-      {
-        _Mgr::_S_create(_M_storage, __value);
+	_Mgr::_S_create(_M_storage, std::forward<_Tp>(__value));
       }
 
     /// Construct with an object created from @p __args as the contained object.
-    template <typename _ValueType, typename... _Args,
-	      typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, _Args&&...> = false>
+    template <typename _Tp, typename... _Args, typename _VTp = decay_t<_Tp>,
+	      typename _Mgr = _Manager<_VTp>,
+	      __any_constructible_t<_VTp, _Args&&...> = false>
       explicit
-      any(in_place_type_t<_ValueType>, _Args&&... __args)
+      any(in_place_type_t<_Tp>, _Args&&... __args)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
       }
 
     /// Construct with an object created from @p __il and @p __args as
     /// the contained object.
-    template <typename _ValueType, typename _Up, typename... _Args,
-	      typename _Tp = _Decay<_ValueType>,
-	      typename _Mgr = _Manager<_Tp>,
-              __any_constructible_t<_Tp, initializer_list<_Up>,
+    template <typename _Tp, typename _Up, typename... _Args,
+	      typename _VTp = decay_t<_Tp>, typename _Mgr = _Manager<_VTp>,
+	      __any_constructible_t<_VTp, initializer_list<_Up>&,
 				    _Args&&...> = false>
       explicit
-      any(in_place_type_t<_ValueType>,
-	  initializer_list<_Up> __il, _Args&&... __args)
+      any(in_place_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args)
       : _M_manager(&_Mgr::_S_manage)
       {
-        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
       }
 
     /// Destructor, calls @c reset()
@@ -232,7 +220,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // assignments
 
     /// Copy the state of another object.
-    any& operator=(const any& __rhs)
+    any&
+    operator=(const any& __rhs)
     {
       *this = any(__rhs);
       return *this;
@@ -243,7 +232,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
      *
      * @post @c !__rhs.has_value() (not guaranteed for other implementations)
      */
-    any& operator=(any&& __rhs) noexcept
+    any&
+    operator=(any&& __rhs) noexcept
     {
       if (!__rhs.has_value())
 	reset();
@@ -258,40 +248,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
     /// Store a copy of @p __rhs as the contained object.
-    template<typename _ValueType>
-      enable_if_t<is_copy_constructible<_Decay<_ValueType>>::value, any&>
-      operator=(_ValueType&& __rhs)
+    template<typename _Tp>
+      enable_if_t<is_copy_constructible<_Decay_if_not_any<_Tp>>::value, any&>
+      operator=(_Tp&& __rhs)
       {
-	*this = any(std::forward<_ValueType>(__rhs));
+	*this = any(std::forward<_Tp>(__rhs));
 	return *this;
       }
 
     /// Emplace with an object created from @p __args as the contained object.
-    template <typename _ValueType, typename... _Args>
-      typename __any_constructible<_Decay<_ValueType>&,
-				   _Decay<_ValueType>, _Args&&...>::type
+    template <typename _Tp, typename... _Args>
+      __emplace_t<decay_t<_Tp>, _Args...>
       emplace(_Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>>(std::forward<_Args>(__args)...);
+	using _VTp = decay_t<_Tp>;
+	__do_emplace<_VTp>(std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
+	return *static_cast<_VTp*>(__arg._M_obj);
       }
 
     /// Emplace with an object created from @p __il and @p __args as
     /// the contained object.
-    template <typename _ValueType, typename _Up, typename... _Args>
-      typename __any_constructible<_Decay<_ValueType>&,
-				   _Decay<_ValueType>,
-				   initializer_list<_Up>,
-				   _Args&&...>::type
+    template <typename _Tp, typename _Up, typename... _Args>
+      __emplace_t<decay_t<_Tp>, initializer_list<_Up>&, _Args&&...>
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>, _Up>(__il,
-					      std::forward<_Args>(__args)...);
+	using _VTp = decay_t<_Tp>;
+	__do_emplace<_VTp, _Up>(__il, std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
+	return *static_cast<_VTp*>(__arg._M_obj);
       }
 
     // modifiers
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index 7f80d06cfbc..25fdfaf735f 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -261,9 +261,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
 	   _BinaryOperation __binary_op)
     {
-      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      using __ref = typename iterator_traits<_InputIterator>::reference;
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, __ref>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, _Tp&>);
       static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, _Tp&>);
-      static_assert(is_convertible_v<value_type, _Tp>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, __ref>);
       if constexpr (__is_random_access_iter<_InputIterator>::value)
 	{
 	  while ((__last - __first) >= 4)
diff --git a/libstdc++-v3/include/std/optional b/libstdc++-v3/include/std/optional
index 503d859bee6..0b264f49a2a 100644
--- a/libstdc++-v3/include/std/optional
+++ b/libstdc++-v3/include/std/optional
@@ -796,7 +796,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up>
 	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
 			    is_constructible<_Tp, const _Up&>,
-			    is_assignable<_Tp&, _Up>,
+			    is_assignable<_Tp&, const _Up&>,
 			    __not_<__converts_from_optional<_Tp, _Up>>,
 			    __not_<__assigns_from_optional<_Tp, _Up>>>,
 		    optional&>
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index 10b294ba012..25b534c27f3 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -1211,8 +1211,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    begin(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to the first element of
@@ -1221,8 +1221,8 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    begin(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]); }
+    begin(const valarray<_Tp>& __va) noexcept
+    { return __va.size() ? std::__addressof(__va[0]) : nullptr; }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1231,8 +1231,13 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline _Tp*
-    end(valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 
   /**
    *  @brief  Return an iterator pointing to one past the last element of
@@ -1241,8 +1246,13 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
    */
   template<class _Tp>
     inline const _Tp*
-    end(const valarray<_Tp>& __va)
-    { return std::__addressof(__va[0]) + __va.size(); }
+    end(const valarray<_Tp>& __va) noexcept
+    {
+      if (auto __n = __va.size())
+	return std::__addressof(__va[0]) + __n;
+      else
+	return nullptr;
+    }
 #endif // C++11
 
   /// @} group numeric_arrays
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index 321228753cd..99a35cc5915 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -1039,6 +1039,14 @@ namespace __variant
 			      std::index_sequence<__indices...>>
     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
 
+  template<size_t _Np, typename _Variant>
+    using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
+
+  // Return type of std::visit.
+  template<typename _Visitor, typename... _Variants>
+    using __visit_result_t
+      = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
+
 } // namespace __variant
 } // namespace __detail
 
@@ -1191,7 +1199,8 @@ namespace __variant
 #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
+    visit(_Visitor&&, _Variants&&...);
 
   template<typename... _Types>
     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
@@ -1638,7 +1647,7 @@ namespace __variant
     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       using _Deduced_type = std::invoke_result<_Visitor,
-	decltype(std::get<0>(std::declval<_Variants>()))...>;
+	__detail::__variant::__get_t<0, _Variants>...>;
 
       using _Result_type = typename std::conditional_t<__use_index,
 	__detail::__variant::__variant_idx_cookie,
@@ -1654,14 +1663,14 @@ namespace __variant
     }
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto)
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
     visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       if ((__variants.valueless_by_exception() || ...))
 	__throw_bad_variant_access("Unexpected index");
 
-      return __do_visit(std::forward<_Visitor>(__visitor),
-			std::forward<_Variants>(__variants)...);
+      return std::__do_visit(std::forward<_Visitor>(__visitor),
+			     std::forward<_Variants>(__variants)...);
     }
 
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index eec7b953514..efffc014847 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -48,6 +48,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -127,6 +128,9 @@ cp-demangle.lo: cp-demangle.c
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 5d8ac5ca0ba..b469f62a43d 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -152,13 +152,13 @@ am__installdirs = "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(bitsdir)" \
 LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libsupc___la_LIBADD =
 am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \
-	bad_alloc.lo bad_array_length.lo bad_array_new.lo bad_cast.lo \
-	bad_typeid.lo class_type_info.lo del_op.lo del_ops.lo \
-	del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo dyncast.lo \
-	eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \
-	eh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \
-	eh_term_handler.lo eh_terminate.lo eh_tm.lo eh_throw.lo \
-	eh_type.lo eh_unex_handler.lo enum_type_info.lo \
+	atomicity.lo bad_alloc.lo bad_array_length.lo bad_array_new.lo \
+	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
+	del_ops.lo del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo \
+	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+	eh_catch.lo eh_exception.lo eh_globals.lo eh_personality.lo \
+	eh_ptr.lo eh_term_handler.lo eh_terminate.lo eh_tm.lo \
+	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
 	function_type_info.lo fundamental_type_info.lo guard.lo \
 	guard_error.lo hash_bytes.lo nested_exception.lo \
 	new_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \
@@ -497,6 +497,7 @@ sources = \
 	array_type_info.cc \
 	atexit_arm.cc \
 	atexit_thread.cc \
+	atomicity.cc \
 	bad_alloc.cc \
 	bad_array_length.cc \
 	bad_array_new.cc \
@@ -563,6 +564,7 @@ sources = \
 
 libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)
+atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
@@ -954,6 +956,8 @@ cp-demangle.lo: cp-demangle.c
 	$(LTCOMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
 cp-demangle.o: cp-demangle.c
 	$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<
+atomicity.cc: ${atomicity_file}
+	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 # Use special rules for the C++17 sources so that the proper flags are passed.
 new_opa.lo: new_opa.cc
diff --git a/libstdc++-v3/python/Makefile.am b/libstdc++-v3/python/Makefile.am
index 44d0b3e7fb4..c3dd4e8b406 100644
--- a/libstdc++-v3/python/Makefile.am
+++ b/libstdc++-v3/python/Makefile.am
@@ -29,6 +29,12 @@ else
 pythondir = $(datadir)/gcc-$(gcc_version)/python
 endif
 
+if GLIBCXX_BUILD_DEBUG
+debug_gdb_py = YES
+else
+debug_gdb_py =
+endif
+
 all-local: gdb.py
 
 nobase_python_DATA = \
@@ -61,4 +67,8 @@ install-data-local: gdb.py
 	  done; \
 	cd $$here; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
index 7b51946c49a..22dfc703e49 100644
--- a/libstdc++-v3/python/Makefile.in
+++ b/libstdc++-v3/python/Makefile.in
@@ -397,6 +397,8 @@ WARN_CXXFLAGS = \
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
 @ENABLE_PYTHONDIR_FALSE@pythondir = $(datadir)/gcc-$(gcc_version)/python
 @ENABLE_PYTHONDIR_TRUE@pythondir = $(prefix)/$(python_mod_dir)
+@GLIBCXX_BUILD_DEBUG_FALSE@debug_gdb_py = 
+@GLIBCXX_BUILD_DEBUG_TRUE@debug_gdb_py = YES
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/xmethods.py \
@@ -614,7 +616,11 @@ install-data-local: gdb.py
 	  done; \
 	cd $$here; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py ; \
+	if [ -n "$(debug_gdb_py)" ]; then \
+	  sed "/^libdir = /s;'$$;/debug';" gdb.py > debug-gdb.py ; \
+	  $(INSTALL_DATA) debug-gdb.py $(DESTDIR)$(toolexeclibdir)/debug/$$libname-gdb.py ; \
+	fi
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 32b8210414a..25d9d2e1868 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -18,7 +18,7 @@
 import gdb
 import itertools
 import re
-import sys
+import sys, os, errno
 
 ### Python 2 + Python 3 compatibility code
 
@@ -85,8 +85,8 @@ except ImportError:
 def find_type(orig, name):
     typ = orig.strip_typedefs()
     while True:
-        # Strip cv-qualifiers.  PR 67440.
-        search = '%s::%s' % (typ.unqualified(), name)
+        # Use Type.tag to ignore cv-qualifiers.  PR 67440.
+        search = '%s::%s' % (typ.tag, name)
         try:
             return gdb.lookup_type(search)
         except RuntimeError:
@@ -1449,6 +1449,45 @@ class StdPairPrinter:
         return None
 
 
+class StdErrorCodePrinter:
+    "Print a std::error_code or std::error_condition"
+
+    _errno_categories = None # List of categories that use errno values
+
+    def __init__ (self, typename, val):
+        self.val = val
+        self.typename = typename
+        # Do this only once ...
+        if StdErrorCodePrinter._errno_categories is None:
+            StdErrorCodePrinter._errno_categories = ['generic']
+            try:
+                import posix
+                StdErrorCodePrinter._errno_categories.append('system')
+            except ImportError:
+                pass
+
+    @staticmethod
+    def _category_name(cat):
+        "Call the virtual function that overrides std::error_category::name()"
+        gdb.set_convenience_variable('__cat', cat)
+        return gdb.parse_and_eval('$__cat->name()').string()
+
+    def to_string (self):
+        value = self.val['_M_value']
+        category = self._category_name(self.val['_M_cat'])
+        strval = str(value)
+        if value == 0:
+            default_cats = {'error_code':'system', 'error_condition':'generic'}
+            unqualified = self.typename.split('::')[-1]
+            if category == default_cats[unqualified]:
+                return self.typename + ' = { }' # default-constructed value
+        if value > 0 and category in StdErrorCodePrinter._errno_categories:
+            try:
+                strval = errno.errorcode[int(value)]
+            except:
+                pass
+        return '%s = {"%s": %s}' % (self.typename, category, strval)
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1846,6 +1885,8 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_version('std::__cxx11::', 'basic_string', StdStringPrinter)
     libstdcxx_printer.add_container('std::', 'bitset', StdBitsetPrinter)
     libstdcxx_printer.add_container('std::', 'deque', StdDequePrinter)
+    libstdcxx_printer.add_version('std::', 'error_code', StdErrorCodePrinter)
+    libstdcxx_printer.add_version('std::', 'error_condition', StdErrorCodePrinter)
     libstdcxx_printer.add_container('std::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::__cxx11::', 'list', StdListPrinter)
     libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
diff --git a/libstdc++-v3/src/c++11/system_error.cc b/libstdc++-v3/src/c++11/system_error.cc
index d67e3a4f975..3c8f32d8eab 100644
--- a/libstdc++-v3/src/c++11/system_error.cc
+++ b/libstdc++-v3/src/c++11/system_error.cc
@@ -70,6 +70,8 @@ namespace
     virtual std::error_condition
     default_error_condition(int ev) const noexcept
     {
+      // Use generic category for all known POSIX errno values (including zero)
+      // and system category otherwise.
       switch (ev)
       {
       // List of errno macros from [cerrno.syn].
@@ -309,6 +311,7 @@ namespace
 #ifdef EXDEV
       case EXDEV:
 #endif
+      case 0:
         return std::error_condition(ev, std::generic_category());
 
       /* Additional system-dependent mappings from non-standard error codes
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index f744d2f7b56..f37d5497075 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -496,7 +496,7 @@ fs::create_directories(const path& p, error_code& ec)
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
@@ -577,8 +577,7 @@ namespace
   {
     bool created = false;
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
-    posix::mode_t mode
-      = static_cast<std::underlying_type_t<fs::perms>>(perm);
+    posix::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);
     if (posix::mkdir(p.c_str(), mode))
       {
 	const int err = errno;
@@ -1404,7 +1403,6 @@ fs::status(const fs::path& p, error_code& ec) noexcept
   auto str = p.c_str();
 
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
-#if ! defined __MINGW64_VERSION_MAJOR || __MINGW64_VERSION_MAJOR < 6
   // stat() fails if there's a trailing slash (PR 88881)
   path p2;
   if (p.has_relative_path() && !p.has_filename())
@@ -1421,7 +1419,6 @@ fs::status(const fs::path& p, error_code& ec) noexcept
 	}
       str = p2.c_str();
     }
-#endif
 #endif
 
   stat_type st;
@@ -1451,7 +1448,6 @@ fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
   auto str = p.c_str();
 
 #if _GLIBCXX_FILESYSTEM_IS_WINDOWS
-#if ! defined __MINGW64_VERSION_MAJOR || __MINGW64_VERSION_MAJOR < 6
   // stat() fails if there's a trailing slash (PR 88881)
   path p2;
   if (p.has_relative_path() && !p.has_filename())
@@ -1468,7 +1464,6 @@ fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
 	}
       str = p2.c_str();
     }
-#endif
 #endif
 
   stat_type st;
diff --git a/libstdc++-v3/src/c++98/Makefile.am b/libstdc++-v3/src/c++98/Makefile.am
index ba88f002389..c215cf2376e 100644
--- a/libstdc++-v3/src/c++98/Makefile.am
+++ b/libstdc++-v3/src/c++98/Makefile.am
@@ -39,7 +39,6 @@ endif
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -65,10 +64,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
-
 if ENABLE_DUAL_ABI
 collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/c++98/Makefile.in b/libstdc++-v3/src/c++98/Makefile.in
index 7825b94b0ad..45a32ac7579 100644
--- a/libstdc++-v3/src/c++98/Makefile.in
+++ b/libstdc++-v3/src/c++98/Makefile.in
@@ -126,9 +126,9 @@ libc__98convenience_la_LIBADD =
 @ENABLE_DUAL_ABI_TRUE@	messages_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	monetary_members_cow.lo \
 @ENABLE_DUAL_ABI_TRUE@	numeric_members_cow.lo
-am__objects_3 = $(am__objects_2) atomicity.lo codecvt_members.lo \
-	collate_members.lo messages_members.lo monetary_members.lo \
-	numeric_members.lo time_members.lo
+am__objects_3 = $(am__objects_2) codecvt_members.lo collate_members.lo \
+	messages_members.lo monetary_members.lo numeric_members.lo \
+	time_members.lo
 @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = allocator-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	concept-inst.lo ext-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	misc-inst.lo
@@ -442,7 +442,6 @@ headers =
 # particular host.
 host_sources = \
 	$(cow_string_host_sources) \
-	atomicity.cc \
 	codecvt_members.cc \
 	collate_members.cc \
 	messages_members.cc \
@@ -450,7 +449,6 @@ host_sources = \
 	numeric_members.cc \
 	time_members.cc
 
-atomicity_file = ${glibcxx_srcdir}/$(ATOMICITY_SRCDIR)/atomicity.h
 
 # Source files linked in via configuration/make substitution for a
 # particular host, but with ad hoc naming rules.
@@ -841,8 +839,6 @@ numeric_members.cc: ${glibcxx_srcdir}/$(CNUMERIC_CC)
 
 time_members.cc: ${glibcxx_srcdir}/$(CTIME_CC)
 	$(LN_S) ${glibcxx_srcdir}/$(CTIME_CC) . || true
-atomicity.cc: ${atomicity_file}
-	$(LN_S) ${atomicity_file} ./atomicity.cc || true
 
 @ENABLE_DUAL_ABI_TRUE@collate_members_cow.cc: ${glibcxx_srcdir}/$(CCOLLATE_CC)
 @ENABLE_DUAL_ABI_TRUE@	$(LN_S) ${glibcxx_srcdir}/$(CCOLLATE_CC) ./$@ || true
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 4859b6e7fa6..ea2693622de 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -426,7 +426,7 @@ fs::create_directories(const path& p, error_code& ec) noexcept
       return false;
     }
 
-  file_status st = symlink_status(p, ec);
+  file_status st = status(p, ec);
   if (is_directory(st))
     return false;
   else if (ec && !status_known(st))
diff --git a/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
new file mode 100644
index 00000000000..61572668385
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/exception_ptr/96657.cc
@@ -0,0 +1,17 @@
+// { dg-options "-nodefaultlibs -lsupc++ -lgcc_s -lc" { target sparc*-*-linux-gnu } }
+// { dg-do link { target c++11 } }
+
+#include <exception>
+
+void
+test01()
+{
+  // PR libstdc++/96657 undefined references in libsupc++
+  std::make_exception_ptr(1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
new file mode 100644
index 00000000000..069b5e284e1
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/error_category/102425.cc
@@ -0,0 +1,18 @@
+// { dg-do run { target c++11 } }
+#include <system_error>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  // PR libstdc++/102425
+  VERIFY( std::error_code() == std::error_condition() );
+
+  auto zero = std::system_category().default_error_condition(0);
+  // This is the condition that the equality above relies on:
+  VERIFY( zero.category() == std::generic_category() );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/101034.cc b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
new file mode 100644
index 00000000000..55f550a839e
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/101034.cc
@@ -0,0 +1,11 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/101034 - wrong constraint in std::any's constructor
+
+#include <any>
+
+struct S {
+  S(std::initializer_list<int>&, int) {}
+};
+
+std::any a(std::in_place_type<S>, {0}, 0);
+S& s = a.emplace<S>({0}, 0);
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/90415.cc b/libstdc++-v3/testsuite/20_util/any/cons/90415.cc
new file mode 100644
index 00000000000..122262386d3
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/90415.cc
@@ -0,0 +1,64 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/90415
+  static_assert( std::is_copy_constructible<std::tuple<std::any>>::value );
+}
+
+struct wrapper
+{
+  wrapper() = default;
+
+  wrapper(const std::any& t);
+
+  wrapper(const wrapper& w);
+
+  auto& operator=(const std::any& t);
+
+  auto& operator=(const wrapper& w)
+  {
+    value = w.value;
+    return *this;
+  }
+
+  std::any value;
+};
+
+void
+test02()
+{
+  // PR libstdc++/91630
+  wrapper a, b;
+  a = b;
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/92156.cc b/libstdc++-v3/testsuite/20_util/any/cons/92156.cc
new file mode 100644
index 00000000000..d797473716d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/92156.cc
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  auto a = std::any(std::in_place_type<std::any>, 5);
+  VERIFY( std::any_cast<int>(std::any_cast<std::any>(a)) == 5 );
+
+  auto b = std::any(std::in_place_type<std::any>, {1});
+  (void) std::any_cast<std::initializer_list<int>>(std::any_cast<std::any>(b));
+}
+
+void
+test02()
+{
+  std::any p = std::pair<std::any, std::any>(1, 1);
+  auto pt = std::any_cast<std::pair<std::any, std::any>>(p);
+  VERIFY( std::any_cast<int>(pt.first) == 1 );
+  VERIFY( std::any_cast<int>(pt.second) == 1 );
+
+  std::any t = std::tuple<std::any>(1);
+  auto tt = std::any_cast<std::tuple<std::any>>(t);
+  VERIFY( std::any_cast<int>(std::get<0>(tt)) == 1 );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
index d8a52d719db..0c56fce963f 100644
--- a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
@@ -1,5 +1,5 @@
 // { dg-options "-std=gnu++17" }
-// { dg-do compile }
+// { dg-do compile { target c++17 } }
 
 // Copyright (C) 2014-2019 Free Software Foundation, Inc.
 //
@@ -26,20 +26,22 @@ using std::any_cast;
 void test01()
 {
   const any y(1);
-  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 461 }
-  // { dg-error "Template argument must be constructible from a const value" "" { target { *-*-* } } 457 }
+  any_cast<int&>(y); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from a const value" "" { target { *-*-* } } 0 }
 }
 
 void test02()
 {
   any y(1);
-  any_cast<int&&>(y);
-  // { dg-error "Template argument must be constructible from an lvalue" "" { target { *-*-* } } 483 }
+  any_cast<int&&>(y); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from an lvalue" "" { target { *-*-* } } 0 }
 }
 
 void test03()
 {
   any y(1);
-  any_cast<int&>(std::move(y));  // { dg-error "invalid static_cast" "" { target { *-*-* } } 501 }
-  // { dg-error "Template argument must be constructible from an rvalue" "" { target { *-*-* } } 497 }
+  any_cast<int&>(std::move(y)); // { dg-error "here" }
+  // { dg-error "Template argument must be constructible from an rvalue" "" { target { *-*-* } } 0 }
 }
+
+// { dg-prune-output "invalid static_cast" }
diff --git a/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc b/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc
new file mode 100644
index 00000000000..4a7bc97bb83
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/modifiers/92156.cc
@@ -0,0 +1,57 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <any>
+#include <utility>
+#include <tuple>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::any a;
+  a.emplace<std::any>(5);
+  VERIFY( std::any_cast<int>(std::any_cast<std::any>(a)) == 5 );
+
+  std::any b;
+  b.emplace<std::any>({1});
+  (void) std::any_cast<std::initializer_list<int>>(std::any_cast<std::any>(b));
+}
+
+void
+test02()
+{
+  std::any p;
+  p.emplace<std::pair<std::any, std::any>>(1, 1);
+  auto pt = std::any_cast<std::pair<std::any, std::any>>(p);
+  VERIFY( std::any_cast<int>(pt.first) == 1 );
+  VERIFY( std::any_cast<int>(pt.second) == 1 );
+
+  std::any t;
+  t.emplace<std::tuple<std::any>>(1);
+  auto tt = std::any_cast<std::tuple<std::any>>(t);
+  VERIFY( std::any_cast<int>(std::get<0>(tt)) == 1 );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
new file mode 100644
index 00000000000..ae565250d68
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/optional/assignment/100982.cc
@@ -0,0 +1,17 @@
+// { dg-do compile { target c++17 } }
+
+#include <optional>
+
+struct U {};
+
+struct T {
+  explicit T(const U&);
+  T& operator=(const U&);
+  T& operator=(U&&) = delete;
+};
+
+int main() {
+  std::optional<U> opt1;
+  std::optional<T> opt2;
+  opt2 = opt1; // PR libstdc++/100982
+}
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
new file mode 100644
index 00000000000..d5f7a5da5e9
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
@@ -0,0 +1,9 @@
+// FIXME: This should use { target { ! c++20 } }
+// { dg-do compile }
+
+#include <memory>
+
+auto p = std::make_shared<int[]>(2); // { dg-error "here" }
+auto q = std::make_shared<int[2]>(1, 2); // { dg-error "here" }
+
+// { dg-prune-output "static assertion failed" }
diff --git a/libstdc++-v3/testsuite/20_util/variant/100384.cc b/libstdc++-v3/testsuite/20_util/variant/100384.cc
new file mode 100644
index 00000000000..4866aa017ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/100384.cc
@@ -0,0 +1,9 @@
+// { dg-do compile { target c++17 } }
+
+#include <variant>
+
+int visit(int*, std::true_type) { return 0; }
+
+const std::true_type dat;
+
+int i = visit(nullptr, dat);
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
new file mode 100644
index 00000000000..cf4644f53c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/95833 - Incorrect static_assert in std::reduce overload
+
+#include <numeric>
+
+struct A { };
+struct B { };
+
+struct binop
+{
+  template<typename T, typename U>
+    A operator()(T&&, U&&) const { return A{}; }
+};
+
+B b;
+A a = std::reduce(&b, &b + 1, A{}, binop{});
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
new file mode 100644
index 00000000000..d2e346760dd
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/103022.cc
@@ -0,0 +1,15 @@
+// { dg-options "-D_GLIBCXX_DEBUG" }
+// { dg-do compile { target c++11 } }
+
+#include <valarray>
+
+int main()
+{
+  // PR libstdc++/103022
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C b/libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
similarity index 100%
rename from libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.C
rename to libstdc++-v3/testsuite/26_numerics/valarray/dr630-3.cc
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
index 352f0e53c9f..e5791e04ffe 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 // Copyright (C) 2010-2019 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <valarray>
 
@@ -25,9 +25,42 @@ void
 test01()
 {
   std::valarray<double> va{1.0, 2.0, 3.0};
-  std::begin(va);
-  std::end(va);
+  (void) std::begin(va);
+  (void) std::end(va);
   const auto& cva = va;
-  std::begin(cva);
-  std::end(cva);
+  (void) std::begin(cva);
+  (void) std::end(cva);
+
+  using Iter = decltype(std::begin(va));
+  using IterTraits = std::iterator_traits<Iter>;
+  static_assert( std::is_same<Iter, decltype(std::end(va))>::value, "" );
+  static_assert( std::is_same<IterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<IterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<IterTraits::reference, double&>::value, "" );
+  using CIter = decltype(std::begin(cva));
+  using CIterTraits = std::iterator_traits<CIter>;
+  static_assert( std::is_same<CIter, decltype(std::end(cva))>::value, "" );
+  static_assert( std::is_same<CIterTraits::iterator_category,
+			      std::random_access_iterator_tag>::value, "" );
+  static_assert( std::is_same<CIterTraits::value_type, double>::value, "" );
+  static_assert( std::is_same<CIterTraits::reference, const double&>::value, "" );
+}
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::begin(va);
+  (void) std::end(va);
+  const auto& cva = va;
+  (void) std::begin(cva);
+  (void) std::end(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
index c0d87c68132..538a3864c05 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
@@ -1,4 +1,4 @@
-// { dg-do compile { target c++14 } }
+// { dg-do run { target c++14 } }
 
 // Copyright (C) 2015-2019 Free Software Foundation, Inc.
 //
@@ -17,7 +17,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// 26.6.10 valarray range access: [valarray.range]
+// C++11 26.6.10 valarray range access: [valarray.range]
 
 #include <iterator>
 #include <valarray>
@@ -33,3 +33,21 @@ test01()
   std::cbegin(cva);
   std::cend(cva);
 }
+
+// PR libstdc++/103022
+void
+test02()
+{
+  std::valarray<double> va;
+  (void) std::cbegin(va);
+  (void) std::cend(va);
+  const auto& cva = va;
+  (void) std::cbegin(cva);
+  (void) std::cend(cva);
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C b/libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
similarity index 100%
rename from libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.C
rename to libstdc++-v3/testsuite/27_io/basic_iostream/cons/16251.cc
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
index c4411dfc1e7..7dd9c209b40 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directories.cc
@@ -146,10 +146,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
index da78fb2de87..9555280e8c6 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/create_directory.cc
@@ -55,6 +55,37 @@ test01()
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = bad_ec;
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
index b0b176fc656..aef29cc71a0 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc
@@ -169,6 +169,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write, fs::perm_options::add);
+  fs::remove_all(dir, ec);
+  f.path.clear();
 #endif
 }
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..eb8473e600e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <filesystem>
+
+void f(bool) { }
+void f(const std::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
new file mode 100644
index 00000000000..9e38c9edaa4
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
@@ -0,0 +1,39 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::cmatch sm;
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() );  // PR libstdc++/83600
+
+  bool matched = std::regex_match("a", sm, std::regex("b"));
+  VERIFY( ! matched );
+  VERIFY( sm.ready() );
+  VERIFY( sm.empty() );
+  VERIFY( sm.size() == 0 );
+  VERIFY( sm.begin() == sm.end() ); // PR libstdc++/102667
+
+  matched = std::regex_match("a", sm, std::regex("a"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 1 );
+  VERIFY( (sm.end() - sm.begin()) == 1 );
+
+  matched = std::regex_search("abcd", sm, std::regex("(b)(c)"));
+  VERIFY( matched );
+  VERIFY( sm.ready() );
+  VERIFY( ! sm.empty() );
+  VERIFY( sm.size() == 3 );
+  VERIFY( (sm.end() - sm.begin()) == 3 );
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
index b6909b630d4..6cfa7800860 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
@@ -129,10 +129,33 @@ test03()
   remove_all(p);
 }
 
+void
+test04()
+{
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510
+  // create_directories reports an error if the path is a symlink to a dir
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  const auto p = __gnu_test::nonexistent_path() / "";
+  fs::create_directories(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  bool created = fs::create_directories(link, ec);
+  VERIFY( !created );
+  VERIFY( !ec );
+  created = fs::create_directories(link);
+  VERIFY( !created );
+  remove_all(p);
+#endif
+}
+
 int
 main()
 {
   test01();
   test02();
   test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
index 3a79d6622b9..20701ae4fcc 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directory.cc
@@ -46,12 +46,44 @@ test01()
   VERIFY( exists(p) );
 
   // Test existing path (libstdc++/71036).
+  ec = make_error_code(std::errc::invalid_argument);
   b = create_directory(p, ec);
   VERIFY( !ec );
   VERIFY( !b );
   b = create_directory(p);
   VERIFY( !b );
 
+  auto f = p/"file";
+  std::ofstream{f} << "create file";
+  b = create_directory(f, ec);
+  VERIFY( ec == std::errc::file_exists );
+  VERIFY( !b );
+  try
+  {
+    create_directory(f);
+    VERIFY( false );
+  }
+  catch (const fs::filesystem_error& e)
+  {
+    VERIFY( e.code() == std::errc::file_exists );
+    VERIFY( e.path1() == f );
+  }
+
+#if defined(__MINGW32__) || defined(__MINGW64__)
+  // no symlinks
+#else
+  // PR libstdc++/101510 create_directory on an existing symlink to a directory
+  fs::create_directory(p/"dir");
+  auto link = p/"link";
+  fs::create_directory_symlink("dir", link);
+  ec = make_error_code(std::errc::invalid_argument);
+  b = fs::create_directory(link, ec);
+  VERIFY( !b );
+  VERIFY( !ec );
+  b = fs::create_directory(link);
+  VERIFY( !b );
+#endif
+
   remove_all(p, ec);
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
index 9d51a66c71f..c233b60c550 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc
@@ -137,6 +137,8 @@ test04()
   }
 
   fs::permissions(dir, fs::perms::owner_write|fs::perms::add_perms);
+  fs::remove_all(dir, ec);
+  f.path.clear();
 #endif
 }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..b2428ff74cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+
+void f(bool) { }
+void f(const std::experimental::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/experimental/random/randint.cc b/libstdc++-v3/testsuite/experimental/random/randint.cc
index 2b7966901f4..67197d3db7a 100644
--- a/libstdc++-v3/testsuite/experimental/random/randint.cc
+++ b/libstdc++-v3/testsuite/experimental/random/randint.cc
@@ -34,7 +34,7 @@ test01()
   }
 
   std::experimental::reseed(99u);
-  const long n1[] = {
+  const int n1[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -42,7 +42,7 @@ test01()
     std::experimental::randint(0, 100)
   };
   std::experimental::reseed(99u);
-  const long n2[] = {
+  const int n2[] = {
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
     std::experimental::randint(0, 100),
@@ -52,13 +52,13 @@ test01()
   for (int i = 0; i < 5; ++i)
     VERIFY( n1[i] == n2[i] );
 
-  std::experimental::reseed();
-  const long n3[] = {
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100),
-    std::experimental::randint(0, 100)
-  };
-  VERIFY( !(n3[0] == n1[0] && n3[1] == n1[1] && n3[2] == n1[2]) );
+  do
+  {
+    std::experimental::reseed();
+  }
+  while (std::experimental::randint(0, 100) == n1[0]
+      && std::experimental::randint(0, 100) == n1[1]
+      && std::experimental::randint(0, 100) == n1[2]);
 }
 
 void
diff --git a/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc b/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
index cd2a48845aa..f34c4fd107e 100644
--- a/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
+++ b/libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc
@@ -31,3 +31,6 @@
 // { dg-prune-output "tuple:993" }
 // PMR alias templates cause ambiguities between debug and profile containers:
 // { dg-prune-output "is ambiguous" }
+// C++20 uniform container erasure causes more errors
+// { dg-prune-output "expected nested-name-specifier before" }
+// { dg-prune-output "expected initializer before" }
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
index 71a50988924..bff9d1b27de 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
@@ -161,6 +161,25 @@ main()
 // { dg-final { note-test tpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
   ExTuple &rtpl = tpl;
 // { dg-final { note-test rtpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
+
+  std::error_code e0;
+  // { dg-final { note-test e0 {std::error_code = { }} } }
+  std::error_condition ec0;
+  // { dg-final { note-test ec0 {std::error_condition = { }} } }
+  std::error_code einval = std::make_error_code(std::errc::invalid_argument);
+  // { dg-final { note-test einval {std::error_code = {"generic": EINVAL}} } }
+  std::error_condition ecinval = std::make_error_condition(std::errc::invalid_argument);
+  // { dg-final { note-test ecinval {std::error_condition = {"generic": EINVAL}} } }
+
+  struct custom_cat : std::error_category {
+    const char* name() const noexcept { return "miaow"; }
+    std::string message(int) const { return ""; }
+  } cat;
+  std::error_code emiaow(42, cat);
+  // { dg-final { note-test emiaow {std::error_code = {"miaow": 42}} } }
+  std::error_condition ecmiaow(42, cat);
+  // { dg-final { note-test ecmiaow {std::error_condition = {"miaow": 42}} } }
+
   placeholder(""); // Mark SPOT
   use(efl);
   use(fl);
