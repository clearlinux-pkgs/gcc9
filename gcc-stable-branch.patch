Alan Modra (2):
      [RS6000] PR94145, make PLT loads volatile
      [RS6000] ICE in decompose, at rtl.h:2282

Alex Coplan (7):
      aarch64: PR target/94591: Don't generate invalid REV64 insns
      arm: Don't generate invalid LDRD insns
      aarch64: Add support for Neoverse V1 CPU
      arm: Add support for Neoverse V1 CPU
      aarch64: Add support for Neoverse N2 CPU
      arm: Add support for Neoverse N2 CPU
      arm: Add missing part number for Neoverse V1

Alexandre Oliva (2):
      [rs6000] fix mffsl emulation
      accept <case> and [cond] in ChangeLog

Andre Vieira (1):
      aarch64: Fix bootstrap with old binutils [PR93053]

Andrea Corallo (2):
      aarch64: backport fix for PR target/94530
      libstdc++-v3/test: Better skip for "use_service.cc"

Andreas Krebbel (5):
      PR94613: Fix vec_sel builtin for IBM Z
      S/390: Fix PR94666
      Add missing changelog entries
      IBM Z: vec_store_len_r/vec_load_len_r fix
      Fix PR97439

Bill Schmidt (1):
      rs6000: Fix -mpower9-vector -mno-altivec ICE (PR87560)

Bin Cheng (5):
      backport PR94125: Update post order number for merged SCC.
      Add unsigned type iv_cand for iv_use with non mode-precision type
      Add missing unit dependence vector in data dependence analysis
      Record and restore postorder information in breaking alias sccs.
      Schedule reduction partition in the last.

Carl Love (4):
      rs6000: Add command line and builtin compatibility check
      rs6000: vec_rlnm fix to make builtin work according to ABI
      rs6000, Fix header comment for intrinsic function _mm_movemask_epi8
      pr94833, fix vec_first_match_index for nulls

Christophe Lyon (3):
      testsuite: Fix gcc.target/arm/stack-protector-1.c for Cortex-M
      arm: Fix -mpure-code support/-mslow-flash-data for armv8-m.base [PR94538]
      testsuite: [aarch64] Fix aarch64/advsimd-intrinsics/v{trn,uzp,zip}_half.c

Claudiu Zissulescu (1):
      arc: Allow more ABIs in GLIBC_DYNAMIC_LINKER

Clement Chigot (1):
      rs6000: Link with libc128.a for long-double-128.

Cui,Lili (2):
      Enable MOVDIRI, MOVDIR64B, CLDEMOTE and WAITPKG for march=tremont
      Put PREFETCHW back to march=broadwell

David Edelsohn (2):
      rs6000: AIX long double builtins for 64 bit long double.
      rs6000: Correct logic to disable NO_SUM_IN_TOC and NO_FP_IN_TOC [PR94065]

Dominique d'Humieres (1):
      PR 93592 - Invalid UP/DOWN rounding with EN descriptor.

Douglas Rupp (1):
      Require powerpc_vsx_ok in gcc.target/powerpc/pr71763.c

Ed Schonberg (1):
      Fix PR ada/98230

Eric Botcazou (25):
      Fix incorrect filling of delay slots in branchy code at -O2
      Fix wrong year in ChangeLog.
      Fix Ada bootstrap on Cygwin64
      Update the baseline symbols for SPARC64/Linux
      Fix memory corruption with vector and variant record
      Fix uninitialized variable with nested variant record types
      Adjust email address
      Fix crash on array component with nonstandard index type
      Fix segfault on elaboration of empty 1-element array at -O
      Fix biased integer arithmetic
      Fix PR target/96607
      Fix PR target/97939
      Fix internal error on library-level type extended locally
      Fix PR testsuite/90806 on the 9 branch
      Fix PR ada/98740
      Fix internal error on extension with interface at -O2
      Fix PR ada/98228
      Fix LTO bootstrap on Windows
      Assorted LTO fixes for Ada
      Fix regression with partial rep clause on variant record type
      Fix -freorder-blocks-and-partition glitch with Windows SEH
      Fix cast in df_worklist_dataflow_doublequeue
      Fix wrong result for 1.0/3.0 at -O2 -fno-omit-frame-pointer -frounding-math
      Fix ICE with pathologically large frames
      Fix build breakage with latest glibc release

François Dumont (3):
      libstdc++: Fix pretty printers script and tests
      libstdc++: Fix [multi]map/[multi]set move constructors noexcept qualification
      libstdc++: Fix unordered containers move constructors noexcept qualification

Fritz Reese (2):
      Fix fortran/85982 ICE in resolve_component.
      Fix fortran/93686 -- ICE matching data statements with derived-type pointers.

GCC Administrator (394):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Gerald Pfeifer (1):
      i386: Define __ILP32__ and _ILP32 for all 32-bit targets

Gustavo Romero (1):
      selftest: Work around GCC 4.2 PR33916 bug by optimizing the ctor [PR89494]

H.J. Lu (11):
      x86: Insert ENDBR if function will be called indirectly
      x86: Restore the frame pointer in word_mode
      x86: Allow -fcf-protection with external thunk
      x86: Update GFNI check
      x86: Update VPCLMULQDQ check
      x86: Handle -mavx512vpopcntdq for -march=native
      x86: Update Intel processor detection
      x96: Remove PTA_CLWB from PTA_ICELAKE_CLIENT
      rtl_data: Add sp_is_clobbered_by_asm
      x86: Use SET operation in MOVDIRI and MOVDIR64B
      x86: Add __volatile__ to __cpuid and __cpuid_count

Haijian Zhang (1):
      pr94780.c fails with ICE on aarch64 [PR94820]

Harald Anlauf (38):
      PR fortran/93364 - ICE in gfc_set_array_spec, at fortran/array.c:879
      PR fortran/95104 - Segfault on a legal WAIT statement
      PR fortran/95104 - Segfault on a legal WAIT statement
      PR fortran/95500 - Segfault compiling extra interface on intrinsic
      PR fortran/95530, PR fortran/95537 - Buffer overflows with long symbols
      PR fortran/95106 - truncation of long symbol names with EQUIVALENCE
      PR fortran/95373 - ICE in build_reference_type, at tree.c:7942
      PR fortran/95373 - ICE in build_reference_type, at tree.c:7942
      PR fortran/95091 - Buffer overflows with submodules and long symbols
      PR fortran/95091 - Buffer overflows with submodules and long symbols
      PR fortran/95611 - ICE in access_attr_decl, at fortran/decl.c:9075
      PR fortran/95503 - Fix ICE in gfc_is_simply_contiguous, at fortran/expr.c:5844
      PR fortran/95587 - ICE in gfc_target_encode_expr, at fortran/target-memory.c:362
      PR fortran/95689 - ICE in check_sym_interfaces, at fortran/interface.c:2015
      Revert "PR fortran/95689 - ICE in check_sym_interfaces, at fortran/interface.c:2015"
      PR fortran/95881 - ICE in resolve_symbol, at fortran/resolve.c:15175
      PR fortran/95880 - ICE in gfc_add_type, at fortran/symbol.c:2030
      PR fortran/71706 - ICE on using sync images with -fcheck=bounds
      PR fortran/88379 - ICE with allocatable coarray, class and associate
      PR fortran/93337 - ICE in gfc_dt_upper_string, at fortran/module.c:441
      PR fortran/95709 - ICE in gfc_resolve_code, at fortran/resolve.c:11807
      PR fortran/89574 - ICE in conv_function_val, at fortran/trans-expr.c:3792
      PR fortran/96890 - Wrong answer with intrinsic IALL
      PR fortran/93423 - ICE on invalid with argument list for module procedure
      PR fortran/97272 - Wrong answer from MAXLOC with character arg
      PR libfortran/97063 - Wrong result for vector (step size is negative) * matrix
      PR fortran/95342 - ICE in gfc_match_subroutine, at fortran/decl.c:7913
      PR fortran/98017 - Suspected regression using PACK
      PR fortran/98307 - Dependency check fails when using "allocatable"
      PR fortran/93685 - ICE in gfc_constructor_append_expr, at fortran/constructor.c:135
      PR fortran/96381 - invalid read in gfc_find_derived_vtab
      PR fortran/78746 - invalid access after error recovery
      PR fortran/86470 - ICE with OpenMP, class(*) allocatable
      PR fortran/99169 - Do not clobber allocatable intent(out) dummy argument
      PR fortran/93340 - fix missed substring simplifications
      PR libfortran/99218 - matmul on temporary array accesses invalid memory
      PR fortran/97491 - Wrong restriction for VALUE arguments of pure procedures
      PR fortran/99840 - ICE in gfc_simplify_matmul, at fortran/simplify.c:4777

Hongyu Wang (1):
      Add missing FSF copyright notes for x86 intrinsic headers.

Iain Buclaw (16):
      d: Fix ICE in add_symbol_to_partition_1, at lto/lto-partition.c:215
      libphobos: Fix struct layout of stat32_t on sparc-*-solaris*
      libphobos: Fix struct layout of addrinfo on sparc-*-solaris*
      libphobos: Fix struct layout of stat_t on sparc-*-solaris*
      d: Fix wrong vtable offset in virtual function call
      d: Fix ICE in verify_gimple_stmt, at tree-cfg.c:4959
      d: Fix multiple definition error when using mixins and interfaces.
      d: Fix ICE in uda_attribute_p when looking up unknown attribute
      d: Fix ICE during error recovery in semantic pass
      d: Fix ICE in expand_intrinsic_vaarg
      d: Fix alias protection being ignored if used before declaration.
      d: Fix ICE in gimplify_expr, at gimplify.c (PR98277)
      libphobos: Fix executables segfault on mipsel architecture
      d: Fix junk in generated symbol on powerpc64-*-* [PR98921]
      d: Fix heap-buffer-overflow in checkModFileAlias [PR 99337]
      Fix ICE: in function_and_variable_visibility, at ipa-visibility.c:795 [PR99466]

Iain Sandoe (3):
      Darwin: Fix i686 bootstrap when the assembler supports GOTOFF in data.
      Darwin, libgfortran : Do not use environ directly from the library.
      libobjc, Darwin : Fix powerpc encoding regression.

Ian Lance Taylor (2):
      go.test: update issue4085b.go to version from Go 1.13
      runtime: cast SIGSTKSZ to uintptr

Jakub Jelinek (83):
      Bump BASE-VER to 9.3.1.
      tailcall: Fix up process_assignment [PR94001]
      inliner: Copy DECL_BY_REFERENCE in copy_decl_to_var [PR93888]
      print-rtl: Fix printing of CONST_STRING in DEBUG_INSNs [PR93399]
      ldist: Further fixes for -ftrapv [PR94114]
      dfp: Fix decimal_to_binary [PR94111]
      aarch64: Fix ICE in aarch64_add_offset_1 [PR94121]
      pdp11: Fix handling of common (local and global) vars [PR94134]
      tree-dse: Fix mem* head trimming if call has lhs [PR94130]
      doc: Fix up ASM_OUTPUT_ALIGNED_DECL_LOCAL description
      maintainer-scripts: Fix up gcc_release without -l, where mkdir was using umask 077 after migration
      aarch64: Fix another bug in aarch64_add_offset_1 [PR94121]
      tree-nested: Fix handling of *reduction clauses with C array sections [PR93566]
      tree-inline: Fix a -fcompare-debug issue in the inliner [PR94167]
      expand: Don't depend on warning flags in code generation of strnlen [PR94189]
      aarch64: Fix ICE due to aarch64_gen_compare_reg_maybe_ze [PR94435]
      i386: Fix emit_reduc_half on V{64Q,32H}Imode [PR94500]
      c++: Fix parsing of invalid enum specifiers [PR90995]
      c: Handle C_TYPE_INCOMPLETE_VARS even for ENUMERAL_TYPEs [PR94172]
      phiopt: Avoid -fcompare-debug bug in phiopt [PR94211]
      c++: Fix up handling of captured vars in lambdas in OpenMP clauses [PR93931]
      c: Fix up cfun->function_end_locus from the C FE [PR94029]
      c: Fix up cfun->function_end_locus on invalid function bodies [PR94239]
      cgraphunit: Avoid code generation differences based on -w/TREE_NO_WARNING [PR94277]
      if-conv: Fix -fcompare-debug bugs in ifcvt_local_dce [PR94283]
      if-conv: Delete dead stmts backwards in ifcvt_local_dce [PR94283]
      varasm: Fix output_constructor where a RANGE_EXPR index needs to skip some elts [PR94303]
      reassoc: Fix -fcompare-debug bug in reassociate_bb [PR94329]
      Fix vextract* masked patterns [PR93069]
      c++: Fix handling of internal fn calls in statement expressions [PR94385]
      fold-const: Fix division folding with vector operands [PR94412]
      objsz: Don't call replace_uses_by on SSA_NAME_OCCURS_IN_ABNORMAL_PHI [PR94423]
      i386: Fix vph{add,subs?}[wd] 256-bit AVX2 RTL patterns [PR94460]
      openmp: Fix ICE on #pragma omp parallel master in template [PR94477]
      debug: Improve debug info of c++14 deduced return type [PR94459]
      aarch64: Fix {ash[lr],lshr}<mode>3 expanders [PR94488]
      openmp: Fix parallel master error recovery [PR94512]
      i386: Fix V{64QI,32HI}mode constant permutations [PR94509]
      libstdc++: Update {x86_64,i?86,powerpc64,s390x,aarch64}-linux baselines for GCC 10.1
      testsuite: Improve g++.dg/ext/attr-parm-1.C testcase [PR94946]
      aarch64: Fix up __aarch64_cas16_acq_rel fallback
      i386: Fix up vector mul and div with broadcasts in -masm=intel mode
      c++: Further fix for -fsanitize=vptr [PR94325]
      i386: Don't use AVX512F integral masks for V*TImode [PR94438]
      vect: Fix up lowering of TRUNC_MOD_EXPR by negative constant [PR94524]
      c++: Fix pasto in structured binding diagnostics [PR94571]
      inliner: Don't ICE on NULL TYPE_DOMAIN [PR94621]
      Fix -fcompare-debug issue in delete_insn_and_edges [PR94618]
      ubsan: Avoid -Wpadded warnings [PR94641]
      attribs: Don't diagnose attribute exclusions during error recovery [PR94705]
      Shortcut identity VEC_PERM expansion [PR94710]
      c++: Avoid -Wreturn-type warning if a template fn calls noreturn template fn [PR94742]
      c-family: Fix ICE on __builtin_speculation_safe_value () [PR94755]
      x86: Fix up ix86_atomic_assign_expand_fenv [PR94780]
      tree: Fix up TREE_SIDE_EFFECTS on internal calls [PR94809]
      rs6000: Fix rs6000_atomic_assign_expand_fenv [PR94826]
      x86: Fix -O0 intrinsic *gather*/*scatter* macros [PR94832]
      x86: Fix -O0 remaining intrinsic macros [PR94832]
      tilegx: Unbreak build
      c: Fix ICE with _Atomic side-effect in nested fn param decls [PR94842]
      combine: Don't replace SET_SRC with REG_EQUAL note content if SET_SRC has side-effects [PR94873]
      riscv: Fix up riscv_atomic_assign_expand_fenv [PR94950]
      c++: Avoid strict_aliasing_warning on dependent types or expressions [PR94951]
      Fix -fcompare-debug issue in purge_dead_edges [PR95080]
      openmp: Fix placement of 2nd+ preparation statement for PHIs in simd clone lowering [PR95108]
      c++: Try to complete decomp types [PR95328]
      fold-const: Fix A <= 0 ? A : -A folding [PR95810]
      c-family: Use TYPE_OVERFLOW_UNDEFINED instead of !TYPE_UNSIGNED in pointer_sum [PR95903]
      tree-cfg: Fix ICE with switch stmt to unreachable opt and forced labels [PR95857]
      fix _mm512_{,mask_}cmp*_p[ds]_mask at -O0 [PR96174]
      veclower: Don't ICE on .VEC_CONVERT calls with no lhs [PR96426]
      openmp: Handle reduction clauses on host teams construct [PR96459]
      openmp: Handle clauses with gimple sequences in convert_nonlocal_omp_clauses properly
      c-family: Fix ICE in get_atomic_generic_size [PR96545]
      c: Fix -Wunused-but-set-* warning with _Generic [PR96571]
      gimple: Ignore *0 = {CLOBBER} in path isolation [PR96722]
      dwarf2out: Fix up dwarf2out_next_real_insn caching [PR96729]
      c++: Disable -frounding-math during manifestly constant evaluation [PR96862]
      store-merging: Consider also overlapping stores earlier in the by bitpos sorting [PR97053]
      optabs: Don't reuse target for multi-word expansions if it overlaps operand(s) [PR97073]
      s390: Fix up s390_atomic_assign_expand_fenv
      testsuite: add another test for the rotate vectorization miscompilation
      arm: Fix up neon_vector_mem_operand [PR97528]

Jason Merrill (19):
      c++: Fix CTAD with multiple-arg ctor template [93248].
      c++: Fix ICE-after-error on partial spec [92068]
      c++: Find parameter pack in typedef in lambda [92909].
      c++: Fix comparison of fn() and ns::fn() [PR90711]
      c++: alias template and parameter packs (PR91966).
      c++: Fix reuse of class constants [PR94453]
      c++: Mangling of dependent conversions [PR91377]
      c++: Avoid ICE with dependent attribute on type.
      c++: generic lambda and -fsanitize=vla-bound [PR93822]
      c++: -fmerge-all-constants vs. destructors [PR91529]
      c++: Local class DMI using local static [PR90479]
      c++: constexpr and lambda capture [PR90212]
      c++: Fix FE devirt with diamond inheritance [PR95158]
      dwarf2: ICE with local class in unused function [PR97918]
      c++: Fix list-init of array of no-copy type [PR63707]
      c++: Allow GNU attributes before lambda -> [PR90333]
      c++: Fix attr-lambda3.C
      c++: C++17 and decltype of multi-operator expression [PR95675]
      c++: Fix class NTTP constness handling [PR98810]

Jiufu Guo (1):
      rs6000: Check -+0 and NaN for smax/smin generation

John David Anglin (2):
      Define __BIG_ENDIAN__
      Add mi_thunk support for vcalls on hppa.

Jonathan Wakely (69):
      libstdc++: Ensure root-dir converted to forward slash (PR93244)
      libstdc++: Fix FS-dependent filesystem tests
      libstdc++: Fix test failure due to -Wnonnull warnings
      libstdc++: Fix name of macro in #undef directive
      libstdc++: Handle type-changing path concatenations (PR 94063)
      libstdc++: Add default constructor to net::service_already_exists (PR 94199)
      doc: Note that some warnings depend on optimizations (PR 92757)
      libstdc++: Fix std::to_address for debug iterators (PR 93960)
      libstdc++: Document correct feature test macro, __cpp_lib_is_invocable
      libstdc++: Update __cpp_lib_erase_if macro (P1115R3)
      libstdc++: Improve C++14 status docs
      libstdc++: Add __cpp_lib_unwrap_ref feature test macro
      libstdc++: Fix some missing/incorrect feature test macros
      Fix <version> header for freestanding
      libstdc++: Define __cpp_lib_constexpr_complex macro
      libstdc++: Define missing __cpp_lib_int_pow2 macro
      libstdc++: Add comments to non-standard feature test macros
      libstdc++: Add missing feature test macros
      libstdc++: Update __cpp_lib_array_constexpr and __cpp_lib_string_view
      libstdc++: Define __cpp_lib_execution feature test
      libstdc++: Make net::service_already_exists default constructible
      libstdc++: Fix type-erasure in experimental::net::executor (PR 94203)
      libstdc++: Fix broken link to SGI STL FAQ
      libstdc++: Document library versioning for 9.[123] and 10.1
      libstdc++: Fix incorrect size calculation in PMR resource  (PR 94906)
      libstdc++: Fix std::from_chars to ignore leading zeros in base 2
      libstdc++: Remove noexcept from match_results comparisons (PR 94627)
      gcc-changelog: Fix typo in output
      cpp: Do not use @dots for ... tokens in code examples
      libstdc++: Fix unnecessary allocations in read_symlink [PR 96484]
      libstdc++: Fix path::generic_string allocator handling (PR 94242)
      libstdc++: Fix experimental::path::generic_string (PR 93245)
      libstdc++: Use _wstat64 for Windows [PR 95749]
      libstdc++: Disable net tests that depend on threads [PR 89760]
      libstdc++: Add deprecated attributes to old iostream members
      libstdc++: Make variant_npos conversions explicit [PR 96766]
      libstdc++: Enable assertions in constexpr string_view members [PR 71960]
      libstdc++: Avoid errors in allocator's noexcept-specifier (PR 89510)
      libstdc++: Fix is_trivially_constructible (PR 94033)
      libstdc++: handle small max_blocks_per_chunk in pool resources [PR 94160]
      libstdc++: Fix noexcept-specifier for std::bind_front [PR 97101]
      libstdc++: Make C++17 ignore --disable-libstdcxx-filesystem-ts [PR 94681]
      libstdc++: Fix build for targets without lstat [PR 94681]
      libstdc++: Fix std::gcd and std::lcm for unsigned integers [PR 92978]
      libstdc++: Use correct argument type for __use_alloc [PR 96803]
      libstdc++: Use correct argument type for __use_alloc, again [PR 96803]
      libstdc++: Fix out-of-bounds string_view access in filesystem::path [PR 97167]
      libstdc++: Fix non-reserved name in header
      libstdc++: Make std::assume_aligned a constexpr function [PR 97132]
      libstdc++: Use non-throwing increment in recursive_directory_iterator [PR 97731]
      libstdc++: Fix __numeric_traits_integer<__int20> [PR 97798]
      libstdc++: Make pmr::synchronized_pool_resource work without libpthread (PR 94936)
      libstdc++: Fix undefined FILE* operations in test
      libstdc++: Remove accidental -std=gnu++17 from test
      libstdc++: improve how pretty printers find node types (PR 91997)
      libstdc++: Fix unique_ptr pretty printer for empty classes
      libstdc++: Fix compatibility support in unique_ptr pretty printer
      libstdc++: Fix std::any pretty printer [PR 68735]
      libstdc++: Only use __builtin_sprintf if supported [PR 96083]
      libstdc++: Fix filesystem::path pretty printer test failure
      libstdc++: Fix misnamed configure option in manual
      libstdc++: Fix clang analyzer suppression [PR 98605]
      libstdc++: Fix Doxygen warning about ambiguous file name
      libstdc++: Fix doxygen markup for group close commands
      libstdc++: Fix more doxygen markup for group close commands
      libstdc++: Fix Doxygen warnings
      libstdc++: Fix even more doxygen markup for group close commands
      libstdc++: Fix invalid constexpr function in C++11 mode [PR 99985]
      libstdc++: Fix bootstrap error due to inconsistent noexcept-specifier [PR 99983]

Joseph Myers (1):
      Remove wrongly committed file.

Julian Brown (1):
      Test cases for mixed structured/dynamic data lifetimes with OpenACC [PR92843]

Kewen Lin (8):
      [testsuite] Fix PR94023 to guard case under vect_hw_misalign
      [testsuite] Fix PR94019 to check vector char when vect_hw_misalign
      [testsuite] Fix PR93935 to guard case under vect_hw_misalign
      Fix PR94043 by making vect_live_op generate lc-phi
      Fix PR94443 with gsi_insert_seq_before [PR94443]
      testsuite: Add -fno-common to pr82374.c [PR94077]
      rs6000: Backport fixes for PR92923 and PR93136
      changelog: Fix up changelogs for commit 8c18220564

Kito Cheng (1):
      PR target/99702: Check RTL type before get value

Kwok Cheung Yeung (1):
      libgomp_g.h: Include stdint.h instead of gstdint.h.

Kyrylo Tkachov (32):
      aarch64: Extend %R for integer registers
      aarch64: Implement TImode compare-and-swap
      aarch64: Tidy aarch64_split_compare_and_swap
      aarch64: Add out-of-line functions for LSE atomics
      aarch64: Implement -moutline-atomics
      [AArch64] Fix shrinkwrapping interactions with atomics (PR92692)
      aarch64: Fix store-exclusive in load-operate LSE helpers
      aarch64: Configure for sys/auxv.h in libgcc for lse-init.c
      aarch64: Fix up aarch64_compare_and_swaphi pattern [PR94368]
      [AArch64] PR target/94518: Fix memmodel index in aarch64_store_exclusive_pair
      [AArch64] Use __getauxval instead of getauxval in LSE detection code in libgcc
      aarch64: Add initial support for -mcpu=zeus
      Add support for __jcvt intrinsic
      Implement __rndr, __rndrrs intrinsics
      AArch64: Implement poly-type vadd intrinsics
      AArch64: Implement missing vceq*_p* intrinsics
      AArch64: Implement missing vcls intrinsics on unsigned types
      AArch64: Implement vstrq_p128 intrinsic
      AArch64: Implement vldrq_p128 intrinsic
      AArch64: Implement missing _p64 intrinsics for vector permutes
      AArch64: Implement missing vrndns_f32 intrinsic
      AArch64: Implement missing p128<->f64 reinterpret intrinsics
      AArch64: Add Linux cpuinfo string for rng feature
      AArch64: Add rng feature to Neoverse V1
      AArch64: Add prefer_advsimd_autovec internal tune_flag
      AArch64: Add Neoverse V1 tuning struct
      PR target/96313 AArch64: vqmovun* return types should be unsigned
      PR target/97150 AArch64: 2nd parameter of unsigned Neon scalar shift intrinsics should be signed
      Implement ACLE intrinsics for FRINT[32,64][Z,X]
      PR target/97349 AArch64: Incorrect types for some Neon vdupq_n_<...> intrinsics
      AArch64: Add Neoverse N2 tuning model
      aarch64: Fix status return logic in RNG intrinsics

Maciej W. Rozycki (1):
      MIPS/libphobos: Fix switchcontext.S assembly for MIPS I ISA

Marek Polacek (5):
      c++: Fix ICE with lambda in operator function [PR93597]
      c++: Fix bogus -Wparentheses warning with fold-expression [PR94505]
      c++: Fix ICE in check_local_shadow with enum [PR95560]
      c++: Fix bogus -Wparentheses warning [PR95344]
      c++: Use c++2a in g++.dg/cpp2a/nontype-class-defarg1.C.

Mark Eggleston (16):
      fortran: ICE using undeclared symbol in array constructor PR93484
      fortran: ICE equivalence with an element of an array PR94030
      fortran : ICE in gfc_resolve_findloc PR93498
      Fortran : Spurious warning message with -Wsurprising PR59107
      Fortran  : ICE in gfc_conv_array_constructor_expr PR93497
      Fortran  : ProcPtr function results: 'ppr@' in error message PR39695
      Fortran  : ICE in gfc_trans_label_assign PR50392
      Fortran  : "type is( real(kind(1.)) )" spurious syntax error PR94397
      Fortran  : ICE in resolve_fl_procedure PR95708
      Fortran  : Bogus error with additional blanks in type(*) PR95829
      Fortran  : ICE in gfc_check_reshape PR95585
      Fortran  : ICE in gfc_check_pointer_assign PR95612
      Fortran  :  get_environment_variable runtime error PR96486
      Fortran  : ICE for division by zero in declaration PR95882
      Fortran  :  ICE in build_field PR95614
      Revert "Fortran  :  ICE in build_field PR95614"

Martin Jambor (4):
      gcc-9 sra: Cap number of sub-access propagations with a param (PR 93435)
      sra-9: Fix sra_modify_expr handling of partial writes (PR 94482)
      ipa: Fix resolving speculations through cgraph_edge::set_call_stmt
      sra: Fix bug in grp_write propagation (PR 97009)

Martin Liska (25):
      Backport 314b91220a07bd63f13c58e37f1b5b9430a3702b
      Backport 55a7380213a5c16120d5c674fb42b38a3d796b57
      Backport e9f799d25973fc38022c5ea71ed5a2bca58a847f
      Add outline-atomics to target attribute.
      Fix backport due to usage for x_target_flags.
      Add new git-backport.py script.
      Fix various limitations of git-backport.py.
      gcov-tool: Flexible endian adjustment for merging coverage data
      Remove accidentally installed file.
      Remove bad ChangeLog entry.
      Add missing store in emission of asan_stack_free.
      asan: fix RTX emission for ilp32
      gcc-changelog: sync from master.
      gcc-changelog: fix when somebody reverts a backport
      gcc-changelog: fix combining of arguments.
      gcov: fix streaming corruption
      gcov: fix streaming of HIST_TYPE_IOR histogram type.
      GCOV: do not mangle .gcno files.
      IPA: fix profile handling in IRA
      IPA: compare VRP types.
      Remove duplicate ChangeLog entry.
      ASAN: disable -Wno-stringop-overflow for 2 tests
      Sync gcc-changelog scripts.
      changelog: fix parsing of a revert commit
      Sync gcc-changelog scripts.

Martin Sebor (1):
      c++: reject scalar array initialization with nullptr [PR94510]

Matthew Malcomson (3):
      aarch64: New Straight Line Speculation (SLS) mitigation flags
      aarch64: Introduce SLS mitigation for RET and BR instructions
      aarch64: Mitigate SLS for BLR instruction

Matthias Klose (2):
      Backport fix for PR/tree-optimization/97236 - fix bad use of VMAT_CONTIGUOUS
      substitute @tie{} with a space for the man pages

Max Filippov (2):
      xtensa: backport fix for PR target/91880
      xtensa: backport fix for PR target/94584

Michael Meissner (2):
      Backport PR target/93932 (variable vec_extract) to GCC 9
      Fix target/94557 PowerPC regression on GCC 9 (variable vec_extract)

Mikael Pettersson (1):
      Fix Ada bootstrap on Cygwin64

Monk Chiang (1):
      PR target/97682 - Fix to reuse t1 register between call address and epilogue.

Nathan Sidwell (3):
      c++: Fix ICE popping local scope [pr84733]
      c++: QT overload regression with attribute [PR94946]
      c++: Fix template parm ICE [PR 98297]

Patrick Palka (3):
      c++: zero_init_expr_p of dependent expression [PR95678]
      c++: Distinguish alignof and __alignof__ in cp_tree_equal [PR97273]
      libstdc++: Fix division by zero in std::sample

Paul Thomas (14):
      This patch fixes PRs 96100 and 96101.
      Fortran: Fix scalarization of constant expressions. [PR94246].
      This patch fixes PR96320. See the explanatory comment in the testcase.
      As well as the PR this patch fixes problems in handling class objects
      Fix failures with -m32 and some memory leaks.
      This patch fixes PR96325. See the explanatory comment in the testcase.
      Change testcase for pr96325 from run to compile.
      Fortran: Enable inquiry references in data statements [PR98022].
      Fortran: Correction to recent patch in light of comments [PR98022].
      Fortran: Fix deferred character lengths in array constructors [PR93833].
      Fortran: Fix deferred character lengths in array constructors [PR98517].
      Fortran: Fix ICE after error regression [PR99060].
      Fortran: Fix for class defined operators [PR99124].
      Fortran: Fix problem with allocate initialization [PR99545].

Peter Bergner (1):
      rs6000: Use the correct minimized testcase

Piotr Kubaj (1):
      rs6000: Add support for powerpc64le-unknown-freebsd

Prathamesh Kulkarni (1):
      PR47785: Add support for handling Xassembler/Wa options with LTO.

Qian Jianhua (2):
      aarch64: Add A64FX machine model
      aarch64: Add cpu cost tables for A64FX

Rainer Orth (2):
      libstdc++: Update Solaris baselines for GCC 9.4
      libsanitizer: Fix GetPcSpBp determination of SP on 32-bit Solaris/x86

Richard Biener (32):
      tree-optimization/94163 constrain alignment set by PRE
      middle-end/94206 fix memset folding to avoid types with padding
      tree-optimization/94103 avoid CSE of loads with padding
      middle-end/94479 - fix gimplification of address
      tree-optimization/95717 - fix SSA update for vectorizer epilogue
      tree-optimization/95133 - avoid abnormal edges in path splitting
      tree-optimization/95049 - fix not terminating RPO VN iteration
      middle-end/94964 - avoid EH loop entry with CP_SIMPLE_PREHEADERS
      ipa/94947 - fix test for externally visible variables for IPA PTA
      ipa/94947 - avoid using externally_visible_p ()
      testsuite/97688 - fix check_vect () with __AVX2__
      middle-end/97554 - avoid overflow in alloc size compute
      testsuite/98002 - fix gcc.dg/strncmp-2.c
      tree-optimization/96514 - avoid if-converting control-altering calls
      tree-optimization/96370 - make reassoc expr rewrite more robust
      tree-optimization/96579 - another special-operands fix in reassoc
      tree-optimization/97081 - fix wrong-code with vectorized shift
      tree-optimization/97255 - missing vector bool pattern of SRAed bool
      tree-optimization/97812 - fix range query in VRP assert discovery
      middle-end/96369 - fix missed short-circuiting during range folding
      tree-optimization/96075 - fix bogus misalignment calculation
      tree-optimization/96075 - adjust testcase
      tree-optimization/97627 - Avoid computing niters for fake edges
      tree-optimization/93964 - adjust ISL code generation for pointer params
      tree-optimization/98117 - fix range set by vectorization on niter IVs
      tree-optimization/98282 - classify V_C_E<constant> as nary
      tree-optimization/98758 - fix integer arithmetic in data-ref analysis
      tree-optimization/99856 - fix overwideing pattern creation
      lto/96385 - avoid unused global UNDEFs in debug objects
      lto/96591 - walk VECTOR_CST elements in walk_tree
      c/99224 - avoid ICEing on invalid __builtin_next_arg
      tree-optimization/99694 - fix value-numbering PHIs

Richard Earnshaw (1):
      arm: correct constraints on movsi_compare0 [PR91913]

Richard Sandiford (6):
      ipa-devirt: Fix crash in obj_type_ref_class [PR95114]
      early-remat: Handle sets of multiple candidate regs [PR94605]
      aarch64: Clear canary value after stack_protect_test [PR96191]
      arm: Clear canary value after stack_protect_test [PR96191]
      Update links to Arm docs
      arm: Extend the PR94780 fix to arm

Romain Naour (1):
      Fix missing dependencies for selftests which occasionally causes failed builds.

Roman Zhuykov (1):
      modulo-sched: Carefully process loop counter initialization [PR97421]

Samuel Thibault (3):
      hurd: libgcc unwinding support over signal trampolines
      hurd: libgcc unwinding over signal trampolines with SIGINFO
      Hurd: Enable ifunc by default

Sebastian Pop (3):
      add --with-tune configure flag
      add --with-{cpu,arch,tune}-{32,64} as alias flags for --with-{cpu,arch,tune}
      disable --with-{cpu,arch,tune}-32

Segher Boessenkool (1):
      rs6000: Properly handle LE index munging in vec_shr (PR94710)

Sinan Lin (1):
      PR target/99314: Fix integer signedness issue for cpymem pattern expansion.

Stam Markianos-Wright (1):
      Backport of the patch for PR target/91816

Stefan Schulze Frielinghaus (1):
      S/390: Emit vector alignment hints for z13 if AS accepts them

Sylvia Taylor (1):
      add intrinsics for vld1(q)_x4 and vst1(q)_x4

Szabolcs Nagy (13):
      aarch64, libgcc: Fix unwinding from pac-ret to normal frames [PR94514]
      aarch64: Fix .cfi_window_save with pac-ret [PR94515]
      aarch64: ensure bti c is emitted at function start [PR94697]
      aarch64: don't emit bti j after NOTE_INSN_DELETED_LABEL [PR94748]
      aarch64: Fix noexecstack note in libitm
      aarch64: Fix noexecstack note in libgcc
      aarch64: Fix BTI support in libgcc [PR96001]
      aarch64: Fix BTI support in libitm
      aarch64: fix return address access with pac [PR94891][PR94791]
      aarch64: fix __builtin_eh_return with pac-ret [PR94891]
      libgcc: fix the handling of return address mangling [PR94891]
      doc: Clarify __builtin_return_address [PR94891]
      aarch64: Add missing ACLE support for PAC-RET

Tamar Christina (11):
      AArch64: Break apart paradoxical subregs for VSTRUCT writes (PR target/94052)
      AArch64: Fix options canonicanization for assembler
      AArch64: Fix bugs in -mcpu=native detection.
      AArch64: Add GCC_CPUINFO override
      Arm: Add GCC_CPUINFO override
      Testsuite: Make it easier to debug environment setting functions
      Testuite: Document environment setting directives
      AArch64: Add test for -mcpu=native
      AArch64: Fix hwasan failure in readline.
      AArch64: Fix overflow in memcopy expansion on aarch64.
      AArch64: Skip test for pr97535 on ILP32 since it can't express the range.

Thomas Koenig (9):
      Revert patch for PR fortran/93956.
      Add early return for invalid STATUS for close.
      Fixes a hang on an invalid ID in a WAIT statement.
      Finalization depends on the expression, not on the component.
      When avoiding double deallocation, look at namespace, expression and component.
      Do not generate recursion check for compiler-generated procedures.
      Always use name from c_interop_kinds_table for -fc-prototypes.
      Fix handling of implicit_pure by checking if non-pure procedures are called.
      Fix description of FINDLOC result.

Thomas König (2):
      Backport from trunk of the fix for PR 94270.
      Fix PR 93956, wrong pointer when returned via function.

Thomas Rodgers (3):
      libstdc++: Fix PSTL tests to run correctly with newer Thread Building Blocks
      libstdc++: Fix date of changelog entry
      libstdc++: Mark experimental::net::system_context ctor deleted

Thomas Schwinge (12):
      Rename 'libgomp.oacc-c-c++-common/static-dynamic-lifetimes-*' to 'libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-*' [PR92843]
      'libgomp.oacc-fortran/{error_,}stop-{1,2,3}.f': initialize before the checkpoint
      [HSA] Avoid ICE when "HSA does not implement indirect calls"
      libgomp testsuite: tell warning from error diagnostics, etc. [PR80219, PR85303]
      Simplify and enhance 'libgomp.oacc-c-c++-common/pr85486*.c' [PR85486]
      [testsuite] Enable column location checking for 'dg-optimized', 'dg-missed'
      [testsuite] Emit 'warning' instead of 'error' diagnostics for 'dg-optimized', 'dg-missed'
      Fix templatized C++ OpenACC 'cache' directive ICEs
      Add 'g++.dg/gomp/map-{1,2}.C'
      Don't create location wrapper nodes within OpenACC clauses
      [nvptx libgomp plugin] Build only in supported configurations
      libgomp HSA/GCN plugins: don't prepend the 'HSA_RUNTIME_LIB' path to 'libhsa-runtime64.so'

Tobias Burnus (11):
      [Fortran] Fix result-variable handling of MODULE PROCEDURE (PR94348)
      ICE in gfc_get_dataptr_offset, at fortran/trans-array.c:6951
      Fortran: Avoid double-free with parse error (PR96041, PR93423)
      configure: Fix in-tree building of GMP on BSD [PR97302]
      Fortran: Fix type-decl for PDT / wrong-code pdt_14.f03 issue [PR97652]
      Fortran: Fix function decl's location [PR95847]
      Fortran: Delay vtab generation until after parsing [PR92587]
      [Fortran] Fix name conflict check for use-assoc (PR 92736)
      [Fortran] PR91640 – Fix call to contiguous dummy
      OpenACC: C/C++ - fix async parsing [PR99137]
      Fortran: Fix 'name' bound size [PR99688]

Uros Bizjak (10):
      i386: Fix REDUC_SSE_SMINMAX_MODE mode conditions.
      i386: Fix REDUC_SSE_SMINMAX_MODE mode conditions.
      i386: Require OPTION_MASK_ISA_SSE2 for __builtin_ia32_movq128 [PR94603]
      i386: Remove unneeded assignments when triggering SSE exceptions
      alpha: Implement the PR94780 fix for alpha.
      i386: Fix restore_stack_nonlocal expander [PR96536].
      i386: Fix up ix86_md_asm_adjust for TImode [PR98086]
      i386: Fix __builtin_floor with FE_DOWNWARD rounding direction [PR96793]
      i386: Fix __builtin_trunc with FE_DOWNWARD rounding direction [PR96793]
      i386: Fix __builtin_rint with FE_DOWNWARD rounding direction [PR96793]

Ville Voutilainen (1):
      PR libstdc++/91807

Wilco Dijkstra (2):
      AArch64: Add support for --with-tune
      [AArch64] Fix symbol offset limit (PR 98618)

Will Schmidt (5):
      backport PR90763: PowerPC vec_xl_len should take const argument.
      rs6000 pragma fix backport from mainline to gcc-9
      Backport to gcc-9
      Add support to enable vmsumudm behind vec_msum builtin.
      Fix vector long long subtype (PR96139)

Xionghu Luo (2):
      rs6000: Don't use HARD_FRAME_POINTER_REGNUM if it's not live in pro_and_epilogue (PR91518)
      rs6000: Correct Power8 cost of l2 cache size [PR97329]

Zackery Spytz (1):
      doc: Fix a typo in the documentation of the copy attribute

liuhongt (2):
      If -mavx implies -mxsave, then -mno-xsave should imply -mno-avx.
      Fix missing defination of PTA_CLDEMOTE, PTA_MOVDIRI, PTA_MOVDIR64B.

diff --git a/ChangeLog b/ChangeLog
index 9605d767a80..6ffd0baf86c 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,34 @@
+2021-03-09  Ian Lance Taylor  <iant@golang.org>
+
+	PR go/99458
+	* libgo/runtime/proc.c: cast SIGSTKSZ to uintptr
+	In newer versions of glibc it is long, which causes a signed
+	comparison warning.
+
+2020-10-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-10-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR target/97302
+	* configure.ac: Only set with_gmp to /usr/local
+	if not building in tree.
+	* configure: Regenerate.
+
+2020-06-02  Martin Liska  <mliska@suse.cz>
+
+	* -: Remove.
+
+2020-04-20  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-04-17  Martin Liska  <mliska@suse.cz>
+		    Jonathan Yong <10walls@gmail.com>
+
+	PR gcov-profile/94570
+	* ltmain.sh: Do not define HAVE_DOS_BASED_FILE_SYSTEM
+	for CYGWIN.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/configure b/configure
index abd93a990a9..8de7fd3afc3 100755
--- a/configure
+++ b/configure
@@ -3679,6 +3679,7 @@ case "${target}" in
     ;;
   *-*-freebsd*)
     if test "x$with_gmp" = x && test "x$with_gmp_dir" = x \
+	&& ! test -d ${srcdir}/gmp \
 	&& test -f /usr/local/include/gmp.h; then
       with_gmp=/usr/local
     fi
diff --git a/configure.ac b/configure.ac
index 9db4fd14aa2..4aab1482e34 100644
--- a/configure.ac
+++ b/configure.ac
@@ -961,6 +961,7 @@ case "${target}" in
     ;;
   *-*-freebsd*)
     if test "x$with_gmp" = x && test "x$with_gmp_dir" = x \
+	&& ! test -d ${srcdir}/gmp \
 	&& test -f /usr/local/include/gmp.h; then
       with_gmp=/usr/local
     fi
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index fde2d2b76eb..7a9613fb4a4 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,87 @@
+2021-03-19  Matthias Klose  <doko@ubuntu.com>
+
+	Backported from master:
+	2021-03-19  Matthias Klose  <doko@ubuntu.com>
+
+	* texi2pod.pl: Substitute @tie{} with a space for the man pages.
+
+2021-01-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR lto/85574
+	* compare-lto: Deal with PE-COFF executables specifically.
+
+2021-01-07  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Sync from master.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_repository.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+
+2020-11-25  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Use revert_regex instead
+	of string prefix.  Convert sets to literals.
+
+2020-11-06  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Sync.
+	* gcc-changelog/git_email.py: Likewise.
+	* gcc-changelog/git_repository.py: Likewise.
+	* gcc-changelog/test_email.py: Likewise.
+	* gcc-changelog/test_patches.txt: Likewise.
+	* gcc-changelog/setup.cfg: New file.
+
+2020-07-29  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: fix how are ChangeLog paths combined.
+
+2020-07-23  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-07-23  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: When reverting a backport,
+	we should print only Revert header.
+
+2020-07-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-07-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* gcc-changelog/git_update_version.py: Fix typo.
+
+2020-07-08  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2020-07-07  Alexandre Oliva  <oliva@adacore.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_commit.py: Support CASE and COND.
+	* gcc-changelog/test_patches.txt: Add test.
+	* gcc-changelog/test_email.py: Add test.
+
+2020-07-02  Martin Liska  <mliska@suse.cz>
+
+	* gcc-changelog/git_check_commit.py: New file.
+	* gcc-changelog/git_commit.py: New file.
+	* gcc-changelog/git_email.py: New file.
+	* gcc-changelog/git_repository.py: New file.
+	* gcc-changelog/git_update_version.py: New file.
+	* gcc-changelog/test_email.py: New file.
+	* gcc-changelog/test_patches.txt: New file.
+
+2020-05-29  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: The script did 'git co HEAD~' when
+	there was no modified ChangeLog file in a successful
+	git cherry pick.
+	Run cherry-pick --continue without editor.
+
+2020-05-27  Martin Liska  <mliska@suse.cz>
+
+	* git-backport.py: New file.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/contrib/compare-lto b/contrib/compare-lto
index 17379e196a7..c0bb71c0765 100755
--- a/contrib/compare-lto
+++ b/contrib/compare-lto
@@ -32,7 +32,7 @@ case $1 in
 esac
 
 if test $# != 2; then
-  echo 'usage: compare-lto file1.o file2.o' >&2
+  echo 'usage: compare-lto file1 file2' >&2
   exit 1
 fi
 
@@ -101,6 +101,25 @@ else
     else
       status=1
     fi
+
+  # PE-COFF executables are timestamped so skip leading bytes for them.
+  else
+    case "$1" in
+      *.exe)
+        if cmp -i 256 "$1" "$2"; then
+          status=0
+        else
+          status=1
+        fi
+        ;;
+      *)
+        if test -f "$1.exe" && cmp -i 256 "$1.exe" "$2.exe"; then
+          status=0
+        else
+          status=1
+        fi
+        ;;
+    esac
   fi
 fi
 
diff --git a/contrib/gcc-changelog/git_check_commit.py b/contrib/gcc-changelog/git_check_commit.py
new file mode 100755
index 00000000000..935425ef813
--- /dev/null
+++ b/contrib/gcc-changelog/git_check_commit.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+import argparse
+
+from git_repository import parse_git_revisions
+
+parser = argparse.ArgumentParser(description='Check git ChangeLog format '
+                                 'of a commit')
+parser.add_argument('revisions', default='HEAD', nargs='?',
+                    help='Git revisions (e.g. hash~5..hash or just hash)')
+parser.add_argument('-g', '--git-path', default='.',
+                    help='Path to git repository')
+parser.add_argument('-p', '--print-changelog', action='store_true',
+                    help='Print final changelog entires')
+parser.add_argument('-n', '--non-strict-mode', action='store_true',
+                    help='Use non-strict mode (allow changes in ChangeLog and '
+                    'other automatically updated files).')
+args = parser.parse_args()
+
+retval = 0
+for git_commit in parse_git_revisions(args.git_path, args.revisions,
+                                      not args.non_strict_mode):
+    res = 'OK' if git_commit.success else 'FAILED'
+    print('Checking %s: %s' % (git_commit.original_info.hexsha, res))
+    if git_commit.success:
+        if args.print_changelog:
+            git_commit.print_output()
+    else:
+        for error in git_commit.errors:
+            print('ERR: %s' % error)
+        retval = 1
+
+exit(retval)
diff --git a/contrib/gcc-changelog/git_commit.py b/contrib/gcc-changelog/git_commit.py
new file mode 100755
index 00000000000..ee1973371be
--- /dev/null
+++ b/contrib/gcc-changelog/git_commit.py
@@ -0,0 +1,723 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+import difflib
+import os
+import re
+
+changelog_locations = {
+    'c++tools',
+    'config',
+    'contrib',
+    'contrib/header-tools',
+    'contrib/reghunt',
+    'contrib/regression',
+    'fixincludes',
+    'gcc/ada',
+    'gcc/analyzer',
+    'gcc/brig',
+    'gcc/c',
+    'gcc/c-family',
+    'gcc',
+    'gcc/cp',
+    'gcc/d',
+    'gcc/fortran',
+    'gcc/go',
+    'gcc/jit',
+    'gcc/lto',
+    'gcc/objc',
+    'gcc/objcp',
+    'gcc/po',
+    'gcc/testsuite',
+    'gnattools',
+    'gotools',
+    'include',
+    'intl',
+    'libada',
+    'libatomic',
+    'libbacktrace',
+    'libcc1',
+    'libcody',
+    'libcpp',
+    'libcpp/po',
+    'libdecnumber',
+    'libffi',
+    'libgcc',
+    'libgcc/config/avr/libf7',
+    'libgcc/config/libbid',
+    'libgfortran',
+    'libgomp',
+    'libhsail-rt',
+    'libiberty',
+    'libitm',
+    'libobjc',
+    'liboffloadmic',
+    'libphobos',
+    'libquadmath',
+    'libsanitizer',
+    'libssp',
+    'libstdc++-v3',
+    'libvtv',
+    'lto-plugin',
+    'maintainer-scripts',
+    'zlib'}
+
+bug_components = {
+    'ada',
+    'analyzer',
+    'boehm-gc',
+    'bootstrap',
+    'c',
+    'c++',
+    'd',
+    'debug',
+    'demangler',
+    'driver',
+    'fastjar',
+    'fortran',
+    'gcov-profile',
+    'go',
+    'hsa',
+    'inline-asm',
+    'ipa',
+    'java',
+    'jit',
+    'libbacktrace',
+    'libf2c',
+    'libffi',
+    'libfortran',
+    'libgcc',
+    'libgcj',
+    'libgomp',
+    'libitm',
+    'libobjc',
+    'libquadmath',
+    'libstdc++',
+    'lto',
+    'middle-end',
+    'modula2',
+    'objc',
+    'objc++',
+    'other',
+    'pch',
+    'pending',
+    'plugins',
+    'preprocessor',
+    'regression',
+    'rtl-optimization',
+    'sanitizer',
+    'spam',
+    'target',
+    'testsuite',
+    'translation',
+    'tree-optimization',
+    'web'}
+
+ignored_prefixes = {
+    'gcc/d/dmd/',
+    'gcc/go/gofrontend/',
+    'gcc/testsuite/gdc.test/',
+    'gcc/testsuite/go.test/test/',
+    'libgo/',
+    'libphobos/libdruntime/',
+    'libphobos/src/',
+    'libsanitizer/',
+    }
+
+wildcard_prefixes = {
+    'gcc/testsuite/',
+    'libstdc++-v3/doc/html/',
+    'libstdc++-v3/testsuite/'
+    }
+
+misc_files = {
+    'gcc/DATESTAMP',
+    'gcc/BASE-VER',
+    'gcc/DEV-PHASE'
+    }
+
+author_line_regex = \
+        re.compile(r'^(?P<datetime>\d{4}-\d{2}-\d{2})\ {2}(?P<name>.*  <.*>)')
+additional_author_regex = re.compile(r'^\t(?P<spaces>\ *)?(?P<name>.*  <.*>)')
+changelog_regex = re.compile(r'^(?:[fF]or +)?([a-z0-9+-/]*)ChangeLog:?')
+pr_regex = re.compile(r'\tPR (?P<component>[a-z+-]+\/)?([0-9]+)$')
+dr_regex = re.compile(r'\tDR ([0-9]+)$')
+star_prefix_regex = re.compile(r'\t\*(?P<spaces>\ *)(?P<content>.*)')
+end_of_location_regex = re.compile(r'[\[<(:]')
+item_empty_regex = re.compile(r'\t(\* \S+ )?\(\S+\):\s*$')
+item_parenthesis_regex = re.compile(r'\t(\*|\(\S+\):)')
+revert_regex = re.compile(r'This reverts commit (?P<hash>\w+).$')
+cherry_pick_regex = re.compile(r'cherry picked from commit (?P<hash>\w+)')
+
+LINE_LIMIT = 100
+TAB_WIDTH = 8
+CO_AUTHORED_BY_PREFIX = 'co-authored-by: '
+
+REVIEW_PREFIXES = ('reviewed-by: ', 'reviewed-on: ', 'signed-off-by: ',
+                   'acked-by: ', 'tested-by: ', 'reported-by: ',
+                   'suggested-by: ')
+DATE_FORMAT = '%Y-%m-%d'
+
+
+def decode_path(path):
+    # When core.quotepath is true (default value), utf8 chars are encoded like:
+    # "b/ko\304\215ka.txt"
+    #
+    # The upstream bug is fixed:
+    # https://github.com/gitpython-developers/GitPython/issues/1099
+    #
+    # but we still need a workaround for older versions of the library.
+    # Please take a look at the explanation of the transformation:
+    # https://stackoverflow.com/questions/990169/how-do-convert-unicode-escape-sequences-to-unicode-characters-in-a-python-string
+
+    if path.startswith('"') and path.endswith('"'):
+        return (path.strip('"').encode('utf8').decode('unicode-escape')
+                .encode('latin-1').decode('utf8'))
+    else:
+        return path
+
+
+class Error:
+    def __init__(self, message, line=None):
+        self.message = message
+        self.line = line
+
+    def __repr__(self):
+        s = self.message
+        if self.line:
+            s += ':"%s"' % self.line
+        return s
+
+
+class ChangeLogEntry:
+    def __init__(self, folder, authors, prs):
+        self.folder = folder
+        # The 'list.copy()' function is not available before Python 3.3
+        self.author_lines = list(authors)
+        self.initial_prs = list(prs)
+        self.prs = list(prs)
+        self.lines = []
+        self.files = []
+        self.file_patterns = []
+
+    def parse_file_names(self):
+        # Whether the content currently processed is between a star prefix the
+        # end of the file list: a colon or an open paren.
+        in_location = False
+
+        for line in self.lines:
+            # If this line matches the star prefix, start the location
+            # processing on the information that follows the star.
+            m = star_prefix_regex.match(line)
+            if m:
+                in_location = True
+                line = m.group('content')
+
+            if in_location:
+                # Strip everything that is not a filename in "line":
+                # entities "(NAME)", cases "<PATTERN>", conditions
+                # "[COND]", entry text (the colon, if present, and
+                # anything that follows it).
+                m = end_of_location_regex.search(line)
+                if m:
+                    line = line[:m.start()]
+                    in_location = False
+
+                # At this point, all that's left is a list of filenames
+                # separated by commas and whitespaces.
+                for file in line.split(','):
+                    file = file.strip()
+                    if file:
+                        if file.endswith('*'):
+                            self.file_patterns.append(file[:-1])
+                        else:
+                            self.files.append(file)
+
+    @property
+    def datetime(self):
+        for author in self.author_lines:
+            if author[1]:
+                return author[1]
+        return None
+
+    @property
+    def authors(self):
+        return [author_line[0] for author_line in self.author_lines]
+
+    @property
+    def is_empty(self):
+        return not self.lines and self.prs == self.initial_prs
+
+    def contains_author(self, author):
+        for author_lines in self.author_lines:
+            if author_lines[0] == author:
+                return True
+        return False
+
+
+class GitInfo:
+    def __init__(self, hexsha, date, author, lines, modified_files):
+        self.hexsha = hexsha
+        self.date = date
+        self.author = author
+        self.lines = lines
+        self.modified_files = modified_files
+
+
+class GitCommit:
+    def __init__(self, info, strict=True, commit_to_info_hook=None):
+        self.original_info = info
+        self.info = info
+        self.message = None
+        self.changes = None
+        self.changelog_entries = []
+        self.errors = []
+        self.top_level_authors = []
+        self.co_authors = []
+        self.top_level_prs = []
+        self.cherry_pick_commit = None
+        self.revert_commit = None
+        self.commit_to_info_hook = commit_to_info_hook
+
+        # Skip Update copyright years commits
+        if self.info.lines and self.info.lines[0] == 'Update copyright years.':
+            return
+
+        # Identify first if the commit is a Revert commit
+        for line in self.info.lines:
+            m = revert_regex.match(line)
+            if m:
+                self.revert_commit = m.group('hash')
+                break
+        if self.revert_commit:
+            self.info = self.commit_to_info_hook(self.revert_commit)
+
+        project_files = [f for f in self.info.modified_files
+                         if self.is_changelog_filename(f[0])
+                         or f[0] in misc_files]
+        ignored_files = [f for f in self.info.modified_files
+                         if self.in_ignored_location(f[0])]
+        if len(project_files) == len(self.info.modified_files):
+            # All modified files are only MISC files
+            return
+        elif project_files and strict:
+            self.errors.append(Error('ChangeLog, DATESTAMP, BASE-VER and '
+                                     'DEV-PHASE updates should be done '
+                                     'separately from normal commits'))
+            return
+
+        all_are_ignored = (len(project_files) + len(ignored_files)
+                           == len(self.info.modified_files))
+        self.parse_lines(all_are_ignored)
+        if self.changes:
+            self.parse_changelog()
+            self.parse_file_names()
+            self.check_for_empty_description()
+            self.deduce_changelog_locations()
+            self.check_file_patterns()
+            if not self.errors:
+                self.check_mentioned_files()
+                self.check_for_correct_changelog()
+
+    @property
+    def success(self):
+        return not self.errors
+
+    @property
+    def new_files(self):
+        return [x[0] for x in self.info.modified_files if x[1] == 'A']
+
+    @classmethod
+    def is_changelog_filename(cls, path):
+        return path.endswith('/ChangeLog') or path == 'ChangeLog'
+
+    @classmethod
+    def find_changelog_location(cls, name):
+        if name.startswith('\t'):
+            name = name[1:]
+        if name.endswith(':'):
+            name = name[:-1]
+        if name.endswith('/'):
+            name = name[:-1]
+        return name if name in changelog_locations else None
+
+    @classmethod
+    def format_git_author(cls, author):
+        assert '<' in author
+        return author.replace('<', ' <')
+
+    @classmethod
+    def parse_git_name_status(cls, string):
+        modified_files = []
+        for entry in string.split('\n'):
+            parts = entry.split('\t')
+            t = parts[0]
+            if t == 'A' or t == 'D' or t == 'M':
+                modified_files.append((parts[1], t))
+            elif t.startswith('R'):
+                modified_files.append((parts[1], 'D'))
+                modified_files.append((parts[2], 'A'))
+        return modified_files
+
+    def parse_lines(self, all_are_ignored):
+        body = self.info.lines
+
+        for i, b in enumerate(body):
+            if not b:
+                continue
+            if (changelog_regex.match(b) or self.find_changelog_location(b)
+                    or star_prefix_regex.match(b) or pr_regex.match(b)
+                    or dr_regex.match(b) or author_line_regex.match(b)):
+                self.changes = body[i:]
+                return
+        if not all_are_ignored:
+            self.errors.append(Error('cannot find a ChangeLog location in '
+                                     'message'))
+
+    def parse_changelog(self):
+        last_entry = None
+        will_deduce = False
+        for line in self.changes:
+            if not line:
+                if last_entry and will_deduce:
+                    last_entry = None
+                continue
+            if line != line.rstrip():
+                self.errors.append(Error('trailing whitespace', line))
+            if len(line.replace('\t', ' ' * TAB_WIDTH)) > LINE_LIMIT:
+                self.errors.append(Error('line exceeds %d character limit'
+                                         % LINE_LIMIT, line))
+            m = changelog_regex.match(line)
+            if m:
+                last_entry = ChangeLogEntry(m.group(1).rstrip('/'),
+                                            self.top_level_authors,
+                                            self.top_level_prs)
+                self.changelog_entries.append(last_entry)
+            elif self.find_changelog_location(line):
+                last_entry = ChangeLogEntry(self.find_changelog_location(line),
+                                            self.top_level_authors,
+                                            self.top_level_prs)
+                self.changelog_entries.append(last_entry)
+            else:
+                author_tuple = None
+                pr_line = None
+                if author_line_regex.match(line):
+                    m = author_line_regex.match(line)
+                    author_tuple = (m.group('name'), m.group('datetime'))
+                elif additional_author_regex.match(line):
+                    m = additional_author_regex.match(line)
+                    if len(m.group('spaces')) != 4:
+                        msg = 'additional author must be indented with '\
+                              'one tab and four spaces'
+                        self.errors.append(Error(msg, line))
+                    else:
+                        author_tuple = (m.group('name'), None)
+                elif pr_regex.match(line):
+                    component = pr_regex.match(line).group('component')
+                    if not component:
+                        self.errors.append(Error('missing PR component', line))
+                        continue
+                    elif not component[:-1] in bug_components:
+                        self.errors.append(Error('invalid PR component', line))
+                        continue
+                    else:
+                        pr_line = line.lstrip()
+                elif dr_regex.match(line):
+                    pr_line = line.lstrip()
+
+                lowered_line = line.lower()
+                if lowered_line.startswith(CO_AUTHORED_BY_PREFIX):
+                    name = line[len(CO_AUTHORED_BY_PREFIX):]
+                    author = self.format_git_author(name)
+                    self.co_authors.append(author)
+                    continue
+                elif lowered_line.startswith(REVIEW_PREFIXES):
+                    continue
+                else:
+                    m = cherry_pick_regex.search(line)
+                    if m:
+                        commit = m.group('hash')
+                        if self.cherry_pick_commit:
+                            msg = 'multiple cherry pick lines'
+                            self.errors.append(Error(msg, line))
+                        else:
+                            self.cherry_pick_commit = commit
+                        continue
+
+                # ChangeLog name will be deduced later
+                if not last_entry:
+                    if author_tuple:
+                        self.top_level_authors.append(author_tuple)
+                        continue
+                    elif pr_line:
+                        # append to top_level_prs only when we haven't met
+                        # a ChangeLog entry
+                        if (pr_line not in self.top_level_prs
+                                and not self.changelog_entries):
+                            self.top_level_prs.append(pr_line)
+                        continue
+                    else:
+                        last_entry = ChangeLogEntry(None,
+                                                    self.top_level_authors,
+                                                    self.top_level_prs)
+                        self.changelog_entries.append(last_entry)
+                        will_deduce = True
+                elif author_tuple:
+                    if not last_entry.contains_author(author_tuple[0]):
+                        last_entry.author_lines.append(author_tuple)
+                    continue
+
+                if not line.startswith('\t'):
+                    err = Error('line should start with a tab', line)
+                    self.errors.append(err)
+                elif pr_line:
+                    last_entry.prs.append(pr_line)
+                else:
+                    m = star_prefix_regex.match(line)
+                    if m:
+                        if len(m.group('spaces')) != 1:
+                            msg = 'one space should follow asterisk'
+                            self.errors.append(Error(msg, line))
+                        else:
+                            content = m.group('content')
+                            parts = content.split(':')
+                            if len(parts) > 1:
+                                for needle in ('()', '[]', '<>'):
+                                    if ' ' + needle in parts[0]:
+                                        msg = f'empty group "{needle}" found'
+                                        self.errors.append(Error(msg, line))
+                            last_entry.lines.append(line)
+                    else:
+                        if last_entry.is_empty:
+                            msg = 'first line should start with a tab, ' \
+                                  'an asterisk and a space'
+                            self.errors.append(Error(msg, line))
+                        else:
+                            last_entry.lines.append(line)
+
+    def parse_file_names(self):
+        for entry in self.changelog_entries:
+            entry.parse_file_names()
+
+    def check_file_patterns(self):
+        for entry in self.changelog_entries:
+            for pattern in entry.file_patterns:
+                name = os.path.join(entry.folder, pattern)
+                if not [name.startswith(pr) for pr in wildcard_prefixes]:
+                    msg = 'unsupported wildcard prefix'
+                    self.errors.append(Error(msg, name))
+
+    def check_for_empty_description(self):
+        for entry in self.changelog_entries:
+            for i, line in enumerate(entry.lines):
+                if (item_empty_regex.match(line) and
+                    (i == len(entry.lines) - 1
+                     or not entry.lines[i+1].strip()
+                     or item_parenthesis_regex.match(entry.lines[i+1]))):
+                    msg = 'missing description of a change'
+                    self.errors.append(Error(msg, line))
+
+    def get_file_changelog_location(self, changelog_file):
+        for file in self.info.modified_files:
+            if file[0] == changelog_file:
+                # root ChangeLog file
+                return ''
+            index = file[0].find('/' + changelog_file)
+            if index != -1:
+                return file[0][:index]
+        return None
+
+    def deduce_changelog_locations(self):
+        for entry in self.changelog_entries:
+            if not entry.folder:
+                changelog = None
+                for file in entry.files:
+                    location = self.get_file_changelog_location(file)
+                    if (location == ''
+                       or (location and location in changelog_locations)):
+                        if changelog and changelog != location:
+                            msg = 'could not deduce ChangeLog file, ' \
+                                  'not unique location'
+                            self.errors.append(Error(msg))
+                            return
+                        changelog = location
+                if changelog is not None:
+                    entry.folder = changelog
+                else:
+                    msg = 'could not deduce ChangeLog file'
+                    self.errors.append(Error(msg))
+
+    @classmethod
+    def in_ignored_location(cls, path):
+        for ignored in ignored_prefixes:
+            if path.startswith(ignored):
+                return True
+        return False
+
+    @classmethod
+    def get_changelog_by_path(cls, path):
+        components = path.split('/')
+        while components:
+            if '/'.join(components) in changelog_locations:
+                break
+            components = components[:-1]
+        return '/'.join(components)
+
+    def check_mentioned_files(self):
+        folder_count = len([x.folder for x in self.changelog_entries])
+        assert folder_count == len(self.changelog_entries)
+
+        mentioned_files = set()
+        mentioned_patterns = []
+        used_patterns = set()
+        for entry in self.changelog_entries:
+            if not entry.files and not entry.file_patterns:
+                msg = 'no files mentioned for ChangeLog in directory'
+                self.errors.append(Error(msg, entry.folder))
+            assert not entry.folder.endswith('/')
+            for file in entry.files:
+                if not self.is_changelog_filename(file):
+                    mentioned_files.add(os.path.join(entry.folder, file))
+            for pattern in entry.file_patterns:
+                mentioned_patterns.append(os.path.join(entry.folder, pattern))
+
+        cand = [x[0] for x in self.info.modified_files
+                if not self.is_changelog_filename(x[0])]
+        changed_files = set(cand)
+        for file in sorted(mentioned_files - changed_files):
+            msg = 'unchanged file mentioned in a ChangeLog'
+            candidates = difflib.get_close_matches(file, changed_files, 1)
+            if candidates:
+                msg += f' (did you mean "{candidates[0]}"?)'
+            self.errors.append(Error(msg, file))
+        for file in sorted(changed_files - mentioned_files):
+            if not self.in_ignored_location(file):
+                if file in self.new_files:
+                    changelog_location = self.get_changelog_by_path(file)
+                    # Python2: we cannot use next(filter(...))
+                    entries = filter(lambda x: x.folder == changelog_location,
+                                     self.changelog_entries)
+                    entries = list(entries)
+                    entry = entries[0] if entries else None
+                    if not entry:
+                        prs = self.top_level_prs
+                        if not prs:
+                            # if all ChangeLog entries have identical PRs
+                            # then use them
+                            prs = self.changelog_entries[0].prs
+                            for entry in self.changelog_entries:
+                                if entry.prs != prs:
+                                    prs = []
+                                    break
+                        entry = ChangeLogEntry(changelog_location,
+                                               self.top_level_authors,
+                                               prs)
+                        self.changelog_entries.append(entry)
+                    # strip prefix of the file
+                    assert file.startswith(entry.folder)
+                    file = file[len(entry.folder):].lstrip('/')
+                    entry.lines.append('\t* %s: New file.' % file)
+                    entry.files.append(file)
+                else:
+                    used_pattern = [p for p in mentioned_patterns
+                                    if file.startswith(p)]
+                    used_pattern = used_pattern[0] if used_pattern else None
+                    if used_pattern:
+                        used_patterns.add(used_pattern)
+                    else:
+                        msg = 'changed file not mentioned in a ChangeLog'
+                        self.errors.append(Error(msg, file))
+
+        for pattern in mentioned_patterns:
+            if pattern not in used_patterns:
+                error = "pattern doesn't match any changed files"
+                self.errors.append(Error(error, pattern))
+
+    def check_for_correct_changelog(self):
+        for entry in self.changelog_entries:
+            for file in entry.files:
+                full_path = os.path.join(entry.folder, file)
+                changelog_location = self.get_changelog_by_path(full_path)
+                if changelog_location != entry.folder:
+                    msg = 'wrong ChangeLog location "%s", should be "%s"'
+                    err = Error(msg % (entry.folder, changelog_location), file)
+                    self.errors.append(err)
+
+    @classmethod
+    def format_authors_in_changelog(cls, authors, timestamp, prefix=''):
+        output = ''
+        for i, author in enumerate(authors):
+            if i == 0:
+                output += '%s%s  %s\n' % (prefix, timestamp, author)
+            else:
+                output += '%s\t    %s\n' % (prefix, author)
+        output += '\n'
+        return output
+
+    def to_changelog_entries(self, use_commit_ts=False):
+        current_timestamp = self.info.date.strftime(DATE_FORMAT)
+        for entry in self.changelog_entries:
+            output = ''
+            timestamp = entry.datetime
+            if self.revert_commit:
+                timestamp = current_timestamp
+                orig_date = self.original_info.date
+                current_timestamp = orig_date.strftime(DATE_FORMAT)
+            elif self.cherry_pick_commit:
+                info = self.commit_to_info_hook(self.cherry_pick_commit)
+                # it can happen that it is a cherry-pick for a different
+                # repository
+                if info:
+                    timestamp = info.date.strftime(DATE_FORMAT)
+                else:
+                    timestamp = current_timestamp
+            elif not timestamp or use_commit_ts:
+                timestamp = current_timestamp
+            authors = entry.authors if entry.authors else [self.info.author]
+            # add Co-Authored-By authors to all ChangeLog entries
+            for author in self.co_authors:
+                if author not in authors:
+                    authors.append(author)
+
+            if self.cherry_pick_commit or self.revert_commit:
+                original_author = self.original_info.author
+                output += self.format_authors_in_changelog([original_author],
+                                                           current_timestamp)
+                if self.revert_commit:
+                    output += '\tRevert:\n'
+                else:
+                    output += '\tBackported from master:\n'
+                output += self.format_authors_in_changelog(authors,
+                                                           timestamp, '\t')
+            else:
+                output += self.format_authors_in_changelog(authors, timestamp)
+            for pr in entry.prs:
+                output += '\t%s\n' % pr
+            for line in entry.lines:
+                output += line + '\n'
+            yield (entry.folder, output.rstrip())
+
+    def print_output(self):
+        for entry, output in self.to_changelog_entries():
+            print('------ %s/ChangeLog ------ ' % entry)
+            print(output)
+
+    def print_errors(self):
+        print('Errors:')
+        for error in self.errors:
+            print(error)
diff --git a/contrib/gcc-changelog/git_email.py b/contrib/gcc-changelog/git_email.py
new file mode 100755
index 00000000000..00ad00458f4
--- /dev/null
+++ b/contrib/gcc-changelog/git_email.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+import os
+import sys
+from itertools import takewhile
+
+from dateutil.parser import parse
+
+from git_commit import GitCommit, GitInfo, decode_path
+
+from unidiff import PatchSet, PatchedFile
+
+DATE_PREFIX = 'Date: '
+FROM_PREFIX = 'From: '
+unidiff_supports_renaming = hasattr(PatchedFile(), 'is_rename')
+
+
+class GitEmail(GitCommit):
+    def __init__(self, filename, strict=False):
+        self.filename = filename
+        diff = PatchSet.from_filename(filename)
+        date = None
+        author = None
+
+        with open(self.filename, 'r') as f:
+            lines = f.read().splitlines()
+        lines = list(takewhile(lambda line: line != '---', lines))
+        for line in lines:
+            if line.startswith(DATE_PREFIX):
+                date = parse(line[len(DATE_PREFIX):])
+            elif line.startswith(FROM_PREFIX):
+                author = GitCommit.format_git_author(line[len(FROM_PREFIX):])
+        header = list(takewhile(lambda line: line != '', lines))
+        body = lines[len(header) + 1:]
+
+        modified_files = []
+        for f in diff:
+            # Strip "a/" and "b/" prefixes
+            source = decode_path(f.source_file)[2:]
+            target = decode_path(f.target_file)[2:]
+
+            if f.is_added_file:
+                t = 'A'
+            elif f.is_removed_file:
+                t = 'D'
+            elif unidiff_supports_renaming and f.is_rename:
+                # Consider that renamed files are two operations: the deletion
+                # of the original name and the addition of the new one.
+                modified_files.append((source, 'D'))
+                t = 'A'
+            else:
+                t = 'M'
+            modified_files.append((target, t))
+        git_info = GitInfo(None, date, author, body, modified_files)
+        super().__init__(git_info, strict=strict,
+                         commit_to_info_hook=lambda x: None)
+
+
+# With zero arguments, process every patch file in the ./patches directory.
+# With one argument, process the named patch file.
+# Patch files must be in 'git format-patch' format.
+if __name__ == '__main__':
+    if len(sys.argv) == 1:
+        allfiles = []
+        for root, _dirs, files in os.walk('patches'):
+            for f in files:
+                full = os.path.join(root, f)
+                allfiles.append(full)
+
+        success = 0
+        for full in sorted(allfiles):
+            email = GitEmail(full, False)
+            print(email.filename)
+            if email.success:
+                success += 1
+                print('  OK')
+            else:
+                for error in email.errors:
+                    print('  ERR: %s' % error)
+
+        print()
+        print('Successfully parsed: %d/%d' % (success, len(allfiles)))
+    else:
+        email = GitEmail(sys.argv[1], False)
+        if email.success:
+            print('OK')
+            email.print_output()
+        else:
+            if not email.info.lines:
+                print('Error: patch contains no parsed lines', file=sys.stderr)
+            email.print_errors()
+            sys.exit(1)
diff --git a/contrib/gcc-changelog/git_repository.py b/contrib/gcc-changelog/git_repository.py
new file mode 100755
index 00000000000..a0e293d756d
--- /dev/null
+++ b/contrib/gcc-changelog/git_repository.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+from datetime import datetime
+
+try:
+    from git import Repo
+except ImportError:
+    print('Cannot import GitPython package, please install the package:')
+    print('  Fedora, openSUSE: python3-GitPython')
+    print('  Debian, Ubuntu: python3-git')
+    exit(1)
+
+from git_commit import GitCommit, GitInfo, decode_path
+
+
+def parse_git_revisions(repo_path, revisions, strict=True):
+    repo = Repo(repo_path)
+
+    def commit_to_info(commit):
+        try:
+            c = repo.commit(commit)
+            diff = repo.commit(commit + '~').diff(commit)
+
+            modified_files = []
+            for file in diff:
+                if hasattr(file, 'renamed_file'):
+                    is_renamed = file.renamed_file
+                else:
+                    is_renamed = file.renamed
+                if file.new_file:
+                    t = 'A'
+                elif file.deleted_file:
+                    t = 'D'
+                elif is_renamed:
+                    # Consider that renamed files are two operations:
+                    # the deletion of the original name
+                    # and the addition of the new one.
+                    modified_files.append((decode_path(file.a_path), 'D'))
+                    t = 'A'
+                else:
+                    t = 'M'
+                modified_files.append((decode_path(file.b_path), t))
+
+            date = datetime.utcfromtimestamp(c.committed_date)
+            author = '%s  <%s>' % (c.author.name, c.author.email)
+            git_info = GitInfo(c.hexsha, date, author,
+                               c.message.split('\n'), modified_files)
+            return git_info
+        except ValueError:
+            return None
+
+    parsed_commits = []
+    if '..' in revisions:
+        commits = list(repo.iter_commits(revisions))
+    else:
+        commits = [repo.commit(revisions)]
+
+    for commit in commits:
+        git_commit = GitCommit(commit_to_info(commit.hexsha), strict=strict,
+                               commit_to_info_hook=commit_to_info)
+        parsed_commits.append(git_commit)
+    return parsed_commits
diff --git a/contrib/gcc-changelog/git_update_version.py b/contrib/gcc-changelog/git_update_version.py
new file mode 100755
index 00000000000..d2cadb8811c
--- /dev/null
+++ b/contrib/gcc-changelog/git_update_version.py
@@ -0,0 +1,145 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+import argparse
+import datetime
+import os
+
+from git import Repo
+
+from git_repository import parse_git_revisions
+
+current_timestamp = datetime.datetime.now().strftime('%Y%m%d\n')
+
+
+def read_timestamp(path):
+    with open(path) as f:
+        return f.read()
+
+
+def prepend_to_changelog_files(repo, folder, git_commit, add_to_git):
+    if not git_commit.success:
+        for error in git_commit.errors:
+            print(error)
+        raise AssertionError()
+    for entry, output in git_commit.to_changelog_entries(use_commit_ts=True):
+        full_path = os.path.join(folder, entry, 'ChangeLog')
+        print('writing to %s' % full_path)
+        if os.path.exists(full_path):
+            with open(full_path) as f:
+                content = f.read()
+        else:
+            content = ''
+        with open(full_path, 'w+') as f:
+            f.write(output)
+            if content:
+                f.write('\n\n')
+                f.write(content)
+        if add_to_git:
+            repo.git.add(full_path)
+
+
+active_refs = ['master', 'releases/gcc-8', 'releases/gcc-9', 'releases/gcc-10']
+
+parser = argparse.ArgumentParser(description='Update DATESTAMP and generate '
+                                 'ChangeLog entries')
+parser.add_argument('-g', '--git-path', default='.',
+                    help='Path to git repository')
+parser.add_argument('-p', '--push', action='store_true',
+                    help='Push updated active branches')
+parser.add_argument('-d', '--dry-mode',
+                    help='Generate patch for ChangeLog entries and do it'
+                         ' even if DATESTAMP is unchanged; folder argument'
+                         ' is expected')
+parser.add_argument('-c', '--current', action='store_true',
+                    help='Modify current branch (--push argument is ignored)')
+args = parser.parse_args()
+
+repo = Repo(args.git_path)
+origin = repo.remotes['origin']
+
+
+def update_current_branch():
+    commit = repo.head.commit
+    commit_count = 1
+    while commit:
+        if (commit.author.email == 'gccadmin@gcc.gnu.org'
+                and commit.message.strip() == 'Daily bump.'):
+            break
+        # We support merge commits but only with 2 parensts
+        assert len(commit.parents) <= 2
+        commit = commit.parents[-1]
+        commit_count += 1
+
+    print('%d revisions since last Daily bump' % commit_count)
+    datestamp_path = os.path.join(args.git_path, 'gcc/DATESTAMP')
+    if (read_timestamp(datestamp_path) != current_timestamp
+            or args.dry_mode or args.current):
+        head = repo.head.commit
+        # if HEAD is a merge commit, start with second parent
+        # (branched that is being merged into the current one)
+        assert len(head.parents) <= 2
+        if len(head.parents) == 2:
+            head = head.parents[1]
+        commits = parse_git_revisions(args.git_path, '%s..%s'
+                                      % (commit.hexsha, head.hexsha))
+        for git_commit in reversed(commits):
+            prepend_to_changelog_files(repo, args.git_path, git_commit,
+                                       not args.dry_mode)
+        if args.dry_mode:
+            diff = repo.git.diff('HEAD')
+            patch = os.path.join(args.dry_mode,
+                                 branch.name.split('/')[-1] + '.patch')
+            with open(patch, 'w+') as f:
+                f.write(diff)
+            print('branch diff written to %s' % patch)
+            repo.git.checkout(force=True)
+        else:
+            # update timestamp
+            print('DATESTAMP will be changed:')
+            with open(datestamp_path, 'w+') as f:
+                f.write(current_timestamp)
+            repo.git.add(datestamp_path)
+            if not args.current:
+                repo.index.commit('Daily bump.')
+                if args.push:
+                    repo.git.push('origin', branch)
+                    print('branch is pushed')
+    else:
+        print('DATESTAMP unchanged')
+
+
+if args.current:
+    print('=== Working on the current branch ===', flush=True)
+    update_current_branch()
+else:
+    for ref in origin.refs:
+        assert ref.name.startswith('origin/')
+        name = ref.name[len('origin/'):]
+        if name in active_refs:
+            if name in repo.branches:
+                branch = repo.branches[name]
+            else:
+                branch = repo.create_head(name, ref).set_tracking_branch(ref)
+            print('=== Working on: %s ===' % branch, flush=True)
+            branch.checkout()
+            origin.pull(rebase=True)
+            print('branch pulled and checked out')
+            update_current_branch()
+            assert not repo.index.diff(None)
+            print('branch is done\n', flush=True)
diff --git a/contrib/gcc-changelog/setup.cfg b/contrib/gcc-changelog/setup.cfg
new file mode 100644
index 00000000000..9e4a0f6479c
--- /dev/null
+++ b/contrib/gcc-changelog/setup.cfg
@@ -0,0 +1,2 @@
+[tool:pytest]
+addopts = -vv --flake8
diff --git a/contrib/gcc-changelog/test_email.py b/contrib/gcc-changelog/test_email.py
new file mode 100755
index 00000000000..5db56caef9e
--- /dev/null
+++ b/contrib/gcc-changelog/test_email.py
@@ -0,0 +1,406 @@
+#!/usr/bin/env python3
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  */
+
+import os
+import tempfile
+import unittest
+
+from git_commit import GitCommit
+
+from git_email import GitEmail
+
+import unidiff
+
+script_path = os.path.dirname(os.path.realpath(__file__))
+
+unidiff_supports_renaming = hasattr(unidiff.PatchedFile(), 'is_rename')
+
+
+NAME_STATUS1 = """
+M	gcc/ada/impunit.adb'
+R097	gcc/ada/libgnat/s-atopar.adb	gcc/ada/libgnat/s-aoinar.adb
+"""
+
+
+class TestGccChangelog(unittest.TestCase):
+    def setUp(self):
+        self.patches = {}
+        self.temps = []
+
+        filename = None
+        patch_lines = []
+        with open(os.path.join(script_path, 'test_patches.txt')) as f:
+            lines = f.read()
+        for line in lines.split('\n'):
+            if line.startswith('==='):
+                if patch_lines:
+                    self.patches[filename] = patch_lines
+                filename = line.split(' ')[1]
+                patch_lines = []
+            else:
+                patch_lines.append(line)
+        if patch_lines:
+            self.patches[filename] = patch_lines
+
+    def tearDown(self):
+        for t in self.temps:
+            assert t.endswith('.patch')
+            os.remove(t)
+
+    def get_git_email(self, filename, strict=False):
+        with tempfile.NamedTemporaryFile(mode='w+', suffix='.patch',
+                                         delete=False) as f:
+            f.write('\n'.join(self.patches[filename]))
+            self.temps.append(f.name)
+        return GitEmail(f.name, strict)
+
+    def from_patch_glob(self, name, strict=False):
+        files = [f for f in self.patches.keys() if f.startswith(name)]
+        assert len(files) == 1
+        return self.get_git_email(files[0], strict)
+
+    def test_simple_patch_format(self):
+        email = self.get_git_email('0577-aarch64-Add-an-and.patch')
+        assert not email.errors
+        assert len(email.changelog_entries) == 2
+        entry = email.changelog_entries[0]
+        assert (entry.author_lines ==
+                [('Richard Sandiford  <richard.sandiford@arm.com>',
+                  '2020-02-06')])
+        assert len(entry.authors) == 1
+        assert (entry.authors[0]
+                == 'Richard Sandiford  <richard.sandiford@arm.com>')
+        assert entry.folder == 'gcc'
+        assert entry.prs == ['PR target/87763']
+        assert len(entry.files) == 3
+        assert entry.files[0] == 'config/aarch64/aarch64-protos.h'
+
+    def test_daily_bump(self):
+        email = self.get_git_email('0085-Daily-bump.patch')
+        assert not email.errors
+        assert not email.changelog_entries
+
+    def test_deduce_changelog_entries(self):
+        email = self.from_patch_glob('0040')
+        assert len(email.changelog_entries) == 2
+        assert email.changelog_entries[0].folder == 'gcc/cp'
+        assert email.changelog_entries[0].prs == ['PR c++/90916']
+        assert email.changelog_entries[0].files == ['pt.c']
+        # this one is added automatically
+        assert email.changelog_entries[1].folder == 'gcc/testsuite'
+
+    def test_only_changelog_updated(self):
+        email = self.from_patch_glob('0129')
+        assert not email.errors
+        assert not email.changelog_entries
+
+    def test_wrong_mentioned_filename(self):
+        email = self.from_patch_glob('0096')
+        assert email.errors
+        err = email.errors[0]
+        assert err.message == 'unchanged file mentioned in a ChangeLog (did ' \
+            'you mean "gcc/testsuite/gcc.target/aarch64/' \
+            'advsimd-intrinsics/vdot-3-1.c"?)'
+        assert err.line == 'gcc/testsuite/gcc.target/aarch64/' \
+                           'advsimd-intrinsics/vdot-compile-3-1.c'
+
+    def test_missing_tab(self):
+        email = self.from_patch_glob('0031')
+        assert len(email.errors) == 2
+        err = email.errors[0]
+        assert err.message == 'line should start with a tab'
+        assert err.line == '    * cfgloopanal.c (average_num_loop_insns): ' \
+                           'Free bbs when early'
+
+    def test_leading_changelog_format(self):
+        email = self.from_patch_glob('0184')
+        assert len(email.errors) == 4
+        assert email.errors[0].line == 'gcc/c-family/c-cppbuiltins.c'
+        assert email.errors[2].line == 'gcc/c-family/c-cppbuiltin.c'
+
+    def test_cannot_deduce_no_blank_line(self):
+        email = self.from_patch_glob('0334')
+        assert len(email.errors) == 1
+        assert len(email.changelog_entries) == 1
+        assert email.changelog_entries[0].folder is None
+
+    def test_author_lines(self):
+        email = self.from_patch_glob('0814')
+        assert not email.errors
+        assert (email.changelog_entries[0].author_lines ==
+                [('Martin Jambor  <mjambor@suse.cz>', '2020-02-19')])
+
+    def test_multiple_authors_and_prs(self):
+        email = self.from_patch_glob('0735')
+        assert len(email.changelog_entries) == 1
+        entry = email.changelog_entries[0]
+        assert len(entry.author_lines) == 2
+        assert len(entry.authors) == 2
+        assert (entry.author_lines[1] ==
+                ('Bernd Edlinger  <bernd.edlinger@hotmail.de>', None))
+
+    def test_multiple_prs(self):
+        email = self.from_patch_glob('1699')
+        assert len(email.changelog_entries) == 2
+        assert len(email.changelog_entries[0].prs) == 2
+
+    def test_missing_PR_component(self):
+        email = self.from_patch_glob('0735')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'missing PR component'
+
+    def test_invalid_PR_component(self):
+        email = self.from_patch_glob('0198')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'invalid PR component'
+
+    def test_additional_author_list(self):
+        email = self.from_patch_glob('0342')
+        msg = 'additional author must be indented ' \
+              'with one tab and four spaces'
+        assert email.errors[1].message == msg
+
+    def test_trailing_whitespaces(self):
+        email = self.get_git_email('trailing-whitespaces.patch')
+        assert len(email.errors) == 3
+
+    def test_space_after_asterisk(self):
+        email = self.from_patch_glob('1999')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'one space should follow asterisk'
+
+    def test_long_lines(self):
+        email = self.get_git_email('long-lines.patch')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'line exceeds 100 character limit'
+
+    def test_new_files(self):
+        email = self.from_patch_glob('0030')
+        assert not email.errors
+
+    def test_wrong_changelog_location(self):
+        email = self.from_patch_glob('0043')
+        assert len(email.errors) == 2
+        assert (email.errors[0].message ==
+                'wrong ChangeLog location "gcc", should be "gcc/testsuite"')
+
+    def test_single_author_name(self):
+        email = self.from_patch_glob('1975')
+        assert len(email.changelog_entries) == 2
+        assert len(email.changelog_entries[0].author_lines) == 1
+        assert len(email.changelog_entries[1].author_lines) == 1
+
+    def test_bad_first_line(self):
+        email = self.from_patch_glob('0413')
+        assert len(email.errors) == 1
+
+    def test_co_authored_by(self):
+        email = self.from_patch_glob('1850')
+        assert email.co_authors == ['Jakub Jelinek  <jakub@redhat.com>']
+        output_entries = list(email.to_changelog_entries())
+        assert len(output_entries) == 2
+        ent0 = output_entries[0]
+        assert ent0[1].startswith('2020-04-16  Martin Liska  '
+                                  '<mliska@suse.cz>\n\t'
+                                  '    Jakub Jelinek  <jakub@redhat.com>')
+
+    def test_multiple_co_author_formats(self):
+        email = self.get_git_email('co-authored-by.patch')
+        assert len(email.co_authors) == 3
+        assert email.co_authors[0] == 'Jakub Jelinek  <jakub@redhat.com>'
+        assert email.co_authors[1] == 'John Miller  <jm@example.com>'
+        assert email.co_authors[2] == 'John Miller2  <jm2@example.com>'
+
+    def test_new_file_added_entry(self):
+        email = self.from_patch_glob('1957')
+        output_entries = list(email.to_changelog_entries())
+        assert len(output_entries) == 2
+        needle = ('\t* g++.dg/cpp2a/lambda-generic-variadic20.C'
+                  ': New file.')
+        assert output_entries[1][1].endswith(needle)
+        assert email.changelog_entries[1].prs == ['PR c++/94546']
+
+    def test_global_pr_entry(self):
+        email = self.from_patch_glob('2004')
+        assert not email.errors
+        assert email.changelog_entries[0].prs == ['PR other/94629']
+
+    def test_unique_prs(self):
+        email = self.get_git_email('pr-check1.patch')
+        assert not email.errors
+        assert email.changelog_entries[0].prs == ['PR ipa/12345']
+        assert email.changelog_entries[1].prs == []
+
+    def test_multiple_prs_not_added(self):
+        email = self.from_patch_glob('0001-Add-patch_are')
+        assert not email.errors
+        assert email.changelog_entries[0].prs == ['PR target/93492']
+        assert email.changelog_entries[1].prs == ['PR target/12345']
+        assert email.changelog_entries[2].prs == []
+        assert email.changelog_entries[2].folder == 'gcc/testsuite'
+
+    def test_strict_mode(self):
+        email = self.from_patch_glob('0001-Add-patch_are',
+                                     True)
+        msg = 'ChangeLog, DATESTAMP, BASE-VER and DEV-PHASE updates should ' \
+              'be done separately from normal commits'
+        assert email.errors[0].message == msg
+
+    def test_strict_mode_normal_patch(self):
+        email = self.get_git_email('0001-Just-test-it.patch', True)
+        assert not email.errors
+
+    def test_strict_mode_datestamp_only(self):
+        email = self.get_git_email('0002-Bump-date.patch', True)
+        assert not email.errors
+
+    def test_wrong_changelog_entry(self):
+        email = self.from_patch_glob('0020-IPA-Avoid')
+        msg = 'first line should start with a tab, an asterisk and a space'
+        assert (email.errors[0].message == msg)
+
+    def test_cherry_pick_format(self):
+        email = self.from_patch_glob('0001-c-Alias.patch')
+        assert not email.errors
+
+    def test_signatures(self):
+        email = self.from_patch_glob('0001-RISC-V-Make-unique.patch')
+        assert not email.errors
+        assert len(email.changelog_entries) == 1
+
+    def test_duplicate_top_level_author(self):
+        email = self.from_patch_glob('0001-Fortran-ProcPtr-function.patch')
+        assert not email.errors
+        assert len(email.changelog_entries[0].author_lines) == 1
+
+    def test_dr_entry(self):
+        email = self.from_patch_glob('0001-c-C-20-DR-2237.patch')
+        assert email.changelog_entries[0].prs == ['DR 2237']
+
+    def test_changes_only_in_ignored_location(self):
+        email = self.from_patch_glob('0001-go-in-ignored-location.patch')
+        assert not email.errors
+
+    def test_changelog_for_ignored_location(self):
+        email = self.from_patch_glob('0001-Update-merge.sh-to-reflect.patch')
+        assert (email.changelog_entries[0].lines[0]
+                == '\t* LOCAL_PATCHES: Use git hash instead of SVN id.')
+
+    def test_multiline_file_list(self):
+        email = self.from_patch_glob(
+            '0001-Ada-Reuse-Is_Package_Or_Generic_Package-where-possib.patch')
+        assert (email.changelog_entries[0].files
+                == ['contracts.adb', 'einfo.adb', 'exp_ch9.adb',
+                    'sem_ch12.adb', 'sem_ch4.adb', 'sem_ch7.adb',
+                    'sem_ch8.adb', 'sem_elab.adb', 'sem_type.adb',
+                    'sem_util.adb'])
+
+    @unittest.skipIf(not unidiff_supports_renaming,
+                     'Newer version of unidiff is needed (0.6.0+)')
+    def test_renamed_file(self):
+        email = self.from_patch_glob(
+            '0001-Ada-Add-support-for-XDR-streaming-in-the-default-run.patch')
+        assert not email.errors
+
+    def test_duplicite_author_lines(self):
+        email = self.from_patch_glob('0001-Fortran-type-is-real-kind-1.patch')
+        assert (email.changelog_entries[0].author_lines[0][0]
+                == 'Steven G. Kargl  <kargl@gcc.gnu.org>')
+        assert (email.changelog_entries[0].author_lines[1][0]
+                == 'Mark Eggleston  <markeggleston@gcc.gnu.org>')
+
+    def test_missing_change_description(self):
+        email = self.from_patch_glob('0001-Missing-change-description.patch')
+        assert len(email.errors) == 2
+        assert email.errors[0].message == 'missing description of a change'
+        assert email.errors[1].message == 'missing description of a change'
+
+    def test_libstdcxx_html_regenerated(self):
+        email = self.from_patch_glob('0001-Fix-text-of-hyperlink')
+        assert not email.errors
+        email = self.from_patch_glob('0002-libstdc-Fake-test-change-1.patch')
+        assert len(email.errors) == 1
+        msg = "pattern doesn't match any changed files"
+        assert email.errors[0].message == msg
+        assert email.errors[0].line == 'libstdc++-v3/doc/html/'
+        email = self.from_patch_glob('0003-libstdc-Fake-test-change-2.patch')
+        assert len(email.errors) == 1
+        msg = 'changed file not mentioned in a ChangeLog'
+        assert email.errors[0].message == msg
+
+    def test_not_deduce(self):
+        email = self.from_patch_glob('0001-configure.patch')
+        assert not email.errors
+        assert len(email.changelog_entries) == 2
+
+    def test_parse_git_name_status(self):
+        modified_files = GitCommit.parse_git_name_status(NAME_STATUS1)
+        assert len(modified_files) == 3
+        assert modified_files[1] == ('gcc/ada/libgnat/s-atopar.adb', 'D')
+        assert modified_files[2] == ('gcc/ada/libgnat/s-aoinar.adb', 'A')
+
+    def test_backport(self):
+        email = self.from_patch_glob('0001-asan-fix-RTX-emission.patch')
+        assert not email.errors
+        expected_hash = '8cff672cb9a132d3d3158c2edfc9a64b55292b80'
+        assert email.cherry_pick_commit == expected_hash
+        assert len(email.changelog_entries) == 1
+        entry = list(email.to_changelog_entries())[0][1]
+        assert entry.startswith('2020-06-11  Martin Liska  <mliska@suse.cz>')
+        assert '\tBackported from master:' in entry
+        assert '\t2020-06-11  Martin Liska  <mliska@suse.cz>' in entry
+        assert '\t\t    Jakub Jelinek  <jakub@redhat.com>' in entry
+
+    def test_backport_double_cherry_pick(self):
+        email = self.from_patch_glob('double-cherry-pick.patch')
+        assert email.errors[0].message.startswith('multiple cherry pick lines')
+
+    def test_square_and_lt_gt(self):
+        email = self.from_patch_glob('0001-Check-for-more-missing')
+        assert not email.errors
+
+    def test_empty_parenthesis(self):
+        email = self.from_patch_glob('0001-tree-optimization-97633-fix')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'empty group "()" found'
+
+    def test_emptry_entry_desc(self):
+        email = self.from_patch_glob('0001-c-Set-CALL_FROM_NEW_OR')
+        assert len(email.errors) == 1
+        assert email.errors[0].message == 'missing description of a change'
+
+    def test_emptry_entry_desc_2(self):
+        email = self.from_patch_glob('0001-lto-fix-LTO-debug')
+        assert not email.errors
+        assert len(email.changelog_entries) == 1
+
+    def test_wildcard_in_subdir(self):
+        email = self.from_patch_glob('0001-Wildcard-subdirs.patch')
+        assert len(email.changelog_entries) == 1
+        err = email.errors[0]
+        assert err.message == "pattern doesn't match any changed files"
+        assert err.line == 'libstdc++-v3/testsuite/28_regex_not-existing/'
+
+    def test_unicode_chars_in_filename(self):
+        email = self.from_patch_glob('0001-Add-horse.patch')
+        assert not email.errors
+
+    def test_bad_unicode_chars_in_filename(self):
+        email = self.from_patch_glob('0001-Add-horse2.patch')
+        assert not email.errors
+        assert email.changelog_entries[0].files == ['koníček.txt']
diff --git a/contrib/gcc-changelog/test_patches.txt b/contrib/gcc-changelog/test_patches.txt
new file mode 100644
index 00000000000..ffd13682d5c
--- /dev/null
+++ b/contrib/gcc-changelog/test_patches.txt
@@ -0,0 +1,3401 @@
+=== 0342-ARC-Propagate-uncached-type-attribute-to-each-member.patch ===
+From 62a715c706d8482560dadfa9ead0766f3c20e434 Mon Sep 17 00:00:00 2001
+From: Claudiu Zissulescu <claziss@gmail.com>
+Date: Mon, 27 Jan 2020 14:51:03 +0200
+Subject: [PATCH 0342/2034] [ARC] Propagate uncached type attribute to each
+ member of a struct.
+
+Like `packed` type attribute, the ARC's `uncached` type attribute
+needs to be propagated to each member of the struct where it is used,
+triggering the .di flag for any access of the struct members. However,
+any complex CFG manipulation may drop memory pointer type attributes,
+leading to the impossibility to discriminate the direct accesses from
+normal ones. To solve this issue, we will treat the direct memory
+accessed specially via unspecs.
+
+gcc/
+xxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>
+	Petro Karashchenko  <petro.karashchenko@ring.com>
+
+	* config/arc/arc.c (arc_is_uncached_mem_p): Check struct
+	attributes if needed.
+	(prepare_move_operands): Generate special
+	unspec instruction for direct access.
+	(arc_isuncached_mem_p): Propagate uncached attribute to each
+	structure member.
+	* config/arc/arc.md (VUNSPEC_ARC_LDDI): Define.
+	(VUNSPEC_ARC_STDI): Likewise.
+	(ALLI): New mode iterator.
+	(mALLI): New mode attribute.
+	(lddi): New instruction pattern.
+	(stdi): Likewise.
+	(stdidi_split): Split instruction for architectures which are not
+	supporting ll64 option.
+	(lddidi_split): Likewise.
+
+testsuite/
+xxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>
+	Petro Karashchenko  <petro.karashchenko@ring.com>
+
+	* gcc.target/arc/uncached-1.c: Update test.
+	* gcc.target/arc/uncached-2.c: Likewise.
+	* gcc.target/arc/uncached-3.c: New test.
+	* gcc.target/arc/uncached-4.c: Likewise.
+	* gcc.target/arc/uncached-5.c: Likewise.
+	* gcc.target/arc/uncached-6.c: Likewise.
+	* gcc.target/arc/uncached-7.c: Likewise.
+	* gcc.target/arc/uncached-8.c: Likewise.
+	* gcc.target/arc/arc.exp (ll64): New predicate.
+---
+ gcc/ChangeLog                             |  19 ++++
+ gcc/config/arc/arc.c                      | 118 ++++++++++++++--------
+ gcc/config/arc/arc.md                     |  60 +++++++++++
+ gcc/testsuite/ChangeLog                   |  11 ++
+ gcc/testsuite/gcc.target/arc/arc.exp      |   9 ++
+ gcc/testsuite/gcc.target/arc/uncached-1.c |   2 +-
+ gcc/testsuite/gcc.target/arc/uncached-2.c |   2 +-
+ gcc/testsuite/gcc.target/arc/uncached-3.c |  22 ++++
+ gcc/testsuite/gcc.target/arc/uncached-4.c |  42 ++++++++
+ gcc/testsuite/gcc.target/arc/uncached-5.c |  29 ++++++
+ gcc/testsuite/gcc.target/arc/uncached-6.c |  35 +++++++
+ gcc/testsuite/gcc.target/arc/uncached-7.c |  11 ++
+ gcc/testsuite/gcc.target/arc/uncached-8.c |  33 ++++++
+ 13 files changed, 351 insertions(+), 42 deletions(-)
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-3.c
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-4.c
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-5.c
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-6.c
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-7.c
+ create mode 100644 gcc/testsuite/gcc.target/arc/uncached-8.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 91dfcd71a4b..2cc61d68cf3 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/arc/arc.c b/gcc/config/arc/arc.c
+index 22475f2732e..e1a865f02e6 100644
+--- a/gcc/config/arc/arc.c
++++ b/gcc/config/arc/arc.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/arc/arc.md b/gcc/config/arc/arc.md
+index cf7aa8d83c9..46cb254ed28 100644
+--- a/gcc/config/arc/arc.md
++++ b/gcc/config/arc/arc.md
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 16ddef07516..991934272e0 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/arc/arc.exp b/gcc/testsuite/gcc.target/arc/arc.exp
+index 8d1844edd22..501d4589c53 100644
+--- a/gcc/testsuite/gcc.target/arc/arc.exp
++++ b/gcc/testsuite/gcc.target/arc/arc.exp
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-1.c b/gcc/testsuite/gcc.target/arc/uncached-1.c
+index 7a6bade81c4..fa5ecb7b7d3 100644
+--- a/gcc/testsuite/gcc.target/arc/uncached-1.c
++++ b/gcc/testsuite/gcc.target/arc/uncached-1.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-2.c b/gcc/testsuite/gcc.target/arc/uncached-2.c
+index 89eed326e01..9d6bfbbb50e 100644
+--- a/gcc/testsuite/gcc.target/arc/uncached-2.c
++++ b/gcc/testsuite/gcc.target/arc/uncached-2.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-3.c b/gcc/testsuite/gcc.target/arc/uncached-3.c
+new file mode 100644
+index 00000000000..f2a317b2816
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-3.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-4.c b/gcc/testsuite/gcc.target/arc/uncached-4.c
+new file mode 100644
+index 00000000000..fecb16648b8
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-4.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-5.c b/gcc/testsuite/gcc.target/arc/uncached-5.c
+new file mode 100644
+index 00000000000..4fe0464fdde
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-5.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-6.c b/gcc/testsuite/gcc.target/arc/uncached-6.c
+new file mode 100644
+index 00000000000..581a9eccb3b
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-6.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-7.c b/gcc/testsuite/gcc.target/arc/uncached-7.c
+new file mode 100644
+index 00000000000..4001b8bd821
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-7.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/arc/uncached-8.c b/gcc/testsuite/gcc.target/arc/uncached-8.c
+new file mode 100644
+index 00000000000..060229b11df
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/arc/uncached-8.c
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0814-sra-Avoid-totally-scalarizing-overallping-field_decl.patch ===
+From 665c5bad168ab63629b29ed2ce08ed042c088dc2 Mon Sep 17 00:00:00 2001
+From: Martin Jambor <mjambor@suse.cz>
+Date: Wed, 19 Feb 2020 11:08:40 +0100
+Subject: [PATCH 0814/2034] sra: Avoid totally scalarizing overallping
+ field_decls (PR 93667)
+
+[[no_unique_address]] C++ attribute can cause two fields of a
+RECORD_TYPE overlap, which currently confuses the totally scalarizing
+code into creating invalid access tree.  For GCC 10, I'd like to
+simply disable total scalarization of types where this happens.
+
+For GCC 11 I'll write down a TODO item to enable total scalarization
+of cases like this where the problematic fields are basically empty -
+despite having a non-zero size - i.e. when they are just RECORD_TYPEs
+without any data fields.
+
+2020-02-19  Martin Jambor  <mjambor@suse.cz>
+
+	gcc/
+
+	PR tree-optimization/93667
+	* tree-sra.c (scalarizable_type_p): Return false if record fields
+	do not follow wach other.
+
+	gcc/testsuite/
+
+	PR tree-optimization/93667
+	* g++.dg/tree-ssa/pr93667.C: New test.
+---
+ gcc/ChangeLog                           |  6 ++++++
+ gcc/testsuite/ChangeLog                 |  5 +++++
+ gcc/testsuite/g++.dg/tree-ssa/pr93667.C | 11 +++++++++++
+ gcc/tree-sra.c                          | 14 ++++++++++++++
+ 4 files changed, 36 insertions(+)
+ create mode 100644 gcc/testsuite/g++.dg/tree-ssa/pr93667.C
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 77c2a9ad810..6b53f9a2f07 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 9b4fe11a6f6..8033fa0a3bb 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr93667.C b/gcc/testsuite/g++.dg/tree-ssa/pr93667.C
+new file mode 100644
+index 00000000000..d875f53d9ec
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/tree-ssa/pr93667.C
+@@ -0,0 +1 @@
++
+diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
+index 0cfac0a8192..4c7d651e6b9 100644
+--- a/gcc/tree-sra.c
++++ b/gcc/tree-sra.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0413-SRA-Total-scalarization-after-access-propagation-PR9.patch ===
+From 636e80eea24b780f1d5f4c14c58fc00001df8508 Mon Sep 17 00:00:00 2001
+From: Martin Jambor <mjambor@suse.cz>
+Date: Wed, 29 Jan 2020 13:13:13 +0100
+Subject: [PATCH 0413/2034] SRA: Total scalarization after access propagation
+ [PR92706]
+
+2020-01-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/92706
+	* tree-sra.c (struct access): Adjust comment of
+	grp_total_scalarization.
+	(find_access_in_subtree): Look for single children spanning an entire
+	access.
+	(scalarizable_type_p): Allow register accesses, adjust callers.
+	(completely_scalarize): Remove function.
+	(scalarize_elem): Likewise.
+	(create_total_scalarization_access): Likewise.
+	(sort_and_splice_var_accesses): Do not track total scalarization
+	flags.
+	(analyze_access_subtree): New parameter totally, adjust to new meaning
+	of grp_total_scalarization.
+	(analyze_access_trees): Pass new parameter to analyze_access_subtree.
+	(can_totally_scalarize_forest_p): New function.
+	(create_total_scalarization_access): Likewise.
+	(create_total_access_and_reshape): Likewise.
+	(total_should_skip_creating_access): Likewise.
+	(totally_scalarize_subtree): Likewise.
+	(analyze_all_variable_accesses): Perform total scalarization after
+	subaccess propagation using the new functions above.
+	(initialize_constant_pool_replacements): Output initializers by
+	traversing the access tree.
+
+	testsuite/
+	* gcc.dg/tree-ssa/pr92706-2.c: New test.
+	* gcc.dg/guality/pr59776.c: Xfail tests for s2.g.
+---
+ gcc/ChangeLog                             |  26 +
+ gcc/testsuite/ChangeLog                   |   6 +
+ gcc/testsuite/gcc.dg/guality/pr59776.c    |   4 +-
+ gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c |  19 +
+ gcc/tree-sra.c                            | 666 ++++++++++++++++------
+ 5 files changed, 537 insertions(+), 184 deletions(-)
+ create mode 100644 gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 16247a59304..61da54df346 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 05518848829..38758207989 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.dg/guality/pr59776.c b/gcc/testsuite/gcc.dg/guality/pr59776.c
+index 382abb622bb..6c1c8165b70 100644
+--- a/gcc/testsuite/gcc.dg/guality/pr59776.c
++++ b/gcc/testsuite/gcc.dg/guality/pr59776.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
+new file mode 100644
+index 00000000000..37ab9765db0
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
+index 36106fecaf1..2b0849858de 100644
+--- a/gcc/tree-sra.c
++++ b/gcc/tree-sra.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0334-Do-not-generate-a-unique-fnname-for-resolver.patch ===
+From c2bd2b4664be8b73f8fd58a64dec1e93871797cc Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 27 Jan 2020 10:48:18 +0100
+Subject: [PATCH 0334/2034] Do not generate a unique fnname for resolver.
+
+	PR target/93274
+	* config/i386/i386-features.c (make_resolver_func):
+	Align the code with ppc64 target implementation.
+	Do not generate a unique name for resolver function.
+	PR target/93274
+	* gcc.target/i386/pr81213.c: Adjust to not expect
+	a globally unique name.
+---
+ gcc/ChangeLog                           |  7 +++++++
+ gcc/config/i386/i386-features.c         | 19 ++++---------------
+ gcc/testsuite/ChangeLog                 |  6 ++++++
+ gcc/testsuite/gcc.target/i386/pr81213.c |  4 ++--
+ 4 files changed, 19 insertions(+), 17 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 45075840824..59806baa757 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/i386/i386-features.c b/gcc/config/i386/i386-features.c
+index e580b26b995..b49e6f8d408 100644
+--- a/gcc/config/i386/i386-features.c
++++ b/gcc/config/i386/i386-features.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 2de060843d9..22a37dd1ab2 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/i386/pr81213.c b/gcc/testsuite/gcc.target/i386/pr81213.c
+index 13e15d5fef0..89c47529861 100644
+--- a/gcc/testsuite/gcc.target/i386/pr81213.c
++++ b/gcc/testsuite/gcc.target/i386/pr81213.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 1850-List-valid-pairs-for-new-and-delete-operators.patch ===
+From d7a65edb629a010f7ef907d457343abcb569fab7 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Thu, 16 Apr 2020 15:39:22 +0200
+Subject: [PATCH 1850/2034] List valid pairs for new and delete operators.
+
+	PR c++/94314
+	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
+	DECL_IS_REPLACEABLE_OPERATOR during cloning.
+	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
+	(propagate_necessity): Check operator names.
+
+	PR c++/94314
+	* g++.dg/pr94314.C: Do not use dg-additional-options
+	and remove not needed stdio.h include.
+	* g++.dg/pr94314-2.C: Likewise.
+	* g++.dg/pr94314-3.C: Likewise.
+	* g++.dg/pr94314-4.C: New test.
+
+Co-Authored-By: Jakub Jelinek <jakub@redhat.com>
+---
+ gcc/ChangeLog                    |  9 +++
+ gcc/cgraphclones.c               |  2 +
+ gcc/testsuite/ChangeLog          | 10 ++++
+ gcc/testsuite/g++.dg/pr94314-2.C |  5 +-
+ gcc/testsuite/g++.dg/pr94314-3.C |  5 +-
+ gcc/testsuite/g++.dg/pr94314-4.C | 30 ++++++++++
+ gcc/testsuite/g++.dg/pr94314.C   |  5 +-
+ gcc/tree-ssa-dce.c               | 98 ++++++++++++++++++++++++++++----
+ 8 files changed, 142 insertions(+), 22 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 74dbeeb44c6..9e499ec9c86 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
+index c73b8f810f0..8f541a28b6e 100644
+--- a/gcc/cgraphclones.c
++++ b/gcc/cgraphclones.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 756f1d759e6..94d2312022d 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
+index 36b93ed6d4d..998ce601767 100644
+--- a/gcc/testsuite/g++.dg/pr94314-2.C
++++ b/gcc/testsuite/g++.dg/pr94314-2.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-3.C b/gcc/testsuite/g++.dg/pr94314-3.C
+index 575ba9d8ad8..846a5d6a3d8 100644
+--- a/gcc/testsuite/g++.dg/pr94314-3.C
++++ b/gcc/testsuite/g++.dg/pr94314-3.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-4.C b/gcc/testsuite/g++.dg/pr94314-4.C
+new file mode 100644
+index 00000000000..d097f29d4ad
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/pr94314-4.C
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/g++.dg/pr94314.C b/gcc/testsuite/g++.dg/pr94314.C
+index 86e651d10ba..4e5ae122e9f 100644
+--- a/gcc/testsuite/g++.dg/pr94314.C
++++ b/gcc/testsuite/g++.dg/pr94314.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree-ssa-dce.c b/gcc/tree-ssa-dce.c
+index fd5f24c746c..757cfad5b5e 100644
+--- a/gcc/tree-ssa-dce.c
++++ b/gcc/tree-ssa-dce.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0085-Daily-bump.patch ===
+From 03647d2e26176bb874460b67deab0c30aa715d59 Mon Sep 17 00:00:00 2001
+From: GCC Administrator <gccadmin@gcc.gnu.org>
+Date: Thu, 16 Jan 2020 00:16:32 +0000
+Subject: [PATCH 0085/2034] Daily bump.
+
+---
+ gcc/DATESTAMP | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
+index ba948c594d4..62611957f86 100644
+--- a/gcc/DATESTAMP
++++ b/gcc/DATESTAMP
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0040-PR90916-ICE-in-retrieve-specialization.patch ===
+From a5a3c2dcf73aa245b0eb6f6cf56c4d03ab6056da Mon Sep 17 00:00:00 2001
+From: Nathan Sidwell <nathans@fb.com>
+Date: Tue, 14 Jan 2020 11:12:40 -0800
+Subject: [PATCH 0040/2034] [PR90916] ICE in retrieve specialization
+
+https://gcc.gnu.org/ml/gcc-patches/2020-01/msg00809.html
+	PR c++/90916
+	* pt.c (retrieve_specialization): Get the TI from the decl or the
+	classtype as appropriate.
+---
+ gcc/cp/ChangeLog                        |  6 ++++++
+ gcc/cp/pt.c                             | 15 ++++++++++-----
+ gcc/testsuite/g++.dg/template/pr90916.C |  8 ++++++++
+ 3 files changed, 24 insertions(+), 5 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/template/pr90916.C
+
+diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
+index 004ce0fdcdf..3cc7c48b490 100644
+--- a/gcc/cp/ChangeLog
++++ b/gcc/cp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
+index fa82ecad233..4fdc74f9ca8 100644
+--- a/gcc/cp/pt.c
++++ b/gcc/cp/pt.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/template/pr90916.C b/gcc/testsuite/g++.dg/template/pr90916.C
+new file mode 100644
+index 00000000000..bdb7e7b58ef
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/template/pr90916.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 2004-amdgcn-Check-HSA-return-codes-PR94629.patch ===
+From 966de09be91c639d66d252c9ae6ab8da5ebfca18 Mon Sep 17 00:00:00 2001
+From: Andrew Stubbs <ams@codesourcery.com>
+Date: Mon, 20 Apr 2020 15:25:31 +0100
+Subject: [PATCH 2004/2034] amdgcn: Check HSA return codes [PR94629]
+
+Ensure that the returned status values are not ignored.  The old code was
+not broken, but this is both safer and satisfies static analysis.
+
+2020-04-23  Andrew Stubbs  <ams@codesourcery.com>
+
+	PR other/94629
+
+	libgomp/
+	* plugin/plugin-gcn.c (init_hsa_context): Check return value from
+	hsa_iterate_agents.
+	(GOMP_OFFLOAD_init_device): Check return values from both calls to
+	hsa_agent_iterate_regions.
+---
+ libgomp/ChangeLog           | 9 +++++++++
+ libgomp/plugin/plugin-gcn.c | 8 ++++++++
+ 2 files changed, 17 insertions(+)
+
+diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
+index c524abbbfb6..ee1764d4ae3 100644
+--- a/libgomp/ChangeLog
++++ b/libgomp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/libgomp/plugin/plugin-gcn.c b/libgomp/plugin/plugin-gcn.c
+index dc72c90962c..4c6a4c03b6e 100644
+--- a/libgomp/plugin/plugin-gcn.c
++++ b/libgomp/plugin/plugin-gcn.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0198-Change-recursive-prepare_block_for_update-to-use-a-w.patch ===
+From 6fc2f9337311c11dabcc464c808cbef205f17a52 Mon Sep 17 00:00:00 2001
+From: Andrew Pinski <apinski@marvell.com>
+Date: Tue, 21 Jan 2020 08:34:42 +0000
+Subject: [PATCH 0198/2034] Change recursive prepare_block_for_update to use a
+ worklist
+
+Reported as PR 93321, prepare_block_for_update with some huge
+recusive inlining can go past the stack limit. Transforming this
+recursive into worklist improves the stack usage here and we no
+longer seg fault for the testcase.  Note the order we walk the siblings
+change.
+
+ChangeLog:
+	PR tree-opt/93321
+	* tree-into-ssa.c (prepare_block_for_update_1): Split out from ...
+	(prepare_block_for_update): This.  Use a worklist instead of recursing.
+---
+ gcc/ChangeLog       |  8 ++++++
+ gcc/tree-into-ssa.c | 59 ++++++++++++++++++++++++++++++++++++---------
+ 2 files changed, 55 insertions(+), 12 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 8c17e5992d2..262f0d6506f 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree-into-ssa.c b/gcc/tree-into-ssa.c
+index c27bf2ce121..6528acac31a 100644
+--- a/gcc/tree-into-ssa.c
++++ b/gcc/tree-into-ssa.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0184-PR-80005-Fix-__has_include.patch ===
+From ad1a3914ae8d67c94b0d2428e3f9672e7db491a1 Mon Sep 17 00:00:00 2001
+From: Nathan Sidwell <nathan@acm.org>
+Date: Mon, 20 Jan 2020 05:39:59 -0800
+Subject: [PATCH 0184/2034] [PR 80005]  Fix __has_include
+
+__has_include is funky in that it is macro-like from the POV of #ifdef and
+friends, but lexes its parenthesize argument #include-like.  We were
+failing the second part of that, because we used a forwarding macro to an
+internal name, and hence always lexed the argument in macro-parameter
+context.  We componded that by not setting the right flag when lexing, so
+it didn't even know.  Mostly users got lucky.
+
+This reimplements the handline.
+1) Remove the forwarding, but declare object-like macros that
+expand to themselves.  This satisfies the #ifdef requirement
+
+2) Correctly set angled_brackets when lexing the parameter.  This tells
+the lexer (a) <...> is a header name and (b) "..." is too (not a string).
+
+3) Remove the in__has_include lexer state, just tell find_file that that's
+what's happenning, so it doesn't emit an error.
+
+We lose the (undocumented) ability to #undef __has_include.  That may well
+have been an accident of implementation.  There are no tests for it.
+
+We gain __has_include behaviour for all users of the preprocessors -- not
+just the C-family ones that defined a forwarding macro.
+
+	libcpp/
+	PR preprocessor/80005
+	* include/cpplib.h (BT_HAS_ATTRIBUTE): Fix comment.
+	* internal.h (struct lexer_state): Delete in__has_include field.
+	(struct spec_nodes): Rename n__has_include{,_next}__ fields.
+	(_cpp_defined_macro_p): New.
+	(_cpp_find_file): Add has_include parm.
+	* directives.c (lex_macro_node): Combine defined,
+	__has_inline{,_next} checking.
+	(do_ifdef, do_ifndef): Use _cpp_defined_macro_p.
+	(_cpp_init_directives): Refactor.
+	* expr.c (parse_defined): Use _cpp_defined_macro_p.
+	(eval_token): Adjust parse_has_include calls.
+	(parse_has_include): Add OP parameter.  Reimplement.
+	* files.c (_cpp_find_file): Add HAS_INCLUDE parm.  Use it to
+	inhibit error message.
+	(_cpp_stack_include): Adjust _cpp_find_file call.
+	(_cpp_fake_include, _cpp_compare_file_date): Likewise.
+	(open_file_failed): Remove in__has_include check.
+	(_cpp_has_header): Adjust _cpp_find_file call.
+	* identifiers.c (_cpp_init_hashtable): Don't init
+	__has_include{,_next} here ...
+	* init.c (cpp_init_builtins): ... init them here.  Define as
+	macros.
+	(cpp_read_main_file): Adjust _cpp_find_file call.
+	* pch.c (cpp_read_state): Adjust __has_include{,_next} access.
+	* traditional.c (_cpp_scan_out_locgical_line): Likewise.
+
+	gcc/c-family/
+	PR preprocessor/80005
+	* c-cppbuiltins.c (c_cpp_builtins): Don't define __has_include{,_next}.
+
+	gcc/testsuite/
+	PR preprocessor/80005
+	* g++.dg/cpp1y/feat-cxx14.C: Adjust.
+	* g++.dg/cpp1z/feat-cxx17.C: Adjust.
+	* g++.dg/cpp2a/feat-cxx2a.C: Adjust.
+	* g++.dg/cpp/pr80005.C: New.
+---
+ gcc/c-family/ChangeLog                  |  5 ++++
+ gcc/c-family/c-cppbuiltin.c             |  6 -----
+ gcc/testsuite/ChangeLog                 |  8 +++++++
+ gcc/testsuite/g++.dg/cpp/pr80005.C      | 24 +++++++++++++++++++
+ gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C | 10 ++------
+ gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C | 10 ++------
+ gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C | 10 ++------
+ libcpp/ChangeLog                        | 29 +++++++++++++++++++++-
+ libcpp/directives.c                     | 29 ++++++++--------------
+ libcpp/expr.c                           | 32 ++++++++++++-------------
+ libcpp/files.c                          | 27 +++++++++++----------
+ libcpp/identifiers.c                    |  3 +--
+ libcpp/include/cpplib.h                 |  2 +-
+ libcpp/init.c                           | 14 ++++++++++-
+ libcpp/internal.h                       | 20 +++++++++++-----
+ libcpp/pch.c                            |  4 ++--
+ libcpp/traditional.c                    |  8 +++----
+ 17 files changed, 146 insertions(+), 95 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/cpp/pr80005.C
+
+diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
+index 09ba2c8b40f..fdddb98a74d 100644
+--- a/gcc/c-family/ChangeLog
++++ b/gcc/c-family/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
+index a6308921dc9..70a12055e27 100644
+--- a/gcc/c-family/c-cppbuiltin.c
++++ b/gcc/c-family/c-cppbuiltin.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index a526e32ac89..67d5f2e9e28 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/cpp/pr80005.C b/gcc/testsuite/g++.dg/cpp/pr80005.C
+new file mode 100644
+index 00000000000..cc752616782
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/cpp/pr80005.C
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C b/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
+index a2a93f437b3..a78b6a36f36 100644
+--- a/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
++++ b/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C b/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
+index 55e56a06fe8..e6f456b2415 100644
+--- a/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
++++ b/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C b/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
+index dd15cd6af3c..82fd602f9f1 100644
+--- a/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
++++ b/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
+index 3249b93fe88..27a841bbdce 100644
+--- a/libcpp/ChangeLog
++++ b/libcpp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/directives.c b/libcpp/directives.c
+index 983206a5838..10735c8c668 100644
+--- a/libcpp/directives.c
++++ b/libcpp/directives.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/expr.c b/libcpp/expr.c
+index 317faf50208..df21a4b9fb9 100644
+--- a/libcpp/expr.c
++++ b/libcpp/expr.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/files.c b/libcpp/files.c
+index 7abae7ae6ec..260e787c329 100644
+--- a/libcpp/files.c
++++ b/libcpp/files.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/identifiers.c b/libcpp/identifiers.c
+index 562d8fee3b5..9627e1bf4b0 100644
+--- a/libcpp/identifiers.c
++++ b/libcpp/identifiers.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
+index 1c26c365347..56cbbd82750 100644
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/init.c b/libcpp/init.c
+index 2b4923e1451..e798140ef8b 100644
+--- a/libcpp/init.c
++++ b/libcpp/init.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/internal.h b/libcpp/internal.h
+index 3623baf8191..5453c3bff85 100644
+--- a/libcpp/internal.h
++++ b/libcpp/internal.h
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/pch.c b/libcpp/pch.c
+index 607f805bebe..e631050936b 100644
+--- a/libcpp/pch.c
++++ b/libcpp/pch.c
+@@ -1 +1,2 @@
+
++
+diff --git a/libcpp/traditional.c b/libcpp/traditional.c
+index 21c63b47dd5..ff06d31a897 100644
+--- a/libcpp/traditional.c
++++ b/libcpp/traditional.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== long-lines.patch ===
+From eb7c7c524556df5364f03adc20f6a9db20858484 Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Mon, 13 Jan 2020 14:14:57 +0100
+Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
+ tree-ssa-forwprop.c some more PR90838
+
+2020-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/90838
+	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
+	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro and and SCALAR_INT_TYPE_MODE directly in and so
+	argument rather than to initialize temporary for targets that
+	don't use the mode argument at all.  Initialize ctzval to avoid
+	warning at -O0.
+---
+ gcc/ChangeLog           | 9 +++++++++
+ gcc/tree-ssa-forwprop.c | 6 +++---
+ 2 files changed, 12 insertions(+), 3 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index a195863212e..f7df07343d1 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
+index aac31d02b6c..56c470f6ecf 100644
+--- a/gcc/tree-ssa-forwprop.c
++++ b/gcc/tree-ssa-forwprop.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0735-PR-87488-Add-with-diagnostics-urls-configuration-opt.patch ===
+From 458c8d6459c4005fc9886b6e25d168a6535ac415 Mon Sep 17 00:00:00 2001
+From: Bernd Edlinger <bernd.edlinger@hotmail.de>
+Date: Wed, 29 Jan 2020 15:31:10 +0100
+Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
+ option
+
+2020-02-15  David Malcolm  <dmalcolm@redhat.com>
+	    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR 87488
+	PR other/93168
+	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
+	* configure.ac (--with-diagnostics-urls): New configuration
+	option, based on --with-diagnostics-color.
+	(DIAGNOSTICS_URLS_DEFAULT): New define.
+	* config.h: Regenerate.
+	* configure: Regenerate.
+	* diagnostic.c (diagnostic_urls_init): Handle -1 for
+	DIAGNOSTICS_URLS_DEFAULT from configure-time
+	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
+	and TERM_URLS environment variable.
+	* diagnostic-url.h (diagnostic_url_format): New enum type.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and change return type.
+	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
+	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
+	the linux console, and mingw.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and adjust.
+	* pretty-print.h (pretty_printer::show_urls): rename to...
+	(pretty_printer::url_format): ... this, and change to enum.
+	* pretty-print.c (pretty_printer::pretty_printer,
+	pp_begin_url, pp_end_url, test_urls): Adjust.
+	* doc/install.texi (--with-diagnostics-urls): Document the new
+	configuration option.
+	(--with-diagnostics-color): Document the existing interaction
+	with GCC_COLORS better.
+	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
+	vindex reference.  Update description of defaults based on the above.
+	(-fdiagnostics-color): Update description of how -fdiagnostics-color
+	interacts with GCC_COLORS.
+---
+ gcc/ChangeLog          |  36 +++++++++++++++
+ gcc/config.in          |   6 +++
+ gcc/configure          |  41 ++++++++++++++++-
+ gcc/configure.ac       |  28 ++++++++++++
+ gcc/diagnostic-color.c | 101 ++++++++++++++++++++++++++++++++++++++---
+ gcc/diagnostic-url.h   |  18 +++++++-
+ gcc/diagnostic.c       |  21 +++++++--
+ gcc/doc/install.texi   |  15 ++++--
+ gcc/doc/invoke.texi    |  39 ++++++++++++++--
+ gcc/pretty-print.c     |  44 +++++++++++++++---
+ gcc/pretty-print.h     |   5 +-
+ 11 files changed, 328 insertions(+), 26 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index e6eb6ab4c21..22f990a3088 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config.in b/gcc/config.in
+index 48292861842..01fb18dbbb5 100644
+--- a/gcc/config.in
++++ b/gcc/config.in
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/configure b/gcc/configure
+index 5fa565a40a4..f55cdb8c77f 100755
+--- a/gcc/configure
++++ b/gcc/configure
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/configure.ac b/gcc/configure.ac
+index 671b9a67d81..0e6e475950d 100644
+--- a/gcc/configure.ac
++++ b/gcc/configure.ac
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic-color.c b/gcc/diagnostic-color.c
+index d5547952921..b1baded2c9e 100644
+--- a/gcc/diagnostic-color.c
++++ b/gcc/diagnostic-color.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic-url.h b/gcc/diagnostic-url.h
+index 6be056941f1..d28460b928b 100644
+--- a/gcc/diagnostic-url.h
++++ b/gcc/diagnostic-url.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
+index 3386f070256..e4a08f76def 100644
+--- a/gcc/diagnostic.c
++++ b/gcc/diagnostic.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
+index 6ffafacff50..8ddebbb6267 100644
+--- a/gcc/doc/install.texi
++++ b/gcc/doc/install.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
+index bd9ecebf103..597151670be 100644
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/pretty-print.c b/gcc/pretty-print.c
+index 817c1059e08..dde138b0533 100644
+--- a/gcc/pretty-print.c
++++ b/gcc/pretty-print.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
+index 001468c966e..22892f12ab7 100644
+--- a/gcc/pretty-print.h
++++ b/gcc/pretty-print.h
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0031-Fix-typo-and-avoid-possible-memory-leak-in-average_n.patch ===
+From b38e86ddb7a9b6d7e87d7cc0b23983d027fcbd96 Mon Sep 17 00:00:00 2001
+From: Kewen Lin <linkw@linux.ibm.com>
+Date: Tue, 14 Jan 2020 02:34:10 -0600
+Subject: [PATCH 0031/2034] Fix typo and avoid possible memory leak in
+ average_num_loop_insns
+
+Function average_num_loop_insns forgets to free loop body in early
+return.  Besides, overflow comparison checks 1000000 (e6) but the
+return value is 100000 (e5), fix this typo.
+
+gcc/ChangeLog
+
+2020-01-14  Kewen Lin  <linkw@gcc.gnu.org>
+
+    * cfgloopanal.c (average_num_loop_insns): Free bbs when early
+    return, fix typo on return value.
+---
+ gcc/ChangeLog     | 5 +++++
+ gcc/cfgloopanal.c | 5 ++++-
+ 2 files changed, 9 insertions(+), 1 deletion(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 07e5bebe909..f3301b16464 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cfgloopanal.c b/gcc/cfgloopanal.c
+index 392b1c337c4..0b33e8272a7 100644
+--- a/gcc/cfgloopanal.c
++++ b/gcc/cfgloopanal.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0735-PR-87488-Add-with-diagnostics-urls-configuration-opt.patch ===
+From 458c8d6459c4005fc9886b6e25d168a6535ac415 Mon Sep 17 00:00:00 2001
+From: Bernd Edlinger <bernd.edlinger@hotmail.de>
+Date: Wed, 29 Jan 2020 15:31:10 +0100
+Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
+ option
+
+2020-02-15  David Malcolm  <dmalcolm@redhat.com>
+	    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR 87488
+	PR other/93168
+	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
+	* configure.ac (--with-diagnostics-urls): New configuration
+	option, based on --with-diagnostics-color.
+	(DIAGNOSTICS_URLS_DEFAULT): New define.
+	* config.h: Regenerate.
+	* configure: Regenerate.
+	* diagnostic.c (diagnostic_urls_init): Handle -1 for
+	DIAGNOSTICS_URLS_DEFAULT from configure-time
+	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
+	and TERM_URLS environment variable.
+	* diagnostic-url.h (diagnostic_url_format): New enum type.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and change return type.
+	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
+	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
+	the linux console, and mingw.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and adjust.
+	* pretty-print.h (pretty_printer::show_urls): rename to...
+	(pretty_printer::url_format): ... this, and change to enum.
+	* pretty-print.c (pretty_printer::pretty_printer,
+	pp_begin_url, pp_end_url, test_urls): Adjust.
+	* doc/install.texi (--with-diagnostics-urls): Document the new
+	configuration option.
+	(--with-diagnostics-color): Document the existing interaction
+	with GCC_COLORS better.
+	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
+	vindex reference.  Update description of defaults based on the above.
+	(-fdiagnostics-color): Update description of how -fdiagnostics-color
+	interacts with GCC_COLORS.
+---
+ gcc/ChangeLog          |  36 +++++++++++++++
+ gcc/config.in          |   6 +++
+ gcc/configure          |  41 ++++++++++++++++-
+ gcc/configure.ac       |  28 ++++++++++++
+ gcc/diagnostic-color.c | 101 ++++++++++++++++++++++++++++++++++++++---
+ gcc/diagnostic-url.h   |  18 +++++++-
+ gcc/diagnostic.c       |  21 +++++++--
+ gcc/doc/install.texi   |  15 ++++--
+ gcc/doc/invoke.texi    |  39 ++++++++++++++--
+ gcc/pretty-print.c     |  44 +++++++++++++++---
+ gcc/pretty-print.h     |   5 +-
+ 11 files changed, 328 insertions(+), 26 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index e6eb6ab4c21..22f990a3088 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config.in b/gcc/config.in
+index 48292861842..01fb18dbbb5 100644
+--- a/gcc/config.in
++++ b/gcc/config.in
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/configure b/gcc/configure
+index 5fa565a40a4..f55cdb8c77f 100755
+--- a/gcc/configure
++++ b/gcc/configure
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/configure.ac b/gcc/configure.ac
+index 671b9a67d81..0e6e475950d 100644
+--- a/gcc/configure.ac
++++ b/gcc/configure.ac
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic-color.c b/gcc/diagnostic-color.c
+index d5547952921..b1baded2c9e 100644
+--- a/gcc/diagnostic-color.c
++++ b/gcc/diagnostic-color.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic-url.h b/gcc/diagnostic-url.h
+index 6be056941f1..d28460b928b 100644
+--- a/gcc/diagnostic-url.h
++++ b/gcc/diagnostic-url.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
+index 3386f070256..e4a08f76def 100644
+--- a/gcc/diagnostic.c
++++ b/gcc/diagnostic.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
+index 6ffafacff50..8ddebbb6267 100644
+--- a/gcc/doc/install.texi
++++ b/gcc/doc/install.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
+index bd9ecebf103..597151670be 100644
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/pretty-print.c b/gcc/pretty-print.c
+index 817c1059e08..dde138b0533 100644
+--- a/gcc/pretty-print.c
++++ b/gcc/pretty-print.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
+index 001468c966e..22892f12ab7 100644
+--- a/gcc/pretty-print.h
++++ b/gcc/pretty-print.h
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== co-authored-by.patch ===
+From d7a65edb629a010f7ef907d457343abcb569fab7 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Thu, 16 Apr 2020 15:39:22 +0200
+Subject: [PATCH 1850/2034] List valid pairs for new and delete operators.
+
+	PR c++/94314
+	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
+	DECL_IS_REPLACEABLE_OPERATOR during cloning.
+	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
+	(propagate_necessity): Check operator names.
+
+	PR c++/94314
+	* g++.dg/pr94314.C: Do not use dg-additional-options
+	and remove not needed stdio.h include.
+	* g++.dg/pr94314-2.C: Likewise.
+	* g++.dg/pr94314-3.C: Likewise.
+	* g++.dg/pr94314-4.C: New test.
+
+co-authored-By: Jakub Jelinek <jakub@redhat.com>
+Co-Authored-by: John Miller <jm@example.com>
+co-authored-by: John Miller2 <jm2@example.com>
+---
+ gcc/ChangeLog                    |  9 +++
+ gcc/cgraphclones.c               |  2 +
+ gcc/testsuite/ChangeLog          | 10 ++++
+ gcc/testsuite/g++.dg/pr94314-2.C |  5 +-
+ gcc/testsuite/g++.dg/pr94314-3.C |  5 +-
+ gcc/testsuite/g++.dg/pr94314-4.C | 30 ++++++++++
+ gcc/testsuite/g++.dg/pr94314.C   |  5 +-
+ gcc/tree-ssa-dce.c               | 98 ++++++++++++++++++++++++++++----
+ 8 files changed, 142 insertions(+), 22 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 74dbeeb44c6..9e499ec9c86 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
+index c73b8f810f0..8f541a28b6e 100644
+--- a/gcc/cgraphclones.c
++++ b/gcc/cgraphclones.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 756f1d759e6..94d2312022d 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
+index 36b93ed6d4d..998ce601767 100644
+--- a/gcc/testsuite/g++.dg/pr94314-2.C
++++ b/gcc/testsuite/g++.dg/pr94314-2.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-3.C b/gcc/testsuite/g++.dg/pr94314-3.C
+index 575ba9d8ad8..846a5d6a3d8 100644
+--- a/gcc/testsuite/g++.dg/pr94314-3.C
++++ b/gcc/testsuite/g++.dg/pr94314-3.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/pr94314-4.C b/gcc/testsuite/g++.dg/pr94314-4.C
+new file mode 100644
+index 00000000000..d097f29d4ad
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/pr94314-4.C
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/g++.dg/pr94314.C b/gcc/testsuite/g++.dg/pr94314.C
+index 86e651d10ba..4e5ae122e9f 100644
+--- a/gcc/testsuite/g++.dg/pr94314.C
++++ b/gcc/testsuite/g++.dg/pr94314.C
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree-ssa-dce.c b/gcc/tree-ssa-dce.c
+index fd5f24c746c..757cfad5b5e 100644
+--- a/gcc/tree-ssa-dce.c
++++ b/gcc/tree-ssa-dce.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 1699-combine-Fix-split_i2i3-ICE-PR94291.patch ===
+From c23c899aedf11069e992eed7358802b262d62f98 Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Tue, 7 Apr 2020 21:30:12 +0200
+Subject: [PATCH 1699/2034] combine: Fix split_i2i3 ICE [PR94291]
+
+The following testcase ICEs on armv7hl-linux-gnueabi.
+try_combine is called on:
+(gdb) p debug_rtx (i3)
+(insn 20 12 22 2 (set (mem/c:SI (plus:SI (reg/f:SI 102 sfp)
+                (const_int -4 [0xfffffffffffffffc])) [1 x+0 S4 A32])
+        (reg:SI 125)) "pr94291.c":7:8 241 {*arm_movsi_insn}
+     (expr_list:REG_DEAD (reg:SI 125)
+        (nil)))
+(gdb) p debug_rtx (i2)
+(insn 12 7 20 2 (parallel [
+            (set (reg:CC 100 cc)
+                (compare:CC (reg:SI 121 [ <retval> ])
+                    (const_int 0 [0])))
+            (set (reg:SI 125)
+                (reg:SI 121 [ <retval> ]))
+        ]) "pr94291.c":7:8 248 {*movsi_compare0}
+     (expr_list:REG_UNUSED (reg:CC 100 cc)
+        (nil)))
+and tries to recognize cc = r121 cmp 0; [sfp-4] = r121 parallel,
+but that isn't recognized, so it splits it into two: split_i2i3
+[sfp-4] = r121 followed by cc = r121 cmp 0 which is recognized, but
+ICEs because the code below insist that the SET_DEST of newi2pat
+(or first set in PARALLEL thereof) must be a REG or SUBREG of REG,
+but it is a MEM in this case.  I don't see any condition that would
+guarantee that, perhaps for the swap_i2i3 case it was somehow guaranteed.
+
+As the code just wants to update LOG_LINKS and LOG_LINKS are only for
+registers, not for MEM or anything else, the patch just doesn't update those
+if it isn't a REG or SUBREG of REG.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94291
+	PR rtl-optimization/84169
+	* combine.c (try_combine): For split_i2i3, don't assume SET_DEST
+	must be a REG or SUBREG of REG; if it is not one of these, don't
+	update LOG_LINKs.
+
+	* gcc.dg/pr94291.c: New test.
+---
+ gcc/ChangeLog                  |  8 +++++++
+ gcc/combine.c                  | 42 +++++++++++++++++++---------------
+ gcc/testsuite/ChangeLog        |  6 +++++
+ gcc/testsuite/gcc.dg/pr94291.c | 14 ++++++++++++
+ 4 files changed, 51 insertions(+), 19 deletions(-)
+ create mode 100644 gcc/testsuite/gcc.dg/pr94291.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index a1ab9fb4ef3..12803e90b0a 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/combine.c b/gcc/combine.c
+index 58366a6d331..cff76cd3303 100644
+--- a/gcc/combine.c
++++ b/gcc/combine.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 71b5a14bcbe..3cbf891d58d 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.dg/pr94291.c b/gcc/testsuite/gcc.dg/pr94291.c
+new file mode 100644
+index 00000000000..7daa2b01166
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/pr94291.c
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0001-Add-patch_area_size-and-patch_area_entry-to-crtl.patch ===
+From 6607bdd99994c834f92fce924abdaea3405f62dc Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 1 May 2020 21:03:10 -0700
+Subject: [PATCH] Add patch_area_size and patch_area_entry to crtl
+
+Currently patchable area is at the wrong place.  It is placed immediately
+after function label and before .cfi_startproc.  A backend should be able
+to add a pseudo patchable area instruction durectly into RTL.  This patch
+adds patch_area_size and patch_area_entry to crtl so that the patchable
+area info is available in RTL passes.
+
+It also limits patch_area_size and patch_area_entry to 65535, which is
+a reasonable maximum size for patchable area.
+
+gcc/
+
+	PR target/93492
+	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
+	* opts.c (common_handle_option): Limit
+	function_entry_patch_area_size and function_entry_patch_area_start
+	to USHRT_MAX.  Fix a typo in error message.
+	* varasm.c (assemble_start_function): Use crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* doc/invoke.texi: Document the maximum value for
+	-fpatchable-function-entry.
+
+gcc/c-family/
+
+	PR target/12345
+	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
+	value to USHRT_MAX (65535).
+
+---
+ gcc/ChangeLog                                 | 14 ++++++++
+ gcc/c-family/ChangeLog                        |  6 ++++
+ gcc/c-family/c-attribs.c                      |  9 +++++
+ gcc/cfgexpand.c                               | 33 +++++++++++++++++++
+ gcc/doc/invoke.texi                           |  1 +
+ gcc/emit-rtl.h                                |  6 ++++
+ gcc/opts.c                                    |  4 ++-
+ gcc/testsuite/ChangeLog                       |  7 ++++
+ .../patchable_function_entry-error-1.c        |  9 +++++
+ .../patchable_function_entry-error-2.c        |  9 +++++
+ .../patchable_function_entry-error-3.c        | 17 ++++++++++
+ gcc/varasm.c                                  | 30 ++---------------
+ 12 files changed, 116 insertions(+), 29 deletions(-)
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index e85a8e8813e..fb776ba5a0e 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
+index c429b49e68c..69ea1fdc4f3 100644
+--- a/gcc/c-family/ChangeLog
++++ b/gcc/c-family/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
+index ac936d5bbbb..a101312c581 100644
+--- a/gcc/c-family/c-attribs.c
++++ b/gcc/c-family/c-attribs.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
+index a7ec77d5c85..86efa22bf60 100644
+--- a/gcc/cfgexpand.c
++++ b/gcc/cfgexpand.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
+index 527d362533a..767d1f07801 100644
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
+index a878efe3cf7..3d6565c8a30 100644
+--- a/gcc/emit-rtl.h
++++ b/gcc/emit-rtl.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/opts.c b/gcc/opts.c
+index c212a1a57dc..3dccef39701 100644
+--- a/gcc/opts.c
++++ b/gcc/opts.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 176aa117904..185f9ea725e 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+new file mode 100644
+index 00000000000..f60bf46cfe3
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+new file mode 100644
+index 00000000000..90f88c78be7
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+new file mode 100644
+index 00000000000..4490e5c15ca
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index 271a67abf56..f062e48071f 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+
+=== 1957-c-generic-lambda-forwarding-function-PR94546.patch ===
+From aedd04caa945260ea77fd22f29b77292f7dba72e Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Wed, 22 Apr 2020 02:27:54 -0400
+Subject: [PATCH 1957/2034] c++: generic lambda forwarding function [PR94546]
+
+While instantiating test(Plot) we partially instantiate the generic lambda.
+We look at forward<T>(rest)... and see that it's just replacing parameter
+packs with new parameter packs and tries to do a direct substitution.  But
+because register_parameter_specializations had built up a
+NONTYPE_ARGUMENT_PACK around the new parameter pack, the substitution
+failed.  So let's not wrap it that way.
+
+gcc/cp/ChangeLog
+2020-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/94546
+	* pt.c (register_parameter_specializations): If the instantiation is
+	still a parameter pack, don't wrap it in a NONTYPE_ARGUMENT_PACK.
+	(tsubst_pack_expansion, tsubst_expr): Adjust.
+---
+ gcc/cp/ChangeLog                              |  7 +++++
+ gcc/cp/pt.c                                   | 28 +++++++------------
+ .../g++.dg/cpp2a/lambda-generic-variadic20.C  | 23 +++++++++++++++
+ 3 files changed, 40 insertions(+), 18 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
+
+diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
+index 640e4948130..4b6691a77f0 100644
+--- a/gcc/cp/ChangeLog
++++ b/gcc/cp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
+index 7bf249cee5c..2fe7b66707c 100644
+--- a/gcc/cp/pt.c
++++ b/gcc/cp/pt.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
+new file mode 100644
+index 00000000000..3d69dbb8e98
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0030-PR-c-92746-ICE-with-noexcept-of-function-concept-che.patch ===
+From edabbec31e3bfc9a9757f80c8610706ed00e5a1a Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Mon, 13 Jan 2020 18:13:46 -0500
+Subject: [PATCH 0030/2034] 	PR c++/92746 - ICE with noexcept of function
+ concept check.
+
+Another place that needs to specially handle Concepts TS function-style
+concepts.
+
+	* except.c (check_noexcept_r): Handle concept-check.
+---
+ gcc/cp/ChangeLog                            | 3 +++
+ gcc/cp/except.c                             | 2 ++
+ gcc/testsuite/g++.dg/concepts/fn-concept3.C | 6 ++++++
+ 3 files changed, 11 insertions(+)
+ create mode 100644 gcc/testsuite/g++.dg/concepts/fn-concept3.C
+
+diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
+index 59646c70fa4..4729e3d331d 100644
+--- a/gcc/cp/ChangeLog
++++ b/gcc/cp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cp/except.c b/gcc/cp/except.c
+index e073bd4d2bc..55b4b6af442 100644
+--- a/gcc/cp/except.c
++++ b/gcc/cp/except.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/concepts/fn-concept3.C b/gcc/testsuite/g++.dg/concepts/fn-concept3.C
+new file mode 100644
+index 00000000000..ecb7f6b12f7
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/concepts/fn-concept3.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0129-Add-PR-number-to-change-log.patch ===
+From f788c2d66a6ee1ded65dafccbc5e485d42af4808 Mon Sep 17 00:00:00 2001
+From: Richard Sandiford <richard.sandiford@arm.com>
+Date: Fri, 17 Jan 2020 12:22:58 +0000
+Subject: [PATCH 0129/2034] Add PR number to change log
+
+---
+ gcc/ChangeLog | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 6c6d586ca75..49ca5f92dec 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0577-aarch64-Add-an-and.patch ===
+From bba0c624c8b1d6e54dc58091dd21b0c2ab000434 Mon Sep 17 00:00:00 2001
+From: Richard Sandiford <richard.sandiford@arm.com>
+Date: Mon, 3 Feb 2020 21:43:44 +0000
+Subject: [PATCH 0577/2034] aarch64: Add an and/ior-based movk pattern
+ [PR87763]
+
+This patch adds a second movk pattern that models the instruction
+as a "normal" and/ior operation rather than an insertion.  It fixes
+the third insv_1.c failure in PR87763, which was a regression from
+GCC 8.
+
+2020-02-06  Richard Sandiford  <richard.sandiford@arm.com>
+
+gcc/
+	PR target/87763
+	* config/aarch64/aarch64-protos.h (aarch64_movk_shift): Declare.
+	* config/aarch64/aarch64.c (aarch64_movk_shift): New function.
+	* config/aarch64/aarch64.md (aarch64_movk<mode>): New pattern.
+
+gcc/testsuite/
+	PR target/87763
+	* gcc.target/aarch64/movk_2.c: New test.
+---
+ gcc/ChangeLog                             |  7 ++
+ gcc/config/aarch64/aarch64-protos.h       |  1 +
+ gcc/config/aarch64/aarch64.c              | 24 +++++++
+ gcc/config/aarch64/aarch64.md             | 17 +++++
+ gcc/testsuite/ChangeLog                   |  5 ++
+ gcc/testsuite/gcc.target/aarch64/movk_2.c | 78 +++++++++++++++++++++++
+ 6 files changed, 132 insertions(+)
+ create mode 100644 gcc/testsuite/gcc.target/aarch64/movk_2.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index efbbbf08225..cea8ffee99c 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
+index 24cc65a383a..d29975a8921 100644
+--- a/gcc/config/aarch64/aarch64-protos.h
++++ b/gcc/config/aarch64/aarch64-protos.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
+index 6581e4cb075..6a1b4099af1 100644
+--- a/gcc/config/aarch64/aarch64.c
++++ b/gcc/config/aarch64/aarch64.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
+index 90eebce85c0..9c1f17d0f85 100644
+--- a/gcc/config/aarch64/aarch64.md
++++ b/gcc/config/aarch64/aarch64.md
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 601bc336290..cdb26581b9c 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/aarch64/movk_2.c b/gcc/testsuite/gcc.target/aarch64/movk_2.c
+new file mode 100644
+index 00000000000..a0477ad5d42
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/aarch64/movk_2.c
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 1975-S-390-Fix-several-test-cases.patch ===
+From 803596fe9591026a50b59ff961ebc114097677b5 Mon Sep 17 00:00:00 2001
+From: Stefan Schulze Frielinghaus <stefansf@linux.ibm.com>
+Date: Tue, 10 Mar 2020 10:49:28 +0100
+Subject: [PATCH 1975/2034] S/390: Fix several test cases
+
+gcc/ChangeLog:
+
+2020-04-21  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config/s390/s390.md ("*<risbg_n>_ior_and_sr_ze<mode>"): Lift from SI
+	mode to DSI. ("*trunc_sidi_and_subreg_ze<clobbercc_or_nocc>"): New
+	insn pattern.
+
+gcc/testsuite/ChangeLog:
+
+2020-04-21  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/addsub-signed-overflow-1.c: Fix options.
+	* gcc.target/s390/addsub-signed-overflow-2.c: Fix options.
+	* gcc.target/s390/bswap-1.c: Fix scan assembler regex.
+	* gcc.target/s390/global-array-element-pic2.c: Fix scan assembler regex.
+	* gcc.target/s390/load-relative-check.c: Fix options.
+	* gcc.target/s390/morestack.c: Fix options.
+	* gcc.target/s390/nobp-return-mem-z900.c: Temporarily silence this case.
+	* gcc.target/s390/risbg-ll-1.c: Fix scan assembler regex.
+	* gcc.target/s390/risbg-ll-2.c: Fix scan assembler regex.
+	* gcc.target/s390/risbg-ll-3.c: Fix scan assembler regex.
+	* gcc.target/s390/target-attribute/pr82012.c: Fix error message.
+---
+ gcc/config/s390/s390.md                       | 39 ++++++++++++-------
+ .../s390/addsub-signed-overflow-1.c           |  2 +-
+ .../s390/addsub-signed-overflow-2.c           |  2 +-
+ gcc/testsuite/gcc.target/s390/bswap-1.c       |  8 ++--
+ .../s390/global-array-element-pic2.c          |  4 +-
+ .../gcc.target/s390/load-relative-check.c     |  2 +-
+ gcc/testsuite/gcc.target/s390/morestack.c     |  2 +-
+ .../gcc.target/s390/nobp-return-mem-z900.c    | 17 ++++++--
+ gcc/testsuite/gcc.target/s390/risbg-ll-1.c    | 13 +++----
+ gcc/testsuite/gcc.target/s390/risbg-ll-2.c    |  6 +--
+ gcc/testsuite/gcc.target/s390/risbg-ll-3.c    |  2 +-
+ .../s390/target-attribute/pr82012.c           |  2 +-
+ 12 files changed, 59 insertions(+), 40 deletions(-)
+
+diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
+index 44b59659e20..cf53ef1b791 100644
+--- a/gcc/config/s390/s390.md
++++ b/gcc/config/s390/s390.md
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
+index 143220d5541..ebc02479587 100644
+--- a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
++++ b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
+index 798e489cece..8bd1a764bc6 100644
+--- a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
++++ b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/bswap-1.c b/gcc/testsuite/gcc.target/s390/bswap-1.c
+index edfcdf888c0..c11a0ea780b 100644
+--- a/gcc/testsuite/gcc.target/s390/bswap-1.c
++++ b/gcc/testsuite/gcc.target/s390/bswap-1.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c b/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
+index b9398a8042f..72b87d40b85 100644
+--- a/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
++++ b/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/load-relative-check.c b/gcc/testsuite/gcc.target/s390/load-relative-check.c
+index 3d4671a6b3f..a55bc2442f1 100644
+--- a/gcc/testsuite/gcc.target/s390/load-relative-check.c
++++ b/gcc/testsuite/gcc.target/s390/load-relative-check.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/morestack.c b/gcc/testsuite/gcc.target/s390/morestack.c
+index aa28b72aa6c..4cfa220e737 100644
+--- a/gcc/testsuite/gcc.target/s390/morestack.c
++++ b/gcc/testsuite/gcc.target/s390/morestack.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
+index 0b318115a8f..3d6aca1f95f 100644
+--- a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
++++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-1.c b/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
+index 30350d04c45..1cac15820c0 100644
+--- a/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
++++ b/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-2.c b/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
+index 754c17311dd..8bf1a0ff88b 100644
+--- a/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
++++ b/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-3.c b/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
+index 2a2db543cd9..90d37f2c1ce 100644
+--- a/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
++++ b/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c b/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
+index 2e1f7ae57be..ad1bf76d4d2 100644
+--- a/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
++++ b/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 1999-rs6000-Fix-C-14-vs.-C-17-ABI-bug-on-powerpc64le-PR94.patch ===
+From a39ed81b8a0b46320a7c6ece3f7ad4c3f8519609 Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Thu, 23 Apr 2020 09:59:57 +0200
+Subject: [PATCH 1999/2034] rs6000: Fix C++14 vs. C++17 ABI bug on powerpc64le
+ [PR94707]
+
+As mentioned in the PR and on IRC, the recently added struct-layout-1.exp
+new tests FAIL on powerpc64le-linux (among other targets).
+FAIL: tmpdir-g++.dg-struct-layout-1/t032 cp_compat_x_tst.o-cp_compat_y_tst.o execute
+FAIL: tmpdir-g++.dg-struct-layout-1/t058 cp_compat_x_tst.o-cp_compat_y_tst.o execute
+FAIL: tmpdir-g++.dg-struct-layout-1/t059 cp_compat_x_tst.o-cp_compat_y_tst.o execute
+in particular.  The problem is that the presence or absence of the C++17
+artificial empty base fields, which have non-zero TYPE_SIZE, but zero
+DECL_SIZE, change the ABI decisions, if it is present (-std=c++17), the type
+might not be considered homogeneous, while if it is absent (-std=c++14), it
+can be.
+
+The following patch fixes that and emits a -Wpsabi inform; perhaps more
+often than it could, because the fact that rs6000_discover_homogeneous_aggregate
+returns true when it didn't in in GCC 7/8/9 with -std=c++17 doesn't still
+mean it will make a different ABI decision, but the warning triggered only
+on the test I've changed (the struct-layout-1.exp tests use -w -Wno-psabi
+already).
+
+2020-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94707
+	* config/rs6000/rs6000-call.c (rs6000_aggregate_candidate): Add
+	cxx17_empty_base_seen argument.  Pass it to recursive calls.
+	Ignore cxx17_empty_base_field_p fields after setting
+	*cxx17_empty_base_seen to true.
+	(rs6000_discover_homogeneous_aggregate): Adjust
+	rs6000_aggregate_candidate caller.  With -Wpsabi, diagnose homogeneous
+	aggregates with C++17 empty base fields.
+
+	* g++.dg/tree-ssa/pr27830.C: Use -Wpsabi -w for -std=c++17 and higher.
+---
+ gcc/ChangeLog                           | 13 ++++++++++
+ gcc/config/rs6000/rs6000-call.c         | 34 +++++++++++++++++++++----
+ gcc/testsuite/ChangeLog                 |  3 +++
+ gcc/testsuite/g++.dg/tree-ssa/pr27830.C |  2 ++
+ 4 files changed, 47 insertions(+), 5 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 06f7eda0033..93c3076eb86 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
+index e08621ace27..a9ae7ab70ca 100644
+--- a/gcc/config/rs6000/rs6000-call.c
++++ b/gcc/config/rs6000/rs6000-call.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 684e408c1a5..245c1512c76 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr27830.C b/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
+index 01c7fc18783..551ebc428cd 100644
+--- a/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
++++ b/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== 0001-Add-patch_area_size-and-patch_area_entry-to-crtl.patch ===
+From 6607bdd99994c834f92fce924abdaea3405f62dc Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 1 May 2020 21:03:10 -0700
+Subject: [PATCH] Add patch_area_size and patch_area_entry to crtl
+
+Currently patchable area is at the wrong place.  It is placed immediately
+after function label and before .cfi_startproc.  A backend should be able
+to add a pseudo patchable area instruction durectly into RTL.  This patch
+adds patch_area_size and patch_area_entry to crtl so that the patchable
+area info is available in RTL passes.
+
+It also limits patch_area_size and patch_area_entry to 65535, which is
+a reasonable maximum size for patchable area.
+
+gcc/
+
+	PR target/93492
+	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
+	* opts.c (common_handle_option): Limit
+	function_entry_patch_area_size and function_entry_patch_area_start
+	to USHRT_MAX.  Fix a typo in error message.
+	* varasm.c (assemble_start_function): Use crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* doc/invoke.texi: Document the maximum value for
+	-fpatchable-function-entry.
+
+gcc/c-family/
+
+	PR target/12345
+	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
+	value to USHRT_MAX (65535).
+
+---
+ gcc/ChangeLog                                 | 14 ++++++++
+ gcc/c-family/ChangeLog                        |  6 ++++
+ gcc/c-family/c-attribs.c                      |  9 +++++
+ gcc/cfgexpand.c                               | 33 +++++++++++++++++++
+ gcc/doc/invoke.texi                           |  1 +
+ gcc/emit-rtl.h                                |  6 ++++
+ gcc/opts.c                                    |  4 ++-
+ gcc/testsuite/ChangeLog                       |  7 ++++
+ .../patchable_function_entry-error-1.c        |  9 +++++
+ .../patchable_function_entry-error-2.c        |  9 +++++
+ .../patchable_function_entry-error-3.c        | 17 ++++++++++
+ gcc/varasm.c                                  | 30 ++---------------
+ 12 files changed, 116 insertions(+), 29 deletions(-)
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+ create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index e85a8e8813e..fb776ba5a0e 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
+index c429b49e68c..69ea1fdc4f3 100644
+--- a/gcc/c-family/ChangeLog
++++ b/gcc/c-family/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
+index ac936d5bbbb..a101312c581 100644
+--- a/gcc/c-family/c-attribs.c
++++ b/gcc/c-family/c-attribs.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
+index a7ec77d5c85..86efa22bf60 100644
+--- a/gcc/cfgexpand.c
++++ b/gcc/cfgexpand.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
+index 527d362533a..767d1f07801 100644
+--- a/gcc/doc/invoke.texi
++++ b/gcc/doc/invoke.texi
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
+index a878efe3cf7..3d6565c8a30 100644
+--- a/gcc/emit-rtl.h
++++ b/gcc/emit-rtl.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/opts.c b/gcc/opts.c
+index c212a1a57dc..3dccef39701 100644
+--- a/gcc/opts.c
++++ b/gcc/opts.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 176aa117904..185f9ea725e 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+new file mode 100644
+index 00000000000..f60bf46cfe3
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+new file mode 100644
+index 00000000000..90f88c78be7
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+new file mode 100644
+index 00000000000..4490e5c15ca
+--- /dev/null
++++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index 271a67abf56..f062e48071f 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+
+=== 0002-Bump-date.patch ===
+From a139bafeec76732d964b99e8be3d61b3cab0359d Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Tue, 12 May 2020 09:27:51 +0200
+Subject: [PATCH 2/2] Bump date.
+
+---
+ gcc/DATESTAMP | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
+index c3d42a6f89a..b03d4a0feab 100644
+--- a/gcc/DATESTAMP
++++ b/gcc/DATESTAMP
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+
+=== 0001-Just-test-it.patch ===
+From 6b10b909c0b49ac7ace2cd53021b3ff7ffb2d3f4 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Tue, 12 May 2020 09:25:54 +0200
+Subject: [PATCH 1/2] Just test it.
+
+gcc/ChangeLog:
+
+2020-05-12  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/12345
+	* tree-vrp.c: Done.
+	* tree.c: Done.
+---
+ gcc/tree-vrp.c | 2 ++
+ gcc/tree.c     | 3 +++
+ 2 files changed, 5 insertions(+)
+
+diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
+index a8861670790..32722d2c714 100644
+--- a/gcc/tree-vrp.c
++++ b/gcc/tree-vrp.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree.c b/gcc/tree.c
+index 0ddf002e9eb..fa7c6b28a4e 100644
+--- a/gcc/tree.c
++++ b/gcc/tree.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+
+=== trailing-whitespaces.patch ===
+From eb7c7c524556df5364f03adc20f6a9db20858484 Mon Sep 17 00:00:00 2001
+From: Jakub Jelinek <jakub@redhat.com>
+Date: Mon, 13 Jan 2020 14:14:57 +0100
+Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
+ tree-ssa-forwprop.c some more PR90838
+
+2020-01-13  Jakub Jelinek  <jakub@redhat.com>   
+
+	PR tree-optimization/90838
+	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
+	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro      
+	argument rather than to initialize temporary for targets that
+	don't use the mode argument at all.  Initialize ctzval to avoid  
+	warning at -O0.
+---
+ gcc/ChangeLog           | 9 +++++++++
+ gcc/tree-ssa-forwprop.c | 6 +++---
+ 2 files changed, 12 insertions(+), 3 deletions(-)
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index a195863212e..f7df07343d1 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
+index aac31d02b6c..56c470f6ecf 100644
+--- a/gcc/tree-ssa-forwprop.c
++++ b/gcc/tree-ssa-forwprop.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.1
+
+=== pr-check1.patch ===
+From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Thu, 16 Jan 2020 16:55:39 -0500
+Subject: [PATCH 0121/2034] PR c++/93286 - ICE with __is_constructible and
+ variadic template.
+
+Here we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST
+because that function knew how to deal with pack expansions, and tsubst
+didn't.  But tsubst_copy_and_build expects to be dealing with expressions,
+so we crash when trying to convert_from_reference a type.
+
+gcc/cp/ChangeLog:
+	PR ipa/12345
+	* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.
+	(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.
+
+gcc/testsuite/ChangeLog:
+	* g++.dg/ext/is_constructible4.C: New file.
+---
+ gcc/cp/ChangeLog                             |  4 ++
+ gcc/cp/pt.c                                  | 74 ++++++++++++++++++--
+ gcc/testsuite/g++.dg/ext/is_constructible4.C | 18 +++++
+ 3 files changed, 89 insertions(+), 7 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/ext/is_constructible4.C
+
+diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
+index 3ca5d7a11b4..c37e461bcc5 100644
+--- a/gcc/cp/ChangeLog
++++ b/gcc/cp/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
+index 9bb8cc13e5f..872f8ff8f52 100644
+--- a/gcc/cp/pt.c
++++ b/gcc/cp/pt.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/ext/is_constructible4.C b/gcc/testsuite/g++.dg/ext/is_constructible4.C
+new file mode 100644
+index 00000000000..6dfe3c01661
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/ext/is_constructible4.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0020-IPA-Avoid-segfault-in-devirtualization_time_bonus-PR.patch ===
+From 8472660b98a31b32b7d030c2cdc4d41d326364d5 Mon Sep 17 00:00:00 2001
+From: Martin Jambor <mjambor@suse.cz>
+Date: Mon, 13 Jan 2020 19:13:46 +0100
+Subject: [PATCH 0020/2034] IPA: Avoid segfault in devirtualization_time_bonus
+ (PR 93223)
+
+2020-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/93223
+	* ipa-cp.c (devirtualization_time_bonus): Check whether isummary is
+	NULL.
+
+	testsuite/
+	* g++.dg/ipa/pr93223.C: New test.
+---
+ gcc/ipa-cp.c                       |  2 +-
+ gcc/testsuite/g++.dg/ipa/pr93223.C | 62 ++++++++++++++++++++++++++++++
+ 2 files changed, 63 insertions(+), 1 deletion(-)
+ create mode 100644 gcc/testsuite/g++.dg/ipa/pr93223.C
+
+diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
+index 612f3d0a89b..17da1d8e8a7 100644
+--- a/gcc/ipa-cp.c
++++ b/gcc/ipa-cp.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/ipa/pr93223.C b/gcc/testsuite/g++.dg/ipa/pr93223.C
+new file mode 100644
+index 00000000000..87f98b5e244
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/ipa/pr93223.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0043-Compare-TREE_ADDRESSABLE-and-TYPE_MODE-when-ODR-chec.patch ===
+From 288c5324bf6e418dd94d718d1619464a4f68ff8e Mon Sep 17 00:00:00 2001
+From: Jan Hubicka <jh@suse.cz>
+Date: Tue, 14 Jan 2020 21:45:03 +0100
+Subject: [PATCH 0043/2034] Compare TREE_ADDRESSABLE and TYPE_MODE when ODR
+ checking types.
+
+	PR lto/91576
+	* ipa-devirt.c (odr_types_equivalent_p): Compare TREE_ADDRESSABLE and
+	TYPE_MODE.
+
+	* testsuite/g++.dg/lto/odr-8_0.C: New testcase.
+	* testsuite/g++.dg/lto/odr-8_1.C: New testcase.
+---
+ gcc/ChangeLog                      |  6 ++++++
+ gcc/ipa-devirt.c                   | 21 +++++++++++++++++++++
+ gcc/testsuite/ChangeLog            |  6 ++++++
+ gcc/testsuite/g++.dg/lto/odr-8_0.C |  7 +++++++
+ gcc/testsuite/g++.dg/lto/odr-8_1.C | 12 ++++++++++++
+ 5 files changed, 52 insertions(+)
+ create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_0.C
+ create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_1.C
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 38165123654..33ca91a6467 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
+index f0031957375..b609a77701d 100644
+--- a/gcc/ipa-devirt.c
++++ b/gcc/ipa-devirt.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 8e3b9105188..dc42601794b 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/g++.dg/lto/odr-8_0.C b/gcc/testsuite/g++.dg/lto/odr-8_0.C
+new file mode 100644
+index 00000000000..59f51399fac
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/lto/odr-8_0.C
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/g++.dg/lto/odr-8_1.C b/gcc/testsuite/g++.dg/lto/odr-8_1.C
+new file mode 100644
+index 00000000000..742df8cc906
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/lto/odr-8_1.C
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0096-GCC-PATCH-AArch64-Add-ACLE-intrinsics-for-dot-produc.patch ===
+From 8c197c851e7528baba7cb837f34c05ba2242f705 Mon Sep 17 00:00:00 2001
+From: Stam Markianos-Wright <stam.markianos-wright@arm.com>
+Date: Thu, 16 Jan 2020 14:20:48 +0000
+Subject: [PATCH 0096/2034] [GCC][PATCH][AArch64]Add ACLE intrinsics for dot
+ product (usdot - vector, <us/su>dot - by element) for AArch64 AdvSIMD ARMv8.6
+ Extension
+
+gcc/ChangeLog:
+
+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* config/aarch64/aarch64-builtins.c: (enum aarch64_type_qualifiers):
+	New qualifier_lane_quadtup_index, TYPES_TERNOP_SSUS,
+	TYPES_QUADOPSSUS_LANE_QUADTUP, TYPES_QUADOPSSSU_LANE_QUADTUP.
+	(aarch64_simd_expand_args): Add case SIMD_ARG_LANE_QUADTUP_INDEX.
+	(aarch64_simd_expand_builtin): Add qualifier_lane_quadtup_index.
+	* config/aarch64/aarch64-simd-builtins.def (usdot, usdot_lane,
+	usdot_laneq, sudot_lane,sudot_laneq): New.
+	* config/aarch64/aarch64-simd.md (aarch64_usdot): New.
+	(aarch64_<sur>dot_lane): New.
+	* config/aarch64/arm_neon.h (vusdot_s32): New.
+	(vusdotq_s32): New.
+	(vusdot_lane_s32): New.
+	(vsudot_lane_s32): New.
+	* config/aarch64/iterators.md (DOTPROD_I8MM): New iterator.
+	(UNSPEC_USDOT, UNSPEC_SUDOT): New unspecs.
+
+gcc/testsuite/ChangeLog:
+
+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-1.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-2.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-3.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-4.c: New test.
+---
+ gcc/ChangeLog                                 |  18 +++
+ gcc/config/aarch64/aarch64-builtins.c         |  45 +++++-
+ gcc/config/aarch64/aarch64-simd-builtins.def  |   5 +
+ gcc/config/aarch64/aarch64-simd.md            |  34 +++++
+ gcc/config/aarch64/arm_neon.h                 |  83 +++++++++++
+ gcc/config/aarch64/iterators.md               |   7 +
+ gcc/testsuite/ChangeLog                       |   7 +
+ .../aarch64/advsimd-intrinsics/vdot-3-1.c     | 136 +++++++++++++++++
+ .../aarch64/advsimd-intrinsics/vdot-3-2.c     | 137 ++++++++++++++++++
+ .../aarch64/advsimd-intrinsics/vdot-3-3.c     |  31 ++++
+ .../aarch64/advsimd-intrinsics/vdot-3-4.c     |  31 ++++
+ 11 files changed, 531 insertions(+), 3 deletions(-)
+ create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
+ create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
+ create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
+ create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
+
+diff --git a/gcc/ChangeLog b/gcc/ChangeLog
+index 9a949980699..49dcecb6777 100644
+--- a/gcc/ChangeLog
++++ b/gcc/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64-builtins.c b/gcc/config/aarch64/aarch64-builtins.c
+index f0e0461b7f0..f50c4857e1c 100644
+--- a/gcc/config/aarch64/aarch64-builtins.c
++++ b/gcc/config/aarch64/aarch64-builtins.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64-simd-builtins.def b/gcc/config/aarch64/aarch64-simd-builtins.def
+index 57fc5933b43..4744dd1f6b2 100644
+--- a/gcc/config/aarch64/aarch64-simd-builtins.def
++++ b/gcc/config/aarch64/aarch64-simd-builtins.def
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
+index 2989096b170..9e56e8caf35 100644
+--- a/gcc/config/aarch64/aarch64-simd.md
++++ b/gcc/config/aarch64/aarch64-simd.md
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/arm_neon.h b/gcc/config/aarch64/arm_neon.h
+index eaba156e26c..c96214003dd 100644
+--- a/gcc/config/aarch64/arm_neon.h
++++ b/gcc/config/aarch64/arm_neon.h
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
+index b9843b83c5f..83720d9802a 100644
+--- a/gcc/config/aarch64/iterators.md
++++ b/gcc/config/aarch64/iterators.md
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
+index 0d8aa6063a7..8b01aa06a40 100644
+--- a/gcc/testsuite/ChangeLog
++++ b/gcc/testsuite/ChangeLog
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
+new file mode 100755
+index 00000000000..ac4f821e771
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
+new file mode 100755
+index 00000000000..96bca2356e4
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
+new file mode 100755
+index 00000000000..18ecabef8dc
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
+new file mode 100755
+index 00000000000..66c87d48694
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
+@@ -0,0 +1 @@
++
+-- 
+2.26.1
+
+=== 0001-c-Alias.patch ===
+From 3f1a149fc35cdba988464562e2fb824b10652d6b Mon Sep 17 00:00:00 2001
+From: Nathan Sidwell <nathan@acm.org>
+Date: Tue, 19 May 2020 13:29:19 -0700
+Subject: [PATCH] c++: Alias template instantiation template info
+
+I discovered that the alias instantiation machinery would setup
+template_info, and then sometime later overwrite that with equivalent
+info.  This broke modules, because the template info, once set, is
+logically immutable.  Let's just not do that.
+
+	* pt.c (lookup_template_class_1): Do not reinit template_info of an
+	alias here.
+
+(cherry picked from commit 74744bb1f2847b5b9ce3e97e0fec9c23bb0e499f)
+---
+ gcc/cp/pt.c | 17 +++++++++++++++--
+ 1 file changed, 15 insertions(+), 2 deletions(-)
+
+diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
+index b8f03d18541..7230ac724ba 100644
+--- a/gcc/cp/pt.c
++++ b/gcc/cp/pt.c
+@@ -1 +1,2 @@
+
++
+-- 
+2.26.2
+=== 0001-RISC-V-Make-unique.patch ===
+From adce62f53d8ad00e8110a6a2de7962d7a850de16 Mon Sep 17 00:00:00 2001
+From: Keith Packard <keithp@keithp.com>
+Date: Wed, 29 Apr 2020 09:49:56 -0700
+Subject: [PATCH] RISC-V: Make unique SECCAT_SRODATA names start with .srodata
+ (not .sdata2)
+
+default_unique_section uses ".sdata2" as a prefix for SECCAT_SRODATA
+unique sections, but RISC-V uses ".srodata" instead. Override the
+TARGET_ASM_UNIQUE_SECTION function to catch this case, allowing the
+default to be used for all other sections.
+
+gcc/
+	* config/riscv/riscv.c (riscv_unique_section): New.
+	(TARGET_ASM_UNIQUE_SECTION): New.
+
+Signed-off-by: Keith Packard <keithp@keithp.com>
+Reviewed-by: Keith Packard <keithp@keithp.com>
+Reviewed-on: Keith Packard <keithp@keithp.com>
+Co-Authored-by: Keith Packard <keithp@keithp.com>
+Acked-By: Keith Packard <keithp@keithp.com>
+Tested-by: Keith Packard <keithp@keithp.com>
+Reported-by: Keith Packard <keithp@keithp.com>
+Suggested-by: Keith Packard <keithp@keithp.com>
+---
+ gcc/ChangeLog            |  5 +++++
+ gcc/config/riscv/riscv.c | 40 ++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 45 insertions(+)
+
+diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
+index e4c08d780db..1ad9799fce4 100644
+--- a/gcc/config/riscv/riscv.c
++++ b/gcc/config/riscv/riscv.c
+@@ -1 +1,2 @@
+
++
+
+-- 
+2.26.2
+
+=== 0001-Fortran-ProcPtr-function.patch ===
+From eb069ae8819c3a84d7f78becc5501e21ee3a9554 Mon Sep 17 00:00:00 2001
+From: Mark Eggleston <markeggleston@gcc.gnu.org>
+Date: Thu, 7 May 2020 08:02:02 +0100
+Subject: [PATCH] Fortran  : ProcPtr function results: 'ppr@' in error message
+ PR39695
+
+The value 'ppr@' is set in the name of result symbol, the actual
+name of the symbol is in the procedure name symbol pointed
+to by the result symbol's namespace (ns). When reporting errors for
+symbols that have the proc_pointer attribute check whether the
+result attribute is set and set the name accordingly.
+
+2020-05-20  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+gcc/fortran/
+
+	PR fortran/39695
+	* resolve.c (resolve_fl_procedure): Set name depending on
+	whether the result attribute is set.  For PROCEDURE/RESULT
+	conflict use the name in sym->ns->proc_name->name.
+	* symbol.c (gfc_add_type): Add check for function and result
+	attributes use sym->ns->proc_name->name if both are set.
+	Where the symbol cannot have a type use the name in
+	sym->ns->proc_name->name.
+
+2020-05-20  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+gcc/testsuite/
+
+	PR fortran/39695
+	* gfortran.dg/pr39695_1.f90: New test.
+	* gfortran.dg/pr39695_2.f90: New test.
+	* gfortran.dg/pr39695_3.f90: New test.
+	* gfortran.dg/pr39695_4.f90: New test.
+---
+ gcc/fortran/ChangeLog                   | 11 +++++++++++
+ gcc/fortran/resolve.c                   |  6 ++++--
+ gcc/fortran/symbol.c                    |  7 +++++--
+ gcc/testsuite/ChangeLog                 |  8 ++++++++
+ gcc/testsuite/gfortran.dg/pr39695_1.f90 |  8 ++++++++
+ gcc/testsuite/gfortran.dg/pr39695_2.f90 | 12 ++++++++++++
+ gcc/testsuite/gfortran.dg/pr39695_3.f90 | 11 +++++++++++
+ gcc/testsuite/gfortran.dg/pr39695_4.f90 | 14 ++++++++++++++
+ 8 files changed, 73 insertions(+), 4 deletions(-)
+ create mode 100644 gcc/testsuite/gfortran.dg/pr39695_1.f90
+ create mode 100644 gcc/testsuite/gfortran.dg/pr39695_2.f90
+ create mode 100644 gcc/testsuite/gfortran.dg/pr39695_3.f90
+ create mode 100644 gcc/testsuite/gfortran.dg/pr39695_4.f90
+
+diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
+index f6e10ea379c..aaee5eb6b9b 100644
+--- a/gcc/fortran/resolve.c
++++ b/gcc/fortran/resolve.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
+index 59f602d80d5..b96706138c9 100644
+--- a/gcc/fortran/symbol.c
++++ b/gcc/fortran/symbol.c
+@@ -1 +1,2 @@
+
++
+diff --git a/gcc/testsuite/gfortran.dg/pr39695_1.f90 b/gcc/testsuite/gfortran.dg/pr39695_1.f90
+new file mode 100644
+index 00000000000..4c4b3045f69
+--- /dev/null
++++ b/gcc/testsuite/gfortran.dg/pr39695_1.f90
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gfortran.dg/pr39695_2.f90 b/gcc/testsuite/gfortran.dg/pr39695_2.f90
+new file mode 100644
+index 00000000000..8534724959a
+--- /dev/null
++++ b/gcc/testsuite/gfortran.dg/pr39695_2.f90
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gfortran.dg/pr39695_3.f90 b/gcc/testsuite/gfortran.dg/pr39695_3.f90
+new file mode 100644
+index 00000000000..661e2540bb3
+--- /dev/null
++++ b/gcc/testsuite/gfortran.dg/pr39695_3.f90
+@@ -0,0 +1 @@
++
+diff --git a/gcc/testsuite/gfortran.dg/pr39695_4.f90 b/gcc/testsuite/gfortran.dg/pr39695_4.f90
+new file mode 100644
+index 00000000000..ecb0a43929f
+--- /dev/null
++++ b/gcc/testsuite/gfortran.dg/pr39695_4.f90
+@@ -0,0 +1 @@
++
+-- 
+2.26.2
+
+=== 0001-c-C-20-DR-2237.patch ===
+From 4b38d56dbac6742b038551a36ec80200313123a1 Mon Sep 17 00:00:00 2001
+From: Marek Polacek <polacek@redhat.com>
+Date: Sat, 4 Apr 2020 18:09:53 -0400
+Subject: [PATCH] c++: C++20 DR 2237, disallow simple-template-id in cdtor.
+
+This patch implements DR 2237 which says that a simple-template-id is
+no longer valid as the declarator-id of a constructor or destructor;
+see [diff.cpp17.class]#2.  It is not explicitly stated but out-of-line
+destructors with a simple-template-id are also meant to be ill-formed
+now.  (Out-of-line constructors like that are invalid since DR1435 I
+think.)  This change only applies to C++20; it is not a DR against C++17.
+
+I'm not crazy about the diagnostic in constructors but ISTM that
+cp_parser_constructor_declarator_p shouldn't print errors.
+
+	DR 2237
+	* parser.c (cp_parser_unqualified_id): Reject simple-template-id as
+	the declarator-id of a destructor.
+---
+diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
+index a6a5d975af3..a8082d39aca 100644
+--- a/gcc/cp/parser.c
++++ b/gcc/cp/parser.c
+@@ -1 +1,2 @@
+
++
+
+=== 0001-go-in-ignored-location.patch ===
+From 81994eab700da7fea6644541c163aa0f0f3b8cf1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Cl=C3=A9ment=20Chigot?= <chigot.c@gmail.com>
+Date: Tue, 19 May 2020 16:03:54 +0200
+Subject: libgo: update x/sys/cpu after gccgo support added
+
+Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/234597
+---
+ gcc/go/gofrontend/MERGE                       |  2 +-
+ .../sys/cpu/{cpu_aix_ppc64.go => cpu_aix.go}  |  2 +-
+ .../golang.org/x/sys/cpu/syscall_aix_gccgo.go | 27 +++++++++++++++++++
+ 3 files changed, 29 insertions(+), 2 deletions(-)
+ rename libgo/go/golang.org/x/sys/cpu/{cpu_aix_ppc64.go => cpu_aix.go} (96%)
+ create mode 100644 libgo/go/golang.org/x/sys/cpu/syscall_aix_gccgo.go
+
+diff --git a/gcc/go/gofrontend/MERGE b/gcc/go/gofrontend/MERGE
+index bc9c1f07eda..284374820b0 100644
+--- a/gcc/go/gofrontend/MERGE
++++ b/gcc/go/gofrontend/MERGE
+@@ -1 +1,2 @@
+
++
+diff --git a/libgo/go/golang.org/x/sys/cpu/cpu_aix_ppc64.go b/libgo/go/golang.org/x/sys/cpu/cpu_aix.go
+similarity index 96%
+rename from libgo/go/golang.org/x/sys/cpu/cpu_aix_ppc64.go
+rename to libgo/go/golang.org/x/sys/cpu/cpu_aix.go
+index b0ede112d4e..02d03129e50 100644
+--- a/libgo/go/golang.org/x/sys/cpu/cpu_aix_ppc64.go
++++ b/libgo/go/golang.org/x/sys/cpu/cpu_aix.go
+@@ -1 +1,2 @@
+
++
+diff --git a/libgo/go/golang.org/x/sys/cpu/syscall_aix_gccgo.go b/libgo/go/golang.org/x/sys/cpu/syscall_aix_gccgo.go
+new file mode 100644
+index 00000000000..2609cc49ae7
+--- /dev/null
++++ b/libgo/go/golang.org/x/sys/cpu/syscall_aix_gccgo.go
+@@ -0,0 +1 @@
++
+
+-- 
+2.27.0.rc0.183.gde8f92d652-goog
+=== 0001-Update-merge.sh-to-reflect.patch  ===
+From b3d566f570f4416299240b51654b70c74f6cba6a Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 25 May 2020 20:55:29 +0200
+Subject: [PATCH] Update merge.sh to reflect usage of git.
+
+After switching to GIT, we should use it in libsanitizer
+merge script. I'll do merge from master as soon as
+PR95311 gets fixed.
+
+I'm going to install the patch.
+
+libsanitizer/ChangeLog:
+
+	* LOCAL_PATCHES: Use git hash instead of SVN id.
+	* merge.sh: Use git instead of VCS.  Update paths
+	relative to upstream git repository.
+---
+ libsanitizer/LOCAL_PATCHES |  2 +-
+ libsanitizer/merge.sh      | 10 ++++------
+ 2 files changed, 5 insertions(+), 7 deletions(-)
+
+diff --git a/libsanitizer/LOCAL_PATCHES b/libsanitizer/LOCAL_PATCHES
+index 292b7a6e489..7732de3d436 100644
+--- a/libsanitizer/LOCAL_PATCHES
++++ b/libsanitizer/LOCAL_PATCHES
+@@ -1 +1,2 @@
+
++
+diff --git a/libsanitizer/merge.sh b/libsanitizer/merge.sh
+index dfa7bf3d196..3f4f1629a22 100755
+--- a/libsanitizer/merge.sh
++++ b/libsanitizer/merge.sh
+@@ -1 +1,2 @@
+
++
+ 
+-- 
+2.26.2
+=== 0001-Ada-Reuse-Is_Package_Or_Generic_Package-where-possib.patch ===
+From 557b268fffffdeb0980a17411f458eee333f55c6 Mon Sep 17 00:00:00 2001
+From: Piotr Trojanek <trojanek@adacore.com>
+Date: Thu, 12 Dec 2019 11:45:24 +0100
+Subject: [PATCH] [Ada] Reuse Is_Package_Or_Generic_Package where possible
+
+2020-05-26  Piotr Trojanek  <trojanek@adacore.com>
+
+gcc/ada/
+
+	* contracts.adb, einfo.adb, exp_ch9.adb, sem_ch12.adb,
+	sem_ch4.adb, sem_ch7.adb, sem_ch8.adb, sem_elab.adb,
+	sem_type.adb, sem_util.adb: Reuse Is_Package_Or_Generic_Package
+	where possible (similarly, reuse Is_Concurrent_Type if it was
+	possible in the same expressions).
+---
+ gcc/ada/contracts.adb |  2 +-
+ gcc/ada/einfo.adb     | 22 +++++++++++-----------
+ gcc/ada/exp_ch9.adb   |  2 +-
+ gcc/ada/sem_ch12.adb  |  2 +-
+ gcc/ada/sem_ch4.adb   |  2 +-
+ gcc/ada/sem_ch7.adb   |  6 +++---
+ gcc/ada/sem_ch8.adb   |  6 +++---
+ gcc/ada/sem_elab.adb  |  2 +-
+ gcc/ada/sem_type.adb  |  2 +-
+ gcc/ada/sem_util.adb  |  6 +++---
+ 10 files changed, 26 insertions(+), 26 deletions(-)
+
+diff --git a/gcc/ada/contracts.adb b/gcc/ada/contracts.adb
+index 981bb91..d58f136 100644
+--- a/gcc/ada/contracts.adb
++++ b/gcc/ada/contracts.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/einfo.adb b/gcc/ada/einfo.adb
+index 98b508f..1df8ed0 100644
+--- a/gcc/ada/einfo.adb
++++ b/gcc/ada/einfo.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/exp_ch9.adb b/gcc/ada/exp_ch9.adb
+index 64ac353..392a221 100644
+--- a/gcc/ada/exp_ch9.adb
++++ b/gcc/ada/exp_ch9.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_ch12.adb b/gcc/ada/sem_ch12.adb
+index dc3a3c2..209e060 100644
+--- a/gcc/ada/sem_ch12.adb
++++ b/gcc/ada/sem_ch12.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_ch4.adb b/gcc/ada/sem_ch4.adb
+index 5910112..702f265 100644
+--- a/gcc/ada/sem_ch4.adb
++++ b/gcc/ada/sem_ch4.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_ch7.adb b/gcc/ada/sem_ch7.adb
+index 6d9a1db..f217dfd 100644
+--- a/gcc/ada/sem_ch7.adb
++++ b/gcc/ada/sem_ch7.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_ch8.adb b/gcc/ada/sem_ch8.adb
+index f083f7c..7f50b40 100644
+--- a/gcc/ada/sem_ch8.adb
++++ b/gcc/ada/sem_ch8.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_elab.adb b/gcc/ada/sem_elab.adb
+index f3cac46..dbf3fac 100644
+--- a/gcc/ada/sem_elab.adb
++++ b/gcc/ada/sem_elab.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_type.adb b/gcc/ada/sem_type.adb
+index e5d01dd..1868568 100644
+--- a/gcc/ada/sem_type.adb
++++ b/gcc/ada/sem_type.adb
+@@ -0,0 +1 @@
++
+diff --git a/gcc/ada/sem_util.adb b/gcc/ada/sem_util.adb
+index b980b4c..c1b1d9e 100644
+--- a/gcc/ada/sem_util.adb
++++ b/gcc/ada/sem_util.adb
+@@ -0,0 +1 @@
++
+-- 
+2.1.4
+
+=== 0001-Ada-Add-support-for-XDR-streaming-in-the-default-run.patch ===
+From ed248d9bc3b72b6888a1b9cd84a8ef26809249f0 Mon Sep 17 00:00:00 2001
+From: Arnaud Charlet <charlet@adacore.com>
+Date: Thu, 23 Apr 2020 05:46:29 -0400
+Subject: [PATCH] [Ada] Add support for XDR streaming in the default runtime
+
+--!# FROM: /homes/derodat/tron/gnat2fsf/gnat
+--!# COMMIT: 5ad4cabb9f70114eb61c025e91406d4fba253f95
+--!# Change-Id: I21f92cad27933747495cdfa544a048f62f944cbd
+--!# TN: T423-014
+
+Currently we provide a separate implementation of Stream_Attributes via
+s-stratt__xdr.adb which needs to be recompiled manually.
+
+This change introduces instead a new binder switch to choose at bind
+time which stream implementation to use and replaces s-stratt__xdr.adb
+by a new unit System.Stream_Attributes.XDR.
+
+2020-05-04  Arnaud Charlet  <charlet@adacore.com>
+
+gcc/ada/
+
+	* Makefile.rtl: Add s-statxd.o.
+	* bindgen.adb (Gen_Adainit): Add support for XDR_Stream.
+	* bindusg.adb (Display): Add mention of -xdr.
+	* gnatbind.adb: Process -xdr switch.
+	* init.c (__gl_xdr_stream): New.
+	* opt.ads (XDR_Stream): New.
+	* libgnat/s-stratt__xdr.adb: Rename to...
+	* libgnat/s-statxd.adb: this and adjust.
+	* libgnat/s-statxd.ads: New.
+	* libgnat/s-stratt.ads, libgnat/s-stratt.adb: Choose between
+	default and XDR implementation at runtime.
+	* libgnat/s-ststop.ads: Update comments.
+	* doc/gnat_rm/implementation_advice.rst: Update doc on XDR
+	streaming.
+	* gnat_rm.texi: Regenerate.
+---
+ gcc/ada/Makefile.rtl                          |   1 +
+ gcc/ada/bindgen.adb                           |  29 +-
+ gcc/ada/bindusg.adb                           |   5 +
+ gcc/ada/doc/gnat_rm/implementation_advice.rst |  35 +--
+ gcc/ada/gnat_rm.texi                          |  36 +--
+ gcc/ada/gnatbind.adb                          |   5 +
+ gcc/ada/init.c                                |   1 +
+ .../{s-stratt__xdr.adb => s-statxd.adb}       |  63 ++--
+ gcc/ada/libgnat/s-statxd.ads                  | 117 +++++++
+ gcc/ada/libgnat/s-stratt.adb                  | 286 +++++++++++++++---
+ gcc/ada/libgnat/s-stratt.ads                  |   7 +-
+ gcc/ada/libgnat/s-ststop.ads                  |   4 +-
+ gcc/ada/opt.ads                               |   6 +-
+ 13 files changed, 428 insertions(+), 167 deletions(-)
+ rename gcc/ada/libgnat/{s-stratt__xdr.adb => s-statxd.adb} (96%)
+ create mode 100644 gcc/ada/libgnat/s-statxd.ads
+
+diff --git a/gcc/ada/Makefile.rtl b/gcc/ada/Makefile.rtl
+index b340a9ef919..15e4f68ccdb 100644
+--- a/gcc/ada/Makefile.rtl
++++ b/gcc/ada/Makefile.rtl
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/bindgen.adb b/gcc/ada/bindgen.adb
+index 99ad3009d13..91b4cb38486 100644
+--- a/gcc/ada/bindgen.adb
++++ b/gcc/ada/bindgen.adb
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/bindusg.adb b/gcc/ada/bindusg.adb
+index 45215d2ebea..6fd55ee8721 100644
+--- a/gcc/ada/bindusg.adb
++++ b/gcc/ada/bindusg.adb
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/doc/gnat_rm/implementation_advice.rst b/gcc/ada/doc/gnat_rm/implementation_advice.rst
+index 31376d92461..998d0c597df 100644
+--- a/gcc/ada/doc/gnat_rm/implementation_advice.rst
++++ b/gcc/ada/doc/gnat_rm/implementation_advice.rst
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/gnat_rm.texi b/gcc/ada/gnat_rm.texi
+index c174073d508..d72f905a2df 100644
+--- a/gcc/ada/gnat_rm.texi
++++ b/gcc/ada/gnat_rm.texi
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/gnatbind.adb b/gcc/ada/gnatbind.adb
+index 4907082a42c..4372152b439 100644
+--- a/gcc/ada/gnatbind.adb
++++ b/gcc/ada/gnatbind.adb
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/init.c b/gcc/ada/init.c
+index f9f627ebcff..e76aa79c5a8 100644
+--- a/gcc/ada/init.c
++++ b/gcc/ada/init.c
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/libgnat/s-stratt__xdr.adb b/gcc/ada/libgnat/s-statxd.adb
+similarity index 96%
+rename from gcc/ada/libgnat/s-stratt__xdr.adb
+rename to gcc/ada/libgnat/s-statxd.adb
+index 7e32fcf9b91..fcefae7e6f2 100644
+--- a/gcc/ada/libgnat/s-stratt__xdr.adb
++++ b/gcc/ada/libgnat/s-statxd.adb
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/libgnat/s-statxd.ads b/gcc/ada/libgnat/s-statxd.ads
+new file mode 100644
+index 00000000000..cca5e5471bd
+--- /dev/null
++++ b/gcc/ada/libgnat/s-statxd.ads
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/libgnat/s-stratt.adb b/gcc/ada/libgnat/s-stratt.adb
+index 64f3f040081..366dabdc7b6 100644
+--- a/gcc/ada/libgnat/s-stratt.adb
++++ b/gcc/ada/libgnat/s-stratt.adb
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/libgnat/s-stratt.ads b/gcc/ada/libgnat/s-stratt.ads
+index 73369490146..c8c453aad2a 100644
+--- a/gcc/ada/libgnat/s-stratt.ads
++++ b/gcc/ada/libgnat/s-stratt.ads
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/libgnat/s-ststop.ads b/gcc/ada/libgnat/s-ststop.ads
+index d0da0609d9d..321460b89d8 100644
+--- a/gcc/ada/libgnat/s-ststop.ads
++++ b/gcc/ada/libgnat/s-ststop.ads
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/ada/opt.ads b/gcc/ada/opt.ads
+index 9e0263b431d..37f3d030e3f 100644
+--- a/gcc/ada/opt.ads
++++ b/gcc/ada/opt.ads
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.20.1
+=== 0001-Fortran-type-is-real-kind-1.patch ===
+From 3ea6977d0f1813d982743a09660eec1760e981ec Mon Sep 17 00:00:00 2001
+From: Mark Eggleston <markeggleston@gcc.gnu.org>
+Date: Wed, 1 Apr 2020 09:52:41 +0100
+Subject: [PATCH] Fortran  : "type is( real(kind(1.)) )" spurious syntax error
+ PR94397
+
+Based on a patch in the comments of the PR. That patch fixed this
+problem but caused the test cases for PR93484 to fail. It has been
+changed to reduce initialisation expressions if the expression is
+not EXPR_VARIABLE and not EXPR_CONSTANT.
+
+2020-05-28  Steven G. Kargl  <kargl@gcc.gnu.org>
+	    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+gcc/fortran/
+
+	PR fortran/94397
+	* match.c (gfc_match_type_spec): New variable ok initialised
+	to true. Set ok with the return value of gfc_reduce_init_expr
+	called only if the expression is not EXPR_CONSTANT and is not
+	EXPR_VARIABLE. Add !ok to the check for type not being integer
+	or the rank being greater than zero.
+
+2020-05-28  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+gcc/testsuite/
+
+	PR fortran/94397
+	* gfortran.dg/pr94397.F90: New test.
+---
+ gcc/fortran/match.c                   |  5 ++++-
+ gcc/testsuite/gfortran.dg/pr94397.F90 | 26 ++++++++++++++++++++++++++
+ 2 files changed, 30 insertions(+), 1 deletion(-)
+ create mode 100644 gcc/testsuite/gfortran.dg/pr94397.F90
+
+diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
+index 8ae34a94a95..82d2b5087e5 100644
+--- a/gcc/fortran/match.c
++++ b/gcc/fortran/match.c
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/testsuite/gfortran.dg/pr94397.F90 b/gcc/testsuite/gfortran.dg/pr94397.F90
+new file mode 100644
+index 00000000000..fda10c1a88b
+--- /dev/null
++++ b/gcc/testsuite/gfortran.dg/pr94397.F90
+@@ -0,0 +1 @@
++
+-- 
+2.26.2
+
+=== 0001-Missing-change-description.patch ===
+From 8ec655bd94615ba45adabae9b50df299edb74eda Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Fri, 29 May 2020 13:42:57 +0200
+Subject: [PATCH] Test me.
+
+gcc/ChangeLog:
+
+	* ipa-icf-gimple.c (compare_gimple_asm):
+	* ipa-icf-gimple2.c (compare_gimple_asm): Good.
+	* ipa-icf-gimple3.c (compare_gimple_asm):
+---
+ contrib/gcc-changelog/git_commit.py | 10 ++++++++++
+ gcc/ipa-icf-gimple.c                |  1 +
+ 2 files changed, 11 insertions(+)
+
+diff --git a/gcc/ipa-icf-gimple.c b/gcc/ipa-icf-gimple.c
+index 1cd5872c03d..6f95aedb3d3 100644
+--- a/gcc/ipa-icf-gimple.c
++++ b/gcc/ipa-icf-gimple.c
+@@ -850,3 +850,4 @@
+ }
+ 
+ } // ipa_icf_gimple namespace
++
+-- 
+2.26.2
+
+=== 0001-Fix-text-of-hyperlink-in-manual.patch ===
+From c7904d9e08a0ca3f733be3c2e8a3b912fa851fc5 Mon Sep 17 00:00:00 2001
+From: Jonathan Wakely <jwakely@redhat.com>
+Date: Fri, 8 Mar 2019 13:56:53 +0000
+Subject: [PATCH] Fix text of hyperlink in manual
+
+	* doc/xml/manual/using.xml: Use link element instead of xref.
+	* doc/html/*: Regenerate.
+
+---
+ libstdc++-v3/ChangeLog                         | 3 +++
+ libstdc++-v3/doc/html/manual/using_macros.html | 3 ++-
+ libstdc++-v3/doc/xml/manual/using.xml          | 4 ++--
+ 3 files changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/libstdc++-v3/doc/html/manual/using_macros.html b/libstdc++-v3/doc/html/manual/using_macros.html
+index 7030bd2d0fd..dad6564a97d 100644
+--- a/libstdc++-v3/doc/html/manual/using_macros.html
++++ b/libstdc++-v3/doc/html/manual/using_macros.html
+@@ -1 +1,2 @@
+ 
++
+diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
+index 2d44a739406..7647e9b8dad 100644
+--- a/libstdc++-v3/doc/xml/manual/using.xml
++++ b/libstdc++-v3/doc/xml/manual/using.xml
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.25.4
+
+=== 0002-libstdc-Fake-test-change-1.patch ===
+From fe4ade6778d1d97214db12bf2c40d0f40e7f953a Mon Sep 17 00:00:00 2001
+From: Jonathan Wakely <jwakely@redhat.com>
+Date: Tue, 2 Jun 2020 11:52:34 +0100
+Subject: [PATCH] libstdc++: Fake change for testing git_commit.py
+
+libstdc++-v3/ChangeLog:
+
+	* doc/xml/faq.xml: Fake change.
+	* doc/html/*: Regenerated.
+---
+ libstdc++-v3/doc/xml/faq.xml | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
+index e419d3c22a0..bcc14dd6d90 100644
+--- a/libstdc++-v3/doc/xml/faq.xml
++++ b/libstdc++-v3/doc/xml/faq.xml
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.25.4
+
+=== 0003-libstdc-Fake-test-change-2.patch ===
+From e460effb3a42c1c046b682fe266da418f2693ef3 Mon Sep 17 00:00:00 2001
+From: Jonathan Wakely <jwakely@redhat.com>
+Date: Tue, 2 Jun 2020 11:52:34 +0100
+Subject: [PATCH] libstdc++: Fake change for testing 2
+
+libstdc++-v3/ChangeLog:
+
+	* doc/xml/faq.xml: Fake change.
+---
+ libstdc++-v3/doc/html/faq.html | 2 +-
+ libstdc++-v3/doc/xml/faq.xml   | 1 +
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
+index 967e5f5f348..95d21b5bf9f 100644
+--- a/libstdc++-v3/doc/html/faq.html
++++ b/libstdc++-v3/doc/html/faq.html
+@@ -1 +1,2 @@
+ 
++
+--- a/libstdc++-v3/doc/xml/faq.xml
++++ b/libstdc++-v3/doc/xml/faq.xml
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.25.4
+=== 0001-configure.patch ===
+From dbe341cf6a77bb28c5fdf8b32dcb0ff1c2a27348 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Tue, 9 Jun 2020 09:39:36 +0200
+Subject: [PATCH] c++: Fix --disable-bootstrap with older g++.
+
+Previously I had AX_CXX_COMPILE_STDCXX in the gcc directory configure, which
+added -std=c++11 to CXX if needed, but then CXX is overridden from the
+toplevel directory, so it didn't have the desired effect.  Fixed by moving
+the check to the toplevel.  Currently it is only used when building GCC
+without bootstrapping; other packages that share the toplevel directory
+can adjust the condition if they also want to require C++11 support.
+
+ChangeLog:
+
+	* configure.ac: Check AX_CXX_COMPILE_STDCXX if not bootstrapping.
+	* configure: Regenerate.
+
+gcc/ChangeLog:
+
+	* aclocal.m4: Remove ax_cxx_compile_stdcxx.m4.
+	* configure.ac: Remove AX_CXX_COMPILE_STDCXX.
+	* configure: Regenerate.
+
+---
+ configure        | 999 ++++++++++++++++++++++++++++++++++++++++++++++-
+ configure.ac     |   6 +-
+ gcc/aclocal.m4   |   1 -
+ gcc/configure    | 997 +---------------------------------------------
+ gcc/configure.ac |   2 -
+ 5 files changed, 1004 insertions(+), 1001 deletions(-)
+
+diff --git a/configure b/configure
+index b7897446c70..a0c5aca9e8d 100755
+--- a/configure
++++ b/configure
+@@ -1 +1,2 @@
+ 
++
+diff --git a/configure.ac b/configure.ac
+index 59bd92a3e53..1a53ed418e4 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/aclocal.m4 b/gcc/aclocal.m4
+index e93c1535063..1737d59d1cb 100644
+--- a/gcc/aclocal.m4
++++ b/gcc/aclocal.m4
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/configure b/gcc/configure
+index 46850710424..629c7c7e153 100755
+--- a/gcc/configure
++++ b/gcc/configure
+@@ -1 +1,2 @@
+ 
++
+diff --git a/gcc/configure.ac b/gcc/configure.ac
+index 60d83c30771..9e7efd13ecc 100644
+--- a/gcc/configure.ac
++++ b/gcc/configure.ac
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.26.2
+
+=== 0001-asan-fix-RTX-emission.patch ===
+From e1d68582022cfa2b1dc76646724b397ba2739439 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Thu, 11 Jun 2020 09:34:41 +0200
+Subject: [PATCH] asan: fix RTX emission for ilp32
+
+gcc/ChangeLog:
+
+	PR sanitizer/95634
+	* asan.c (asan_emit_stack_protection): Fix emission for ilp32
+	by using Pmode instead of ptr_mode.
+
+Co-Authored-By: Jakub Jelinek <jakub@redhat.com>
+(cherry picked from commit 8cff672cb9a132d3d3158c2edfc9a64b55292b80 (only part))
+---
+ gcc/asan.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/asan.c b/gcc/asan.c
+index 823eb539993..4ec22162c12 100644
+--- a/gcc/asan.c
++++ b/gcc/asan.c
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.27.0
+
+=== double-cherry-pick.patch ===
+From e1d68582022cfa2b1dc76646724b397ba2739439 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Thu, 11 Jun 2020 09:34:41 +0200
+Subject: [PATCH] asan: fix RTX emission for ilp32
+
+gcc/ChangeLog:
+
+	PR sanitizer/95634
+	* asan.c (asan_emit_stack_protection): Fix emission for ilp32
+	by using Pmode instead of ptr_mode.
+
+Co-Authored-By: Jakub Jelinek <jakub@redhat.com>
+(cherry picked from commit 8cff672cb9a132d3d3158c2edfc9a64b55292b80)
+(cherry picked from commit 8cff672cb9a132d3d3158c2edfc9a64b55292b80)
+---
+ gcc/asan.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/gcc/asan.c b/gcc/asan.c
+index 823eb539993..4ec22162c12 100644
+--- a/gcc/asan.c
++++ b/gcc/asan.c
+@@ -1 +1,2 @@
+ 
++
+-- 
+2.27.0
+
+=== 0001-Check-for-more-missing-math-decls-on-vxworks.patch ===
+From 0edfc1fd22405ee8e946101e44cd8edc0ee12047 Mon Sep 17 00:00:00 2001
+From: Douglas B Rupp <douglas.b.rupp@gmail.com>
+Date: Sun, 31 May 2020 13:25:28 -0700
+Subject: [PATCH] Check for more missing math decls on vxworks.
+
+Use the GLIBCXX_CHECK_MATH_DECL macro to check for the full list of
+vxworks math decls.
+
+for libstdc++-v3/ChangeLog:
+
+	* crossconfig.m4 <*-vxworks>: Check for more math decls.
+	* configure [FAKEPATCH]: Rebuild.
+---
+ libstdc++-v3/configure      | 255 ++++++++++++++++++++++++++++++++++++++++++++
+ libstdc++-v3/crossconfig.m4 |   3 +-
+ 2 files changed, 257 insertions(+), 1 deletion(-)
+
+diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
+index b5beb45..4ef678e 100755
+--- a/libstdc++-v3/configure
++++ b/libstdc++-v3/configure
+@@ -1 +1,2 @@
+ 
++
+diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
+index fe18288..313f84d 100644
+--- a/libstdc++-v3/crossconfig.m4
++++ b/libstdc++-v3/crossconfig.m4
+@@ -1 +1,2 @@
+ 
++
+-- 
+=== 0001-tree-optimization-97633-fix-SLP-scheduling-of-single.patch ===
+From c0bfd9672e19caf08e45afeb4277f848488ced2b Mon Sep 17 00:00:00 2001
+From: Richard Biener <rguenther@suse.de>
+Date: Fri, 30 Oct 2020 09:57:02 +0100
+Subject: [PATCH] tree-optimization/97633 - fix SLP scheduling of single-node
+ cycles
+
+This makes sure to update backedges in single-node cycles.
+
+2020-10-30  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97633
+	* tree-vect-slp.c (): Update backedges in single-node cycles.
+	Optimize processing of externals.
+
+	* g++.dg/vect/slp-pr97636.cc: New testcase.
+	* gcc.dg/vect/bb-slp-pr97633.c: Likewise.
+---
+ gcc/testsuite/g++.dg/vect/slp-pr97636.cc   |  83 +++++++++++
+ gcc/testsuite/gcc.dg/vect/bb-slp-pr97633.c |  27 ++++
+ gcc/tree-vect-slp.c                        | 162 +++++++++++----------
+ 3 files changed, 198 insertions(+), 74 deletions(-)
+ create mode 100644 gcc/testsuite/g++.dg/vect/slp-pr97636.cc
+ create mode 100644 gcc/testsuite/gcc.dg/vect/bb-slp-pr97633.c
+
+diff --git a/gcc/testsuite/g++.dg/vect/slp-pr97636.cc b/gcc/testsuite/g++.dg/vect/slp-pr97636.cc
+new file mode 100644
+index 00000000000..012342004f1
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/vect/slp-pr97636.cc
+@@ -0,0 +1 @@
++
+diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
+index 5d69a98c2a9..714e50697bd 100644
+--- a/gcc/tree-vect-slp.c
++++ b/gcc/tree-vect-slp.c
+@@ -1 +1,2 @@
+ 
++
+-- 
+
+2.7.4
+=== 0001-c-Set-CALL_FROM_NEW_OR_DELETE_P-on-more-calls.patch ===
+From 4f4ced28826ece7b7b76649522ee2a9601a63b90 Mon Sep 17 00:00:00 2001
+From: Jason Merrill <jason@redhat.com>
+Date: Fri, 2 Oct 2020 09:00:49 +0200
+Subject: [PATCH] c++: Set CALL_FROM_NEW_OR_DELETE_P on more calls.
+
+We were failing to set the flag on a delete call in a new expression, in a
+deleting destructor, and in a coroutine.  Fixed by setting it in the
+function that builds the call.
+
+2020-10-02  Jason Merril  <jason@redhat.com>
+
+gcc/cp/ChangeLog:
+	* init.c (build_new_1, build_vec_delete_1, build_delete): Not here.
+	(build_delete):
+
+---
+ gcc/cp/init.c                  |  1 -
+ 1 files changed, 0 insertions(+), 1 deletions(-)
+
+diff --git a/gcc/cp/init.c b/gcc/cp/init.c
+index e84e985492d..00fff3f7327 100644
+--- a/gcc/cp/init.c
++++ b/gcc/cp/init.c
+@@ -3436,1 +3435,0 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
+-
+-- 
+2.25.1
+
+=== 0001-lto-fix-LTO-debug-sections-copying.patch ===
+From 190c04ba36d9c6c3dce41f12012aa97c6d7f22f5 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 5 Oct 2020 18:03:08 +0200
+Subject: [PATCH] lto: fix LTO debug sections copying.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+libiberty/ChangeLog:
+
+	PR lto/97290
+	* simple-object-elf.c (simple_object_elf_copy_lto_debug_sections):
+	Use sh_link of a .symtab_shndx section.
+---
+ libiberty/simple-object-elf.c | 1 -
+ 1 file changed, 0 insertions(+), 1 deletions(-)
+
+diff --git a/libiberty/simple-object-elf.c b/libiberty/simple-object-elf.c
+index 7c9d492f6a4..37e73348cb7 100644
+--- a/libiberty/simple-object-elf.c
++++ b/libiberty/simple-object-elf.c
+@@ -1191,1 +1191,0 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,
+- 
+-- 
+2.25.1
+
+=== 0001-Wildcard-subdirs.patch ===
+From b798205595426c53eb362065f6ed6c320dcc161d Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 30 Nov 2020 13:27:51 +0100
+Subject: [PATCH] Fix it.
+
+libstdc++-v3/ChangeLog:
+
+	* testsuite/28_regex/*: Fix them all.
+	* testsuite/28_regex_not-existing/*: Fix them all.
+---
+ contrib/gcc-changelog/git_commit.py          | 1 +
+ libstdc++-v3/testsuite/28_regex/init-list.cc | 1 +
+ 2 files changed, 2 insertions(+)
+
+diff --git a/libstdc++-v3/testsuite/28_regex/init-list.cc b/libstdc++-v3/testsuite/28_regex/init-list.cc
+index f51453f019a..d10ecf483f4 100644
+--- a/libstdc++-v3/testsuite/28_regex/init-list.cc
++++ b/libstdc++-v3/testsuite/28_regex/init-list.cc
+@@ -1 +1,2 @@
+ 
++
+--
+2.29.2
+
+=== 0001-Add-horse.patch ===
+From 2884248d07e4e2c922e137365253e2e521c425b0 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 21 Dec 2020 10:14:46 +0100
+Subject: [PATCH] Add horse.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+ChangeLog:
+
+	* koníček.txt: New file.
+---
+ koníček.txt | 1 +
+ 1 file changed, 1 insertion(+)
+ create mode 100644 koníček.txt
+
+diff --git a/koníček.txt b/koníček.txt
+new file mode 100644
+index 00000000000..56c67f58752
+--- /dev/null
++++ b/koníček.txt
+@@ -0,0 +1 @@
++I'm a horse.
+-- 
+2.29.2
+=== 0001-Add-horse2.patch ===
+From 2884248d07e4e2c922e137365253e2e521c425b0 Mon Sep 17 00:00:00 2001
+From: Martin Liska <mliska@suse.cz>
+Date: Mon, 21 Dec 2020 10:14:46 +0100
+Subject: [PATCH] Add horse.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+ChangeLog:
+
+	* koníček.txt: New file.
+---
+ "kon\303\255\304\215ek.txt" | 1 +
+ 1 file changed, 1 insertion(+)
+ create mode 100644 "kon\303\255\304\215ek.txt"
+
+diff --git "a/kon\303\255\304\215ek.txt" "b/kon\303\255\304\215ek.txt"
+new file mode 100644
+index 00000000000..56c67f58752
+--- /dev/null
++++ "b/kon\303\255\304\215ek.txt"
+@@ -0,0 +1 @@
++I'm a horse.
+-- 
+2.29.2
+
+
diff --git a/contrib/git-backport.py b/contrib/git-backport.py
new file mode 100755
index 00000000000..2b8e4686719
--- /dev/null
+++ b/contrib/git-backport.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+import argparse
+import subprocess
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description='Backport a git revision and '
+                                     'stash all ChangeLog files.')
+    parser.add_argument('revision', help='Revision')
+    args = parser.parse_args()
+
+    r = subprocess.run('git cherry-pick -x %s' % args.revision, shell=True)
+    if r.returncode == 0:
+        cmd = 'git show --name-only --pretty="" -- "*ChangeLog"'
+        changelogs = subprocess.check_output(cmd, shell=True, encoding='utf8')
+        changelogs = changelogs.strip()
+        if changelogs:
+            for changelog in changelogs.split('\n'):
+                subprocess.check_output('git checkout HEAD~ %s' % changelog,
+                                        shell=True)
+        subprocess.check_output('git commit --amend --no-edit', shell=True)
+    else:
+        # 1) remove all ChangeLog files from conflicts
+        out = subprocess.check_output('git diff --name-only --diff-filter=U',
+                                      shell=True,
+                                      encoding='utf8')
+        conflicts = out.strip().split('\n')
+        changelogs = [c for c in conflicts if c.endswith('ChangeLog')]
+        if changelogs:
+            cmd = 'git checkout --theirs %s' % ' '.join(changelogs)
+            subprocess.check_output(cmd, shell=True)
+        # 2) remove all ChangeLog files from index
+        cmd = 'git diff --name-only --diff-filter=M HEAD'
+        out = subprocess.check_output(cmd, shell=True, encoding='utf8')
+        out = out.strip().split('\n')
+        modified = [c for c in out if c.endswith('ChangeLog')]
+        for m in modified:
+            subprocess.check_output('git reset %s' % m, shell=True)
+            subprocess.check_output('git checkout %s' % m, shell=True)
+
+        # try to continue
+        if len(conflicts) == len(changelogs):
+            cmd = 'git -c core.editor=true cherry-pick --continue'
+            subprocess.check_output(cmd, shell=True)
+        else:
+            print('Please resolve all remaining file conflicts.')
diff --git a/contrib/texi2pod.pl b/contrib/texi2pod.pl
index 91bdbb5cea9..e643967e930 100755
--- a/contrib/texi2pod.pl
+++ b/contrib/texi2pod.pl
@@ -209,6 +209,7 @@ while(<$inf>) {
     s/\@TeX\{\}/TeX/g;
     s/\@pounds\{\}/\#/g;
     s/\@minus(?:\{\})?/-/g;
+    s/\@tie\{\}/ /g;
     s/\\,/,/g;
 
     # Now the ones that have to be replaced by special escapes
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index b13d146a7b0..3b74042132a 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.3.0
+9.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index d8e53874e68..f3680507369 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,2693 @@
+2021-04-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-04-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/97009
+	* tree-sra.c (access_or_its_child_written): New function.
+	(propagate_subaccesses_from_rhs): Use it instead of a simple grp_write
+	test.
+
+2021-04-01  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99856
+	* tree-vect-patterns.c (vect_recog_over_widening_pattern): Promote
+	precision to vector element precision.
+
+2021-03-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-03-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR ipa/99466
+	* tree-emutls.c (get_emutls_init_templ_addr): Mark initializer of weak
+	TLS declarations as public.
+
+2021-03-25  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	Backported from master:
+	2021-03-25  Xionghu Luo  <luoxhu@linux.ibm.com>
+
+	PR target/97329
+	* config/rs6000/rs6000.c (power8_costs): Change l2 cache
+	from 256 to 512.
+
+2021-03-23  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2021-03-23  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/99704
+	* config/i386/cpuid.h (__cpuid): Add __volatile__.
+	(__cpuid_count): Likewise.
+
+2021-03-22  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backported from master:
+	2021-03-22  Kito Cheng  <kito.cheng@sifive.com>
+
+	PR target/99702
+	* config/riscv/riscv.c (riscv_expand_block_move): Get RTL value
+	after type checking.
+
+2021-03-18  Sinan Lin  <sinan@isrc.iscas.ac.cn>
+
+	Backported from master:
+	2021-03-18  Sinan Lin  <sinan@isrc.iscas.ac.cn>
+		    Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/riscv.c (riscv_block_move_straight): Change type
+	to unsigned HOST_WIDE_INT for parameter and local variable with
+	HOST_WIDE_INT type.
+	(riscv_adjust_block_mem): Ditto.
+	(riscv_block_move_loop): Ditto.
+	(riscv_expand_block_move): Ditto.
+
+2021-03-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2021-03-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-builtins.c (aarch64_expand_rng_builtin): Use EQ
+	to compare against CC_REG rather than NE.
+
+2021-03-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-03-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/98078
+	* cgraph.c (cgraph_edge::set_call_stmt): Do not update all
+	corresponding speculative edges if we are about to resolve
+	speculation.  Make edge direct (and so resolve speculations) before
+	removing it from call_site_hash.
+	(cgraph_edge::make_direct): Relax the initial assert to allow calling
+	the function on speculative direct edges.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-03-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98758
+	* tree-data-ref.c (int_divides_p): Use lambda_int arguments.
+	(lambda_matrix_right_hermite): Avoid undefinedness with
+	signed integer abs and multiplication.
+	(analyze_subscript_affine_affine): Use lambda_int.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98282
+	* tree-ssa-sccvn.c (vn_get_stmt_kind): Classify tcc_reference on
+	invariants as VN_NARY.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98117
+	* tree-vect-loop-manip.c (vect_gen_vector_loop_niters):
+	Properly handle degenerate niter when setting the vector
+	loop IV range.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-03-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93964
+	* graphite-isl-ast-to-gimple.c
+	(gcc_expression_from_isl_ast_expr_id): Add intermediate
+	conversion for pointer to integer converts.
+	* graphite-scop-detection.c (assign_parameter_index_in_region):
+	Relax assert.
+
+2021-03-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/85074
+	* config/pa/pa.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Define as
+	hook_bool_const_tree_hwi_hwi_const_tree_true.
+	(pa_asm_output_mi_thunk): Add support for nonzero vcall_offset.
+
+2021-03-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/99234
+	* config/i386/i386.c (ix86_compute_frame_layout): For a SEH target,
+	point back the hard frame pointer to its default location when the
+	frame is larger than SEH_MAX_FRAME_SIZE.
+
+2021-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/99234
+	* config/i386/i386.c (ix86_compute_frame_layout): For a SEH target,
+	point the hard frame pointer to the SSE register save area instead
+	of the general register save area.  Perform only minimal adjustment
+	for small frames if it is initially not correctly aligned.
+	(ix86_expand_prologue): Remove early saves for a SEH target.
+	* config/i386/winnt.c (struct seh_frame_state): Document constraint.
+
+2021-02-23  Qian Jianhua  <qianjh@cn.fujitsu.com>
+
+	Backported from master:
+	2021-02-23  Qian Jianhua  <qianjh@cn.fujitsu.com>
+
+	* config/aarch64/aarch64-cost-tables.h (a64fx_extra_costs): New.
+	* config/aarch64/aarch64.c (a64fx_addrcost_table): New.
+	(a64fx_regmove_cost, a64fx_vector_cost): New.
+	(a64fx_tunings): Use the new added cost tables.
+
+2021-02-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* df-core.c (df_worklist_dataflow_doublequeue): Use proper cast.
+
+2021-02-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/winnt.c (i386_pe_seh_unwind_emit): When switching to
+	the cold section, emit a nop before the directive if the previous
+	active instruction can throw.
+
+2021-02-05  Matthias Klose  <doko@ubuntu.com>
+
+	Backported from master:
+	2020-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97236
+	* tree-vect-stmts.c (get_group_load_store_type): Keep
+	VMAT_ELEMENTWISE for single-element vectors.
+
+2021-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97528
+	* config/arm/arm.c (neon_vector_mem_operand): For POST_MODIFY, require
+	first POST_MODIFY operand is a REG and is equal to the first operand
+	of PLUS.
+
+2021-01-29  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-29  Bin Cheng  <bin.cheng@linux.alibaba.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97627
+	* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):
+	Do not analyze fake edges.
+
+2021-01-21  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backported from master:
+	2019-10-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/98618
+	* config/aarch64/aarch64.c (aarch64_classify_symbol):
+	Apply reasonable limit to symbol offsets.
+
+2021-01-13  Samuel Thibault  <samuel.thibault@ens-lyon.org>
+
+	Backported from master:
+	2021-01-13  Samuel Thibault  <samuel.thibault@ens-lyon.org>
+
+	* config.gcc [$target == *-*-gnu*]: Enable
+	'default_gnu_indirect_function'.
+
+2021-01-06  2019-07-10  Marc Glisse  <marc.glisse@inria.fr>
+
+	PR testsuite/90806
+	Backport from mainline
+	* wide-int.h (wi::lshift): Reject negative values for the fast path.
+
+2020-12-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* config/i386/i386.c (ix86_expand_rint):
+	Remove the sign of the intermediate value for flag_rounding_math.
+
+2020-12-28  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	Backported from master:
+	2020-12-16  Piotr Kubaj  <pkubaj@FreeBSD.org>
+
+	* config.gcc (powerpc*le-*-freebsd*): Add.
+	* configure.ac (powerpc*le-*-freebsd*): Ditto.
+	* configure: Regenerate.
+	* config/rs6000/freebsd64.h (ASM_SPEC_COMMON): Use ENDIAN_SELECT.
+	(DEFAULT_ASM_ENDIAN): Add little endian support.
+	(LINK_OS_FREEBSD_SPEC64): Ditto.
+
+2020-12-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* config/i386/i386.c (ix86_expand_truncdf_32):
+	Remove the sign of the intermediate value for flag_rounding_math.
+
+2020-12-24  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backported from master:
+	2020-12-05  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/97421
+	* modulo-sched.c (generate_prolog_epilog): Remove forward
+	declaration, adjust last argument name and type.
+	(const_iteration_count): Add bool pointer parameter to return
+	whether count register is read in pre-header after its
+	initialization.
+	(sms_schedule): Fix count register initialization adjustment
+	procedure according to what const_iteration_count said.
+
+2020-12-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* config/i386/i386.c (ix86_expand_floorceil):
+	Remove the sign of the intermediate value for flag_rounding_math.
+	(ix86_expand_floorceildf_32): Ditto.
+
+2020-12-14  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* config.gcc (aarch64*-*-*): Add --with-tune. Support --with-cpu=native.
+	* config/aarch64/aarch64.h (OPTION_DEFAULT_SPECS): Add --with-tune.
+
+2020-12-14  Sebastian Pop  <spop@amazon.com>
+
+	* config.gcc (aarch64*-*-*): Remove --with-{cpu,arch,tune}-32 flags.
+
+2020-12-03  Uroš Bizjak  <ubizjak@gmail.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/98086
+	* config/i386/i386.c (ix86_md_asm_adjustmd): Rewrite
+	zero-extension part to use convert_to_mode.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96075
+	* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Use
+	TYPE_SIZE_UNIT of the vector component type instead of DR_STEP
+	for the misalignment calculation for negative step.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/96369
+	* fold-const.c (fold_range_test): Special-case constant
+	LHS for short-circuiting operations.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97812
+	* tree-vrp.c (register_edge_assert_for_2): Extend the range
+	according to its sign before seeing whether it fits.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-10-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97255
+	* tree-vect-patterns.c (vect_recog_bool_pattern): Also handle
+	VIEW_CONVERT_EXPR.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-09-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97081
+	* tree-vect-patterns.c (vect_recog_rotate_pattern): Use the
+	precision of the shifted operand to determine the mask.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96579
+	* tree-ssa-reassoc.c (linearize_expr_tree): If we expand
+	rhs via special ops make sure to swap operands.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-30  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96370
+	* tree-ssa-reassoc.c (rewrite_expr_tree): Add operation
+	code parameter and use it instead of picking it up from
+	the stmt that is being rewritten.
+	(reassociate_bb): Pass down the operation code.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96514
+	* tree-if-conv.c (if_convertible_bb_p): If the last stmt
+	is a call that is control-altering, fail.
+
+2020-12-01  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-10-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/97554
+	* sbitmap.c (sbitmap_vector_alloc): Use size_t for byte
+	quantities to avoid overflow.
+
+2020-11-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* config/arm/arm-protos.h: New function arm_gen_far_branch prototype.
+	* config/arm/arm.c (arm_gen_far_branch): New function
+	arm_gen_far_branch.
+	* config/arm/arm.md: Update b<cond> for Thumb2 range checks.
+
+2020-11-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/97939
+	* config/sparc/predicates.md (arith_double_add_operand): Comment.
+	* config/sparc/sparc.md (uaddvdi4): Use arith_double_operand.
+	(addvdi4): Use arith_double_add_operand.
+	(addsi3): Remove useless attributes.
+	(addvsi4): Use arith_add_operand.
+	(*cmp_ccv_plus): Likewise and add second alternative accordingly.
+	(*cmp_ccxv_plus): Likewise.
+	(*cmp_ccv_plus_set): Likewise.
+	(*cmp_ccxv_plus_set): Likewise.
+	(*cmp_ccv_plus_sltu_set): Likewise.
+	(usubvdi4): Use arith_double_operand.
+	(subvdi4): Use arith_double_add_operand.
+	(subsi3): Remove useless attributes.
+	(subvsi4): Use arith_add_operand.
+	(*cmp_ccv_minus): Likewise and add second alternative accordingly.
+	(*cmp_ccxv_minus): Likewise.
+	(*cmp_ccv_minus_set): Likewise.
+	(*cmp_ccxv_minus_set): Likewise.
+	(*cmp_ccv_minus_sltu_set): Likewise.
+	(negsi2): Use register_operand.
+	(unegvsi3): Likewise.
+	(negvsi3) Likewise.
+	(*cmp_ccnz_neg): Likewise.
+	(*cmp_ccxnz_neg): Likewise.
+	(*cmp_ccnz_neg_set): Likewise.
+	(*cmp_ccxnz_neg_set): Likewise.
+	(*cmp_ccc_neg_set): Likewise.
+	(*cmp_ccxc_neg_set): Likewise.
+	(*cmp_ccc_neg_sltu_set): Likewise.
+	(*cmp_ccv_neg): Likewise.
+	(*cmp_ccxv_neg): Likewise.
+	(*cmp_ccv_neg_set): Likewise.
+	(*cmp_ccxv_neg_set): Likewise.
+	(*cmp_ccv_neg_sltu_set): Likewise.
+
+2020-11-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/96607
+	* config/sparc/sparc-protos.h (eligible_for_call_delay): Delete.
+	* config/sparc/sparc.c (eligible_for_call_delay): Likewise.
+	* config/sparc/sparc.md (in_call_delay): Likewise.
+	(tls_delay_slot): New attribute.
+	(define_delay [call]): Use in_branch_delay.
+	(tgd_call<P:mode>): Set type to call_no_delay_slot when
+	tls_delay_slot is false.
+	(tldm_call<P:mode>): Likewise.
+
+2020-11-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/97918
+	* dwarf2out.c (dwarf2out_early_finish): flush_limbo_die_list
+	after gen_scheduled_generic_parms_dies.
+
+2020-11-17  Sebastian Pop  <spop@amazon.com>
+
+	Backported from master:
+	2020-11-17  Sebastian Pop  <spop@amazon.com>
+
+	* config.gcc: add configure flags --with-{cpu,arch,tune}-{32,64}
+	as alias flags for --with-{cpu,arch,tune} on AArch64.
+	* doc/install.texi: Document new flags for aarch64.
+
+2020-11-17  Sebastian Pop  <spop@amazon.com>
+
+	Backported from master:
+	2020-11-17  Sebastian Pop  <spop@amazon.com>
+
+	* config.gcc: Add --with-tune to AArch64 configure flags.
+
+2020-11-17  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-10-27  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/97535
+	* config/aarch64/aarch64.c (aarch64_expand_cpymem): Use unsigned
+	arithmetic in check.
+
+2020-11-17  Monk Chiang  <monk.chiang@sifive.com>
+
+	Backported from master:
+	2020-11-14  Monk Chiang  <monk.chiang@sifive.com>
+
+	PR target/97682
+	* config/riscv/riscv.h (RISCV_PROLOGUE_TEMP_REGNUM): Change register
+	to t0.
+	(RISCV_CALL_ADDRESS_TEMP_REGNUM): New Marco, define t1 register.
+	(RISCV_CALL_ADDRESS_TEMP): Use it for call instructions.
+	* config/riscv/riscv.c (riscv_legitimize_call_address): Use
+	RISCV_CALL_ADDRESS_TEMP.
+	(riscv_compute_frame_info): Change temporary register to t0 form t1.
+	(riscv_trampoline_init): Adjust comment.
+
+2020-11-16  Cui,Lili  <lili.cui@intel.com>
+
+	* config/i386/i386.h: Add PREFETCHW to march=broadwell.
+	* doc/invoke.texi: Put PREFETCHW back to relation arch.
+
+2020-11-11  liuhongt  <hongtao.liu@intel.com>
+
+	* config/i386/i386.c (ix86_option_override_internal):
+	Handle PTA_CLDEMOTE, PTA_MOVDIRI, PTA_MOVDIR64B.
+	* config/i386/i386.h (PTA_CLDEMOTE, PTA_MOVDIRI,
+	PTA_MOVDIR64B.): Define.
+
+2020-11-09  Lili Cui  <lili.cui@intel.com>
+
+	PR target/97685
+	* config/i386/i386.h:
+	(PTA_BROADWELL): Delete PTA_PRFCHW.
+	(PTA_SILVERMONT): Add PTA_PRFCHW.
+	(PTA_KNL): Add PTA_PREFETCHWT1.
+	(PTA_TREMONT): Add PTA_MOVDIRI, PTA_MOVDIR64B, PTA_CLDEMOTE and PTA_WAITPKG.
+	* doc/invoke.texi: Delete PREFETCHW for broadwell, skylake, knl, knm,
+	skylake-avx512, cannonlake, icelake-client, icelake-server, cascadelake,
+	cooperlake, tigerlake and sapphirerapids.
+	Add PREFETCHW for silvermont, goldmont, goldmont-plus and tremont.
+	Add XSAVEC and XSAVES for goldmont, goldmont-plus and tremont.
+	Add MOVDIRI, MOVDIR64B, CLDEMOTE and WAITPKG for tremont.
+	Add KEYLOCKER and HREST for alderlake.
+	Add AMX-BF16, AMX-TILE, AMX-INT8 and UINTR for sapphirerapids.
+	Add KEYLOCKER for tigerlake.
+
+2020-10-22  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backported from master:
+	2020-10-22  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR rtl-optimization/97439
+	* dfp.c (decimal_real_maxval): Set the sign flag in the
+	generated number.
+
+2020-10-16  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-10-16  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/97404
+	* ipa-prop.c (struct ipa_vr_ggc_hash_traits):
+	Compare types of VRP as we can merge ranges of different types.
+
+2020-10-15  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-10-15  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/97295
+	* profile-count.c (profile_count::to_frequency): Move part of
+	gcc_assert to STATIC_ASSERT.
+	* regs.h (REG_FREQ_FROM_BB): Do not use count.to_frequency for
+	a function that does not have count_max initialized.
+
+2020-10-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.c (neoversen2_tunings): Define.
+	* config/aarch64/aarch64-cores.def (neoverse-n2): Use it.
+
+2020-10-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/97349
+	* config/aarch64/arm_neon.h (vdupq_n_p8, vdupq_n_p16,
+	vdupq_n_p64, vdupq_n_s8, vdupq_n_s16, vdupq_n_u8, vdupq_n_u16):
+	Fix argument type.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md ("unspec"): Add UNSPEC_FRINT32Z,
+	UNSPEC_FRINT32X, UNSPEC_FRINT64Z, UNSPEC_FRINT64X.
+	(aarch64_<frintnzs_op><mode>): New define_insn.
+	* config/aarch64/aarch64.h (TARGET_FRINT): Define.
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define
+	__ARM_FEATURE_FRINT when appropriate.
+	* config/aarch64/aarch64-simd-builtins.def: Add builtins for frint32z,
+	frint32x, frint64z, frint64x.
+	* config/aarch64/arm_acle.h (__rint32zf, __rint32z, __rint64zf,
+	__rint64z, __rint32xf, __rint32x, __rint64xf, __rint64x): Define.
+	* config/aarch64/arm_neon.h (vrnd32z_f32, vrnd32zq_f32, vrnd32z_f64,
+	vrnd32zq_f64, vrnd32x_f32, vrnd32xq_f32, vrnd32x_f64, vrnd32xq_f64,
+	vrnd64z_f32, vrnd64zq_f32, vrnd64z_f64, vrnd64zq_f64, vrnd64x_f32,
+	vrnd64xq_f32, vrnd64x_f64, vrnd64xq_f64): Define.
+	* config/aarch64/iterators.md (VSFDF): Define.
+	(FRINTNZX): Likewise.
+	(frintnzs_op): Likewise.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/97150
+	* config/aarch64/arm_neon.h (vqrshlb_u8): Make second argument
+	signed.
+	(vqrshlh_u16): Likewise.
+	(vqrshls_u32): Likewise.
+	(vqrshld_u64): Likewise.
+	(vqshlb_u8): Likewise.
+	(vqshlh_u16): Likewise.
+	(vqshls_u32): Likewise.
+	(vqshld_u64): Likewise.
+	(vshld_u64): Likewise.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/96313
+	* config/aarch64/aarch64-simd-builtins.def (sqmovun): Use UNOPUS
+	qualifiers.
+	* config/aarch64/arm_neon.h (vqmovun_s16): Adjust builtin call.
+	Remove unnecessary result cast.
+	(vqmovun_s32): Likewise.
+	(vqmovun_s64): Likewise.
+	(vqmovunh_s16): Likewise.  Fix return type.
+	(vqmovuns_s32): Likewise.
+	(vqmovund_s64): Likewise.
+
+2020-10-08  Alan Modra  <amodra@gmail.com>
+
+	Backported from master:
+	2020-10-01  Alan Modra  <amodra@gmail.com>
+
+	* config/rs6000/rs6000.c (rs6000_legitimize_address): Use
+	gen_int_mode for high part of address constant.
+
+2020-10-05  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/arm/arm-cpus.in (neoverse-v1): Add missing vendor and
+	part numbers.
+
+2020-10-02  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/arm/arm-cpus.in (neoverse-n2): New.
+	* config/arm/arm-tables.opt: Regenerate.
+	* config/arm/arm-tune.md: Regenerate.
+	* doc/invoke.texi: Document support for Neoverse N2.
+
+2020-10-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.c (neoversev1_tunings): Define.
+	* config/aarch64/aarch64-cores.def (zeus): Use it.
+	(neoverse-v1): Likewise.
+
+2020-10-02  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-10-02  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/97193
+	* coverage.c (coverage_init): GCDA note files should not be
+	mangled and should end in output directory.
+
+2020-10-02  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-09-25  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/64636
+	* value-prof.c (stream_out_histogram_value): Allow negative
+	values for HIST_TYPE_IOR.
+
+2020-10-02  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-09-23  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/97069
+	* profile.c (branch_prob): Line number must be at least 1.
+
+2020-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-tuning-flags.def
+	(PREFER_ADVSIMD_AUTOVEC): Define.
+	* config/aarch64/aarch64.c (aarch64_preferred_simd_mode): Use
+	it.
+	(aarch64_autovectorize_vector_sizes): Likewise.
+
+2020-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (zeus): Add AARCH64_FL_RNG to
+	features.
+	(neoverse-v1): Likewise.
+
+2020-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/s390/s390.c (s390_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for the first assignments to
+	fenv_var and old_fpc.  Formatting fixes.
+
+2020-10-01  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/aarch64/aarch64-cores.def: Add Neoverse N2.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi: Document AArch64 support for Neoverse N2.
+
+2020-09-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-option-extensions.def (rng): Add
+	cpuinfo string.
+
+2020-09-30  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2020-09-30  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/97184
+	* config/i386/i386.md (UNSPECV_MOVDIRI): Renamed to ...
+	(UNSPEC_MOVDIRI): This.
+	(UNSPECV_MOVDIR64B): Renamed to ...
+	(UNSPEC_MOVDIR64B): This.
+	(movdiri<mode>): Use SET operation.
+	(@movdir64b_<mode>): Likewise.
+
+2020-09-29  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2020-09-29  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/97231
+	* config/i386/pconfigintrin.h: Add FSF copyright notes.
+	* config/i386/wbnoinvdintrin.h: Ditto.
+
+2020-09-29  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/arm/arm-cpus.in (neoverse-v1): New.
+	* config/arm/arm-tables.opt: Regenerate.
+	* config/arm/arm-tune.md: Regenerate.
+	* doc/invoke.texi: Document AArch32 support for Neoverse V1.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vreinterpretq_f64_p128,
+	vreinterpretq_p128_f64): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/aarch64-simd-builtins.def (frintn): Use BUILTIN_VHSDF_HSDF
+	for modes.  Remove explicit hf instantiation.
+	* config/aarch64/arm_neon.h (vrndns_f32): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vtrn1q_p64, vtrn2q_p64, vuzp1q_p64,
+	vuzp2q_p64, vzip1q_p64, vzip2q_p64): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vldrq_p128): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vstrq_p128): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vcls_u8, vcls_u16, vcls_u32,
+	vclsq_u8, vclsq_u16, vclsq_u32): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vceqq_p64, vceqz_p64, vceqzq_p64): Define.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/arm_neon.h (vadd_p8, vadd_p16, vadd_p64, vaddq_p8,
+	vaddq_p16, vaddq_p64, vaddq_p128): Define.
+
+2020-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/97073
+	* optabs.c (expand_binop, expand_absneg_bit, expand_unop,
+	expand_copysign_bit): Check reg_overlap_mentioned_p between target
+	and operand(s) and if it returns true, force a pseudo as target.
+
+2020-09-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* config/aarch64/aarch64.md (UNSPEC_RNDR, UNSPEC_RNDRRS):
+	Define.
+	(aarch64_rndr): New define_insn.
+	(aarch64_rndrrs): Likewise.
+	* config/aarch64/aarch64.h (AARCH64_ISA_RNG): Define.
+	(TARGET_RNG): Likewise.
+	* config/aarch64/aarch64-builtins.c (enum aarch64_builtins):
+	Add AARCH64_BUILTIN_RNG_RNDR, AARCH64_BUILTIN_RNG_RNDRRS.
+	(aarch64_init_rng_builtins): Define.
+	(aarch64_init_builtins): Call aarch64_init_rng_builtins.
+	(aarch64_expand_rng_builtin): Define.
+	(aarch64_expand_builtin): Use IGNORE argument, handle
+	RNG builtins.
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_RNG when TARGET_RNG.
+	* config/aarch64/arm_acle.h (__rndr, __rndrrs): Define.
+
+2020-09-24  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2020-09-16  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/97032
+	* cfgexpand.c (asm_clobber_reg_kind): Set sp_is_clobbered_by_asm
+	to true if the stack pointer is clobbered by asm statement.
+	* emit-rtl.h (rtl_data): Add sp_is_clobbered_by_asm.
+	* config/i386/i386.c (ix86_get_drap_rtx): Set need_drap to true
+	if the stack pointer is clobbered by asm statement.
+
+2020-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+		    Andrea Corallo   <andrea.corallo@arm.com>
+
+	PR target/71233
+	* config/aarch64/aarch64.md (UNSPEC_FJCVTZS): Define.
+	(aarch64_fjcvtzs): New define_insn.
+	* config/aarch64/aarch64.h (TARGET_JSCVT): Define.
+	* config/aarch64/aarch64-builtins.c (aarch64_builtins):
+	Add AARCH64_JSCVT.
+	(aarch64_init_builtins): Initialize __builtin_aarch64_jcvtzs.
+	(aarch64_expand_builtin): Handle AARCH64_JSCVT.
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define
+	__ARM_FEATURE_JCVT where appropriate.
+	* config/aarch64/arm_acle.h (__jcvt): Define.
+	* doc/sourcebuild.texi (aarch64_fjcvtzs_hw) Document new
+	target supports option.
+
+2020-09-24  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/aarch64/aarch64-cores.def: Add Neoverse V1.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi: Document support for Neoverse V1.
+
+2020-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/97053
+	* gimple-ssa-store-merging.c (check_no_overlap): Add FIRST_ORDER,
+	START, FIRST_EARLIER and LAST_EARLIER arguments.  Return false if
+	any stores between FIRST_EARLIER inclusive and LAST_EARLIER exclusive
+	has order in between FIRST_ORDER and LAST_ORDER and overlaps the to
+	be merged store.
+	(imm_store_chain_info::try_coalesce_bswap): Add FIRST_EARLIER argument.
+	Adjust check_no_overlap caller.
+	(imm_store_chain_info::coalesce_immediate_stores): Add first_earlier
+	and last_earlier variables, adjust them during iterations.  Adjust
+	check_no_overlap callers, call check_no_overlap even when extending
+	overlapping stores by extra INTEGER_CST stores.
+
+2020-09-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/arm/arm-builtins.c (arm_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for the first assignments to
+	fenv_var and new_fenv_var.
+
+2020-09-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2020-04-24  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/94710
+	* config/rs6000/vector.md (vec_shr_<mode> for VEC_L): Correct little
+	endian byteshift_val calculation.
+
+2020-09-17  liuhongt  <hongtao.liu@intel.com>
+
+	* common/config/i386/i386-common.c
+	(OPTION_MASK_ISA_AVX_UNSET): Remove OPTION_MASK_ISA_XSAVE_UNSET.
+	(OPTION_MASK_ISA_XSAVE_UNSET): Add OPTION_MASK_ISA_AVX_UNSET.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/96729
+	* dwarf2out.c (dwarf2out_next_real_insn): Adjust function comment.
+	(dwarf2out_var_location): Look for next_note only if next_real is
+	non-NULL, in that case look for the first non-deleted
+	NOTE_INSN_VAR_LOCATION between loc_note and next_real, if any.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/96722
+	* gimple.c (infer_nonnull_range): Formatting fix.
+	(infer_nonnull_range_by_dereference): Return false for clobber stmts.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/93553
+	* tree-nested.c (convert_nonlocal_omp_clauses): For
+	OMP_CLAUSE_REDUCTION, OMP_CLAUSE_LASTPRIVATE and OMP_CLAUSE_LINEAR
+	save info->new_local_var_chain around walks of the clause gimple
+	sequences and declare_vars if needed into the sequence.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/96459
+	* omp-low.c (lower_omp_taskreg): Call lower_reduction_clauses even in
+	for host teams.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/96426
+	* tree-vect-generic.c (expand_vector_conversion): Replace .VEC_CONVERT
+	call with GIMPLE_NOP if there is no lhs.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-07-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/96174
+	* config/i386/avx512fintrin.h (_mm512_cmpeq_pd_mask,
+	_mm512_mask_cmpeq_pd_mask, _mm512_cmplt_pd_mask,
+	_mm512_mask_cmplt_pd_mask, _mm512_cmple_pd_mask,
+	_mm512_mask_cmple_pd_mask, _mm512_cmpunord_pd_mask,
+	_mm512_mask_cmpunord_pd_mask, _mm512_cmpneq_pd_mask,
+	_mm512_mask_cmpneq_pd_mask, _mm512_cmpnlt_pd_mask,
+	_mm512_mask_cmpnlt_pd_mask, _mm512_cmpnle_pd_mask,
+	_mm512_mask_cmpnle_pd_mask, _mm512_cmpord_pd_mask,
+	_mm512_mask_cmpord_pd_mask, _mm512_cmpeq_ps_mask,
+	_mm512_mask_cmpeq_ps_mask, _mm512_cmplt_ps_mask,
+	_mm512_mask_cmplt_ps_mask, _mm512_cmple_ps_mask,
+	_mm512_mask_cmple_ps_mask, _mm512_cmpunord_ps_mask,
+	_mm512_mask_cmpunord_ps_mask, _mm512_cmpneq_ps_mask,
+	_mm512_mask_cmpneq_ps_mask, _mm512_cmpnlt_ps_mask,
+	_mm512_mask_cmpnlt_ps_mask, _mm512_cmpnle_ps_mask,
+	_mm512_mask_cmpnle_ps_mask, _mm512_cmpord_ps_mask,
+	_mm512_mask_cmpord_ps_mask): Move outside of __OPTIMIZE__ guarded
+	section.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/95857
+	* tree-cfg.c (group_case_labels_stmt): When removing an unreachable
+	base_bb, remember all forced and non-local labels on it and later
+	treat those as if they have NULL label_to_block.  Formatting fix.
+	Fix a comment typo.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95810
+	* fold-const.c (fold_cond_expr_with_comparison): Optimize
+	A <= 0 ? A : -A into (type)-absu(A) rather than -abs(A).
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95108
+	* omp-simd-clone.c (struct modify_stmt_info): Add after_stmt member.
+	(ipa_simd_modify_stmt_ops): For PHIs, only add before first stmt in
+	entry block if info->after_stmt is NULL, otherwise add after that stmt
+	and update it after adding each stmt.
+	(ipa_simd_modify_function_body): Initialize info.after_stmt.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/95080
+	* cfgrtl.c (purge_dead_edges): Skip over debug and note insns even
+	if the last insn is a note.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94950
+	* config/riscv/riscv-builtins.c (riscv_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for first assignment to old_flags.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94873
+	* combine.c (combine_instructions): Don't optimize using REG_EQUAL
+	note if SET_SRC (set) has side-effects.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/tilegx/tilegx.md
+	(insn_stnt<I124MODE:n>_add<I48MODE:bitsuffix>): Use <I124MODE:n>
+	rather than just <n>.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94832
+	* config/i386/avx512bwintrin.h (_mm512_alignr_epi8,
+	_mm512_mask_alignr_epi8, _mm512_maskz_alignr_epi8): Wrap macro operands
+	used in casts into parens.
+	* config/i386/avx512fintrin.h (_mm512_cvt_roundps_ph, _mm512_cvtps_ph,
+	_mm512_mask_cvt_roundps_ph, _mm512_mask_cvtps_ph,
+	_mm512_maskz_cvt_roundps_ph, _mm512_maskz_cvtps_ph,
+	_mm512_mask_cmp_epi64_mask, _mm512_mask_cmp_epi32_mask,
+	_mm512_mask_cmp_epu64_mask, _mm512_mask_cmp_epu32_mask,
+	_mm512_mask_cmp_round_pd_mask, _mm512_mask_cmp_round_ps_mask,
+	_mm512_mask_cmp_pd_mask, _mm512_mask_cmp_ps_mask): Likewise.
+	* config/i386/avx512vlbwintrin.h (_mm256_mask_alignr_epi8,
+	_mm256_maskz_alignr_epi8, _mm_mask_alignr_epi8, _mm_maskz_alignr_epi8,
+	_mm256_mask_cmp_epu8_mask): Likewise.
+	* config/i386/avx512vlintrin.h (_mm_mask_cvtps_ph, _mm_maskz_cvtps_ph,
+	_mm256_mask_cvtps_ph, _mm256_maskz_cvtps_ph): Likewise.
+	* config/i386/f16cintrin.h (_mm_cvtps_ph, _mm256_cvtps_ph): Likewise.
+	* config/i386/shaintrin.h (_mm_sha1rnds4_epu32): Likewise.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94832
+	* config/i386/avx2intrin.h (_mm_mask_i32gather_pd,
+	_mm256_mask_i32gather_pd, _mm_mask_i64gather_pd,
+	_mm256_mask_i64gather_pd, _mm_mask_i32gather_ps,
+	_mm256_mask_i32gather_ps, _mm_mask_i64gather_ps,
+	_mm256_mask_i64gather_ps, _mm_i32gather_epi64,
+	_mm_mask_i32gather_epi64, _mm256_i32gather_epi64,
+	_mm256_mask_i32gather_epi64, _mm_i64gather_epi64,
+	_mm_mask_i64gather_epi64, _mm256_i64gather_epi64,
+	_mm256_mask_i64gather_epi64, _mm_i32gather_epi32,
+	_mm_mask_i32gather_epi32, _mm256_i32gather_epi32,
+	_mm256_mask_i32gather_epi32, _mm_i64gather_epi32,
+	_mm_mask_i64gather_epi32, _mm256_i64gather_epi32,
+	_mm256_mask_i64gather_epi32): Surround macro parameter uses with
+	parens.
+	(_mm_i32gather_pd, _mm256_i32gather_pd, _mm_i64gather_pd,
+	_mm256_i64gather_pd, _mm_i32gather_ps, _mm256_i32gather_ps,
+	_mm_i64gather_ps, _mm256_i64gather_ps): Likewise.  Don't use
+	as mask vector containing -1.0 or -1.0f elts, but instead vector
+	with all bits set using _mm*_cmpeq_p? with zero operands.
+	* config/i386/avx512fintrin.h (_mm512_i32gather_ps,
+	_mm512_mask_i32gather_ps, _mm512_i32gather_pd,
+	_mm512_mask_i32gather_pd, _mm512_i64gather_ps,
+	_mm512_mask_i64gather_ps, _mm512_i64gather_pd,
+	_mm512_mask_i64gather_pd, _mm512_i32gather_epi32,
+	_mm512_mask_i32gather_epi32, _mm512_i32gather_epi64,
+	_mm512_mask_i32gather_epi64, _mm512_i64gather_epi32,
+	_mm512_mask_i64gather_epi32, _mm512_i64gather_epi64,
+	_mm512_mask_i64gather_epi64, _mm512_i32scatter_ps,
+	_mm512_mask_i32scatter_ps, _mm512_i32scatter_pd,
+	_mm512_mask_i32scatter_pd, _mm512_i64scatter_ps,
+	_mm512_mask_i64scatter_ps, _mm512_i64scatter_pd,
+	_mm512_mask_i64scatter_pd, _mm512_i32scatter_epi32,
+	_mm512_mask_i32scatter_epi32, _mm512_i32scatter_epi64,
+	_mm512_mask_i32scatter_epi64, _mm512_i64scatter_epi32,
+	_mm512_mask_i64scatter_epi32, _mm512_i64scatter_epi64,
+	_mm512_mask_i64scatter_epi64): Surround macro parameter uses with
+	parens.
+	* config/i386/avx512pfintrin.h (_mm512_prefetch_i32gather_pd,
+	_mm512_prefetch_i32gather_ps, _mm512_mask_prefetch_i32gather_pd,
+	_mm512_mask_prefetch_i32gather_ps, _mm512_prefetch_i64gather_pd,
+	_mm512_prefetch_i64gather_ps, _mm512_mask_prefetch_i64gather_pd,
+	_mm512_mask_prefetch_i64gather_ps, _mm512_prefetch_i32scatter_pd,
+	_mm512_prefetch_i32scatter_ps, _mm512_mask_prefetch_i32scatter_pd,
+	_mm512_mask_prefetch_i32scatter_ps, _mm512_prefetch_i64scatter_pd,
+	_mm512_prefetch_i64scatter_ps, _mm512_mask_prefetch_i64scatter_pd,
+	_mm512_mask_prefetch_i64scatter_ps): Likewise.
+	* config/i386/avx512vlintrin.h (_mm256_mmask_i32gather_ps,
+	_mm_mmask_i32gather_ps, _mm256_mmask_i32gather_pd,
+	_mm_mmask_i32gather_pd, _mm256_mmask_i64gather_ps,
+	_mm_mmask_i64gather_ps, _mm256_mmask_i64gather_pd,
+	_mm_mmask_i64gather_pd, _mm256_mmask_i32gather_epi32,
+	_mm_mmask_i32gather_epi32, _mm256_mmask_i32gather_epi64,
+	_mm_mmask_i32gather_epi64, _mm256_mmask_i64gather_epi32,
+	_mm_mmask_i64gather_epi32, _mm256_mmask_i64gather_epi64,
+	_mm_mmask_i64gather_epi64, _mm256_i32scatter_ps,
+	_mm256_mask_i32scatter_ps, _mm_i32scatter_ps, _mm_mask_i32scatter_ps,
+	_mm256_i32scatter_pd, _mm256_mask_i32scatter_pd, _mm_i32scatter_pd,
+	_mm_mask_i32scatter_pd, _mm256_i64scatter_ps,
+	_mm256_mask_i64scatter_ps, _mm_i64scatter_ps, _mm_mask_i64scatter_ps,
+	_mm256_i64scatter_pd, _mm256_mask_i64scatter_pd, _mm_i64scatter_pd,
+	_mm_mask_i64scatter_pd, _mm256_i32scatter_epi32,
+	_mm256_mask_i32scatter_epi32, _mm_i32scatter_epi32,
+	_mm_mask_i32scatter_epi32, _mm256_i32scatter_epi64,
+	_mm256_mask_i32scatter_epi64, _mm_i32scatter_epi64,
+	_mm_mask_i32scatter_epi64, _mm256_i64scatter_epi32,
+	_mm256_mask_i64scatter_epi32, _mm_i64scatter_epi32,
+	_mm_mask_i64scatter_epi32, _mm256_i64scatter_epi64,
+	_mm256_mask_i64scatter_epi64, _mm_i64scatter_epi64,
+	_mm_mask_i64scatter_epi64): Likewise.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94826
+	* config/rs6000/rs6000.c (rs6000_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for first assignment to
+	fenv_var, fenv_clear and old_fenv variables.  For fenv_addr
+	take address of TARGET_EXPR of fenv_var with void_node initializer.
+	Formatting fixes.
+
+2020-09-16  Haijian Zhang  <z.zhanghaijian@huawei.com>
+
+	Backported from master:
+	2020-04-29  Haijian Zhang  <z.zhanghaijian@huawei.com>
+
+	PR target/94820
+	* config/aarch64/aarch64-builtins.c
+	(aarch64_atomic_assign_expand_fenv): Use TARGET_EXPR instead of
+	MODIFY_EXPR for first assignment to fenv_cr, fenv_sr and
+	new_fenv_var.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94809
+	* tree.c (build_call_expr_internal_loc_array): Call
+	process_call_operands.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94780
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for first assignment to
+	sw_var, exceptions_var, mxcsr_orig_var and mxcsr_mod_var.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94710
+	* optabs.c (expand_vec_perm_const): For shift_amt const0_rtx
+	just return v2.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94705
+	* attribs.c (decl_attribute): Don't diagnose attribute exclusions
+	if last_decl is error_mark_node or has such a TREE_TYPE.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94641
+	* stor-layout.c (place_field, finalize_record_size): Don't emit
+	-Wpadded warning on TYPE_ARTIFICIAL rli->t.
+	* ubsan.c (ubsan_get_type_descriptor_type,
+	ubsan_get_source_location_type, ubsan_create_data): Set
+	TYPE_ARTIFICIAL.
+	* asan.c (asan_global_struct): Likewise.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94618
+	* cfgrtl.c (delete_insn_and_edges): Set purge not just when
+	insn is the BB_END of its block, but also when it is only followed
+	by DEBUG_INSNs in its block.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94621
+	* tree-inline.c (remap_type_1): Don't dereference NULL TYPE_DOMAIN.
+	Move id->adjust_array_error_bounds check first in the condition.
+
+2020-09-16  Gustavo Romero  <gromero@linux.ibm.com>
+
+	Backported from master:
+	2020-04-15  Gustavo Romero  <gromero@linux.ibm.com>
+
+	PR bootstrap/89494
+	* dumpfile.c (selftest::temp_dump_context::temp_dump_context):
+	Don't construct a dump_context temporary to call static method.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94524
+	* tree-vect-generic.c (expand_vector_divmod): If any elt of op1 is
+	negative for signed TRUNC_MOD_EXPR, multiply with absolute value of
+	op1 rather than op1 itself at the end.  Punt for signed modulo by
+	most negative constant.
+	* tree-vect-patterns.c (vect_recog_divmod_pattern): Punt for signed
+	modulo by most negative constant.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94438
+	* config/i386/i386.c (ix86_get_mask_mode): Only use int mask for elem_size
+	1, 2, 4 and 8.
+
+2020-09-16  Sylvia Taylor  <sylvia.taylor@arm.com>
+
+	Backported from master:
+	2019-08-22  Sylvia Taylor  <sylvia.taylor@arm.com>
+
+	* config/aarch64/aarch64-simd-builtins.def:
+	(ld1x4): New.
+	(st1x4): Likewise.
+	* config/aarch64/aarch64-simd.md:
+	(aarch64_ld1x4<VALLDIF:mode>): New pattern.
+	(aarch64_st1x4<VALLDIF:mode>): Likewise.
+	(aarch64_ld1_x4_<mode>): Likewise.
+	(aarch64_st1_x4_<mode>): Likewise.
+	* config/aarch64/arm_neon.h:
+	(vld1_s8_x4): New function.
+	(vld1q_s8_x4): Likewise.
+	(vld1_s16_x4): Likewise.
+	(vld1q_s16_x4): Likewise.
+	(vld1_s32_x4): Likewise.
+	(vld1q_s32_x4): Likewise.
+	(vld1_u8_x4): Likewise.
+	(vld1q_u8_x4): Likewise.
+	(vld1_u16_x4): Likewise.
+	(vld1q_u16_x4): Likewise.
+	(vld1_u32_x4): Likewise.
+	(vld1q_u32_x4): Likewise.
+	(vld1_f16_x4): Likewise.
+	(vld1q_f16_x4): Likewise.
+	(vld1_f32_x4): Likewise.
+	(vld1q_f32_x4): Likewise.
+	(vld1_p8_x4): Likewise.
+	(vld1q_p8_x4): Likewise.
+	(vld1_p16_x4): Likewise.
+	(vld1q_p16_x4): Likewise.
+	(vld1_s64_x4): Likewise.
+	(vld1_u64_x4): Likewise.
+	(vld1_p64_x4): Likewise.
+	(vld1q_s64_x4): Likewise.
+	(vld1q_u64_x4): Likewise.
+	(vld1q_p64_x4): Likewise.
+	(vld1_f64_x4): Likewise.
+	(vld1q_f64_x4): Likewise.
+	(vst1_s8_x4): Likewise.
+	(vst1q_s8_x4): Likewise.
+	(vst1_s16_x4): Likewise.
+	(vst1q_s16_x4): Likewise.
+	(vst1_s32_x4): Likewise.
+	(vst1q_s32_x4): Likewise.
+	(vst1_u8_x4): Likewise.
+	(vst1q_u8_x4): Likewise.
+	(vst1_u16_x4): Likewise.
+	(vst1q_u16_x4): Likewise.
+	(vst1_u32_x4): Likewise.
+	(vst1q_u32_x4): Likewise.
+	(vst1_f16_x4): Likewise.
+	(vst1q_f16_x4): Likewise.
+	(vst1_f32_x4): Likewise.
+	(vst1q_f32_x4): Likewise.
+	(vst1_p8_x4): Likewise.
+	(vst1q_p8_x4): Likewise.
+	(vst1_p16_x4): Likewise.
+	(vst1q_p16_x4): Likewise.
+	(vst1_s64_x4): Likewise.
+	(vst1_u64_x4): Likewise.
+	(vst1_p64_x4): Likewise.
+	(vst1q_s64_x4): Likewise.
+	(vst1q_u64_x4): Likewise.
+	(vst1q_p64_x4): Likewise.
+	(vst1_f64_x4): Likewise.
+	(vst1q_f64_x4): Likewise.
+
+2020-09-15  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_init_builtin): Update V2DI_type_node
+	and unsigned_V2DI_type_node definitions.
+
+2020-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97028
+	* config/i386/sse.md (mul<mode>3<mask_name>_bcs,
+	<avx512>_div<mode>3<mask_name>_bcst): Use <avx512bcst> instead of
+	<<avx512bcst>>.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-07  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/94947
+	* tree-ssa-structalias.c (refered_from_nonlocal_fn): Use
+	DECL_EXTERNAL || TREE_PUBLIC instead of externally_visible.
+	(refered_from_nonlocal_var): Likewise.
+	(ipa_pta_execute): Likewise.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/94947
+	* tree-ssa-structalias.c (ipa_pta_execute): Use
+	varpool_node::externally_visible_p ().
+	(refered_from_nonlocal_var): Likewise.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/94964
+	* cfgloopmanip.c (create_preheader): Require non-complex
+	preheader edge for CP_SIMPLE_PREHEADERS.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95049
+	* tree-ssa-sccvn.c (set_ssa_val_to): Reject lattice transition
+	between different constants.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95133
+	* gimple-ssa-split-paths.c
+	(find_block_to_duplicate_for_splitting_paths): Check for
+	normal edges.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-06-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95717
+	* tree-vect-loop-manip.c (slpeel_tree_duplicate_loop_to_edge_cfg):
+	Move BB SSA updating before exit/latch PHI current def copying.
+
+2020-09-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2019-12-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/92923
+	* config/rs6000/rs6000-builtin.def (VAND, VANDC, VNOR, VOR, VXOR):
+	Delete.
+	(EQV_V16QI_UNS, EQV_V8HI_UNS, EQV_V4SI_UNS, EQV_V2DI_UNS, EQV_V1TI_UNS,
+	NAND_V16QI_UNS, NAND_V8HI_UNS, NAND_V4SI_UNS, NAND_V2DI_UNS,
+	NAND_V1TI_UNS, ORC_V16QI_UNS, ORC_V8HI_UNS, ORC_V4SI_UNS, ORC_V2DI_UNS,
+	ORC_V1TI_UNS, VAND_V16QI_UNS, VAND_V16QI, VAND_V8HI_UNS, VAND_V8HI,
+	VAND_V4SI_UNS, VAND_V4SI, VAND_V2DI_UNS, VAND_V2DI, VAND_V4SF,
+	VAND_V2DF, VANDC_V16QI_UNS, VANDC_V16QI, VANDC_V8HI_UNS, VANDC_V8HI,
+	VANDC_V4SI_UNS, VANDC_V4SI, VANDC_V2DI_UNS, VANDC_V2DI, VANDC_V4SF,
+	VANDC_V2DF, VNOR_V16QI_UNS, VNOR_V16QI, VNOR_V8HI_UNS, VNOR_V8HI,
+	VNOR_V4SI_UNS, VNOR_V4SI, VNOR_V2DI_UNS, VNOR_V2DI, VNOR_V4SF,
+	VNOR_V2DF, VOR_V16QI_UNS, VOR_V16QI, VOR_V8HI_UNS, VOR_V8HI,
+	VOR_V4SI_UNS, VOR_V4SI, VOR_V2DI_UNS, VOR_V2DI, VOR_V4SF, VOR_V2DF,
+	VXOR_V16QI_UNS, VXOR_V16QI, VXOR_V8HI_UNS, VXOR_V8HI,
+	VXOR_V4SI_UNS, VXOR_V4SI, VXOR_V2DI_UNS, VXOR_V2DI, VXOR_V4SF,
+	VXOR_V2DF): Add definitions.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins)
+	<ALTIVEC_BUILTIN_VAND, ALTIVEC_BUILTIN_VANDC, ALTIVEC_BUILTIN_VNOR,
+	ALTIVEC_BUILTIN_VOR, ALTIVEC_BUILTIN_VXOR>: Remove.
+	<ALTIVEC_BUILTIN_VAND_V4SF, ALTIVEC_BUILTIN_VAND_V2DF,
+	ALTIVEC_BUILTIN_VAND_V2DI, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
+	ALTIVEC_BUILTIN_VAND_V4SI_UNS, ALTIVEC_BUILTIN_VAND_V4SI,
+	ALTIVEC_BUILTIN_VAND_V8HI_UNS, ALTIVEC_BUILTIN_VAND_V8HI,
+	ALTIVEC_BUILTIN_VAND_V16QI, ALTIVEC_BUILTIN_VAND_V16QI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V4SF, ALTIVEC_BUILTIN_VANDC_V2DF,
+	ALTIVEC_BUILTIN_VANDC_V2DI, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V4SI_UNS, ALTIVEC_BUILTIN_VANDC_V4SI,
+	ALTIVEC_BUILTIN_VANDC_V8HI_UNS, ALTIVEC_BUILTIN_VANDC_V8HI,
+	ALTIVEC_BUILTIN_VANDC_V16QI, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V4SF, ALTIVEC_BUILTIN_VNOR_V2DF,
+	ALTIVEC_BUILTIN_VNOR_V2DI, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V4SI, ALTIVEC_BUILTIN_VNOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V8HI, ALTIVEC_BUILTIN_VNOR_V8HI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V16QI, ALTIVEC_BUILTIN_VNOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VOR_V4SF, ALTIVEC_BUILTIN_VOR_V2DF,
+	ALTIVEC_BUILTIN_VOR_V2DI, ALTIVEC_BUILTIN_VOR_V2DI_UNS,
+	ALTIVEC_BUILTIN_VOR_V4SI_UNS, ALTIVEC_BUILTIN_VOR_V4SI,
+	ALTIVEC_BUILTIN_VOR_V8HI_UNS, ALTIVEC_BUILTIN_VOR_V8HI,
+	ALTIVEC_BUILTIN_VOR_V16QI, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V4SF, ALTIVEC_BUILTIN_VXOR_V2DF,
+	ALTIVEC_BUILTIN_VXOR_V2DI, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V4SI_UNS, ALTIVEC_BUILTIN_VXOR_V4SI,
+	ALTIVEC_BUILTIN_VXOR_V8HI, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V16QI, ALTIVEC_BUILTIN_VXOR_V16QI_UNS>: Add
+	definitions.
+	<P8V_BUILTIN_EQV_V16QI, P8V_BUILTIN_EQV_V8HI, P8V_BUILTIN_EQV_V4SI,
+	P8V_BUILTIN_EQV_V2DI, P8V_BUILTIN_NAND_V16QI, P8V_BUILTIN_NAND_V8HI,
+	P8V_BUILTIN_NAND_V4SI, P8V_BUILTIN_NAND_V2DI, P8V_BUILTIN_ORC_V16QI,
+	P8V_BUILTIN_ORC_V8HI, P8V_BUILTIN_ORC_V4SI,
+	P8V_BUILTIN_ORC_V2DI>: Change unsigned usages to use the new *_UNS
+	definition names.
+	* config/rs6000/rs6000.c
+	(rs6000_gimple_fold_builtin) <ALTIVEC_BUILTIN_VAND_V16QI_UNS,
+	ALTIVEC_BUILTIN_VAND_V16QI, ALTIVEC_BUILTIN_VAND_V8HI_UNS,
+	ALTIVEC_BUILTIN_VAND_V8HI, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
+	ALTIVEC_BUILTIN_VAND_V4SI, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
+	ALTIVEC_BUILTIN_VAND_V2DI, ALTIVEC_BUILTIN_VAND_V4SF,
+	ALTIVEC_BUILTIN_VAND_V2DF, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V16QI, ALTIVEC_BUILTIN_VANDC_V8HI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V8HI, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V4SI, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V2DI, ALTIVEC_BUILTIN_VANDC_V4SF,
+	ALTIVEC_BUILTIN_VANDC_V2DF, P8V_BUILTIN_NAND_V16QI_UNS,
+	P8V_BUILTIN_NAND_V8HI_UNS, P8V_BUILTIN_NAND_V4SI_UNS,
+	P8V_BUILTIN_NAND_V2DI_UNS, P8V_BUILTIN_NAND_V2DI,
+	ALTIVEC_BUILTIN_VOR_V16QI_UNS, ALTIVEC_BUILTIN_VOR_V16QI,
+	ALTIVEC_BUILTIN_VOR_V8HI_UNS, ALTIVEC_BUILTIN_VOR_V8HI,
+	ALTIVEC_BUILTIN_VOR_V4SI_UNS, ALTIVEC_BUILTIN_VOR_V4SI,
+	ALTIVEC_BUILTIN_VOR_V2DI_UNS, ALTIVEC_BUILTIN_VOR_V2DI,
+	ALTIVEC_BUILTIN_VOR_V4SF, ALTIVEC_BUILTIN_VOR_V2DF,
+	P8V_BUILTIN_ORC_V16QI_UNS, P8V_BUILTIN_ORC_V8HI_UNS,
+	P8V_BUILTIN_ORC_V4SI_UNS, P8V_BUILTIN_ORC_V2DI_UNS,
+	P8V_BUILTIN_ORC_V2DI, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V16QI, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V8HI, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V4SI, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V2DI, ALTIVEC_BUILTIN_VXOR_V4SF,
+	ALTIVEC_BUILTIN_VXOR_V2DF, ALTIVEC_BUILTIN_VNOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V16QI, ALTIVEC_BUILTIN_VNOR_V8HI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V8HI, ALTIVEC_BUILTIN_VNOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V4SI, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V2DI, ALTIVEC_BUILTIN_VNOR_V4SF,
+	ALTIVEC_BUILTIN_VNOR_V2DF>: Use new definition names.
+	(builtin_function_type) <ALTIVEC_BUILTIN_VAND_V16QI_UNS,
+	ALTIVEC_BUILTIN_VAND_V8HI_UNS, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
+	ALTIVEC_BUILTIN_VAND_V2DI_UNS, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V8HI_UNS, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
+	ALTIVEC_BUILTIN_VANDC_V2DI_UNS, ALTIVEC_BUILTIN_VNOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V8HI_UNS, ALTIVEC_BUILTIN_VNOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VNOR_V2DI_UNS, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VOR_V8HI_UNS, ALTIVEC_BUILTIN_VOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VOR_V2DI_UNS, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V8HI_UNS, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
+	ALTIVEC_BUILTIN_VXOR_V2DI_UNS, P8V_BUILTIN_EQV_V16QI_UNS,
+	P8V_BUILTIN_EQV_V8HI_UNS, P8V_BUILTIN_EQV_V4SI_UNS,
+	P8V_BUILTIN_EQV_V2DI_UNS, P8V_BUILTIN_EQV_V1TI_UNS,
+	P8V_BUILTIN_NAND_V16QI_UNS, P8V_BUILTIN_NAND_V8HI_UNS,
+	P8V_BUILTIN_NAND_V4SI_UNS, P8V_BUILTIN_NAND_V2DI_UNS,
+	P8V_BUILTIN_NAND_V1TI_UNS, P8V_BUILTIN_ORC_V16QI_UNS,
+	P8V_BUILTIN_ORC_V8HI_UNS, P8V_BUILTIN_ORC_V4SI_UNS,
+	P8V_BUILTIN_ORC_V2DI_UNS, P8V_BUILTIN_ORC_V1TI_UNS>: Handle unsigned
+	builtins.
+
+2020-08-27  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backported from master:
+	2020-08-24  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/94538
+	PR target/94538
+	* config/arm/thumb1.md: Disable set-constant splitter when
+	TARGET_HAVE_MOVT.
+	(thumb1_movsi_insn): Fix -mpure-code
+	alternative.
+
+2020-08-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-08-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* doc/extend.texi: Update links to Arm docs.
+	* doc/invoke.texi: Likewise.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-08-03  Tamar Christina  <tamar.christina@arm.com>
+
+	* config/aarch64/driver-aarch64.c (readline): Check return value fgets.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* doc/sourcebuild.texi (dg-set-compiler-env-var,
+	dg-set-target-env-var): Document.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* config/arm/driver-arm.c (host_detect_local_cpu): Add GCC_CPUINFO.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* config/aarch64/driver-aarch64.c (host_detect_local_cpu):
+	Add GCC_CPUINFO.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* config/aarch64/driver-aarch64.c (INCLUDE_SET): New.
+	(parse_field): Use std::string.
+	(split_words, readline, find_field): New.
+	(host_detect_local_cpu): Fix truncation issues.
+
+2020-08-18  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96536
+	* config/i386/i386.md (restore_stack_nonlocal):
+	Add missing compare RTX.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-08-06  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/96191
+	* config/arm/arm.md (arm_stack_protect_test_insn): Zero out
+	operand 2 after use.
+	* config/arm/thumb1.md (thumb1_stack_protect_test_insn): Likewise.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-08-05  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/96191
+	* config/aarch64/aarch64.md (stack_protect_test_<mode>): Set the
+	CC register directly, instead of a GPR.  Replace the original GPR
+	destination with an extra scratch register.  Zero out operand 3
+	after use.
+	(stack_protect_test): Update accordingly.
+
+2020-08-07  Qian Jianhua  <qianjh@cn.fujitsu.com>
+
+	Backported from master:
+	2020-08-03  Qian jianhua  <qianjh@cn.fujitsu.com>
+
+	* config/aarch64/aarch64-cores.def (a64fx): New core.
+	* config/aarch64/aarch64-tune.md: Regenerated.
+	* config/aarch64/aarch64.c (a64fx_prefetch_tune, a64fx_tunings): New.
+	* doc/invoke.texi: Add a64fx to the list.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-04-16  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/94605
+	* early-remat.c (early_remat::process_block): Handle insns that
+	set multiple candidate registers.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-07-13  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/95114
+	* tree.h (virtual_method_call_p): Add a default-false parameter
+	that indicates whether the function is being called from dump
+	routines.
+	(obj_type_ref_class): Likewise.
+	* tree.c (virtual_method_call_p): Likewise.
+	* ipa-devirt.c (obj_type_ref_class): Likewise.  Lazily add ODR
+	type information for the type when the parameter is false.
+	* tree-pretty-print.c (dump_generic_node): Update calls to
+	virtual_method_call_p and obj_type_ref_class accordingly.
+
+2020-08-04  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	* config/aarch64/aarch64-protos.h (aarch64_indirect_call_asm):
+	New declaration.
+	* config/aarch64/aarch64.c (aarch64_regno_regclass): Handle new
+	stub registers class.
+	(aarch64_class_max_nregs): Likewise.
+	(aarch64_register_move_cost): Likewise.
+	(aarch64_sls_shared_thunks): Global array to store stub labels.
+	(aarch64_sls_emit_function_stub): New.
+	(aarch64_create_blr_label): New.
+	(aarch64_sls_emit_blr_function_thunks): New.
+	(aarch64_sls_emit_shared_blr_thunks): New.
+	(aarch64_asm_file_end): New.
+	(aarch64_indirect_call_asm): New.
+	(TARGET_ASM_FILE_END): Use aarch64_asm_file_end.
+	(TARGET_ASM_FUNCTION_EPILOGUE): Use
+	aarch64_sls_emit_blr_function_thunks.
+	* config/aarch64/aarch64.h (STB_REGNUM_P): New.
+	(enum reg_class): Add STUB_REGS class.
+	(machine_function): Introduce `call_via` array for
+	function-local stub labels.
+	* config/aarch64/aarch64.md (*call_insn, *call_value_insn): Use
+	aarch64_indirect_call_asm to emit code when hardening BLR
+	instructions.
+	* config/aarch64/constraints.md (Ucr): New constraint
+	representing registers for indirect calls.  Is GENERAL_REGS
+	usually, and STUB_REGS when hardening BLR instruction against
+	SLS.
+	* config/aarch64/predicates.md (aarch64_general_reg): STUB_REGS class
+	is also a general register.
+
+2020-08-04  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	* config/aarch64/aarch64-protos.h (aarch64_sls_barrier): New.
+	* config/aarch64/aarch64.c (aarch64_output_casesi): Emit
+	speculation barrier after BR instruction if needs be.
+	(aarch64_trampoline_init): Handle ptr_mode value & adjust size
+	of code copied.
+	(aarch64_sls_barrier): New.
+	(aarch64_asm_trampoline_template): Add needed barriers.
+	* config/aarch64/aarch64.h (AARCH64_ISA_SB): New.
+	(TARGET_SB): New.
+	(TRAMPOLINE_SIZE): Account for barrier.
+	* config/aarch64/aarch64.md (indirect_jump, *casesi_dispatch,
+	simple_return, *do_return, *sibcall_insn, *sibcall_value_insn):
+	Emit barrier if needs be, also account for possible barrier using
+	"sls_length" attribute.
+	(sls_length): New attribute.
+	(length): Determine default using any non-default sls_length
+	value.
+
+2020-08-04  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	* config/aarch64/aarch64-protos.h (aarch64_harden_sls_retbr_p):
+	New.
+	(aarch64_harden_sls_blr_p): New.
+	* config/aarch64/aarch64.c (enum aarch64_sls_hardening_type):
+	New.
+	(aarch64_harden_sls_retbr_p): New.
+	(aarch64_harden_sls_blr_p): New.
+	(aarch64_validate_sls_mitigation): New.
+	(aarch64_override_options): Parse options for SLS mitigation.
+	* config/aarch64/aarch64.opt (-mharden-sls): New option.
+	* doc/invoke.texi: Document new option.
+
+2020-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/cpp.texi (Variadic Macros): Use the exact ... token in
+	code examples.
+
+2020-07-23  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backported from master:
+	2020-03-06  David Edelsohn  <dje.gcc@gmail.com>
+
+	PR target/94065
+	* config/rs6000/aix61.h (TARGET_NO_SUM_IN_TOC): Set to 1 for
+	cmodel=large.
+	(TARGET_NO_FP_IN_TOC): Same.
+	* config/rs6000/aix71.h: Same.
+	* config/rs6000/aix72.h: Same.
+
+2020-07-17  Romain Naour  <romain.naour@gmail.com>
+
+	Backported from master:
+	2020-07-17  Romain Naour  <romain.naour@gmail.com>
+
+	* Makefile.in (SELFTEST_DEPS): Move before including language makefile
+	fragments.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Add
+	__ARM_FEATURE_PAC_DEFAULT support.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94891
+	* doc/extend.texi: Update the text for  __builtin_return_address.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94891
+	* config/aarch64/aarch64.c (aarch64_return_address_signing_enabled):
+	Disable return address signing if __builtin_eh_return is used.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94891
+	PR target/94791
+	* config/aarch64/aarch64-protos.h (aarch64_return_addr_rtx): Declare.
+	* config/aarch64/aarch64.c (aarch64_return_addr_rtx): New.
+	(aarch64_return_addr): Use aarch64_return_addr_rtx.
+	* config/aarch64/aarch64.h (PROFILE_HOOK): Likewise.
+
+2020-07-16  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2020-06-16  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config.in: Regenerate.
+	* config/s390/s390.c (print_operand): Emit vector alignment hints
+	for target z13, if AS accepts them.  For other targets the logic
+	stays the same.
+	* config/s390/s390.h (TARGET_VECTOR_LOADSTORE_ALIGNMENT_HINTS): Define
+	macro.
+	* configure: Regenerate.
+	* configure.ac: Check HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS_ON_Z13.
+
+2020-07-10  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_vmsumudm): New define.
+	* config/rs6000/altivec.md (UNSPEC_VMSUMUDM): New unspec.
+	  (altivec_vmsumudm): New define_insn.
+	* config/rs6000/rs6000-builtin.def (altivec_vmsumudm): New BU_ALTIVEC_3
+	  entry. (vmsumudm): New BU_ALTIVEC_OVERLOAD_3 entry.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	  entries for ALTIVEC_BUILTIN_VMSUMUDM variants of vec_msum.
+	* doc/extend.texi: Add document for vmsumudm behind vmsum.
+
+2020-07-10  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2020-07-09  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/95804
+	* tree-loop-distribution.c (break_alias_scc_partitions): Force
+	negative post order to reduction partition.
+
+2020-07-10  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2020-06-20  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/95638
+	* tree-loop-distribution.c (pg_edge_callback_data): New field.
+	(loop_distribution::break_alias_scc_partitions): Record and restore
+	postorder information.  Fix memory leak.
+
+2020-07-06  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/94954
+	* config/rs6000/altivec.h (vec_pack_to_short_fp32): Update.
+	* config/rs6000/altivec.md (UNSPEC_CONVERT_4F32_8F16): New unspec.
+	(convert_4f32_8f16): New define_expand
+	* config/rs6000/rs6000-builtin.def (convert_4f32_8f16): New builtin define
+	and overload.
+	* config/rs6000/rs6000-c.c (P9V_BUILTIN_VEC_CONVERT_4F32_8F16): New
+	overloaded builtin entry.
+	* config/rs6000/vsx.md (UNSPEC_VSX_XVCVSPHP): New unspec.
+	(vsx_xvcvsphp): New define_insn.
+
+2020-06-30  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2020-05-18  Alex Coplan  <alex.coplan@arm.com>
+
+	* config/arm/arm.c (output_move_double): Fix codegen when loading into
+	a register pair with an odd base register.
+
+2020-06-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2020-06-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/95874
+	* config/i386/i386.h (PTA_ICELAKE_CLIENT): Remove PTA_CLWB.
+	(PTA_ICELAKE_SERVER): Add PTA_CLWB.
+
+2020-06-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-06-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* hsa-gen.c (gen_hsa_insns_for_call): Move 'function_decl ==
+	NULL_TREE' check earlier.
+
+2020-06-12  Martin Liska  <mliska@suse.cz>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/95634
+	* asan.c (asan_emit_stack_protection): Fix emission for ilp32
+	by using Pmode instead of ptr_mode.
+
+2020-06-12  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/94910
+	* asan.c (asan_emit_stack_protection): Emit
+	also **SavedFlagPtr(FakeStack, class_id) = 0 in order to release
+	a stack frame.
+
+2020-06-06  Carl Love  <cel@us.ibm.com>
+
+	PR target/94833
+	* config/rs6000/vsx.md (define_expand): Fix instruction generation for
+	first_match_index_<mode>.
+
+2020-06-05  H.J. Lu  <hjl.tools@gmail.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Support
+	Intel Airmont, Tremont, Comet Lake, Ice Lake and Tiger Lake
+	processor families.
+
+2020-06-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (zeus): Define.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi (AArch64 Options): Document zeus -mcpu option.
+
+2020-05-31  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* config/i386/i386-c.c (ix86_target_macros): Define _ILP32 and
+	__ILP32__ for 32-bit targets.
+
+2020-05-29  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/94591
+	* config/aarch64/aarch64.c (aarch64_evpc_rev_local): Don't match
+	identity permutation.
+
+2020-05-29  Dong JianQiang  <dongjianqiang2@huawei.com>
+
+	PR gcov-profile/95332
+	* gcov-io.c (gcov_var::endian): Move field.
+	(from_file): Add IN_GCOV_TOOL check.
+	* gcov-io.h (gcov_magic): Ditto.
+
+2020-05-26  Alexandre Oliva  <oliva@adacore.com>
+
+	PR target/94812
+	* config/rs6000/rs6000.md (rs6000_mffsl): Copy result to
+	output operand in emulation.  Don't overwrite pseudos.
+
+2020-05-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/95258
+	* config/i386/driver-i386.c (host_detect_local_cpu): Detect
+	AVX512VPOPCNTDQ.
+
+2020-05-22  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backport from master
+	PR tree-optimization/94969
+	2020-05-13  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	* tree-data-ref.c (constant_access_functions): Rename to...
+	(invariant_access_functions): ...this.  Add parameter.  Check for
+	invariant access function, rather than constant.
+	(build_classic_dist_vector): Call above function.
+	* tree-loop-distribution.c (pg_add_dependence_edges): Add comment.
+
+2020-05-21  Martin Liska  <mliska@suse.cz>
+
+	* common/config/aarch64/aarch64-common.c (aarch64_handle_option):
+	Use MASK_OUTLINE_ATOMICS for x_target_flags.
+
+2020-05-21  Martin Liska  <mliska@suse.cz>
+
+	* common/config/aarch64/aarch64-common.c (aarch64_handle_option):
+	Handle OPT_moutline_atomics.
+	* config/aarch64/aarch64.c: Add outline-atomics to
+	aarch64_attributes.
+	* doc/extend.texi: Document the newly added target attribute.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-30  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94748
+	* config/aarch64/aarch64-bti-insert.c (rest_of_insert_bti): Remove
+	the check for NOTE_INSN_DELETED_LABEL.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-23  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94697
+	* config/aarch64/aarch64-bti-insert.c (rest_of_insert_bti): Swap
+	bti c and bti j handling.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-27  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94515
+	* dwarf2cfi.c (struct GTY): Add ra_mangled.
+	(cfi_row_equal_p): Check ra_mangled.
+	(dwarf2out_frame_debug_cfa_window_save): Remove the argument,
+	this only handles the sparc logic now.
+	(dwarf2out_frame_debug_cfa_toggle_ra_mangle): New function for
+	the aarch64 specific logic.
+	(dwarf2out_frame_debug): Update to use the new subroutines.
+	(change_cfi_row): Check ra_mangled.
+
+2020-05-12  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2020-04-08  Clement Chigot  <clement.chigot@atos.net>
+
+        * config/rs6000/aix61.h (LIB_SPEC): Add -lc128 with -mlong-double-128.
+        * config/rs6000/aix71.h (LIB_SPEC): Likewise.
+        * config/rs6000/aix72.h (LIB_SPEC): Likewise.
+
+2020-05-12  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2020-05-04  Clement Chigot  <clement.chigot@atos.net>
+		    David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/rs6000.c (rs6000_init_builtins): Override explicit
+	for fmodl, frexpl, ldexpl and modfl builtins.
+
+2020-05-11  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from master.
+	2020-04-27  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	PR target/91518
+	* config/rs6000/rs6000.c (frame_pointer_needed_indeed):
+	New variable.
+	(rs6000_emit_prologue_components):
+	Check with frame_pointer_needed_indeed.
+	(rs6000_emit_epilogue_components): Likewise.
+	(rs6000_emit_prologue): Likewise.
+	(rs6000_emit_epilogue): Set frame_pointer_needed_indeed.
+
+2020-05-07 Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_atomic_assign_expand_fenv): Use
+	TARGET_EXPR instead of MODIFY_EXPR for the first assignments to
+	fenv_var and new_fenv_var.
+
+2020-05-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/constraints.md ("j>f", "jb4"): New constraints.
+	* config/s390/vecintrin.h (vec_load_len_r, vec_store_len_r): Fix
+	macro definitions.
+	* config/s390/vx-builtins.md ("vlrlrv16qi", "vstrlrv16qi"): Add a
+	separate expander.
+	("*vlrlrv16qi", "*vstrlrv16qi"): Add alternative for vl/vst.
+	Change constraint for vlrl/vstrl to jb4.
+
+2020-05-04  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vector.md ("popcountv8hi2_vx", "popcountv4si2_vx")
+	("popcountv2di2_vx"): Use simplify_gen_subreg.
+
+2020-05-04  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/94613
+	* config/s390/s390-builtin-types.def: Add 3 new function modes.
+	* config/s390/s390-builtins.def: Add mode dependent low-level
+	builtin and map the overloaded builtins to these.
+	* config/s390/vx-builtins.md ("vec_selV_HW"): Rename to ...
+	("vsel<V_HW"): ... this and rewrite the pattern with bitops.
+
+2020-05-04  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/93674
+	Backport from master
+	2020-04-09  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	* tree-ssa-loop-ivopts.c (langhooks.h): New include.
+	(add_iv_candidate_for_use): For iv_use of non integer or pointer type,
+	or non-mode precision type, add candidate in unsigned type with the
+	same precision.
+
+2020-05-01  Alan Modra	 <amodra@gmail.com>
+
+	PR target/94145
+	Backport from master
+	2020-03-27  Alan Modra	 <amodra@gmail.com>
+
+	* config/rs6000/rs6000.c (rs6000_longcall_ref): Use unspec_volatile
+	for PLT16_LO.
+	* config/rs6000/rs6000.md (UNSPEC_PLT16_LO): Remove.
+	(UNSPECV_PLT16_LO): Define.
+	(pltseq_plt16_lo_): Use unspec_volatile.
+
+2020-04-30  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/emmintrin.h (_mm_movemask_epi8): Fix comment.
+
+2020-04-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-04-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93654
+	* config/i386/i386.c (ix86_set_indirect_branch_type): Allow
+	-fcf-protection with -mindirect-branch=thunk-extern and
+	-mfunction-return=thunk-extern.
+	* doc/invoke.texi: Update notes for -fcf-protection=branch with
+	-mindirect-branch=thunk-extern and -mindirect-return=thunk-extern.
+
+2020-04-21  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from master
+	2020-04-09  Martin Jambor  <mjambor@suse.cz>
+	            Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/94482
+	* tree-sra.c (create_access_replacement): Dump new replacement with
+	TDF_UID.
+	(sra_modify_expr): Fix handling of cases when the original EXPR writes
+	to only part of the replacement.
+	* tree-ssa-forwprop.c (pass_forwprop::execute): Properly verify
+	the first operand of combinations into REAL/IMAGPART_EXPR and
+	BIT_FIELD_REF.
+
+2020-04-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-04-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/94556
+	* config/i386/i386.c (ix86_expand_epilogue): Restore the frame
+	pointer in word_mode for eh_return epilogues.
+
+2020-04-20  Andrea Corallo  <andrea.corallo@arm.com>
+
+	Backport from mainline.
+	2020-04-15  Andrea Corallo  <andrea.corallo@arm.com>
+
+	PR target/94530
+	* config/aarch64/falkor-tag-collision-avoidance.c
+	(valid_src_p): Check for aarch64_address_info type before
+	accessing base field.
+
+2020-04-20  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from mainline.
+	2020-04-03  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/94396
+	* common/config/aarch64/aarch64-common.c
+	(aarch64_get_extension_string_for_isa_flags): Handle default flags.
+
+2020-04-20  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-04-17  Martin Liska  <mliska@suse.cz>
+		    Jonathan Yong <10walls@gmail.com>
+
+	PR gcov-profile/94570
+	* coverage.c (coverage_init): Use separator properly.
+
+2020-04-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-04-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/94417
+	* config/i386/i386.c (rest_of_insert_endbranch): Insert ENDBR at
+	function entry if function will be called indirectly.
+
+2020-04-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2020-04-03  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR tree-optimization/94443
+	* tree-vect-loop.c (vectorizable_live_operation): Use
+	gsi_insert_seq_before to replace gsi_insert_before.
+
+2020-04-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2020-04-01  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR tree-optimization/94043
+	* tree-vect-loop.c (vectorizable_live_operation): Generate loop-closed
+	phi for vec_lhs and use it for lane extraction.
+
+2020-04-16  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/94557
+	* config/rs6000/rs6000.c (rs6000_adjust_vec_address): Fix
+	regression caused by PR target/93932 backport.  Mask variable
+	vector extract index so it does not go beyond the vector when
+	extracting a vector element from memory.
+
+2020-04-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-04-07  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/94479
+	* gimplify.c (gimplify_addr_expr): Also consider generated
+	MEM_REFs.
+
+2020-04-15  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline.
+	2020-04-14  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR target/94584
+	* config/xtensa/xtensa.md (zero_extendhisi2, zero_extendqisi2)
+	(extendhisi2_internal): Add %v1 before the load instructions.
+
+2020-04-15  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline.
+	2019-09-26  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (hwloop_optimize): Insert zero overhead
+	loop instruction into new basic block before the loop when basic
+	block that precedes the loop is empty.
+
+2020-04-15  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/94603
+	* config/i386/i386-builtin.def (__builtin_ia32_movq128):
+	Require OPTION_MASK_ISA_SSE2.
+
+2020-04-11  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/94494
+	* config/i386/sse.md (REDUC_SSE_SMINMAX_MODE): Use TARGET_SSE2
+	condition for V4SI, V8HI and V16QI modes.
+
+2020-04-10  Claudiu Zissulescu  <claziss@synopsys.com>
+
+	Backport from trunk
+	2020-0-31  Vineet Gupta <vgupta@synopsys.com>
+	* config/arc/linux.h: GLIBC_DYNAMIC_LINKER support BE/arc700.
+
+2020-04-09  Michael Meissner  <meissner@linux.ibm.com>
+
+	Back port from trunk
+	2020-02-26  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/93932
+	* config/rs6000/vsx.md (vsx_extract_<mode>_var, VSX_D iterator):
+	Split the insn into two parts.  This insn only does variable
+	extract from a register.
+	(vsx_extract_<mode>_var_load, VSX_D iterator): New insn, do
+	variable extract from memory.
+	(vsx_extract_v4sf_var): Split the insn into two parts.  This insn
+	only does variable extract from a register.
+	(vsx_extract_v4sf_var_load): New insn, do variable extract from
+	memory.
+	(vsx_extract_<mode>_var, VSX_EXTRACT_I iterator): Split the insn
+	into two parts.  This insn only does variable extract from a
+	register.
+	(vsx_extract_<mode>_var_load, VSX_EXTRACT_I iterator): New insn,
+	do variable extract from memory.
+
+2020-04-07  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from mainline.
+	2020-03-23  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/rs6000-call.c altivec_init_builtins(): Remove
+	code to skip defining builtins based on builtin_mask.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94509
+	* config/i386/i386.c (expand_vec_perm_pshufb): Fix the check
+	for inter-lane permutation for 64-byte modes.
+
+	PR target/94488
+	* config/aarch64/aarch64-simd.md (ashl<mode>3, lshr<mode>3,
+	ashr<mode>3): Force operands[2] into reg whenever it is not CONST_INT.
+	Assume it is a REG after that instead of testing it and doing FAIL
+	otherwise.  Formatting fix.
+
+	Backported from mainline
+	2020-04-04  Hannes Domani  <ssbssa@yahoo.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94459
+	* dwarf2out.c (gen_subprogram_die): Look through references, pointers,
+	arrays, pointer-to-members, function types and qualifiers when
+	checking if in-class DIE had an 'auto' or 'decltype(auto)' return type
+	to emit type again on definition.
+
+	2020-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94460
+	* config/i386/sse.md (avx2_ph<plusminus_mnemonic>wv16hi3,
+	avx2_ph<plusminus_mnemonic>dv8si3): Fix up RTL pattern to do
+	second half of first lane from first lane of second operand and
+	first half of second lane from second lane of first operand.
+
+	2020-04-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94423
+	* tree-object-size.c (pass_object_sizes::execute): Don't call
+	replace_uses_by for SSA_NAME_OCCURS_IN_ABNORMAL_PHI lhs, instead
+	call replace_call_with_value.
+
+	2020-03-31  Marc Glisse  <marc.glisse@inria.fr>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94412
+	* fold-const.c (fold_binary_loc) <case TRUNC_DIV_EXPR>: Use
+	ANY_INTEGRAL_TYPE_P instead of INTEGRAL_TYPE_P.
+
+	2020-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93069
+	* config/i386/sse.md (vec_extract_lo_<mode><mask_name>): Use
+	<store_mask_constraint> instead of m in output operand constraint.
+	(vec_extract_hi_<mode><mask_name>): Use <mask_operand2> instead of
+	%{%3%}.
+
+	2020-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94329
+	* tree-ssa-reassoc.c (reassociate_bb): When calling reassoc_remove_stmt
+	on the last stmt in a bb, make sure gsi_prev isn't done immediately
+	after gsi_last_bb.
+
+	2020-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94303
+	* varasm.c (output_constructor_array_range): If local->index
+	RANGE_EXPR doesn't start at the current location in the constructor,
+	skip needed number of bytes using assemble_zeros or assert we don't
+	go backwards.
+
+	2020-03-25  Richard Biener  <rguenther@suse.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94283
+	* tree-if-conv.c (ifcvt_local_dce): Delete dead statements backwards.
+
+	2020-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94283
+	* tree-if-conv.c (ifcvt_local_dce): For gimple debug stmts, just set
+	GF_PLF_2, but don't add them to worklist.  Don't add an assigment to
+	worklist or set GF_PLF_2 just because it is used in a debug stmt in
+	another bb.  Formatting improvements.
+
+	PR debug/94277
+	* cgraphunit.c (check_global_declaration): For DECL_EXTERNAL and
+	non-TREE_PUBLIC non-DECL_ARTIFICIAL FUNCTION_DECLs, set TREE_PUBLIC
+	regardless of whether TREE_NO_WARNING is set on it or whether
+	warn_unused_function is true or not.
+
+	2020-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94211
+	* tree-ssa-phiopt.c (value_replacement): Use estimate_num_insns_seq
+	instead of estimate_num_insns for bb_seq (middle_bb).  Rename
+	emtpy_or_with_defined_p variable to empty_or_with_defined_p, adjust
+	all uses.
+
+2020-04-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/94518
+	2019-09-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/atomics.md (aarch64_store_exclusive_pair): Fix
+	memmodel index.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94500
+	* config/i386/i386.c (emit_reduc_half): For V{64QI,32HI}mode
+	handle i < 64 using avx512bw_lshrv4ti3.  Formatting fixes.
+
+2020-04-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/93435
+	* params.def (PARAM_SRA_MAX_PROPAGATIONS): New parameter.
+	* tree-sra.c (propagation_budget): New variable.
+	(budget_for_propagation_access): New function.
+	(propagate_subaccesses_across_link): Use it.
+	(propagate_all_subaccesses): Set up and destroy propagation_budget.
+	* doc/invoke.texi (sra-max-propagations): New.
+
+2020-04-03  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-04-03  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/94445
+	* ipa-icf-gimple.c (func_checker::compare_gimple_call):
+	  Compare type attributes for gimple_call_fntypes.
+
+2020-04-02  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backport from master.
+	2020-04-02  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/85982
+	* fortran/decl.c (match_attr_spec): Lump COMP_STRUCTURE/COMP_MAP into
+	attribute checking used by TYPE.
+
+2020-04-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/94103
+	* tree-ssa-sccvn.c (visit_reference_op_load): Avoid type
+	punning when the mode precision is not sufficient.
+
+	2020-03-18  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/94206
+	* gimple-fold.c (gimple_fold_builtin_memset): Avoid using
+	partial int modes or not mode-precision integer types for
+	the store.
+
+2020-04-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94435
+	* config/aarch64/aarch64.c (aarch64_gen_compare_reg_maybe_ze): For
+	y_mode E_[QH]Imode and y being a CONST_INT, change y_mode to SImode.
+
+2020-04-01  Zackery Spytz  <zspytz@gmail.com>
+
+	* doc/extend.texi: Fix a typo in the documentation of the
+	copy function attribute.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2020-03-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94368
+	* config/aarch64/constraints.md (Uph): New constraint.
+	* config/aarch64/atomics.md (cas_short_expected_imm): New mode attr.
+	(@aarch64_compare_and_swap<mode>): Use it instead of n in operand 2's
+	constraint.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2020-01-17  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/92692
+	* config/aarch64/atomics.md (aarch64_compare_and_swap<mode>)
+	Use epilogue_completed rather than reload_completed.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* config/aarch64/aarch64.opt (-moutline-atomics): New.
+	* config/aarch64/aarch64.c (aarch64_atomic_ool_func): New.
+	(aarch64_ool_cas_names, aarch64_ool_swp_names): New.
+	(aarch64_ool_ldadd_names, aarch64_ool_ldset_names): New.
+	(aarch64_ool_ldclr_names, aarch64_ool_ldeor_names): New.
+	(aarch64_expand_compare_and_swap): Honor TARGET_OUTLINE_ATOMICS.
+	* config/aarch64/atomics.md (atomic_exchange<ALLI>): Likewise.
+	(atomic_<atomic_op><ALLI>): Likewise.
+	(atomic_fetch_<atomic_op><ALLI>): Likewise.
+	(atomic_<atomic_op>_fetch<ALLI>): Likewise.
+	* doc/invoke.texi: Document -moutline-atomics.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* config/aarch64/aarch64 (aarch64_split_compare_and_swap): Disable
+	strong_zero_p for aarch64_track_speculation; unify some code paths;
+	use aarch64_gen_compare_reg instead of open-coding.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* config/aarch64/aarch64.c (aarch64_gen_compare_reg): Add support
+	for NE comparison of TImode values.
+	(aarch64_emit_load_exclusive): Add support for TImode.
+	(aarch64_emit_store_exclusive): Likewise.
+	(aarch64_split_compare_and_swap): Disable strong_zero_p for TImode.
+	* config/aarch64/atomics.md (@atomic_compare_and_swap<ALLI_TI>):
+	Change iterator from ALLI to ALLI_TI.
+	(@atomic_compare_and_swap<JUST_TI>): New.
+	(@atomic_compare_and_swap<JUST_TI>_lse): New.
+	(aarch64_load_exclusive_pair): New.
+	(aarch64_store_exclusive_pair): New.
+	* config/aarch64/iterators.md (JUST_TI): New.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* config/aarch64/aarch64.c (aarch64_print_operand): Allow integer
+	registers with %R.
+
+2020-03-31  Carl Love  <cel@us.ibm.com>
+
+	Backport of:
+	  commit e97929e20b2f52e6cfc046c1302324d1b24d95e3
+	  Author: Carl Love <carll@us.ibm.com>
+	  Date:   Wed Mar 25 18:33:37 2020 -0500
+
+	PR target/93819
+        * gcc/config/rs6000/altivec.h:
+        Fixed swapped arguments for vec_rlnm define.
+
+2020-03-31  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	  commit 68dd57808f7c0147acdb5ca72c88ff655afcb0ce
+	  Author: Carl Love <carll@us.ibm.com>
+	  Date:   Fri Mar 20 18:15:05 2020 -0500
+	with ChangeLog typo fixed.
+
+	PR target/87583
+	* gcc/config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Add check for TARGET_FPRND for Power 7 or newer.
+
+2020-03-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR lto/94249
+	* config/pa/pa.h (TARGET_CPU_CPP_BUILTINS): Define __BIG_ENDIAN__.
+
+2020-03-24  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/94052
+	* config/aarch64/aarch64-simd.md (mov<mode>): Remove paradoxical
+	subregs of VSTRUCT modes.
+
+2020-03-24  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backport from mainline
+	2020-03-16  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/94125
+	* tree-loop-distribution.c
+	(loop_distribution::break_alias_scc_partitions): Update post order
+	number for merged scc.
+
+2020-03-23  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from mainline
+	2020-03-10  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/90763
+	    * config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	    Add clause to handle P9V_BUILTIN_VEC_LXVL with const arguments.
+
+2020-03-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from master.
+	2020-03-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (JUMP_TABLES_IN_TEXT_SECTION): Remove
+	references to Darwin.
+	* config/i386/i386.h (JUMP_TABLES_IN_TEXT_SECTION): Define this
+	unconditionally and comment on why.
+
+2020-03-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR driver/92757
+	* doc/invoke.texi (Warning Options): Add caveat about some warnings
+	depending on optimization settings.
+
+2020-03-19  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/93709
+	* gcc/config/rs6000/rs6000.c (rs6000_emit_p9_fp_minmax): Check
+	NAN and SIGNED_ZEROR for smax/smin.
+
+2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94189
+	* builtins.c (expand_builtin_strnlen): Do return NULL_RTX if we would
+	emit a warning if it was enabled and don't depend on TREE_NO_WARNING
+	for code-generation.
+
+	Backported from mainline
+	2020-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94167
+	* tree-inline.c (insert_init_stmt): Don't gimple_regimplify_operands
+	DEBUG_STMTs.
+
+	2020-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93566
+	* tree-nested.c (convert_nonlocal_omp_clauses,
+	convert_local_omp_clauses): Handle {,in_,task_}reduction clauses
+	with C/C++ array sections.
+
+	2020-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94121
+	* config/aarch64/aarch64.c (aarch64_add_offset_1): Use gen_int_mode
+	instead of GEN_INT.
+
+	2020-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* doc/tm.texi.in (ASM_OUTPUT_ALIGNED_DECL_LOCAL): Change
+	ASM_OUTPUT_ALIGNED_DECL in description to ASM_OUTPUT_ALIGNED_LOCAL
+	and ASM_OUTPUT_DECL to ASM_OUTPUT_LOCAL.
+	* doc/tm.texi: Regenerated.
+
+	PR tree-optimization/94130
+	* tree-ssa-dse.c: Include gimplify.h.
+	(increment_start_addr): If stmt has lhs, drop the lhs from call and
+	set it after the call to the original value of the first argument.
+	Formatting fixes.
+	(decrement_count): Formatting fix.
+
+	2020-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94134
+	* config/pdp11/pdp11.c (pdp11_asm_output_var): Call switch_to_section
+	at the start to switch to data section.  Don't print extra newline if
+	.globl directive has not been emitted.
+
+	PR target/94121
+	* config/aarch64/aarch64.c (aarch64_add_offset_1): Use absu_hwi
+	instead of abs_hwi, change moffset type to unsigned HOST_WIDE_INT.
+
+	PR middle-end/94111
+	* dfp.c (decimal_to_binary): Only use decimal128ToString if from->cl
+	is rvc_normal, otherwise use real_to_decimal to print the number to
+	string.
+
+	PR tree-optimization/94114
+	* tree-loop-distribution.c (generate_memset_builtin): Call
+	rewrite_to_non_trapping_overflow even on mem.
+	(generate_memcpy_builtin): Call rewrite_to_non_trapping_overflow even
+	on dest and src.
+
+	2020-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93399
+	* tree-pretty-print.h (pretty_print_string): Declare.
+	* tree-pretty-print.c (pretty_print_string): Remove forward
+	declaration, no longer static.  Change nbytes parameter type
+	from unsigned to size_t.
+	* print-rtl.c (print_value) <case CONST_STRING>: Use
+	pretty_print_string and for shrink way too long strings.
+
+	2020-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/93888
+	* tree-inline.c (copy_decl_to_var): Copy DECL_BY_REFERENCE flag.
+
+	PR tree-optimization/94001
+	* tree-tailcall.c (process_assignment): Before comparing op1 to
+	*ass_var, verify *ass_var is non-NULL.
+
+2020-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/94163
+	* tree-ssa-pre.c (create_expression_by_pieces): Check
+	whether alignment would be zero.
+
+2020-03-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/94119
+	* resource.h (clear_hashed_info_until_next_barrier): Declare.
+	* resource.c (clear_hashed_info_until_next_barrier): New function.
+	* reorg.c (add_to_delay_list): Fix formatting.
+	(relax_delay_slots): Call clear_hashed_info_until_next_barrier on
+	the next instruction after removing a BARRIER.
+
+2020-03-12  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from master
+	2020-03-02  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/87560
+	* rs6000-cpus.def (OTHER_ALTIVEC_MASKS): New #define.
+	* rs6000.c (rs6000_disable_incompatible_switches): Add table entry
+	for OPTION_MASK_ALTIVEC.
+
+2020-03-12  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from master
+	2020-02-10  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/91913
+	* config/arm/arm.md (movsi_compare0): Allow SP as a source register
+	in Thumb state and also as a destination in Arm state.  Add T16
+	variants.
+
+2020-03-12  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-03-09  Martin Liska  <mliska@suse.cz>
+
+	PR target/93800
+	* config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Remove set of str_align_loops and str_align_jumps as these
+	should be set in previous 2 conditions in the function.
+
+2020-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.3.1.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index abae872cd63..35d90f12d4c 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1687,6 +1687,10 @@ $(FULL_DRIVER_NAME): ./xgcc
 	$(LN_S) $< $@
 
 #
+# SELFTEST_DEPS need to be set before including language makefile fragments.
+# Otherwise $(SELFTEST_DEPS) is empty when used from <LANG>/Make-lang.in.
+SELFTEST_DEPS = $(GCC_PASSES) stmp-int-hdrs $(srcdir)/testsuite/selftests
+
 # Language makefile fragments.
 
 # The following targets define the interface between us and the languages.
@@ -1950,8 +1954,6 @@ DEVNULL=$(if $(findstring mingw,$(build)),nul,/dev/null)
 SELFTEST_FLAGS = -nostdinc $(DEVNULL) -S -o $(DEVNULL) \
 	-fself-test=$(srcdir)/testsuite/selftests
 
-SELFTEST_DEPS = $(GCC_PASSES) stmp-int-hdrs $(srcdir)/testsuite/selftests
-
 # Run the selftests during the build once we have a driver and the frontend,
 # so that self-test failures are caught as early as possible.
 # Use "s-selftest-FE" to ensure that we only run the selftests if the
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index a819f57a2bf..9dd9f8f646a 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,100 @@
+2021-03-10  Mikael Pettersson  <mikpelinux@gmail.com>
+
+	PR bootstrap/94918
+	* raise-gcc.c: On Cygwin include mingw32.h to prevent
+	windows.h from including x86intrin.h or emmintrin.h.
+
+2021-03-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/99264
+	* init.c (__gnat_alternate_sta) [Linux]: Remove preprocessor test on
+	MINSIGSTKSZ and bump size to 32KB.
+	* libgnarl/s-osinte__linux.ads (Alternate_Stack_Size): Bump to 32KB.
+
+2021-02-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (components_to_record): If the first component
+	with rep clause is the _Parent field with variable size, temporarily
+	set it aside when computing the internal layout of the REP part again.
+	* gcc-interface/utils.c (finish_record_type): Revert to taking the
+	maximum when merging sizes for all record types with rep clause.
+	(merge_sizes): Put SPECIAL parameter last and adjust recursive calls.
+
+2021-02-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Make the
+	two fields of the fat pointer type addressable, and do not make the
+	template type read-only.
+	<E_Record_Type>: If the type has discriminants mark it as may_alias.
+	* gcc-interface/utils.c (make_dummy_type): Likewise.
+	(build_dummy_unc_pointer_types): Likewise.
+
+2021-01-26  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	PR ada/98228
+	* gcc-interface/utils.c (maybe_pad_type): Test the size of the new
+	packable type instead of its alignment for addressability's sake.
+
+2021-01-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (make_covariant_thunk): Set the DECL_CONTEXT
+	of the parameters and do not set TREE_PUBLIC on the thunk.
+	(maybe_make_gnu_thunk): Pass the alias to the covariant thunk.
+	* gcc-interface/utils.c (finish_subprog_decl): Set the DECL_CONTEXT
+	of the parameters here...
+	(begin_subprog_body): ...instead of here.
+
+2021-01-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/98740
+	* gcc-interface/trans.c (add_decl_expr): Always mark TYPE_ADA_SIZE.
+
+2020-12-10  Ed Schonberg  <schonberg@adacore.com>
+
+	PR ada/98230
+	* exp_attr.adb (Expand_N_Attribute_Reference, case Mod): Use base
+	type of argument to obtain static bound and required size.
+
+2020-12-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (maybe_make_gnu_thunk): Return false if the
+	target is local and thunk and target do not have the same context.
+
+2020-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (build_binary_op_trapv): Convert operands
+	to the result type before doing generic overflow checking.
+	* gcc-interface/utils.c (can_materialize_object_renaming_p): Add
+	pair of missing parentheses.
+
+2020-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (can_be_lower_p): Remove.
+	(Regular_Loop_to_gnu): Add ENTRY_COND unconditionally if
+	BOTTOM_COND is non-zero.
+
+2020-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Only
+	create extra subtypes for discriminants if the RM size of the base
+	type of the index type is lower than that of the index type.
+
+2020-09-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (build_subst_list): For a definition, make
+	sure to instantiate the SAVE_EXPRs generated by the elaboration of
+	the constraints in front of the elaboration of the type itself.
+
+2020-06-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Allocator>: Minor tweaks.
+	Call Has_Constrained_Partial_View on base type of designated type.
+
+2020-05-04  Mikael Pettersson  <mikpelinux@gmail.com>
+
+	PR bootstrap/94918
+	* mingw32.h: Prevent windows.h from including emmintrin.h on Cygwin64.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/ada/exp_attr.adb b/gcc/ada/exp_attr.adb
index cbf7db372ff..06a542c912f 100644
--- a/gcc/ada/exp_attr.adb
+++ b/gcc/ada/exp_attr.adb
@@ -4709,13 +4709,15 @@ package body Exp_Attr is
 
       when Attribute_Mod => Mod_Case : declare
          Arg  : constant Node_Id := Relocate_Node (First (Exprs));
-         Hi   : constant Node_Id := Type_High_Bound (Etype (Arg));
+         Hi   : constant Node_Id := Type_High_Bound (Base_Type (Etype (Arg)));
          Modv : constant Uint    := Modulus (Btyp);
 
       begin
 
          --  This is not so simple. The issue is what type to use for the
-         --  computation of the modular value.
+         --  computation of the modular value. In addition we need to use
+         --  the base type as above to retrieve a static bound for the
+         --  comparisons that follow.
 
          --  The easy case is when the modulus value is within the bounds
          --  of the signed integer type of the argument. In this case we can
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index 8118d119bab..de43c66b77c 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -2162,14 +2162,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	  }
 	else
 	  {
+	    /* We make the fields addressable for the sake of compatibility
+	       with languages for which the regular fields are addressable.  */
 	    tem
 	      = create_field_decl (get_identifier ("P_ARRAY"),
 				   ptr_type_node, gnu_fat_type,
-				   NULL_TREE, NULL_TREE, 0, 0);
+				   NULL_TREE, NULL_TREE, 0, 1);
 	    DECL_CHAIN (tem)
 	      = create_field_decl (get_identifier ("P_BOUNDS"),
 				   gnu_ptr_template, gnu_fat_type,
-				   NULL_TREE, NULL_TREE, 0, 0);
+				   NULL_TREE, NULL_TREE, 0, 1);
 	    finish_fat_pointer_type (gnu_fat_type, tem);
 	    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);
 	  }
@@ -2275,7 +2277,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	    = chainon (gnu_template_fields, gnu_temp_fields[index]);
 	finish_record_type (gnu_template_type, gnu_template_fields, 0,
 			    debug_info_p);
-	TYPE_READONLY (gnu_template_type) = 1;
 
 	/* If Component_Size is not already specified, annotate it with the
 	   size of the component.  */
@@ -2433,8 +2434,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);
 	      tree gnu_min, gnu_max, gnu_high;
 
-	      /* We try to define subtypes for discriminants used as bounds
-		 that are more restrictive than those declared by using the
+	      /* We try to create subtypes for discriminants used as bounds
+		 that are more restrictive than those declared, by using the
 		 bounds of the index type of the base array type.  This will
 		 make it possible to calculate the maximum size of the record
 		 type more conservatively.  This may have already been done by
@@ -2442,8 +2443,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 		 there will be a conversion that needs to be removed first.  */
 	      if (CONTAINS_PLACEHOLDER_P (gnu_orig_min)
 		  && TYPE_RM_SIZE (gnu_base_index_type)
-		  && !tree_int_cst_lt (TYPE_RM_SIZE (gnu_index_type),
-				       TYPE_RM_SIZE (gnu_base_index_type)))
+		  && tree_int_cst_lt (TYPE_RM_SIZE (gnu_base_index_type),
+				      TYPE_RM_SIZE (gnu_index_type)))
 		{
 		  gnu_orig_min = remove_conversions (gnu_orig_min, false);
 		  TREE_TYPE (gnu_orig_min)
@@ -2454,8 +2455,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 
 	      if (CONTAINS_PLACEHOLDER_P (gnu_orig_max)
 		  && TYPE_RM_SIZE (gnu_base_index_type)
-		  && !tree_int_cst_lt (TYPE_RM_SIZE (gnu_index_type),
-				       TYPE_RM_SIZE (gnu_base_index_type)))
+		  && tree_int_cst_lt (TYPE_RM_SIZE (gnu_base_index_type),
+				      TYPE_RM_SIZE (gnu_index_type)))
 		{
 		  gnu_orig_max = remove_conversions (gnu_orig_max, false);
 		  TREE_TYPE (gnu_orig_max)
@@ -2997,15 +2998,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 			|| Present (Parent_Subtype (gnat_entity)));
 	  }
 
-	/* Make a node for the record.  If we are not defining the record,
-	   suppress expanding incomplete types.  */
+	/* Make a node for the record type.  */
 	gnu_type = make_node (tree_code_for_record_type (gnat_entity));
 	TYPE_NAME (gnu_type) = gnu_entity_name;
 	TYPE_PACKED (gnu_type) = (packed != 0) || has_align || has_rep;
 	TYPE_REVERSE_STORAGE_ORDER (gnu_type)
 	  = Reverse_Storage_Order (gnat_entity);
+
+	/* If the record type has discriminants, pointers to it may also point
+	   to constrained subtypes of it, so mark it as may_alias for LTO.  */
+	if (has_discr)
+	  prepend_one_attribute
+	    (&attr_list, ATTR_MACHINE_ATTRIBUTE,
+	     get_identifier ("may_alias"), NULL_TREE,
+	     gnat_entity);
+
 	process_attributes (&gnu_type, &attr_list, true, gnat_entity);
 
+	/* If we are not defining it, suppress expanding incomplete types.  */
 	if (!definition)
 	  {
 	    defer_incomplete_level++;
@@ -8138,12 +8148,12 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,
   if (p_gnu_rep_list && gnu_rep_list)
     *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_rep_list);
 
-  /* Deal with the annoying case of an extension of a record with variable size
-     and partial rep clause, for which the _Parent field is forced at offset 0
-     and has variable size, which we do not support below.  Note that we cannot
-     do it if the field has fixed size because we rely on the presence of the
-     REP part built below to trigger the reordering of the fields in a derived
-     record type when all the fields have a fixed position.  */
+  /* Deal with the case of an extension of a record type with variable size and
+     partial rep clause, for which the _Parent field is forced at offset 0 and
+     has variable size.  Note that we cannot do it if the field has fixed size
+     because we rely on the presence of the REP part built below to trigger the
+     reordering of the fields in a derived record type when all the fields have
+     a fixed position.  */
   else if (gnu_rep_list
 	   && !DECL_CHAIN (gnu_rep_list)
 	   && TREE_CODE (DECL_SIZE (gnu_rep_list)) != INTEGER_CST
@@ -8161,33 +8171,52 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,
      record, before the others, if we also have fields without rep clause.  */
   else if (gnu_rep_list)
     {
-      tree gnu_rep_type, gnu_rep_part;
-      int i, len = list_length (gnu_rep_list);
-      tree *gnu_arr = XALLOCAVEC (tree, len);
+      tree gnu_parent, gnu_rep_type;
 
       /* If all the fields have a rep clause, we can do a flat layout.  */
       layout_with_rep = !gnu_field_list
 			&& (!gnu_variant_part || variants_have_rep);
+
+      /* Same as above but the extension itself has a rep clause, in which case
+	 we need to set aside the _Parent field to lay out the REP part.  */
+      if (TREE_CODE (DECL_SIZE (gnu_rep_list)) != INTEGER_CST
+	  && !layout_with_rep
+	  && !variants_have_rep
+	  && first_free_pos
+	  && integer_zerop (first_free_pos)
+	  && integer_zerop (bit_position (gnu_rep_list)))
+	{
+	  gnu_parent = gnu_rep_list;
+	  gnu_rep_list = DECL_CHAIN (gnu_rep_list);
+	}
+      else
+	gnu_parent = NULL_TREE;
+
       gnu_rep_type
 	= layout_with_rep ? gnu_record_type : make_node (RECORD_TYPE);
 
-      for (gnu_field = gnu_rep_list, i = 0;
-	   gnu_field;
-	   gnu_field = DECL_CHAIN (gnu_field), i++)
-	gnu_arr[i] = gnu_field;
+      /* Sort the fields in order of increasing bit position.  */
+      const int len = list_length (gnu_rep_list);
+      tree *gnu_arr = XALLOCAVEC (tree, len);
+
+      gnu_field = gnu_rep_list;
+      for (int i = 0; i < len; i++)
+	{
+	  gnu_arr[i] = gnu_field;
+	  gnu_field = DECL_CHAIN (gnu_field);
+	}
 
       qsort (gnu_arr, len, sizeof (tree), compare_field_bitpos);
 
-      /* Put the fields in the list in order of increasing position, which
-	 means we start from the end.  */
       gnu_rep_list = NULL_TREE;
-      for (i = len - 1; i >= 0; i--)
+      for (int i = len - 1; i >= 0; i--)
 	{
 	  DECL_CHAIN (gnu_arr[i]) = gnu_rep_list;
 	  gnu_rep_list = gnu_arr[i];
 	  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;
 	}
 
+      /* Do the layout of the REP part, if any.  */
       if (layout_with_rep)
 	gnu_field_list = gnu_rep_list;
       else
@@ -8196,14 +8225,36 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,
 	    = create_concat_name (gnat_record_type, "REP");
 	  TYPE_REVERSE_STORAGE_ORDER (gnu_rep_type)
 	    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);
-	  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);
+	  finish_record_type (gnu_rep_type, gnu_rep_list, 1, false);
 
 	  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields
 	     without rep clause are laid out starting from this position.
 	     Therefore, we force it as a minimal size on the REP part.  */
-	  gnu_rep_part
+	  tree gnu_rep_part
 	    = create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);
 
+	  /* If this is an extension, put back the _Parent field as the first
+	     field of the REP part at offset 0 and update its layout.  */
+	  if (gnu_parent)
+	    {
+	      const unsigned int align = DECL_ALIGN (gnu_parent);
+	      DECL_CHAIN (gnu_parent) = TYPE_FIELDS (gnu_rep_type);
+	      TYPE_FIELDS (gnu_rep_type) = gnu_parent;
+	      DECL_CONTEXT (gnu_parent) = gnu_rep_type;
+	      if (align > TYPE_ALIGN (gnu_rep_type))
+		{
+		  SET_TYPE_ALIGN (gnu_rep_type, align);
+		  TYPE_SIZE (gnu_rep_type)
+		    = round_up (TYPE_SIZE (gnu_rep_type), align);
+		  TYPE_SIZE_UNIT (gnu_rep_type)
+		    = round_up (TYPE_SIZE_UNIT (gnu_rep_type), align);
+		  SET_DECL_ALIGN (gnu_rep_part, align);
+		}
+	    }
+
+	  if (debug_info)
+	    rest_of_record_type_compilation (gnu_rep_type);
+
 	  /* Chain the REP part at the beginning of the field list.  */
 	  DECL_CHAIN (gnu_rep_part) = gnu_field_list;
 	  gnu_field_list = gnu_rep_part;
@@ -8673,11 +8724,15 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)
     if (!Is_Access_Type (Etype (Node (gnat_constr))))
       {
 	tree gnu_field = gnat_to_gnu_field_decl (gnat_discrim);
-	tree replacement = convert (TREE_TYPE (gnu_field),
-				    elaborate_expression
-				    (Node (gnat_constr), gnat_subtype,
-				     get_entity_char (gnat_discrim),
-				     definition, true, false));
+	tree replacement
+	  = elaborate_expression (Node (gnat_constr), gnat_subtype,
+				  get_entity_char (gnat_discrim),
+				  definition, true, false);
+	/* If this is a definition, we need to make sure that the SAVE_EXPRs
+	   are instantiated on every possibly path in size computations.  */
+	if (definition && TREE_CODE (replacement) == SAVE_EXPR)
+	  add_stmt (replacement);
+	replacement = convert (TREE_TYPE (gnu_field), replacement);
 	subst_pair s = { gnu_field, replacement };
 	gnu_list.safe_push (s);
       }
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index 2581b71d6fa..32351bf0f9b 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -3234,38 +3234,6 @@ can_equal_max_val_p (tree val, tree type, bool reverse)
   return can_equal_min_or_max_val_p (val, type, !reverse);
 }
 
-/* Return true if VAL1 can be lower than VAL2.  */
-
-static bool
-can_be_lower_p (tree val1, tree val2)
-{
-  if (TREE_CODE (val1) == NOP_EXPR)
-    {
-      tree type = TREE_TYPE (TREE_OPERAND (val1, 0));
-      if (can_be_lower_p (TYPE_MAX_VALUE (type), TYPE_MIN_VALUE (type)))
-	return true;
-
-      val1 = TYPE_MIN_VALUE (type);
-    }
-
-  if (TREE_CODE (val1) != INTEGER_CST)
-    return true;
-
-  if (TREE_CODE (val2) == NOP_EXPR)
-    {
-      tree type = TREE_TYPE (TREE_OPERAND (val2, 0));
-      if (can_be_lower_p (TYPE_MAX_VALUE (type), TYPE_MIN_VALUE (type)))
-	return true;
-
-      val2 = TYPE_MAX_VALUE (type);
-    }
-
-  if (TREE_CODE (val2) != INTEGER_CST)
-    return true;
-
-  return tree_int_cst_lt (val1, val2);
-}
-
 /* Replace EXPR1 and EXPR2 by invariant expressions if possible.  Return
    true if both expressions have been replaced and false otherwise.  */
 
@@ -3691,19 +3659,16 @@ Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)
 	}
 
       /* If we use the BOTTOM_COND, we can turn the test into an inequality
-	 test but we may have to add ENTRY_COND to protect the empty loop.  */
+	 test but we have to add ENTRY_COND to protect the empty loop.  */
       if (LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt))
 	{
 	  test_code = NE_EXPR;
-	  if (can_be_lower_p (gnu_high, gnu_low))
-	    {
-	      gnu_cond_expr
-		= build3 (COND_EXPR, void_type_node,
-			  build_binary_op (LE_EXPR, boolean_type_node,
-					   gnu_low, gnu_high),
-			  NULL_TREE, alloc_stmt_list ());
-	      set_expr_location_from_node (gnu_cond_expr, gnat_iter_scheme);
-	    }
+	  gnu_cond_expr
+	    = build3 (COND_EXPR, void_type_node,
+		      build_binary_op (LE_EXPR, boolean_type_node,
+				       gnu_low, gnu_high),
+		      NULL_TREE, alloc_stmt_list ());
+	  set_expr_location_from_node (gnu_cond_expr, gnat_iter_scheme);
 	}
 
       /* Open a new nesting level that will surround the loop to declare the
@@ -7636,9 +7601,8 @@ gnat_to_gnu (Node_Id gnat_node)
 
     case N_Allocator:
       {
-	tree gnu_init = NULL_TREE;
-	tree gnu_type;
-	bool ignore_init_type = false;
+	tree gnu_type, gnu_init;
+	bool ignore_init_type;
 
 	gnat_temp = Expression (gnat_node);
 
@@ -7648,15 +7612,22 @@ gnat_to_gnu (Node_Id gnat_node)
 	   initial value for the object.  */
 	if (Nkind (gnat_temp) == N_Identifier
 	    || Nkind (gnat_temp) == N_Expanded_Name)
-	  gnu_type = gnat_to_gnu_type (Entity (gnat_temp));
+	  {
+	    ignore_init_type = false;
+	    gnu_init = NULL_TREE;
+	    gnu_type = gnat_to_gnu_type (Entity (gnat_temp));
+	  }
+
 	else if (Nkind (gnat_temp) == N_Qualified_Expression)
 	  {
 	    Entity_Id gnat_desig_type
 	      = Designated_Type (Underlying_Type (Etype (gnat_node)));
 
-	    ignore_init_type = Has_Constrained_Partial_View (gnat_desig_type);
-	    gnu_init = gnat_to_gnu (Expression (gnat_temp));
+	    /* The flag is effectively only set on the base types.  */
+	    ignore_init_type
+	      = Has_Constrained_Partial_View (Base_Type (gnat_desig_type));
 
+	    gnu_init = gnat_to_gnu (Expression (gnat_temp));
 	    gnu_init = maybe_unconstrained_array (gnu_init);
 	    if (Do_Range_Check (Expression (gnat_temp)))
 	      gnu_init
@@ -8951,15 +8922,16 @@ add_decl_expr (tree gnu_decl, Node_Id gnat_node)
 	  MARK_VISITED (DECL_SIZE_UNIT (gnu_decl));
 	  MARK_VISITED (DECL_INITIAL (gnu_decl));
 	}
-      /* In any case, we have to deal with our own TYPE_ADA_SIZE field.  */
-      else if (TREE_CODE (gnu_decl) == TYPE_DECL
-	       && RECORD_OR_UNION_TYPE_P (type)
-	       && !TYPE_FAT_POINTER_P (type))
-	MARK_VISITED (TYPE_ADA_SIZE (type));
     }
   else
     add_stmt_with_node (gnu_stmt, gnat_node);
 
+  /* Mark our TYPE_ADA_SIZE field now since it will not be gimplified.  */
+  if (TREE_CODE (gnu_decl) == TYPE_DECL
+      && RECORD_OR_UNION_TYPE_P (type)
+      && !TYPE_FAT_POINTER_P (type))
+    MARK_VISITED (TYPE_ADA_SIZE (type));
+
   /* If this is a variable and an initializer is attached to it, it must be
      valid for the context.  Similar to init_const in create_var_decl.  */
   if (TREE_CODE (gnu_decl) == VAR_DECL
@@ -9830,6 +9802,11 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,
   /* If no operand is a constant, we use the generic implementation.  */
   if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (rhs) != INTEGER_CST)
     {
+      /* First convert the operands to the result type like build_binary_op.
+	 This is where the bias is made explicit for biased types.  */
+      lhs = convert (gnu_type, lhs);
+      rhs = convert (gnu_type, rhs);
+
       /* Never inline a 64-bit mult for a 32-bit target, it's way too long.  */
       if (code == MULT_EXPR && precision == 64 && BITS_PER_WORD < 64)
 	{
@@ -11149,7 +11126,7 @@ make_alias_for_thunk (tree target)
   return alias;
 }
 
-/* Create the covariant part of the {GNAT,GNU}_THUNK.  */
+/* Create the local covariant part of {GNAT,GNU}_THUNK.  */
 
 static tree
 make_covariant_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
@@ -11160,6 +11137,11 @@ make_covariant_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
 		  gnu_name, TREE_TYPE (gnu_thunk));
 
   DECL_ARGUMENTS (gnu_cv_thunk) = copy_list (DECL_ARGUMENTS (gnu_thunk));
+  for (tree param_decl = DECL_ARGUMENTS (gnu_cv_thunk);
+       param_decl;
+       param_decl = DECL_CHAIN (param_decl))
+    DECL_CONTEXT (param_decl) = gnu_cv_thunk;
+
   DECL_RESULT (gnu_cv_thunk) = copy_node (DECL_RESULT (gnu_thunk));
   DECL_CONTEXT (DECL_RESULT (gnu_cv_thunk)) = gnu_cv_thunk;
 
@@ -11167,7 +11149,6 @@ make_covariant_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
   DECL_CONTEXT (gnu_cv_thunk) = DECL_CONTEXT (gnu_thunk);
   TREE_READONLY (gnu_cv_thunk) = TREE_READONLY (gnu_thunk);
   TREE_THIS_VOLATILE (gnu_cv_thunk) = TREE_THIS_VOLATILE (gnu_thunk);
-  TREE_PUBLIC (gnu_cv_thunk) = TREE_PUBLIC (gnu_thunk);
   DECL_ARTIFICIAL (gnu_cv_thunk) = 1;
 
   return gnu_cv_thunk;
@@ -11267,8 +11248,11 @@ maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
 
   tree gnu_target = gnat_to_gnu_entity (gnat_target, NULL_TREE, false);
 
-  /* Thunk and target must have the same nesting level, if any.  */
-  gcc_assert (DECL_CONTEXT (gnu_thunk) == DECL_CONTEXT (gnu_target));
+  /* If the target is local, then thunk and target must have the same context
+     because cgraph_node::expand_thunk can only forward the static chain.  */
+  if (DECL_STATIC_CHAIN (gnu_target)
+      && DECL_CONTEXT (gnu_thunk) != DECL_CONTEXT (gnu_target))
+    return false;
 
   /* If the target returns by invisible reference and is external, apply the
      same transformation as Subprogram_Body_to_gnu here.  */
@@ -11293,6 +11277,12 @@ maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
 
   cgraph_node *target_node = cgraph_node::get_create (gnu_target);
 
+  /* We may also need to create an alias for the target in order to make
+     the call local, depending on the linkage of the target.  */
+  tree gnu_alias = use_alias_for_thunk_p (gnu_target)
+		  ? make_alias_for_thunk (gnu_target)
+		  : gnu_target;
+
   /* If the return type of the target is a controlling type, then we need
      both an usual this thunk and a covariant thunk in this order:
 
@@ -11305,17 +11295,11 @@ maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)
       tree gnu_cv_thunk = make_covariant_thunk (gnat_thunk, gnu_thunk);
       target_node->create_thunk (gnu_cv_thunk, gnu_target, false,
 				 - fixed_offset, 0, 0,
-				 NULL_TREE, gnu_target);
+				 NULL_TREE, gnu_alias);
 
-      gnu_target = gnu_cv_thunk;
+      gnu_alias = gnu_target = gnu_cv_thunk;
     }
 
-  /* We may also need to create an alias for the target in order to make
-     the call local, depending on the linkage of the target.  */
-  tree gnu_alias = use_alias_for_thunk_p (gnu_target)
-		  ? make_alias_for_thunk (gnu_target)
-		  : gnu_target;
-
   target_node->create_thunk (gnu_thunk, gnu_target, true,
 			     fixed_offset, virtual_value, indirect_offset,
 			     virtual_offset, gnu_alias);
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
index 2290f0413d5..882802a19e4 100644
--- a/gcc/ada/gcc-interface/utils.c
+++ b/gcc/ada/gcc-interface/utils.c
@@ -388,6 +388,11 @@ make_dummy_type (Entity_Id gnat_type)
     = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);
   if (Is_By_Reference_Type (gnat_equiv))
     TYPE_BY_REFERENCE_P (gnu_type) = 1;
+  if (Has_Discriminants (gnat_equiv))
+    decl_attributes (&gnu_type,
+		     tree_cons (get_identifier ("may_alias"), NULL_TREE,
+				NULL_TREE),
+		     ATTR_FLAG_TYPE_IN_PLACE);
 
   SET_DUMMY_NODE (gnat_equiv, gnu_type);
 
@@ -437,10 +442,10 @@ build_dummy_unc_pointer_types (Entity_Id gnat_desig_type, tree gnu_desig_type)
     = create_type_stub_decl (create_concat_name (gnat_desig_type, "XUP"),
 			     gnu_fat_type);
   fields = create_field_decl (get_identifier ("P_ARRAY"), gnu_ptr_array,
-			      gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
+			      gnu_fat_type, NULL_TREE, NULL_TREE, 0, 1);
   DECL_CHAIN (fields)
     = create_field_decl (get_identifier ("P_BOUNDS"), gnu_ptr_template,
-			 gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
+			 gnu_fat_type, NULL_TREE, NULL_TREE, 0, 1);
   finish_fat_pointer_type (gnu_fat_type, fields);
   SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_desig_type);
   /* Suppress debug info until after the type is completed.  */
@@ -1387,7 +1392,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,
     {
       tree packable_type = make_packable_type (type, true);
       if (TYPE_MODE (packable_type) != BLKmode
-	  && align >= TYPE_ALIGN (packable_type))
+	  && compare_tree_int (TYPE_SIZE (packable_type), align) <= 0)
         type = packable_type;
     }
 
@@ -1861,7 +1866,6 @@ finish_record_type (tree record_type, tree field_list, int rep_level,
 	this_ada_size = this_size;
 
       const bool variant_part = (TREE_CODE (type) == QUAL_UNION_TYPE);
-      const bool variant_part_at_zero = variant_part && integer_zerop (pos);
 
       /* Clear DECL_BIT_FIELD for the cases layout_decl does not handle.  */
       if (DECL_BIT_FIELD (field)
@@ -1904,7 +1908,7 @@ finish_record_type (tree record_type, tree field_list, int rep_level,
       /* Clear DECL_BIT_FIELD_TYPE for a variant part at offset 0, it's simply
 	 not supported by the DECL_BIT_FIELD_REPRESENTATIVE machinery because
 	 the variant part is always the last field in the list.  */
-      if (variant_part_at_zero)
+      if (variant_part && integer_zerop (pos))
 	DECL_BIT_FIELD_TYPE (field) = NULL_TREE;
 
       /* If we still have DECL_BIT_FIELD set at this point, we know that the
@@ -1939,18 +1943,20 @@ finish_record_type (tree record_type, tree field_list, int rep_level,
 	case RECORD_TYPE:
 	  /* Since we know here that all fields are sorted in order of
 	     increasing bit position, the size of the record is one
-	     higher than the ending bit of the last field processed,
-	     unless we have a variant part at offset 0, since in this
-	     case we might have a field outside the variant part that
-	     has a higher ending position; so use a MAX in this case.
-	     Also, if this field is a QUAL_UNION_TYPE, we need to take
-	     into account the previous size in the case of empty variants.  */
+	     higher than the ending bit of the last field processed
+	     unless we have a rep clause, because we might be processing
+	     the REP part of a record with a variant part for which the
+	     variant part has a rep clause but not the fixed part, in
+	     which case this REP part may contain overlapping fields
+	     and thus needs to be treated like a union tyoe above, so
+	     use a MAX in that case.  Also, if this field is a variant
+	     part, we need to take into account the previous size in
+	     the case of empty variants.  */
 	  ada_size
-	    = merge_sizes (ada_size, pos, this_ada_size, variant_part,
-			   variant_part_at_zero);
+	    = merge_sizes (ada_size, pos, this_ada_size, rep_level > 0,
+			   variant_part);
 	  size
-	    = merge_sizes (size, pos, this_size, variant_part,
-			   variant_part_at_zero);
+	    = merge_sizes (size, pos, this_size, rep_level > 0, variant_part);
 	  break;
 
 	default:
@@ -2229,14 +2235,14 @@ rest_of_record_type_compilation (tree record_type)
 }
 
 /* Utility function of above to merge LAST_SIZE, the previous size of a record
-   with FIRST_BIT and SIZE that describe a field.  SPECIAL is true if this
-   represents a QUAL_UNION_TYPE in which case we must look for COND_EXPRs and
-   replace a value of zero with the old size.  If MAX is true, we take the
+   with FIRST_BIT and SIZE that describe a field.  If MAX is true, we take the
    MAX of the end position of this field with LAST_SIZE.  In all other cases,
-   we use FIRST_BIT plus SIZE.  Return an expression for the size.  */
+   we use FIRST_BIT plus SIZE.  SPECIAL is true if it's for a QUAL_UNION_TYPE,
+   in which case we must look for COND_EXPRs and replace a value of zero with
+   the old size.  Return an expression for the size.  */
 
 static tree
-merge_sizes (tree last_size, tree first_bit, tree size, bool special, bool max)
+merge_sizes (tree last_size, tree first_bit, tree size, bool max, bool special)
 {
   tree type = TREE_TYPE (last_size);
   tree new_size;
@@ -2253,11 +2259,11 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special, bool max)
 			    integer_zerop (TREE_OPERAND (size, 1))
 			    ? last_size : merge_sizes (last_size, first_bit,
 						       TREE_OPERAND (size, 1),
-						       1, max),
+						       max, special),
 			    integer_zerop (TREE_OPERAND (size, 2))
 			    ? last_size : merge_sizes (last_size, first_bit,
 						       TREE_OPERAND (size, 2),
-						       1, max));
+						       max, special));
 
   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially
      when fed through SUBSTITUTE_IN_EXPR) into thinking that a constant
@@ -3328,6 +3334,12 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,
 void
 finish_subprog_decl (tree decl, tree asm_name, tree type)
 {
+  /* DECL_ARGUMENTS is set by the caller, but not its context.  */
+  for (tree param_decl = DECL_ARGUMENTS (decl);
+       param_decl;
+       param_decl = DECL_CHAIN (param_decl))
+    DECL_CONTEXT (param_decl) = decl;
+
   tree result_decl
     = build_decl (DECL_SOURCE_LOCATION (decl), RESULT_DECL, NULL_TREE,
 		  TREE_TYPE (type));
@@ -3373,8 +3385,6 @@ finish_subprog_decl (tree decl, tree asm_name, tree type)
 void
 begin_subprog_body (tree subprog_decl)
 {
-  tree param_decl;
-
   announce_function (subprog_decl);
 
   /* This function is being defined.  */
@@ -3391,10 +3401,6 @@ begin_subprog_body (tree subprog_decl)
      this function.  */
   gnat_pushlevel ();
 
-  for (param_decl = DECL_ARGUMENTS (subprog_decl); param_decl;
-       param_decl = DECL_CHAIN (param_decl))
-    DECL_CONTEXT (param_decl) = subprog_decl;
-
   make_decl_rtl (subprog_decl);
 }
 
@@ -5624,7 +5630,7 @@ can_materialize_object_renaming_p (Node_Id expr)
     {
       expr = Original_Node (expr);
 
-      switch Nkind (expr)
+      switch (Nkind (expr))
 	{
 	case N_Identifier:
 	case N_Expanded_Name:
diff --git a/gcc/ada/init.c b/gcc/ada/init.c
index 00f32e5e02a..050800ffbf8 100644
--- a/gcc/ada/init.c
+++ b/gcc/ada/init.c
@@ -570,12 +570,8 @@ __gnat_error_handler (int sig, siginfo_t *si ATTRIBUTE_UNUSED, void *ucontext)
 
 #ifndef __ia64__
 #define HAVE_GNAT_ALTERNATE_STACK 1
-/* This must be in keeping with System.OS_Interface.Alternate_Stack_Size.
-   It must be larger than MINSIGSTKSZ and hopefully near 2 * SIGSTKSZ.  */
-# if 16 * 1024 < MINSIGSTKSZ
-#  error "__gnat_alternate_stack too small"
-# endif
-char __gnat_alternate_stack[16 * 1024];
+/* This must be in keeping with System.OS_Interface.Alternate_Stack_Size.  */
+char __gnat_alternate_stack[32 * 1024];
 #endif
 
 #ifdef __XENO__
diff --git a/gcc/ada/libgnarl/s-osinte__linux.ads b/gcc/ada/libgnarl/s-osinte__linux.ads
index ba3b82423ad..9d5cd05257a 100644
--- a/gcc/ada/libgnarl/s-osinte__linux.ads
+++ b/gcc/ada/libgnarl/s-osinte__linux.ads
@@ -329,7 +329,7 @@ package System.OS_Interface is
    pragma Import (C, Alternate_Stack, "__gnat_alternate_stack");
    --  The alternate signal stack for stack overflows
 
-   Alternate_Stack_Size : constant := 16 * 1024;
+   Alternate_Stack_Size : constant := 32 * 1024;
    --  This must be in keeping with init.c:__gnat_alternate_stack
 
    function Get_Stack_Base (thread : pthread_t) return Address;
diff --git a/gcc/ada/mingw32.h b/gcc/ada/mingw32.h
index fe6464fd601..3dbf7974a67 100644
--- a/gcc/ada/mingw32.h
+++ b/gcc/ada/mingw32.h
@@ -56,6 +56,7 @@
 /* Note: windows.h on cygwin-64 includes x86intrin.h which uses malloc.
    That fails to compile, if malloc is poisoned, i.e. if !IN_RTS.  */
 #define _X86INTRIN_H_INCLUDED
+#define _EMMINTRIN_H_INCLUDED
 #endif
 #include <windows.h>
 
diff --git a/gcc/ada/raise-gcc.c b/gcc/ada/raise-gcc.c
index 6092a87b881..9e78526dc77 100644
--- a/gcc/ada/raise-gcc.c
+++ b/gcc/ada/raise-gcc.c
@@ -79,6 +79,12 @@ typedef char bool;
    (SJLJ or DWARF). We need a consistently named interface to import from
    a-except, so wrappers are defined here.  */
 
+#ifdef __CYGWIN__
+/* Prevent compile error due to unwind-generic.h including <windows.h>,
+   see comment above #include <windows.h> in mingw32.h.  */
+#include "mingw32.h"
+#endif
+
 #ifndef IN_RTS
   /* For gnat1/gnatbind compilation: cannot use unwind.h, as it is for the
      target. So mimic configure...
diff --git a/gcc/asan.c b/gcc/asan.c
index 3b800b26b69..7c392547c0e 100644
--- a/gcc/asan.c
+++ b/gcc/asan.c
@@ -1597,8 +1597,25 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,
       if (use_after_return_class < 5
 	  && can_store_by_pieces (sz, builtin_memset_read_str, &c,
 				  BITS_PER_UNIT, true))
-	store_by_pieces (shadow_mem, sz, builtin_memset_read_str, &c,
-			 BITS_PER_UNIT, true, RETURN_BEGIN);
+	{
+	  /* Emit:
+	       memset(ShadowBase, kAsanStackAfterReturnMagic, ShadowSize);
+	       **SavedFlagPtr(FakeStack, class_id) = 0
+	  */
+	  store_by_pieces (shadow_mem, sz, builtin_memset_read_str, &c,
+			   BITS_PER_UNIT, true, RETURN_BEGIN);
+
+	  unsigned HOST_WIDE_INT offset
+	    = (1 << (use_after_return_class + 6));
+	  offset -= GET_MODE_SIZE (ptr_mode);
+	  mem = gen_rtx_MEM (ptr_mode, base);
+	  mem = adjust_address (mem, ptr_mode, offset);
+	  rtx addr = gen_reg_rtx (ptr_mode);
+	  emit_move_insn (addr, mem);
+	  addr = convert_memory_address (Pmode, addr);
+	  mem = gen_rtx_MEM (QImode, addr);
+	  emit_move_insn (mem, const0_rtx);
+	}
       else if (use_after_return_class >= 5
 	       || !set_storage_via_setmem (shadow_mem,
 					   GEN_INT (sz),
@@ -2660,6 +2677,7 @@ asan_global_struct (void)
   TYPE_FIELDS (ret) = fields[0];
   TYPE_NAME (ret) = type_decl;
   TYPE_STUB_DECL (ret) = type_decl;
+  TYPE_ARTIFICIAL (ret) = 1;
   layout_type (ret);
   return ret;
 }
diff --git a/gcc/attribs.c b/gcc/attribs.c
index 4441922543f..ee2f03c07d7 100644
--- a/gcc/attribs.c
+++ b/gcc/attribs.c
@@ -682,7 +682,8 @@ decl_attributes (tree *node, tree attributes, int flags,
 	 reject incompatible attributes.  */
       bool built_in = flags & ATTR_FLAG_BUILT_IN;
       if (spec->exclude
-	  && (flag_checking || !built_in))
+	  && (flag_checking || !built_in)
+	  && !error_operand_p (last_decl))
 	{
 	  /* Always check attributes on user-defined functions.
 	     Check them on built-ins only when -fchecking is set.
diff --git a/gcc/builtins.c b/gcc/builtins.c
index ed11f79ff0b..39ba87a6759 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -3112,27 +3112,25 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)
 	    return NULL_RTX;
 	}
 
-      if (lendata.decl
-	  && !TREE_NO_WARNING (exp)
-	  && ((tree_int_cst_lt (len, bound))
-	      || !exact))
+      if (lendata.decl && (tree_int_cst_lt (len, bound) || !exact))
 	{
 	  location_t warnloc
 	    = expansion_point_location_if_in_system_header (loc);
 
-	  if (warning_at (warnloc, OPT_Wstringop_overflow_,
-			  exact
-			  ? G_("%K%qD specified bound %E exceeds the size %E "
-			       "of unterminated array")
-			  : G_("%K%qD specified bound %E may exceed the size "
-			       "of at most %E of unterminated array"),
-			  exp, func, bound, len))
+	  if (!TREE_NO_WARNING (exp)
+	      && warning_at (warnloc, OPT_Wstringop_overflow_,
+			     exact
+			     ? G_("%K%qD specified bound %E exceeds the size "
+				  "%E of unterminated array")
+			     : G_("%K%qD specified bound %E may exceed the "
+				  "size of at most %E of unterminated array"),
+			     exp, func, bound, len))
 	    {
 	      inform (DECL_SOURCE_LOCATION (lendata.decl),
 		      "referenced argument declared here");
 	      TREE_NO_WARNING (exp) = true;
-	      return NULL_RTX;
 	    }
+	  return NULL_RTX;
 	}
 
       if (!len)
@@ -10269,7 +10267,8 @@ fold_builtin_next_arg (tree exp, bool va_start_p)
       arg = CALL_EXPR_ARG (exp, 0);
     }
 
-  if (TREE_CODE (arg) == SSA_NAME)
+  if (TREE_CODE (arg) == SSA_NAME
+      && SSA_NAME_VAR (arg))
     arg = SSA_NAME_VAR (arg);
 
   /* We destructively modify the call to be __builtin_va_start (ap, 0)
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 1baceaa1bd5..a2e701e162c 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,32 @@
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/96545
+	* c-common.c (get_atomic_generic_size): Require that first argument's
+	type points to a complete type and use tree_fits_uhwi_p instead of
+	just INTEGER_CST TREE_CODE check for the TYPE_SIZE_UNIT.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-06-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95903
+	* c-common.c (pointer_int_sum): Use TYPE_OVERFLOW_UNDEFINED instead of
+	!TYPE_UNSIGNED check to see if we can apply distributive law and handle
+	smaller precision intop operands separately.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94755
+	* c-common.c (resolve_overloaded_builtin): Return error_mark_node for
+	fncode == BUILT_IN_NONE before initialization of first_param.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index d220e813564..485e2076f68 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -3150,7 +3150,7 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,
       /* If the constant is unsigned, and smaller than the pointer size,
 	 then we must skip this optimization.  This is because it could cause
 	 an overflow error if the constant is negative but INTOP is not.  */
-      && (!TYPE_UNSIGNED (TREE_TYPE (intop))
+      && (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (intop))
 	  || (TYPE_PRECISION (TREE_TYPE (intop))
 	      == TYPE_PRECISION (TREE_TYPE (ptrop)))))
     {
@@ -6891,8 +6891,15 @@ get_atomic_generic_size (location_t loc, tree function,
       return 0;
     }
 
+  if (!COMPLETE_TYPE_P (TREE_TYPE (type_0)))
+    {
+      error_at (loc, "argument 1 of %qE must be a pointer to a complete type",
+		function);
+      return 0;
+    }
+
   /* Types must be compile time constant sizes. */
-  if (TREE_CODE ((TYPE_SIZE_UNIT (TREE_TYPE (type_0)))) != INTEGER_CST)
+  if (!tree_fits_uhwi_p ((TYPE_SIZE_UNIT (TREE_TYPE (type_0)))))
     {
       error_at (loc, 
 		"argument 1 of %qE must be a pointer to a constant size type",
@@ -7348,9 +7355,11 @@ resolve_overloaded_builtin (location_t loc, tree function,
 	enum built_in_function fncode
 	  = speculation_safe_value_resolve_call (function, params);;
 
+	if (fncode == BUILT_IN_NONE)
+	  return error_mark_node;
+
 	first_param = (*params)[0];
-	if (fncode == BUILT_IN_NONE
-	    || !speculation_safe_value_resolve_params (loc, function, params))
+	if (!speculation_safe_value_resolve_params (loc, function, params))
 	  return error_mark_node;
 
 	if (targetm.have_speculation_safe_value (true))
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index c38f1d73605..e70c6ce9f22 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,78 @@
+2021-03-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-03-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/99137
+	* c-parser.c (c_parser_oacc_clause_async): Reject comma expressions.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/96571
+	* c-parser.c (c_parser_generic_selection): Change match_found from bool
+	to int, holding index of the match.  Call mark_exp_read on the selector
+	expression and on expressions other than the selected one.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94842
+	* c-decl.c (set_labels_context_r): In addition to context-less
+	LABEL_DECLs adjust also LABEL_DECLs with context equal to
+	parent function if any.
+	(store_parm_decls): Adjust comment.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94512
+	* c-parser.c (c_parser_omp_parallel): Set OMP_PARALLEL_COMBINED
+	if c_parser_omp_master succeeded.
+
+	Backported from mainline
+	2020-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR gcov-profile/94029
+	PR c/94239
+	* c-parser.c (c_parser_declaration_or_fndef): Initialize endloc to
+	the function_start_locus location.  Don't do that afterwards for the
+	__GIMPLE body parsing.
+
+	2020-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR gcov-profile/94029
+	* c-tree.h (finish_function): Add location_t argument defaulted to
+	input_location.
+	* c-parser.c (c_parser_compound_statement): Add endlocp argument and
+	set it to the locus of closing } if non-NULL.
+	(c_parser_compound_statement_nostart): Return locus of closing }.
+	(c_parser_parse_rtl_body): Likewise.
+	(c_parser_declaration_or_fndef): Propagate locus of closing } to
+	finish_function.
+	* c-decl.c (finish_function): Add end_loc argument, use it instead of
+	input_location to set function_end_locus.
+
+	2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94172
+	* c-tree.h (C_TYPE_INCOMPLETE_VARS): Define to TYPE_LANG_SLOT_1
+	instead of TYPE_VFIELD, and support it on {RECORD,UNION,ENUMERAL}_TYPE.
+	(TYPE_ACTUAL_ARG_TYPES): Check that it is only used on FUNCTION_TYPEs.
+	* c-decl.c (pushdecl): Push C_TYPE_INCOMPLETE_VARS also to
+	ENUMERAL_TYPEs.
+	(finish_incomplete_vars): New function, moved from finish_struct.  Use
+	relayout_decl instead of layout_decl.
+	(finish_struct): Remove obsolete comment about C_TYPE_INCOMPLETE_VARS
+	being TYPE_VFIELD.  Use finish_incomplete_vars.
+	(finish_enum): Clear C_TYPE_INCOMPLETE_VARS.  Call
+	finish_incomplete_vars.
+	* c-typeck.c (c_build_qualified_type): Clear C_TYPE_INCOMPLETE_VARS
+	also on ENUMERAL_TYPEs.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index 859a6241258..80071112130 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -3272,7 +3272,8 @@ pushdecl (tree x)
 	element = TREE_TYPE (element);
       element = TYPE_MAIN_VARIANT (element);
 
-      if (RECORD_OR_UNION_TYPE_P (element)
+      if ((RECORD_OR_UNION_TYPE_P (element)
+	   || TREE_CODE (element) == ENUMERAL_TYPE)
 	  && (TREE_CODE (x) != TYPE_DECL
 	      || TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE)
 	  && !COMPLETE_TYPE_P (element))
@@ -8141,6 +8142,26 @@ field_decl_cmp (const void *x_p, const void *y_p)
   return 1;
 }
 
+/* If this structure or union completes the type of any previous
+   variable declaration, lay it out and output its rtl.  */
+static void
+finish_incomplete_vars (tree incomplete_vars, bool toplevel)
+{
+  for (tree x = incomplete_vars; x; x = TREE_CHAIN (x))
+    {
+      tree decl = TREE_VALUE (x);
+      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
+	layout_array_type (TREE_TYPE (decl));
+      if (TREE_CODE (decl) != TYPE_DECL)
+	{
+	  relayout_decl (decl);
+	  if (c_dialect_objc ())
+	    objc_check_decl (decl);
+	  rest_of_decl_compilation (decl, toplevel, 0);
+	}
+    }
+}
+
 /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.
    LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.
    FIELDLIST is a chain of FIELD_DECL nodes for the fields.
@@ -8399,13 +8420,6 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,
       warning_at (loc, 0, "union cannot be made transparent");
     }
 
-  /* Note: C_TYPE_INCOMPLETE_VARS overloads TYPE_VFIELD which is used
-     in dwarf2out via rest_of_decl_compilation below and means
-     something totally different.  Since we will be clearing
-     C_TYPE_INCOMPLETE_VARS shortly after we iterate through them,
-     clear it ahead of time and avoid problems in dwarf2out.  Ideally,
-     C_TYPE_INCOMPLETE_VARS should use some language specific
-     node.  */
   tree incomplete_vars = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t));
   for (x = TYPE_MAIN_VARIANT (t); x; x = TYPE_NEXT_VARIANT (x))
     {
@@ -8426,21 +8440,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,
   /* Finish debugging output for this type.  */
   rest_of_type_compilation (t, toplevel);
 
-  /* If this structure or union completes the type of any previous
-     variable declaration, lay it out and output its rtl.  */
-  for (x = incomplete_vars; x; x = TREE_CHAIN (x))
-    {
-      tree decl = TREE_VALUE (x);
-      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
-	layout_array_type (TREE_TYPE (decl));
-      if (TREE_CODE (decl) != TYPE_DECL)
-	{
-	  layout_decl (decl, 0);
-	  if (c_dialect_objc ())
-	    objc_check_decl (decl);
-	  rest_of_decl_compilation (decl, toplevel, 0);
-	}
-    }
+  finish_incomplete_vars (incomplete_vars, toplevel);
 
   /* If we're inside a function proper, i.e. not file-scope and not still
      parsing parameters, then arrange for the size of a variable sized type
@@ -8719,8 +8719,10 @@ finish_enum (tree enumtype, tree values, tree attributes)
   TYPE_LANG_SPECIFIC (enumtype) = lt;
 
   /* Fix up all variant types of this enum type.  */
+  tree incomplete_vars = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (enumtype));
   for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))
     {
+      C_TYPE_INCOMPLETE_VARS (tem) = NULL_TREE;
       if (tem == enumtype)
 	continue;
       TYPE_VALUES (tem) = TYPE_VALUES (enumtype);
@@ -8739,6 +8741,8 @@ finish_enum (tree enumtype, tree values, tree attributes)
   /* Finish debugging output for this type.  */
   rest_of_type_compilation (enumtype, toplevel);
 
+  finish_incomplete_vars (incomplete_vars, toplevel);
+
   /* If this enum is defined inside a struct, add it to
      struct_types.  */
   if (warn_cxx_compat
@@ -9460,15 +9464,18 @@ store_parm_decls_from (struct c_arg_info *arg_info)
   store_parm_decls ();
 }
 
-/* Called by walk_tree to look for and update context-less labels.  */
+/* Called by walk_tree to look for and update context-less labels
+   or labels with context in the parent function.  */
 
 static tree
 set_labels_context_r (tree *tp, int *walk_subtrees, void *data)
 {
+  tree ctx = static_cast<tree>(data);
   if (TREE_CODE (*tp) == LABEL_EXPR
-      && DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == NULL_TREE)
+      && (DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == NULL_TREE
+	  || DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) == DECL_CONTEXT (ctx)))
     {
-      DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) = static_cast<tree>(data);
+      DECL_CONTEXT (LABEL_EXPR_LABEL (*tp)) = ctx;
       *walk_subtrees = 0;
     }
 
@@ -9539,7 +9546,11 @@ store_parm_decls (void)
 	 gotos, labels, etc.  Because at that time the function decl
 	 for F has not been created yet, those labels do not have any
 	 function context.  But we have the fndecl now, so update the
-	 labels accordingly.  gimplify_expr would crash otherwise.  */
+	 labels accordingly.  gimplify_expr would crash otherwise.
+	 Or with nested functions the labels could be created with parent
+	 function's context, while when the statement is emitted at the
+	 start of the nested function, it needs the nested function's
+	 context.  */
       walk_tree_without_duplicates (&arg_info->pending_sizes,
 				    set_labels_context_r, fndecl);
       add_stmt (arg_info->pending_sizes);
@@ -9593,7 +9604,7 @@ temp_pop_parm_decls (void)
    This is called after parsing the body of the function definition.  */
 
 void
-finish_function (void)
+finish_function (location_t end_loc)
 {
   tree fndecl = current_function_decl;
   
@@ -9689,7 +9700,7 @@ finish_function (void)
 
   /* Store the end of the function, so that we get good line number
      info for the epilogue.  */
-  cfun->function_end_locus = input_location;
+  cfun->function_end_locus = end_loc;
 
   /* Finalize the ELF visibility for the function.  */
   c_determine_visibility (fndecl);
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index aafe8d1740b..53e90c78a47 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -1402,8 +1402,8 @@ static struct c_expr c_parser_braced_init (c_parser *, tree, bool,
 static void c_parser_initelt (c_parser *, struct obstack *);
 static void c_parser_initval (c_parser *, struct c_expr *,
 			      struct obstack *);
-static tree c_parser_compound_statement (c_parser *);
-static void c_parser_compound_statement_nostart (c_parser *);
+static tree c_parser_compound_statement (c_parser *, location_t * = NULL);
+static location_t c_parser_compound_statement_nostart (c_parser *);
 static void c_parser_label (c_parser *);
 static void c_parser_statement (c_parser *, bool *, location_t * = NULL);
 static void c_parser_statement_after_labels (c_parser *, bool *,
@@ -1498,8 +1498,7 @@ static void c_parser_objc_at_synthesize_declaration (c_parser *);
 static void c_parser_objc_at_dynamic_declaration (c_parser *);
 static bool c_parser_objc_diagnose_bad_element_prefix
   (c_parser *, struct c_declspecs *);
-
-static void c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass);
+static location_t c_parser_parse_rtl_body (c_parser *, char *);
 
 /* Parse a translation unit (C90 6.7, C99 6.9, C11 6.9).
 
@@ -2321,14 +2320,16 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
 				   omp_declare_simd_clauses);
       if (oacc_routine_data)
 	c_finish_oacc_routine (oacc_routine_data, current_function_decl, true);
+      location_t startloc = c_parser_peek_token (parser)->location;
       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus
-	= c_parser_peek_token (parser)->location;
+	= startloc;
+      location_t endloc = startloc;
 
       /* If the definition was marked with __RTL, use the RTL parser now,
 	 consuming the function body.  */
       if (specs->declspec_il == cdil_rtl)
 	{
-	  c_parser_parse_rtl_body (parser, specs->gimple_or_rtl_pass);
+	  endloc = c_parser_parse_rtl_body (parser, specs->gimple_or_rtl_pass);
 
 	  /* Normally, store_parm_decls sets next_is_function_body,
 	     anticipating a function body.  We need a push_scope/pop_scope
@@ -2337,7 +2338,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
 	  push_scope ();
 	  pop_scope ();
 
-	  finish_function ();
+	  finish_function (endloc);
 	  return;
 	}
       /* If the definition was marked with __GIMPLE then parse the
@@ -2351,7 +2352,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
 	  in_late_binary_op = saved;
 	}
       else
-	fnbody = c_parser_compound_statement (parser);
+	fnbody = c_parser_compound_statement (parser, &endloc);
       tree fndecl = current_function_decl;
       if (nested)
 	{
@@ -2362,7 +2363,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
 	     by initializer_constant_valid_p.  See gcc.dg/nested-fn-2.c.  */
 	  DECL_STATIC_CHAIN (decl) = 1;
 	  add_stmt (fnbody);
-	  finish_function ();
+	  finish_function (endloc);
 	  c_pop_function_context ();
 	  add_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));
 	}
@@ -2370,7 +2371,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
 	{
 	  if (fnbody)
 	    add_stmt (fnbody);
-	  finish_function ();
+	  finish_function (endloc);
 	}
       /* Get rid of the empty stmt list for GIMPLE/RTL.  */
       if (specs->declspec_il != cdil_none)
@@ -4965,7 +4966,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after,
      cancellation-point-directive  */
 
 static tree
-c_parser_compound_statement (c_parser *parser)
+c_parser_compound_statement (c_parser *parser, location_t *endlocp)
 {
   tree stmt;
   location_t brace_loc;
@@ -4979,7 +4980,9 @@ c_parser_compound_statement (c_parser *parser)
       return error_mark_node;
     }
   stmt = c_begin_compound_stmt (true);
-  c_parser_compound_statement_nostart (parser);
+  location_t end_loc = c_parser_compound_statement_nostart (parser);
+  if (endlocp)
+    *endlocp = end_loc;
 
   return c_end_compound_stmt (brace_loc, stmt, true);
 }
@@ -4988,7 +4991,7 @@ c_parser_compound_statement (c_parser *parser)
    used for parsing both compound statements and statement expressions
    (which follow different paths to handling the opening).  */
 
-static void
+static location_t
 c_parser_compound_statement_nostart (c_parser *parser)
 {
   bool last_stmt = false;
@@ -4997,9 +5000,10 @@ c_parser_compound_statement_nostart (c_parser *parser)
   location_t label_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */
   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
     {
-      add_debug_begin_stmt (c_parser_peek_token (parser)->location);
+      location_t endloc = c_parser_peek_token (parser)->location;
+      add_debug_begin_stmt (endloc);
       c_parser_consume_token (parser);
-      return;
+      return endloc;
     }
   mark_valid_location_for_stdc_pragma (true);
   if (c_parser_next_token_is_keyword (parser, RID_LABEL))
@@ -5040,8 +5044,9 @@ c_parser_compound_statement_nostart (c_parser *parser)
     {
       mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
       c_parser_error (parser, "expected declaration or statement");
+      location_t endloc = c_parser_peek_token (parser)->location;
       c_parser_consume_token (parser);
-      return;
+      return endloc;
     }
   while (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))
     {
@@ -5122,7 +5127,7 @@ c_parser_compound_statement_nostart (c_parser *parser)
 	{
 	  mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
 	  c_parser_error (parser, "expected declaration or statement");
-	  return;
+	  return c_parser_peek_token (parser)->location;
 	}
       else if (c_parser_next_token_is_keyword (parser, RID_ELSE))
         {
@@ -5130,7 +5135,7 @@ c_parser_compound_statement_nostart (c_parser *parser)
             {
 	      mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
 	      error_at (loc, "expected %<}%> before %<else%>");
-              return;
+	      return c_parser_peek_token (parser)->location;
             }
           else
             {
@@ -5152,9 +5157,11 @@ c_parser_compound_statement_nostart (c_parser *parser)
     }
   if (last_label)
     error_at (label_loc, "label at end of compound statement");
+  location_t endloc = c_parser_peek_token (parser)->location;
   c_parser_consume_token (parser);
   /* Restore the value we started with.  */
   mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
+  return endloc;
 }
 
 /* Parse all consecutive labels. */
@@ -7777,7 +7784,7 @@ c_parser_generic_selection (c_parser *parser)
   struct c_expr selector, error_expr;
   tree selector_type;
   struct c_generic_association matched_assoc;
-  bool match_found = false;
+  int match_found = -1;
   location_t generic_loc, selector_loc;
 
   error_expr.original_code = ERROR_MARK;
@@ -7812,6 +7819,7 @@ c_parser_generic_selection (c_parser *parser)
       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
       return selector;
     }
+  mark_exp_read (selector.value);
   selector_type = TREE_TYPE (selector.value);
   /* In ISO C terms, rvalues (including the controlling expression of
      _Generic) do not have qualified types.  */
@@ -7911,18 +7919,18 @@ c_parser_generic_selection (c_parser *parser)
 
       if (assoc.type == NULL_TREE)
 	{
-	  if (!match_found)
+	  if (match_found < 0)
 	    {
 	      matched_assoc = assoc;
-	      match_found = true;
+	      match_found = associations.length ();
 	    }
 	}
       else if (comptypes (assoc.type, selector_type))
 	{
-	  if (!match_found || matched_assoc.type == NULL_TREE)
+	  if (match_found < 0 || matched_assoc.type == NULL_TREE)
 	    {
 	      matched_assoc = assoc;
-	      match_found = true;
+	      match_found = associations.length ();
 	    }
 	  else
 	    {
@@ -7940,13 +7948,19 @@ c_parser_generic_selection (c_parser *parser)
       c_parser_consume_token (parser);
     }
 
+  unsigned int ix;
+  struct c_generic_association *iter;
+  FOR_EACH_VEC_ELT (associations, ix, iter)
+    if (ix != (unsigned) match_found)
+      mark_exp_read (iter->expression.value);
+
   if (!parens.require_close (parser))
     {
       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
       return error_expr;
     }
 
-  if (!match_found)
+  if (match_found < 0)
     {
       error_at (selector_loc, "%<_Generic%> selector of type %qT is not "
 		"compatible with any association",
@@ -13372,7 +13386,7 @@ c_parser_oacc_clause_async (c_parser *parser, tree list)
     {
       c_parser_consume_token (parser);
 
-      t = c_parser_expression (parser).value;
+      t = c_parser_expr_no_commas (parser, NULL).value;
       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))
 	c_parser_error (parser, "expected integer expression");
       else if (t == error_mark_node
@@ -17624,9 +17638,9 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,
 	  stmt = c_finish_omp_parallel (loc,
 					cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],
 					block);
-	  OMP_PARALLEL_COMBINED (stmt) = 1;
 	  if (ret == NULL)
 	    return ret;
+	  OMP_PARALLEL_COMBINED (stmt) = 1;
 	  return stmt;
 	}
       else if (!flag_openmp)  /* flag_openmp_simd  */
@@ -19920,13 +19934,13 @@ c_parse_file (void)
 
    Take ownership of START_WITH_PASS, if non-NULL.  */
 
-void
+location_t
 c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass)
 {
   if (!c_parser_require (parser, CPP_OPEN_BRACE, "expected %<{%>"))
     {
       free (start_with_pass);
-      return;
+      return c_parser_peek_token (parser)->location;
     }
 
   location_t start_loc = c_parser_peek_token (parser)->location;
@@ -19948,7 +19962,7 @@ c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass)
 	case CPP_EOF:
 	  error_at (start_loc, "no closing brace");
 	  free (start_with_pass);
-	  return;
+	  return c_parser_peek_token (parser)->location;
 	default:
 	  break;
 	}
@@ -19966,7 +19980,7 @@ c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass)
   if (!read_rtl_function_body_from_file_range (start_loc, end_loc))
     {
       free (start_with_pass);
-      return;
+      return end_loc;
     }
 
  /*  If a pass name was provided for START_WITH_PASS, run the backend
@@ -19974,6 +19988,7 @@ c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass)
      ownership of START_WITH_PASS.  */
   if (start_with_pass)
     run_rtl_passes (start_with_pass);
+  return end_loc;
 }
 
 #include "gt-c-c-parser.h"
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index 7e35ab1f0bc..4642d682452 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -38,9 +38,12 @@ along with GCC; see the file COPYING3.  If not see
    nonzero if the definition of the type has already started.  */
 #define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)
 
-/* In an incomplete RECORD_TYPE or UNION_TYPE, a list of variable
-   declarations whose type would be completed by completing that type.  */
-#define C_TYPE_INCOMPLETE_VARS(TYPE) TYPE_VFIELD (TYPE)
+/* In an incomplete RECORD_TYPE, UNION_TYPE or ENUMERAL_TYPE, a list of
+   variable declarations whose type would be completed by completing
+   that type.  */
+#define C_TYPE_INCOMPLETE_VARS(TYPE) \
+  TYPE_LANG_SLOT_1 (TREE_CHECK4 (TYPE, RECORD_TYPE, UNION_TYPE, \
+				 QUAL_UNION_TYPE, ENUMERAL_TYPE))
 
 /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a
    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword.  */
@@ -111,7 +114,8 @@ along with GCC; see the file COPYING3.  If not see
 /* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as
    TYPE_ARG_TYPES for functions with prototypes, but created for functions
    without prototypes.  */
-#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_LANG_SLOT_1 (NODE)
+#define TYPE_ACTUAL_ARG_TYPES(NODE) \
+  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))
 
 /* For a CONSTRUCTOR, whether some initializer contains a
    subexpression meaning it is not a constant expression.  */
@@ -558,7 +562,7 @@ extern bool c_check_switch_jump_warnings (struct c_spot_bindings *,
 					  location_t, location_t);
 extern void finish_decl (tree, location_t, tree, tree, tree);
 extern tree finish_enum (tree, tree, tree);
-extern void finish_function (void);
+extern void finish_function (location_t = input_location);
 extern tree finish_struct (location_t, tree, tree, tree,
 			   struct c_struct_parse_info *);
 extern struct c_arg_info *build_arg_info (void);
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index c0582a54c93..24106c126cd 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -14965,7 +14965,8 @@ c_build_qualified_type (tree type, int type_quals, tree orig_qual_type,
 		   : build_qualified_type (type, type_quals));
   /* A variant type does not inherit the list of incomplete vars from the
      type main variant.  */
-  if (RECORD_OR_UNION_TYPE_P (var_type)
+  if ((RECORD_OR_UNION_TYPE_P (var_type)
+       || TREE_CODE (var_type) == ENUMERAL_TYPE)
       && TYPE_MAIN_VARIANT (var_type) != var_type)
     C_TYPE_INCOMPLETE_VARS (var_type) = 0;
   return var_type;
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index e252975f546..1b0591193c3 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -2879,11 +2879,15 @@ asm_clobber_reg_is_valid (int regno, int nregs, const char *regname)
      as it was before, so no asm can validly clobber the stack pointer in
      the usual sense.  Adding the stack pointer to the clobber list has
      traditionally had some undocumented and somewhat obscure side-effects.  */
-  if (overlaps_hard_reg_set_p (regset, Pmode, STACK_POINTER_REGNUM)
-      && warning (OPT_Wdeprecated, "listing the stack pointer register"
-		  " %qs in a clobber list is deprecated", regname))
-    inform (input_location, "the value of the stack pointer after an %<asm%>"
-	    " statement must be the same as it was before the statement");
+  if (overlaps_hard_reg_set_p (regset, Pmode, STACK_POINTER_REGNUM))
+    {
+      crtl->sp_is_clobbered_by_asm = true;
+      if (warning (OPT_Wdeprecated, "listing the stack pointer register"
+		   " %qs in a clobber list is deprecated", regname))
+	inform (input_location, "the value of the stack pointer after"
+		" an %<asm%> statement must be the same as it was before"
+		" the statement");
+    }
 
   return is_valid;
 }
diff --git a/gcc/cfgloopmanip.c b/gcc/cfgloopmanip.c
index bfee48ed8cc..3980a9b45f5 100644
--- a/gcc/cfgloopmanip.c
+++ b/gcc/cfgloopmanip.c
@@ -1505,9 +1505,10 @@ create_preheader (struct loop *loop, int flags)
       else
         {
           /* If we want simple preheaders, also force the preheader to have
-             just a single successor.  */
+	     just a single successor and a normal edge.  */
           if ((flags & CP_SIMPLE_PREHEADERS)
-              && !single_succ_p (single_entry->src))
+	      && ((single_entry->flags & EDGE_COMPLEX)
+		  || !single_succ_p (single_entry->src)))
             need_forwarder_block = true;
           /* If we want fallthru preheaders, also create forwarder block when
              preheader ends with a jump or has predecessors from loop.  */
diff --git a/gcc/cfgrtl.c b/gcc/cfgrtl.c
index 08e534f2485..d6a8dc7c053 100644
--- a/gcc/cfgrtl.c
+++ b/gcc/cfgrtl.c
@@ -224,10 +224,20 @@ delete_insn_and_edges (rtx_insn *insn)
 {
   bool purge = false;
 
-  if (INSN_P (insn)
-      && BLOCK_FOR_INSN (insn)
-      && BB_END (BLOCK_FOR_INSN (insn)) == insn)
-    purge = true;
+  if (INSN_P (insn) && BLOCK_FOR_INSN (insn))
+    {
+      basic_block bb = BLOCK_FOR_INSN (insn);
+      if (BB_END (bb) == insn)
+	purge = true;
+      else if (DEBUG_INSN_P (BB_END (bb)))
+	for (rtx_insn *dinsn = NEXT_INSN (insn);
+	     DEBUG_INSN_P (dinsn); dinsn = NEXT_INSN (dinsn))
+	  if (BB_END (bb) == dinsn)
+	    {
+	      purge = true;
+	      break;
+	    }
+    }
   delete_insn (insn);
   if (purge)
     return purge_dead_edges (BLOCK_FOR_INSN (insn));
@@ -3058,7 +3068,7 @@ purge_dead_edges (basic_block bb)
   bool found;
   edge_iterator ei;
 
-  if (DEBUG_INSN_P (insn) && insn != BB_HEAD (bb))
+  if ((DEBUG_INSN_P (insn) || NOTE_P (insn)) && insn != BB_HEAD (bb))
     do
       insn = PREV_INSN (insn);
     while ((DEBUG_INSN_P (insn) || NOTE_P (insn)) && insn != BB_HEAD (bb));
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index 1febb6369a0..3547db54d87 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -780,9 +780,22 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)
 {
   tree decl;
 
+  cgraph_node *new_direct_callee = NULL;
+  if (indirect_unknown_callee
+      && (decl = gimple_call_fndecl (new_stmt)))
+    {
+      /* Constant propagation and especially inlining can turn an indirect call
+	 into a direct one.  */
+      new_direct_callee = cgraph_node::get (decl);
+      gcc_checking_assert (new_direct_callee);
+    }
+
   /* Speculative edges has three component, update all of them
      when asked to.  */
-  if (update_speculative && speculative)
+  if (update_speculative && speculative
+      /* If we are about to resolve the speculation by calling make_direct
+	 below, do not bother going over all the speculative edges now.  */
+      && !new_direct_callee)
     {
       cgraph_edge *direct, *indirect;
       ipa_ref *ref;
@@ -794,28 +807,20 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)
       return;
     }
 
-  /* Only direct speculative edges go to call_site_hash.  */
-  if (caller->call_site_hash
-      && (!speculative || !indirect_unknown_callee))
-    {
-      caller->call_site_hash->remove_elt_with_hash
-	(call_stmt, cgraph_edge_hasher::hash (call_stmt));
-    }
-
   cgraph_edge *e = this;
+  if (new_direct_callee)
+    e = make_direct (new_direct_callee);
 
-  call_stmt = new_stmt;
-  if (indirect_unknown_callee
-      && (decl = gimple_call_fndecl (new_stmt)))
+  /* Only direct speculative edges go to call_site_hash.  */
+  if (e->caller->call_site_hash
+      && (!e->speculative || !e->indirect_unknown_callee))
     {
-      /* Constant propagation (and possibly also inlining?) can turn an
-	 indirect call into a direct one.  */
-      cgraph_node *new_callee = cgraph_node::get (decl);
-
-      gcc_checking_assert (new_callee);
-      e = make_direct (new_callee);
+      e->caller->call_site_hash->remove_elt_with_hash
+	(e->call_stmt, cgraph_edge_hasher::hash (e->call_stmt));
     }
 
+  e->call_stmt = new_stmt;
+
   function *fun = DECL_STRUCT_FUNCTION (e->caller->decl);
   e->can_throw_external = stmt_can_throw_external (fun, new_stmt);
   if (e->caller->call_site_hash)
@@ -1211,15 +1216,15 @@ cgraph_edge::resolve_speculation (tree callee_decl)
   return edge;
 }
 
-/* Make an indirect edge with an unknown callee an ordinary edge leading to
-   CALLEE.  DELTA is an integer constant that is to be added to the this
-   pointer (first parameter) to compensate for skipping a thunk adjustment.  */
+/* Turn an indirect edge with an unknown callee or a speculative edge into an
+   ordinary edge leading to CALLEE.  Speculations can be resolved in the
+   process.  Return the edge that now represents the call.  */
 
 cgraph_edge *
 cgraph_edge::make_direct (cgraph_node *callee)
 {
   cgraph_edge *edge = this;
-  gcc_assert (indirect_unknown_callee);
+  gcc_assert (indirect_unknown_callee || speculative);
 
   /* If we are redirecting speculative call, make it non-speculative.  */
   if (indirect_unknown_callee && speculative)
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 4a27867b82c..0f933bdc758 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -967,15 +967,15 @@ check_global_declaration (symtab_node *snode)
       && DECL_INITIAL (decl) == 0
       && DECL_EXTERNAL (decl)
       && ! DECL_ARTIFICIAL (decl)
-      && ! TREE_NO_WARNING (decl)
-      && ! TREE_PUBLIC (decl)
-      && (warn_unused_function
-	  || snode->referred_to_p (/*include_self=*/false)))
+      && ! TREE_PUBLIC (decl))
     {
-      if (snode->referred_to_p (/*include_self=*/false))
+      if (TREE_NO_WARNING (decl))
+	;
+      else if (snode->referred_to_p (/*include_self=*/false))
 	pedwarn (input_location, 0, "%q+F used but never defined", decl);
       else
-	warning (OPT_Wunused_function, "%q+F declared %<static%> but never defined", decl);
+	warning (OPT_Wunused_function, "%q+F declared %<static%> but never "
+				       "defined", decl);
       /* This symbol is effectively an "extern" declaration now.  */
       TREE_PUBLIC (decl) = 1;
     }
diff --git a/gcc/combine.c b/gcc/combine.c
index 48a60eb0206..ab8463bf27b 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -1488,6 +1488,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)
 	      if ((set = single_set (temp)) != 0
 		  && (note = find_reg_equal_equiv_note (temp)) != 0
 		  && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST
+		  && ! side_effects_p (SET_SRC (set))
 		  /* Avoid using a register that may already been marked
 		     dead by an earlier instruction.  */
 		  && ! unmentioned_reg_p (note, SET_SRC (set))
diff --git a/gcc/common/config/aarch64/aarch64-common.c b/gcc/common/config/aarch64/aarch64-common.c
index bab3ab3fa36..bc59d646a4c 100644
--- a/gcc/common/config/aarch64/aarch64-common.c
+++ b/gcc/common/config/aarch64/aarch64-common.c
@@ -161,6 +161,13 @@ aarch64_handle_option (struct gcc_options *opts,
       opts->x_flag_omit_leaf_frame_pointer = val;
       return true;
 
+    case OPT_moutline_atomics:
+      if (val)
+	opts->x_target_flags |= MASK_OUTLINE_ATOMICS;
+      else
+	opts->x_target_flags &= ~MASK_OUTLINE_ATOMICS;
+      return true;
+
     default:
       return true;
     }
@@ -433,7 +440,22 @@ aarch64_get_extension_string_for_isa_flags (unsigned long isa_flags,
 	/* We remove all the dependent bits, to prevent them from being turned
 	   on twice.  This only works because we assume that all there are
 	   individual options to set all bits standalone.  */
-	isa_flag_bits &= ~opt->flags_on;
+
+	/* PR target/94396.
+
+	   For flags which would already imply a bit that's on by default (e.g
+	   fp16fml which implies +fp,+fp16) we must emit the flags that are not
+	   on by default.  i.e. in Armv8.4-a +fp16fml is default if +fp16.  So
+	   if a user passes armv8.4-a+fp16 (or +fp16fml) then we need to emit
+	   +fp16.  But if +fp16fml is used in an architecture where it is
+	   completely optional we only have to emit the canonical flag.  */
+	uint64_t toggle_bits = opt->flags_on & default_arch_flags;
+	/* Now check to see if the canonical flag is on by default.  If it
+	   is not then enabling it will enable all bits in flags_on.  */
+	if ((opt->flag_canonical & default_arch_flags) == 0)
+	  toggle_bits = opt->flags_on;
+
+	isa_flag_bits &= ~toggle_bits;
 	isa_flag_bits |= opt->flag_canonical;
       }
     }
diff --git a/gcc/common/config/i386/i386-common.c b/gcc/common/config/i386/i386-common.c
index 087bb1520ed..c7841939e89 100644
--- a/gcc/common/config/i386/i386-common.c
+++ b/gcc/common/config/i386/i386-common.c
@@ -182,12 +182,13 @@ along with GCC; see the file COPYING3.  If not see
 #define OPTION_MASK_ISA_AVX_UNSET \
   (OPTION_MASK_ISA_AVX | OPTION_MASK_ISA_FMA_UNSET \
    | OPTION_MASK_ISA_FMA4_UNSET | OPTION_MASK_ISA_F16C_UNSET \
-   | OPTION_MASK_ISA_AVX2_UNSET | OPTION_MASK_ISA_XSAVE_UNSET)
+   | OPTION_MASK_ISA_AVX2_UNSET )
 #define OPTION_MASK_ISA_FMA_UNSET OPTION_MASK_ISA_FMA
 #define OPTION_MASK_ISA_FXSR_UNSET OPTION_MASK_ISA_FXSR
 #define OPTION_MASK_ISA_XSAVE_UNSET \
   (OPTION_MASK_ISA_XSAVE | OPTION_MASK_ISA_XSAVEOPT_UNSET \
-   | OPTION_MASK_ISA_XSAVES_UNSET | OPTION_MASK_ISA_XSAVEC_UNSET)
+   | OPTION_MASK_ISA_XSAVES_UNSET | OPTION_MASK_ISA_XSAVEC_UNSET \
+   | OPTION_MASK_ISA_AVX_UNSET)
 #define OPTION_MASK_ISA_XSAVEOPT_UNSET OPTION_MASK_ISA_XSAVEOPT
 #define OPTION_MASK_ISA_AVX2_UNSET \
   (OPTION_MASK_ISA_AVX2 | OPTION_MASK_ISA_AVX512F_UNSET)
diff --git a/gcc/config.gcc b/gcc/config.gcc
index b2282ecdf0b..82f80d4c748 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2617,6 +2617,10 @@ powerpc*-*-freebsd*)
 	tm_file="${tm_file} dbxelf.h elfos.h gnu-user.h ${fbsd_tm_file} rs6000/sysv4.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	case ${target} in
+	    powerpc*le-*-*)
+		tm_file="${tm_file} rs6000/sysv4le.h" ;;
+	esac
 	case ${target} in
 	     powerpc64*)
 	    	tm_file="${tm_file} rs6000/default64.h rs6000/freebsd64.h"
@@ -3279,7 +3283,9 @@ esac
 case ${target} in
 *-*-linux*android*|*-*-linux*uclibc*|*-*-linux*musl*)
         ;;
-*-*-linux*)
+*-*-kfreebsd*-gnu | *-*-kopensolaris*-gnu)
+        ;;
+*-*-linux* | *-*-gnu*)
 	case ${target} in
 	aarch64*-* | arm*-* | i[34567]86-* | powerpc*-* | s390*-* | sparc*-* | x86_64-*)
 		default_gnu_indirect_function=yes
@@ -3806,9 +3812,17 @@ fi
 supported_defaults=
 case "${target}" in
 	aarch64*-*-*)
-		supported_defaults="abi cpu arch"
-		for which in cpu arch; do
-
+		supported_defaults="abi cpu cpu_64 arch arch_64 tune tune_64"
+		if test x$with_cpu_64 != x && test x$with_cpu = x; then
+			with_cpu=$with_cpu_64
+		fi
+		if test x$with_arch_64 != x && test x$with_arch = x; then
+			with_arch=$with_arch_64
+		fi
+		if test x$with_tune_64 != x && test x$with_tune = x; then
+			with_tune=$with_tune_64
+		fi
+		for which in cpu arch tune; do
 			eval "val=\$with_$which"
 			base_val=`echo $val | sed -e 's/\+.*//'`
 			ext_val=`echo $val | sed -e 's/[a-z0-9.-]\+//'`
@@ -3847,6 +3861,12 @@ case "${target}" in
 				  sed -e 's/,.*$//'`
 			  fi
 
+			  # Disallow extensions in --with-tune=cortex-a53+crc.
+			  if [ $which = tune ] && [ x"$ext_val" != x ]; then
+			    echo "Architecture extensions not supported in --with-$which=$val" 1>&2
+			    exit 1
+			  fi
+
 			  while [ x"$ext_val" != x ]
 			  do
 				ext_val=`echo $ext_val | sed -e 's/\+//'`
@@ -3896,8 +3916,13 @@ case "${target}" in
 			  fi
 			  true
 			else
-			  echo "Unknown $which used in --with-$which=$val" 1>&2
-			  exit 1
+			  # Allow --with-$which=native.
+			  if [ "$val" = native ]; then
+			    true
+			  else
+			    echo "Unknown $which used in --with-$which=$val" 1>&2
+			    exit 1
+			  fi
 			fi
 		done
 		;;
diff --git a/gcc/config.in b/gcc/config.in
index a718ceaf3da..bfef2340339 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -676,6 +676,13 @@
 #endif
 
 
+/* Define if your assembler supports vl/vst/vlm/vstm with an optional
+   alignment hint argument on z13. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS_ON_Z13
+#endif
+
+
 /* Define if your assembler supports VSX instructions. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_VSX
diff --git a/gcc/config/aarch64/aarch64-bti-insert.c b/gcc/config/aarch64/aarch64-bti-insert.c
index e519a0f0ac1..7da89074ce0 100644
--- a/gcc/config/aarch64/aarch64-bti-insert.c
+++ b/gcc/config/aarch64/aarch64-bti-insert.c
@@ -130,22 +130,6 @@ rest_of_insert_bti (void)
   rtx_insn *insn;
   basic_block bb;
 
-  /* Since a Branch Target Exception can only be triggered by an indirect call,
-     we exempt function that are only called directly.  We also exempt
-     functions that are already protected by Return Address Signing (PACIASP/
-     PACIBSP).  For all other cases insert a BTI C at the beginning of the
-     function.  */
-  if (!cgraph_node::get (cfun->decl)->only_called_directly_p ())
-    {
-      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
-      insn = BB_HEAD (bb);
-      if (!aarch64_pac_insn_p (get_first_nonnote_insn ()))
-	{
-	  bti_insn = gen_bti_c ();
-	  emit_insn_before (bti_insn, insn);
-	}
-    }
-
   bb = 0;
   FOR_EACH_BB_FN (bb, cfun)
     {
@@ -153,14 +137,10 @@ rest_of_insert_bti (void)
 	   insn = NEXT_INSN (insn))
 	{
 	  /* If a label is marked to be preserved or can be a non-local goto
-	     target, it must be protected with a BTI J.  The same applies to
-	     NOTE_INSN_DELETED_LABEL since they are basically labels that might
-	     be referenced via variables or constant pool.  */
-	  if ((LABEL_P (insn)
+	     target, it must be protected with a BTI J.  */
+	  if (LABEL_P (insn)
 	       && (LABEL_PRESERVE_P (insn)
 		   || bb->flags & BB_NON_LOCAL_GOTO_TARGET))
-	      || (NOTE_P (insn)
-		  && NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))
 	    {
 	      bti_insn = gen_bti_j ();
 	      emit_insn_after (bti_insn, insn);
@@ -201,6 +181,22 @@ rest_of_insert_bti (void)
 	}
     }
 
+  /* Since a Branch Target Exception can only be triggered by an indirect call,
+     we exempt function that are only called directly.  We also exempt
+     functions that are already protected by Return Address Signing (PACIASP/
+     PACIBSP).  For all other cases insert a BTI C at the beginning of the
+     function.  */
+  if (!cgraph_node::get (cfun->decl)->only_called_directly_p ())
+    {
+      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+      insn = BB_HEAD (bb);
+      if (!aarch64_pac_insn_p (get_first_nonnote_insn ()))
+	{
+	  bti_insn = gen_bti_c ();
+	  emit_insn_before (bti_insn, insn);
+	}
+    }
+
   timevar_pop (TV_MACH_DEP);
   return 0;
 }
diff --git a/gcc/config/aarch64/aarch64-builtins.c b/gcc/config/aarch64/aarch64-builtins.c
index d7b1b7bd686..c3a8e45ed3f 100644
--- a/gcc/config/aarch64/aarch64-builtins.c
+++ b/gcc/config/aarch64/aarch64-builtins.c
@@ -436,6 +436,11 @@ enum aarch64_builtins
   /* Special cased Armv8.3-A Complex FMA by Lane quad Builtins.  */
   AARCH64_SIMD_FCMLA_LANEQ_BUILTIN_BASE,
   AARCH64_SIMD_FCMLA_LANEQ_BUILTINS
+  /* Builtin for Arm8.3-a Javascript conversion instruction.  */
+  AARCH64_JSCVT,
+  /* Armv8.5-a RNG instruction builtins.  */
+  AARCH64_BUILTIN_RNG_RNDR,
+  AARCH64_BUILTIN_RNG_RNDRRS,
   AARCH64_BUILTIN_MAX
 };
 
@@ -1057,6 +1062,25 @@ aarch64_init_pauth_hint_builtins (void)
 			    NULL_TREE);
 }
 
+/* Add builtins for Random Number instructions.  */
+
+static void
+aarch64_init_rng_builtins (void)
+{
+  tree unsigned_ptr_type = build_pointer_type (unsigned_intDI_type_node);
+  tree ftype
+    = build_function_type_list (integer_type_node, unsigned_ptr_type, NULL);
+  aarch64_builtin_decls[AARCH64_BUILTIN_RNG_RNDR]
+    = add_builtin_function ("__builtin_aarch64_rndr", ftype,
+			    AARCH64_BUILTIN_RNG_RNDR, BUILT_IN_MD, NULL,
+			    NULL_TREE);
+  aarch64_builtin_decls[AARCH64_BUILTIN_RNG_RNDRRS]
+    = add_builtin_function ("__builtin_aarch64_rndrrs", ftype,
+			    AARCH64_BUILTIN_RNG_RNDRRS, BUILT_IN_MD, NULL,
+			    NULL_TREE);
+}
+
+
 void
 aarch64_init_builtins (void)
 {
@@ -1085,6 +1109,13 @@ aarch64_init_builtins (void)
 
   aarch64_init_crc32_builtins ();
   aarch64_init_builtin_rsqrt ();
+  aarch64_init_rng_builtins ();
+
+  tree ftype_jcvt
+    = build_function_type_list (intSI_type_node, double_type_node, NULL);
+  aarch64_builtin_decls[AARCH64_JSCVT]
+    = add_builtin_function ("__builtin_aarch64_jcvtzs", ftype_jcvt,
+			    AARCH64_JSCVT, BUILT_IN_MD, NULL, NULL_TREE);
 
   /* Initialize pointer authentication builtins which are backed by instructions
      in NOP encoding space.
@@ -1497,6 +1528,42 @@ aarch64_expand_fcmla_builtin (tree exp, rtx target, int fcode)
   return target;
 }
 
+/* Expand a random number builtin EXP with code FCODE, putting the result
+   int TARGET.  If IGNORE is true the return value is ignored.  */
+
+rtx
+aarch64_expand_rng_builtin (tree exp, rtx target, int fcode, int ignore)
+{
+  rtx pat;
+  enum insn_code icode;
+  if (fcode == AARCH64_BUILTIN_RNG_RNDR)
+    icode = CODE_FOR_aarch64_rndr;
+  else if (fcode == AARCH64_BUILTIN_RNG_RNDRRS)
+    icode = CODE_FOR_aarch64_rndrrs;
+  else
+    gcc_unreachable ();
+
+  rtx rand = gen_reg_rtx (DImode);
+  pat = GEN_FCN (icode) (rand);
+  if (!pat)
+    return NULL_RTX;
+
+  tree arg0 = CALL_EXPR_ARG (exp, 0);
+  rtx res_addr = expand_normal (arg0);
+  res_addr = convert_memory_address (Pmode, res_addr);
+  rtx res_mem = gen_rtx_MEM (DImode, res_addr);
+  emit_insn (pat);
+  emit_move_insn (res_mem, rand);
+  /* If the status result is unused don't generate the CSET code.  */
+  if (ignore)
+    return target;
+
+  rtx cc_reg = gen_rtx_REG (CC_Zmode, CC_REGNUM);
+  rtx cmp_rtx = gen_rtx_fmt_ee (EQ, SImode, cc_reg, const0_rtx);
+  emit_insn (gen_aarch64_cstoresi (target, cmp_rtx, cc_reg));
+  return target;
+}
+
 /* Expand an expression EXP that calls a built-in function,
    with result going to TARGET if that's convenient.  */
 rtx
@@ -1576,6 +1643,16 @@ aarch64_expand_builtin (tree exp,
 
       return target;
 
+    case AARCH64_JSCVT:
+      {
+	expand_operand ops[2];
+	create_output_operand (&ops[0], target, SImode);
+	op0 = expand_normal (CALL_EXPR_ARG (exp, 0));
+	create_input_operand (&ops[1], op0, DFmode);
+	expand_insn (CODE_FOR_aarch64_fjcvtzs, 2, ops);
+	return ops[0].value;
+      }
+
     case AARCH64_SIMD_BUILTIN_FCMLA_LANEQ0_V2SF:
     case AARCH64_SIMD_BUILTIN_FCMLA_LANEQ90_V2SF:
     case AARCH64_SIMD_BUILTIN_FCMLA_LANEQ180_V2SF:
@@ -1585,6 +1662,9 @@ aarch64_expand_builtin (tree exp,
     case AARCH64_SIMD_BUILTIN_FCMLA_LANEQ180_V4HF:
     case AARCH64_SIMD_BUILTIN_FCMLA_LANEQ270_V4HF:
       return aarch64_expand_fcmla_builtin (exp, target, fcode);
+    case AARCH64_BUILTIN_RNG_RNDR:
+    case AARCH64_BUILTIN_RNG_RNDRRS:
+      return aarch64_expand_rng_builtin (exp, target, fcode, ignore);
     }
 
   if (fcode >= AARCH64_SIMD_BUILTIN_BASE && fcode <= AARCH64_SIMD_BUILTIN_MAX)
@@ -1945,10 +2025,12 @@ aarch64_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   mask_sr = build_int_cst (unsigned_type_node,
 			   ~(AARCH64_FE_ALL_EXCEPT));
 
-  ld_fenv_cr = build2 (MODIFY_EXPR, unsigned_type_node,
-		       fenv_cr, build_call_expr (get_fpcr, 0));
-  ld_fenv_sr = build2 (MODIFY_EXPR, unsigned_type_node,
-		       fenv_sr, build_call_expr (get_fpsr, 0));
+  ld_fenv_cr = build4 (TARGET_EXPR, unsigned_type_node,
+		       fenv_cr, build_call_expr (get_fpcr, 0),
+		       NULL_TREE, NULL_TREE);
+  ld_fenv_sr = build4 (TARGET_EXPR, unsigned_type_node,
+		       fenv_sr, build_call_expr (get_fpsr, 0),
+		       NULL_TREE, NULL_TREE);
 
   masked_fenv_cr = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_cr, mask_cr);
   masked_fenv_sr = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_sr, mask_sr);
@@ -1980,8 +2062,9 @@ aarch64_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
        __atomic_feraiseexcept (new_fenv_var);  */
 
   new_fenv_var = create_tmp_var_raw (unsigned_type_node);
-  reload_fenv = build2 (MODIFY_EXPR, unsigned_type_node,
-			new_fenv_var, build_call_expr (get_fpsr, 0));
+  reload_fenv = build4 (TARGET_EXPR, unsigned_type_node,
+			new_fenv_var, build_call_expr (get_fpsr, 0),
+			NULL_TREE, NULL_TREE);
   restore_fnenv = build_call_expr (set_fpsr, 1, fenv_sr);
   atomic_feraiseexcept = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);
   update_call = build_call_expr (atomic_feraiseexcept, 1,
diff --git a/gcc/config/aarch64/aarch64-c.c b/gcc/config/aarch64/aarch64-c.c
index 6d5acb02fc6..73527ac960f 100644
--- a/gcc/config/aarch64/aarch64-c.c
+++ b/gcc/config/aarch64/aarch64-c.c
@@ -110,6 +110,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
   aarch64_def_or_undef (TARGET_CRC32, "__ARM_FEATURE_CRC32", pfile);
   aarch64_def_or_undef (TARGET_DOTPROD, "__ARM_FEATURE_DOTPROD", pfile);
   aarch64_def_or_undef (TARGET_COMPLEX, "__ARM_FEATURE_COMPLEX", pfile);
+  aarch64_def_or_undef (TARGET_JSCVT, "__ARM_FEATURE_JCVT", pfile);
 
   cpp_undef (pfile, "__AARCH64_CMODEL_TINY__");
   cpp_undef (pfile, "__AARCH64_CMODEL_SMALL__");
@@ -156,6 +157,21 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
   aarch64_def_or_undef (TARGET_SM4, "__ARM_FEATURE_SM4", pfile);
   aarch64_def_or_undef (TARGET_F16FML, "__ARM_FEATURE_FP16_FML", pfile);
 
+  aarch64_def_or_undef (aarch64_bti_enabled (),
+			"__ARM_FEATURE_BTI_DEFAULT", pfile);
+
+  cpp_undef (pfile, "__ARM_FEATURE_PAC_DEFAULT");
+  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE)
+    {
+      int v = 1;
+      if (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL)
+	v |= 4;
+      builtin_define_with_int_value ("__ARM_FEATURE_PAC_DEFAULT", v);
+    }
+
+  aarch64_def_or_undef (TARGET_RNG, "__ARM_FEATURE_RNG", pfile);
+  aarch64_def_or_undef (TARGET_FRINT, "__ARM_FEATURE_FRINT", pfile);
+
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
      16-bit floating-point extensions.  */
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 82d91d62519..3cd7db88b77 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -104,14 +104,25 @@ AARCH64_CORE("ares",  ares, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_F
 AARCH64_CORE("neoverse-n1",  neoversen1, cortexa57, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_PROFILE, neoversen1, 0x41, 0xd0c, -1)
 AARCH64_CORE("neoverse-e1",  neoversee1, cortexa53, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_RCPC | AARCH64_FL_DOTPROD | AARCH64_FL_SSBS, cortexa53, 0x41, 0xd4a, -1)
 
+/* Fujitsu ('F') cores. */
+AARCH64_CORE("a64fx", a64fx, a64fx, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_F16 | AARCH64_FL_SVE, a64fx, 0x46, 0x001, -1)
+
 /* HiSilicon ('H') cores. */
 AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2, tsv110,   0x48, 0xd01, -1)
 
 /* ARMv8.4-A Architecture Processors.  */
 
+/* ARM ('A') cores. */
+AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_RCPC | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS, neoversev1, 0x41, 0xd40, -1)
+
+
 /* Qualcomm ('Q') cores. */
 AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
 
+/* Armv8.5-A Architecture Processors.  */
+AARCH64_CORE("neoverse-n2", neoversen2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoversen2, 0x41, 0xd49, -1)
+
 /* ARMv8-A big.LITTLE implementations.  */
 
 AARCH64_CORE("cortex-a57.cortex-a53",  cortexa57cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, 0x41, AARCH64_BIG_LITTLE (0xd07, 0xd03), -1)
diff --git a/gcc/config/aarch64/aarch64-cost-tables.h b/gcc/config/aarch64/aarch64-cost-tables.h
index 5c9442e1b89..36134777797 100644
--- a/gcc/config/aarch64/aarch64-cost-tables.h
+++ b/gcc/config/aarch64/aarch64-cost-tables.h
@@ -438,4 +438,107 @@ const struct cpu_cost_table tsv110_extra_costs =
   }
 };
 
+const struct cpu_cost_table a64fx_extra_costs =
+{
+  /* ALU */
+  {
+    0,                 /* arith.  */
+    0,                 /* logical.  */
+    0,                 /* shift.  */
+    0,                 /* shift_reg.  */
+    COSTS_N_INSNS (1), /* arith_shift.  */
+    COSTS_N_INSNS (1), /* arith_shift_reg.  */
+    COSTS_N_INSNS (1), /* log_shift.  */
+    COSTS_N_INSNS (1), /* log_shift_reg.  */
+    0,                 /* extend.  */
+    COSTS_N_INSNS (1), /* extend_arith.  */
+    0,                 /* bfi.  */
+    0,                 /* bfx.  */
+    0,                 /* clz.  */
+    0,                 /* rev.  */
+    0,                 /* non_exec.  */
+    true               /* non_exec_costs_exec.  */
+  },
+  {
+    /* MULT SImode */
+    {
+      COSTS_N_INSNS (4),       /* simple.  */
+      COSTS_N_INSNS (4),       /* flag_setting.  */
+      COSTS_N_INSNS (4),       /* extend.  */
+      COSTS_N_INSNS (5),       /* add.  */
+      COSTS_N_INSNS (5),       /* extend_add.  */
+      COSTS_N_INSNS (18)       /* idiv.  */
+    },
+    /* MULT DImode */
+    {
+      COSTS_N_INSNS (4),       /* simple.  */
+      0,                       /* flag_setting (N/A).  */
+      COSTS_N_INSNS (4),       /* extend.  */
+      COSTS_N_INSNS (5),       /* add.  */
+      COSTS_N_INSNS (5),       /* extend_add.  */
+      COSTS_N_INSNS (26)       /* idiv.  */
+    }
+  },
+  /* LD/ST */
+  {
+    COSTS_N_INSNS (4),         /* load.  */
+    COSTS_N_INSNS (4),         /* load_sign_extend.  */
+    COSTS_N_INSNS (5),         /* ldrd.  */
+    COSTS_N_INSNS (4),         /* ldm_1st.  */
+    1,                         /* ldm_regs_per_insn_1st.  */
+    2,                         /* ldm_regs_per_insn_subsequent.  */
+    COSTS_N_INSNS (4),         /* loadf.  */
+    COSTS_N_INSNS (4),         /* loadd.  */
+    COSTS_N_INSNS (5),         /* load_unaligned.  */
+    0,                         /* store.  */
+    0,                         /* strd.  */
+    0,                         /* stm_1st.  */
+    1,                         /* stm_regs_per_insn_1st.  */
+    2,                         /* stm_regs_per_insn_subsequent.  */
+    0,                         /* storef.  */
+    0,                         /* stored.  */
+    0,                         /* store_unaligned.  */
+    COSTS_N_INSNS (1),         /* loadv.  */
+    COSTS_N_INSNS (1)          /* storev.  */
+  },
+  {
+    /* FP SFmode */
+    {
+      COSTS_N_INSNS (6),      /* div.  */
+      COSTS_N_INSNS (1),       /* mult.  */
+      COSTS_N_INSNS (1),       /* mult_addsub.  */
+      COSTS_N_INSNS (2),       /* fma.  */
+      COSTS_N_INSNS (1),       /* addsub.  */
+      COSTS_N_INSNS (1),       /* fpconst.  */
+      COSTS_N_INSNS (1),       /* neg.  */
+      COSTS_N_INSNS (1),       /* compare.  */
+      COSTS_N_INSNS (2),       /* widen.  */
+      COSTS_N_INSNS (2),       /* narrow.  */
+      COSTS_N_INSNS (2),       /* toint.  */
+      COSTS_N_INSNS (2),       /* fromint.  */
+      COSTS_N_INSNS (2)        /* roundint.  */
+    },
+    /* FP DFmode */
+    {
+      COSTS_N_INSNS (11),      /* div.  */
+      COSTS_N_INSNS (1),       /* mult.  */
+      COSTS_N_INSNS (1),       /* mult_addsub.  */
+      COSTS_N_INSNS (2),       /* fma.  */
+      COSTS_N_INSNS (1),       /* addsub.  */
+      COSTS_N_INSNS (1),       /* fpconst.  */
+      COSTS_N_INSNS (1),       /* neg.  */
+      COSTS_N_INSNS (1),       /* compare.  */
+      COSTS_N_INSNS (2),       /* widen.  */
+      COSTS_N_INSNS (2),       /* narrow.  */
+      COSTS_N_INSNS (2),       /* toint.  */
+      COSTS_N_INSNS (2),       /* fromint.  */
+      COSTS_N_INSNS (2)        /* roundint.  */
+    }
+  },
+  /* Vector */
+  {
+    COSTS_N_INSNS (1)  /* alu.  */
+  }
+};
+
 #endif
diff --git a/gcc/config/aarch64/aarch64-option-extensions.def b/gcc/config/aarch64/aarch64-option-extensions.def
index 010fd3ccf76..76d581bb300 100644
--- a/gcc/config/aarch64/aarch64-option-extensions.def
+++ b/gcc/config/aarch64/aarch64-option-extensions.def
@@ -118,7 +118,7 @@ AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | A
 AARCH64_OPT_EXTENSION("profile", AARCH64_FL_PROFILE, 0, 0, false, "")
 
 /* Enabling/Disabling "rng" only changes "rng".  */
-AARCH64_OPT_EXTENSION("rng", AARCH64_FL_RNG, 0, 0, false, "")
+AARCH64_OPT_EXTENSION("rng", AARCH64_FL_RNG, 0, 0, false, "rng")
 
 /* Enabling/Disabling "memtag" only changes "memtag".  */
 AARCH64_OPT_EXTENSION("memtag", AARCH64_FL_MEMTAG, 0, 0, false, "")
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index c083cad5327..c9e5d586a51 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -492,6 +492,7 @@ int aarch64_vec_fpconst_pow_of_2 (rtx);
 rtx aarch64_eh_return_handler_rtx (void);
 rtx aarch64_mask_from_zextract_ops (rtx, rtx);
 const char *aarch64_output_move_struct (rtx *operands);
+rtx aarch64_return_addr_rtx (void);
 rtx aarch64_return_addr (int, rtx);
 rtx aarch64_simd_gen_const_vector_dup (machine_mode, HOST_WIDE_INT);
 bool aarch64_simd_mem_operand_p (rtx);
@@ -644,4 +645,22 @@ poly_uint64 aarch64_regmode_natural_size (machine_mode);
 
 bool aarch64_high_bits_all_ones_p (HOST_WIDE_INT);
 
+struct atomic_ool_names
+{
+    const char *str[5][4];
+};
+
+rtx aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
+			    const atomic_ool_names *names);
+extern const atomic_ool_names aarch64_ool_swp_names;
+extern const atomic_ool_names aarch64_ool_ldadd_names;
+extern const atomic_ool_names aarch64_ool_ldset_names;
+extern const atomic_ool_names aarch64_ool_ldclr_names;
+extern const atomic_ool_names aarch64_ool_ldeor_names;
+
+const char *aarch64_sls_barrier (int);
+const char *aarch64_indirect_call_asm (rtx);
+extern bool aarch64_harden_sls_retbr_p (void);
+extern bool aarch64_harden_sls_blr_p (void);
+
 #endif /* GCC_AARCH64_PROTOS_H */
diff --git a/gcc/config/aarch64/aarch64-simd-builtins.def b/gcc/config/aarch64/aarch64-simd-builtins.def
index 17bb0c4869b..d8fb8484267 100644
--- a/gcc/config/aarch64/aarch64-simd-builtins.def
+++ b/gcc/config/aarch64/aarch64-simd-builtins.def
@@ -155,7 +155,7 @@
   BUILTIN_VQN (TERNOP, raddhn2, 0)
   BUILTIN_VQN (TERNOP, rsubhn2, 0)
 
-  BUILTIN_VSQN_HSDI (UNOP, sqmovun, 0)
+  BUILTIN_VSQN_HSDI (UNOPUS, sqmovun, 0)
   /* Implemented by aarch64_<sur>qmovn<mode>.  */
   BUILTIN_VSQN_HSDI (UNOP, sqmovn, 0)
   BUILTIN_VSQN_HSDI (UNOP, uqmovn, 0)
@@ -314,12 +314,11 @@
   BUILTIN_VHSDF (UNOP, nearbyint, 2)
   BUILTIN_VHSDF (UNOP, rint, 2)
   BUILTIN_VHSDF (UNOP, round, 2)
-  BUILTIN_VHSDF_DF (UNOP, frintn, 2)
+  BUILTIN_VHSDF_HSDF (UNOP, frintn, 2)
 
   VAR1 (UNOP, btrunc, 2, hf)
   VAR1 (UNOP, ceil, 2, hf)
   VAR1 (UNOP, floor, 2, hf)
-  VAR1 (UNOP, frintn, 2, hf)
   VAR1 (UNOP, nearbyint, 2, hf)
   VAR1 (UNOP, rint, 2, hf)
   VAR1 (UNOP, round, 2, hf)
@@ -465,12 +464,18 @@
   /* Implemented by aarch64_ld1x3<VALLDIF:mode>.  */
   BUILTIN_VALLDIF (LOADSTRUCT, ld1x3, 0)
 
+  /* Implemented by aarch64_ld1x4<VALLDIF:mode>.  */
+  BUILTIN_VALLDIF (LOADSTRUCT, ld1x4, 0)
+
   /* Implemented by aarch64_st1x2<VALLDIF:mode>.  */
   BUILTIN_VALLDIF (STORESTRUCT, st1x2, 0)
 
   /* Implemented by aarch64_st1x3<VALLDIF:mode>.  */
   BUILTIN_VALLDIF (STORESTRUCT, st1x3, 0)
 
+  /* Implemented by aarch64_st1x4<VALLDIF:mode>.  */
+  BUILTIN_VALLDIF (STORESTRUCT, st1x4, 0)
+
   /* Implemented by fma<mode>4.  */
   BUILTIN_VHSDF (TERNOP, fma, 4)
   VAR1 (TERNOP, fma, 4, hf)
@@ -670,3 +675,9 @@
   /* Implemented by aarch64_fml<f16mac1>lq_laneq_highv4sf.  */
   VAR1 (QUADOP_LANE, fmlalq_laneq_high, 0, v4sf)
   VAR1 (QUADOP_LANE, fmlslq_laneq_high, 0, v4sf)
+
+  /* Implemented by aarch64_<frintnzs_op><mode>.  */
+  BUILTIN_VSFDF (UNOP, frint32z, 0)
+  BUILTIN_VSFDF (UNOP, frint32x, 0)
+  BUILTIN_VSFDF (UNOP, frint64z, 0)
+  BUILTIN_VSFDF (UNOP, frint64x, 0)
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index e3852c5d182..eb473e01957 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -1012,31 +1012,17 @@
 						     tmp));
           DONE;
         }
-      else
-        {
-          operands[2] = force_reg (SImode, operands[2]);
-        }
-    }
-  else if (MEM_P (operands[2]))
-    {
-      operands[2] = force_reg (SImode, operands[2]);
     }
 
-  if (REG_P (operands[2]))
-    {
-      rtx tmp = gen_reg_rtx (<MODE>mode);
-      emit_insn (gen_aarch64_simd_dup<mode> (tmp,
-					     convert_to_mode (<VEL>mode,
-							      operands[2],
-							      0)));
-      emit_insn (gen_aarch64_simd_reg_sshl<mode> (operands[0], operands[1],
-						  tmp));
-      DONE;
-    }
-  else
-    FAIL;
-}
-)
+  operands[2] = force_reg (SImode, operands[2]);
+
+  rtx tmp = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_aarch64_simd_dup<mode> (tmp, convert_to_mode (<VEL>mode,
+							       operands[2],
+							       0)));
+  emit_insn (gen_aarch64_simd_reg_sshl<mode> (operands[0], operands[1], tmp));
+  DONE;
+})
 
 (define_expand "lshr<mode>3"
   [(match_operand:VDQ_I 0 "register_operand" "")
@@ -1059,31 +1045,19 @@
 						  tmp));
 	  DONE;
 	}
-      else
-        operands[2] = force_reg (SImode, operands[2]);
-    }
-  else if (MEM_P (operands[2]))
-    {
-      operands[2] = force_reg (SImode, operands[2]);
     }
 
-  if (REG_P (operands[2]))
-    {
-      rtx tmp = gen_reg_rtx (SImode);
-      rtx tmp1 = gen_reg_rtx (<MODE>mode);
-      emit_insn (gen_negsi2 (tmp, operands[2]));
-      emit_insn (gen_aarch64_simd_dup<mode> (tmp1,
-					     convert_to_mode (<VEL>mode,
-							      tmp, 0)));
-      emit_insn (gen_aarch64_simd_reg_shl<mode>_unsigned (operands[0],
-							  operands[1],
-							  tmp1));
-      DONE;
-    }
-  else
-    FAIL;
-}
-)
+  operands[2] = force_reg (SImode, operands[2]);
+
+  rtx tmp = gen_reg_rtx (SImode);
+  rtx tmp1 = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_negsi2 (tmp, operands[2]));
+  emit_insn (gen_aarch64_simd_dup<mode> (tmp1,
+					 convert_to_mode (<VEL>mode, tmp, 0)));
+  emit_insn (gen_aarch64_simd_reg_shl<mode>_unsigned (operands[0], operands[1],
+						      tmp1));
+  DONE;
+})
 
 (define_expand "ashr<mode>3"
   [(match_operand:VDQ_I 0 "register_operand" "")
@@ -1106,31 +1080,19 @@
 						  tmp));
           DONE;
 	}
-      else
-        operands[2] = force_reg (SImode, operands[2]);
-    }
-  else if (MEM_P (operands[2]))
-    {
-      operands[2] = force_reg (SImode, operands[2]);
     }
 
-  if (REG_P (operands[2]))
-    {
-      rtx tmp = gen_reg_rtx (SImode);
-      rtx tmp1 = gen_reg_rtx (<MODE>mode);
-      emit_insn (gen_negsi2 (tmp, operands[2]));
-      emit_insn (gen_aarch64_simd_dup<mode> (tmp1,
-					     convert_to_mode (<VEL>mode,
-							      tmp, 0)));
-      emit_insn (gen_aarch64_simd_reg_shl<mode>_signed (operands[0],
-							operands[1],
-							tmp1));
-      DONE;
-    }
-  else
-    FAIL;
-}
-)
+  operands[2] = force_reg (SImode, operands[2]);
+
+  rtx tmp = gen_reg_rtx (SImode);
+  rtx tmp1 = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_negsi2 (tmp, operands[2]));
+  emit_insn (gen_aarch64_simd_dup<mode> (tmp1, convert_to_mode (<VEL>mode,
+								tmp, 0)));
+  emit_insn (gen_aarch64_simd_reg_shl<mode>_signed (operands[0], operands[1],
+						    tmp1));
+  DONE;
+})
 
 (define_expand "vashl<mode>3"
  [(match_operand:VDQ_I 0 "register_operand" "")
@@ -5214,6 +5176,26 @@
       if (GET_CODE (operands[0]) != REG)
 	operands[1] = force_reg (<MODE>mode, operands[1]);
     }
+
+  /* If we have a paradoxical subreg trying to write to <MODE> from and the
+     registers don't overlap then we need to break it apart.  What it's trying
+     to do is give two kind of information at the same time.  It's trying to
+     convey liveness information by saying that the entire register will be
+     written to eventually, but it also only wants to write a single part of the
+     register.  Hence the paradoxical subreg.
+
+     Instead of allowing this we will split the two concerns.  The liveness
+     information will be conveyed using a clobber and then we break apart the
+     paradoxical subreg into just a normal write of the part that it wanted to
+     write originally.  */
+
+  if (REG_P (operands[0]) && paradoxical_subreg_p (operands[1]))
+    {
+      if (!reg_overlap_mentioned_p (operands[0], operands[1]))
+	emit_clobber (operands[0]);
+      operands[1] = SUBREG_REG (operands[1]);
+      operands[0] = gen_lowpart (GET_MODE (operands[1]), operands[0]);
+    }
 })
 
 
@@ -5238,6 +5220,28 @@
   [(set_attr "type" "neon_load1_3reg<q>")]
 )
 
+(define_expand "aarch64_ld1x4<VALLDIF:mode>"
+  [(match_operand:XI 0 "register_operand" "=w")
+   (match_operand:DI 1 "register_operand" "r")
+   (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+  "TARGET_SIMD"
+{
+  rtx mem = gen_rtx_MEM (XImode, operands[1]);
+  emit_insn (gen_aarch64_ld1_x4_<VALLDIF:mode> (operands[0], mem));
+  DONE;
+})
+
+(define_insn "aarch64_ld1_x4_<mode>"
+  [(set (match_operand:XI 0 "register_operand" "=w")
+	(unspec:XI
+	  [(match_operand:XI 1 "aarch64_simd_struct_operand" "Utv")
+	   (unspec:VALLDIF [(const_int 4)] UNSPEC_VSTRUCTDUMMY)]
+	UNSPEC_LD1))]
+  "TARGET_SIMD"
+  "ld1\\t{%S0.<Vtype> - %V0.<Vtype>}, %1"
+  [(set_attr "type" "neon_load1_4reg<q>")]
+)
+
 (define_expand "aarch64_st1x2<VALLDIF:mode>"
   [(match_operand:DI 0 "register_operand" "")
    (match_operand:OI 1 "register_operand" "")
@@ -5280,6 +5284,28 @@
   [(set_attr "type" "neon_store1_3reg<q>")]
 )
 
+(define_expand "aarch64_st1x4<VALLDIF:mode>"
+  [(match_operand:DI 0 "register_operand" "")
+   (match_operand:XI 1 "register_operand" "")
+   (unspec:VALLDIF [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
+  "TARGET_SIMD"
+{
+  rtx mem = gen_rtx_MEM (XImode, operands[0]);
+  emit_insn (gen_aarch64_st1_x4_<VALLDIF:mode> (mem, operands[1]));
+  DONE;
+})
+
+(define_insn "aarch64_st1_x4_<mode>"
+  [(set (match_operand:XI 0 "aarch64_simd_struct_operand" "=Utv")
+	(unspec:XI
+	   [(match_operand:XI 1 "register_operand" "w")
+	   (unspec:VALLDIF [(const_int 4)] UNSPEC_VSTRUCTDUMMY)]
+	UNSPEC_ST1))]
+  "TARGET_SIMD"
+  "st1\\t{%S1.<Vtype> - %V1.<Vtype>}, %0"
+  [(set_attr "type" "neon_store1_4reg<q>")]
+)
+
 (define_insn "*aarch64_mov<mode>"
   [(set (match_operand:VSTRUCT 0 "aarch64_simd_nonimmediate_operand" "=w,Utv,w")
 	(match_operand:VSTRUCT 1 "aarch64_simd_general_operand" " w,w,Utv"))]
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 2b1ec85ae31..0a73e105e08 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,tsv110,saphira,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
+	"cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,ares,neoversen1,neoversee1,a64fx,tsv110,zeus,neoversev1,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/aarch64-tuning-flags.def b/gcc/config/aarch64/aarch64-tuning-flags.def
index 91a0ff5ea04..47852b509d3 100644
--- a/gcc/config/aarch64/aarch64-tuning-flags.def
+++ b/gcc/config/aarch64/aarch64-tuning-flags.def
@@ -46,4 +46,7 @@ AARCH64_EXTRA_TUNING_OPTION ("no_ldp_stp_qregs", NO_LDP_STP_QREGS)
 
 AARCH64_EXTRA_TUNING_OPTION ("rename_load_regs", RENAME_LOAD_REGS)
 
+/* Prefer Advanced SIMD over SVE for auto-vectorization.  */
+AARCH64_EXTRA_TUNING_OPTION ("prefer_advsimd_autovec", PREFER_ADVSIMD_AUTOVEC)
+
 #undef AARCH64_EXTRA_TUNING_OPTION
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index b452a53af99..d71daf92d0b 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -317,6 +317,22 @@ static const struct cpu_addrcost_table qdf24xx_addrcost_table =
   2, /* imm_offset  */
 };
 
+static const struct cpu_addrcost_table a64fx_addrcost_table =
+{
+    {
+      1, /* hi  */
+      1, /* si  */
+      1, /* di  */
+      2, /* ti  */
+    },
+  0, /* pre_modify  */
+  0, /* post_modify  */
+  2, /* register_offset  */
+  3, /* register_sextend  */
+  3, /* register_zextend  */
+  0, /* imm_offset  */
+};
+
 static const struct cpu_regmove_cost generic_regmove_cost =
 {
   1, /* GP2GP  */
@@ -403,6 +419,16 @@ static const struct cpu_regmove_cost tsv110_regmove_cost =
   2  /* FP2FP  */
 };
 
+static const struct cpu_regmove_cost a64fx_regmove_cost =
+{
+  1, /* GP2GP  */
+  /* Avoid the use of slow int<->fp moves for spilling by setting
+     their cost higher than memmov_cost.  */
+  5, /* GP2FP  */
+  7, /* FP2GP  */
+  2 /* FP2FP  */
+};
+
 /* Generic costs for vector insn classes.  */
 static const struct cpu_vector_cost generic_vector_cost =
 {
@@ -561,6 +587,25 @@ static const struct cpu_vector_cost thunderx2t99_vector_cost =
   1  /* cond_not_taken_branch_cost  */
 };
 
+static const struct cpu_vector_cost a64fx_vector_cost =
+{
+  1, /* scalar_int_stmt_cost  */
+  5, /* scalar_fp_stmt_cost  */
+  4, /* scalar_load_cost  */
+  1, /* scalar_store_cost  */
+  2, /* vec_int_stmt_cost  */
+  5, /* vec_fp_stmt_cost  */
+  3, /* vec_permute_cost  */
+  13, /* vec_to_scalar_cost  */
+  4, /* scalar_to_vec_cost  */
+  6, /* vec_align_load_cost  */
+  6, /* vec_unalign_load_cost  */
+  1, /* vec_unalign_store_cost  */
+  1, /* vec_store_cost  */
+  3, /* cond_taken_branch_cost  */
+  1 /* cond_not_taken_branch_cost  */
+};
+
 /* Generic costs for branch instructions.  */
 static const struct cpu_branch_cost generic_branch_cost =
 {
@@ -681,6 +726,17 @@ static const cpu_prefetch_tune xgene1_prefetch_tune =
   -1			/* default_opt_level  */
 };
 
+static const cpu_prefetch_tune a64fx_prefetch_tune =
+{
+  8,			/* num_slots  */
+  64,			/* l1_cache_size  */
+  256,			/* l1_cache_line_size  */
+  32768,		/* l2_cache_size  */
+  true,			/* prefetch_dynamic_strides */
+  -1,			/* minimum_stride */
+  -1			/* default_opt_level  */
+};
+
 static const struct tune_params generic_tunings =
 {
   &cortexa57_extra_costs,
@@ -1111,6 +1167,84 @@ static const struct tune_params neoversen1_tunings =
   &generic_prefetch_tune
 };
 
+static const struct tune_params neoversev1_tunings =
+{
+  &cortexa57_extra_costs,
+  &generic_addrcost_table,
+  &generic_regmove_cost,
+  &cortexa57_vector_cost,
+  &generic_branch_cost,
+  &generic_approx_modes,
+  SVE_256, /* sve_width  */
+  4, /* memmov_cost  */
+  3, /* issue_rate  */
+  AARCH64_FUSE_AES_AESMC, /* fusible_ops  */
+  "32:16",      /* function_align.  */
+  "32:16",      /* jump_align.  */
+  "32:16",      /* loop_align.  */
+  2,    /* int_reassoc_width.  */
+  4,    /* fp_reassoc_width.  */
+  2,    /* vec_reassoc_width.  */
+  2,    /* min_div_recip_mul_sf.  */
+  2,    /* min_div_recip_mul_df.  */
+  0,    /* max_case_values.  */
+  tune_params::AUTOPREFETCHER_WEAK,     /* autoprefetcher_model.  */
+  (AARCH64_EXTRA_TUNE_PREFER_ADVSIMD_AUTOVEC),    /* tune_flags.  */
+  &generic_prefetch_tune
+};
+
+static const struct tune_params neoversen2_tunings =
+{
+  &cortexa57_extra_costs,
+  &generic_addrcost_table,
+  &generic_regmove_cost,
+  &cortexa57_vector_cost,
+  &generic_branch_cost,
+  &generic_approx_modes,
+  SVE_128, /* sve_width  */
+  4, /* memmov_cost  */
+  3, /* issue_rate  */
+  AARCH64_FUSE_AES_AESMC, /* fusible_ops  */
+  "32:16",      /* function_align.  */
+  "32:16",      /* jump_align.  */
+  "32:16",      /* loop_align.  */
+  2,    /* int_reassoc_width.  */
+  4,    /* fp_reassoc_width.  */
+  2,    /* vec_reassoc_width.  */
+  2,    /* min_div_recip_mul_sf.  */
+  2,    /* min_div_recip_mul_df.  */
+  0,    /* max_case_values.  */
+  tune_params::AUTOPREFETCHER_WEAK,     /* autoprefetcher_model.  */
+  (AARCH64_EXTRA_TUNE_PREFER_ADVSIMD_AUTOVEC),    /* tune_flags.  */
+  &generic_prefetch_tune
+};
+
+static const struct tune_params a64fx_tunings =
+{
+  &a64fx_extra_costs,
+  &a64fx_addrcost_table,
+  &a64fx_regmove_cost,
+  &a64fx_vector_cost,
+  &generic_branch_cost,
+  &generic_approx_modes,
+  SVE_512, /* sve_width  */
+  4, /* memmov_cost  */
+  7, /* issue_rate  */
+  (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */
+  "32",	/* function_align.  */
+  "16",	/* jump_align.  */
+  "32",	/* loop_align.  */
+  4,	/* int_reassoc_width.  */
+  2,	/* fp_reassoc_width.  */
+  2,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  0,	/* max_case_values.  */
+  tune_params::AUTOPREFETCHER_WEAK,	/* autoprefetcher_model.  */
+  (AARCH64_EXTRA_TUNE_NONE),	/* tune_flags.  */
+  &a64fx_prefetch_tune
+};
+
 /* Support for fine-grained override of the tuning structures.  */
 struct aarch64_tuning_override_function
 {
@@ -1879,10 +2013,33 @@ emit_set_insn (rtx x, rtx y)
 rtx
 aarch64_gen_compare_reg (RTX_CODE code, rtx x, rtx y)
 {
-  machine_mode mode = SELECT_CC_MODE (code, x, y);
-  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);
+  machine_mode cmp_mode = GET_MODE (x);
+  machine_mode cc_mode;
+  rtx cc_reg;
+
+  if (cmp_mode == TImode)
+    {
+      gcc_assert (code == NE);
+
+      cc_mode = CCmode;
+      cc_reg = gen_rtx_REG (cc_mode, CC_REGNUM);
 
-  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));
+      rtx x_lo = operand_subword (x, 0, 0, TImode);
+      rtx y_lo = operand_subword (y, 0, 0, TImode);
+      emit_set_insn (cc_reg, gen_rtx_COMPARE (cc_mode, x_lo, y_lo));
+
+      rtx x_hi = operand_subword (x, 1, 0, TImode);
+      rtx y_hi = operand_subword (y, 1, 0, TImode);
+      emit_insn (gen_ccmpdi (cc_reg, cc_reg, x_hi, y_hi,
+			     gen_rtx_EQ (cc_mode, cc_reg, const0_rtx),
+			     GEN_INT (AARCH64_EQ)));
+    }
+  else
+    {
+      cc_mode = SELECT_CC_MODE (code, x, y);
+      cc_reg = gen_rtx_REG (cc_mode, CC_REGNUM);
+      emit_set_insn (cc_reg, gen_rtx_COMPARE (cc_mode, x, y));
+    }
   return cc_reg;
 }
 
@@ -1895,7 +2052,10 @@ aarch64_gen_compare_reg_maybe_ze (RTX_CODE code, rtx x, rtx y,
   if (y_mode == E_QImode || y_mode == E_HImode)
     {
       if (CONST_INT_P (y))
-	y = GEN_INT (INTVAL (y) & GET_MODE_MASK (y_mode));
+	{
+	  y = GEN_INT (INTVAL (y) & GET_MODE_MASK (y_mode));
+	  y_mode = SImode;
+	}
       else
 	{
 	  rtx t, cc_reg;
@@ -2818,7 +2978,7 @@ aarch64_add_offset_1 (scalar_int_mode mode, rtx dest,
   gcc_assert (emit_move_imm || temp1 != NULL_RTX);
   gcc_assert (temp1 == NULL_RTX || !reg_overlap_mentioned_p (temp1, src));
 
-  HOST_WIDE_INT moffset = abs_hwi (offset);
+  unsigned HOST_WIDE_INT moffset = absu_hwi (offset);
   rtx_insn *insn;
 
   if (!moffset)
@@ -2862,7 +3022,8 @@ aarch64_add_offset_1 (scalar_int_mode mode, rtx dest,
   if (emit_move_imm)
     {
       gcc_assert (temp1 != NULL_RTX || can_create_pseudo_p ());
-      temp1 = aarch64_force_temporary (mode, temp1, GEN_INT (moffset));
+      temp1 = aarch64_force_temporary (mode, temp1,
+				       gen_int_mode (moffset, mode));
     }
   insn = emit_insn (offset < 0
 		    ? gen_sub3_insn (dest, src, temp1)
@@ -4854,6 +5015,17 @@ aarch64_return_address_signing_enabled (void)
   /* This function should only be called after frame laid out.   */
   gcc_assert (cfun->machine->frame.laid_out);
 
+  /* Turn return address signing off in any function that uses
+     __builtin_eh_return.  The address passed to __builtin_eh_return
+     is not signed so either it has to be signed (with original sp)
+     or the code path that uses it has to avoid authenticating it.
+     Currently eh return introduces a return to anywhere gadget, no
+     matter what we do here since it uses ret with user provided
+     address. An ideal fix for that is to use indirect branch which
+     can be protected with BTI j (to some extent).  */
+  if (crtl->calls_eh_return)
+    return false;
+
   /* If signing scope is AARCH64_FUNCTION_NON_LEAF, we only sign a leaf function
      if it's LR is pushed onto stack.  */
   return (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL
@@ -7541,7 +7713,7 @@ sizetochar (int size)
      'S/T/U/V':		Print a FP/SIMD register name for a register list.
 			The register printed is the FP/SIMD register name
 			of X + 0/1/2/3 for S/T/U/V.
-     'R':		Print a scalar FP/SIMD register name + 1.
+     'R':		Print a scalar Integer/FP/SIMD register name + 1.
      'X':		Print bottom 16 bits of integer constant in hex.
      'w/x':		Print a general register name or the zero register
 			(32-bit or 64-bit).
@@ -7733,12 +7905,13 @@ aarch64_print_operand (FILE *f, rtx x, int code)
       break;
 
     case 'R':
-      if (!REG_P (x) || !FP_REGNUM_P (REGNO (x)))
-	{
-	  output_operand_lossage ("incompatible floating point / vector register operand for '%%%c'", code);
-	  return;
-	}
-      asm_fprintf (f, "q%d", REGNO (x) - V0_REGNUM + 1);
+      if (REG_P (x) && FP_REGNUM_P (REGNO (x)))
+	asm_fprintf (f, "q%d", REGNO (x) - V0_REGNUM + 1);
+      else if (REG_P (x) && GP_REGNUM_P (REGNO (x)))
+	asm_fprintf (f, "x%d", REGNO (x) - R0_REGNUM + 1);
+      else
+	output_operand_lossage ("incompatible register operand for '%%%c'",
+				code);
       break;
 
     case 'X':
@@ -8190,6 +8363,9 @@ aarch64_label_mentioned_p (rtx x)
 enum reg_class
 aarch64_regno_regclass (unsigned regno)
 {
+  if (STUB_REGNUM_P (regno))
+    return STUB_REGS;
+
   if (GP_REGNUM_P (regno))
     return GENERAL_REGS;
 
@@ -8397,6 +8573,24 @@ aarch64_initial_elimination_offset (unsigned from, unsigned to)
   return cfun->machine->frame.frame_size;
 }
 
+
+/* Get return address without mangling.  */
+
+rtx
+aarch64_return_addr_rtx (void)
+{
+  rtx val = get_hard_reg_initial_val (Pmode, LR_REGNUM);
+  /* Note: aarch64_return_address_signing_enabled only
+     works after cfun->machine->frame.laid_out is set,
+     so here we don't know if the return address will
+     be signed or not.  */
+  rtx lr = gen_rtx_REG (Pmode, LR_REGNUM);
+  emit_move_insn (lr, val);
+  emit_insn (GEN_FCN (CODE_FOR_xpaclri) ());
+  return lr;
+}
+
+
 /* Implement RETURN_ADDR_RTX.  We do not support moving back to a
    previous frame.  */
 
@@ -8405,15 +8599,15 @@ aarch64_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)
 {
   if (count != 0)
     return const0_rtx;
-  return get_hard_reg_initial_val (Pmode, LR_REGNUM);
+  return aarch64_return_addr_rtx ();
 }
 
 
 static void
 aarch64_asm_trampoline_template (FILE *f)
 {
-  int offset1 = 16;
-  int offset2 = 20;
+  int offset1 = 24;
+  int offset2 = 28;
 
   if (aarch64_bti_enabled ())
     {
@@ -8436,6 +8630,17 @@ aarch64_asm_trampoline_template (FILE *f)
     }
   asm_fprintf (f, "\tbr\t%s\n", reg_names [IP1_REGNUM]);
 
+  /* We always emit a speculation barrier.
+     This is because the same trampoline template is used for every nested
+     function.  Since nested functions are not particularly common or
+     performant we don't worry too much about the extra instructions to copy
+     around.
+     This is not yet a problem, since we have not yet implemented function
+     specific attributes to choose between hardening against straight line
+     speculation or not, but such function specific attributes are likely to
+     happen in the future.  */
+  asm_fprintf (f, "\tdsb\tsy\n\tisb\n");
+
   /* The trampoline needs an extra padding instruction.  In case if BTI is
      enabled the padding instruction is replaced by the BTI instruction at
      the beginning.  */
@@ -8450,10 +8655,14 @@ static void
 aarch64_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 {
   rtx fnaddr, mem, a_tramp;
-  const int tramp_code_sz = 16;
+  const int tramp_code_sz = 24;
 
   /* Don't need to copy the trailing D-words, we fill those in below.  */
-  emit_block_move (m_tramp, assemble_trampoline_template (),
+  /* We create our own memory address in Pmode so that `emit_block_move` can
+     use parts of the backend which expect Pmode addresses.  */
+  rtx temp = convert_memory_address (Pmode, XEXP (m_tramp, 0));
+  emit_block_move (gen_rtx_MEM (BLKmode, temp),
+		   assemble_trampoline_template (),
 		   GEN_INT (tramp_code_sz), BLOCK_OP_NORMAL);
   mem = adjust_address (m_tramp, ptr_mode, tramp_code_sz);
   fnaddr = XEXP (DECL_RTL (fndecl), 0);
@@ -8484,6 +8693,7 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)
   unsigned int nregs;
   switch (regclass)
     {
+    case STUB_REGS:
     case TAILCALL_ADDR_REGS:
     case POINTER_REGS:
     case GENERAL_REGS:
@@ -8640,6 +8850,8 @@ aarch64_output_casesi (rtx *operands)
   output_asm_insn (buf, operands);
   output_asm_insn (patterns[index][1], operands);
   output_asm_insn ("br\t%3", operands);
+  output_asm_insn (aarch64_sls_barrier (aarch64_harden_sls_retbr_p ()),
+		   operands);
   assemble_label (asm_out_file, label);
   return "";
 }
@@ -10676,10 +10888,12 @@ aarch64_register_move_cost (machine_mode mode,
     = aarch64_tune_params.regmove_cost;
 
   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */
-  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS)
+  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS
+      || to == STUB_REGS)
     to = GENERAL_REGS;
 
-  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)
+  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS
+      || from == STUB_REGS)
     from = GENERAL_REGS;
 
   /* Moving between GPR and stack cost is the same as GP2GP.  */
@@ -11734,6 +11948,79 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,
   return false;
 }
 
+/* Straight line speculation indicators.  */
+enum aarch64_sls_hardening_type
+{
+  SLS_NONE = 0,
+  SLS_RETBR = 1,
+  SLS_BLR = 2,
+  SLS_ALL = 3,
+};
+static enum aarch64_sls_hardening_type aarch64_sls_hardening;
+
+/* Return whether we should mitigatate Straight Line Speculation for the RET
+   and BR instructions.  */
+bool
+aarch64_harden_sls_retbr_p (void)
+{
+  return aarch64_sls_hardening & SLS_RETBR;
+}
+
+/* Return whether we should mitigatate Straight Line Speculation for the BLR
+   instruction.  */
+bool
+aarch64_harden_sls_blr_p (void)
+{
+  return aarch64_sls_hardening & SLS_BLR;
+}
+
+/* As of yet we only allow setting these options globally, in the future we may
+   allow setting them per function.  */
+static void
+aarch64_validate_sls_mitigation (const char *const_str)
+{
+  char *token_save = NULL;
+  char *str = NULL;
+
+  if (strcmp (const_str, "none") == 0)
+    {
+      aarch64_sls_hardening = SLS_NONE;
+      return;
+    }
+  if (strcmp (const_str, "all") == 0)
+    {
+      aarch64_sls_hardening = SLS_ALL;
+      return;
+    }
+
+  char *str_root = xstrdup (const_str);
+  str = strtok_r (str_root, ",", &token_save);
+  if (!str)
+    error ("invalid argument given to %<-mharden-sls=%>");
+
+  int temp = SLS_NONE;
+  while (str)
+    {
+      if (strcmp (str, "blr") == 0)
+	temp |= SLS_BLR;
+      else if (strcmp (str, "retbr") == 0)
+	temp |= SLS_RETBR;
+      else if (strcmp (str, "none") == 0 || strcmp (str, "all") == 0)
+	{
+	  error ("%<%s%> must be by itself for %<-mharden-sls=%>", str);
+	  break;
+	}
+      else
+	{
+	  error ("invalid argument %<%s%> for %<-mharden-sls=%>", str);
+	  break;
+	}
+      str = strtok_r (NULL, ",", &token_save);
+    }
+  aarch64_sls_hardening = (aarch64_sls_hardening_type) temp;
+  free (str_root);
+}
+
 /* Parses CONST_STR for branch protection features specified in
    aarch64_branch_protect_types, and set any global variables required.  Returns
    the parsing result and assigns LAST_STR to the last processed token from
@@ -11972,6 +12259,9 @@ aarch64_override_options (void)
   selected_arch = NULL;
   selected_tune = NULL;
 
+  if (aarch64_harden_sls_string)
+    aarch64_validate_sls_mitigation (aarch64_harden_sls_string);
+
   if (aarch64_branch_protection_string)
     aarch64_validate_mbranch_protection (aarch64_branch_protection_string);
 
@@ -12517,6 +12807,8 @@ static const struct aarch64_attribute_info aarch64_attributes[] =
      aarch64_handle_attr_branch_protection, OPT_mbranch_protection_ },
   { "sign-return-address", aarch64_attr_enum, false, NULL,
      OPT_msign_return_address_ },
+  { "outline-atomics", aarch64_attr_bool, true, NULL,
+     OPT_moutline_atomics},
   { NULL, aarch64_attr_custom, false, NULL, OPT____ }
 };
 
@@ -13050,26 +13342,31 @@ aarch64_classify_symbol (rtx x, HOST_WIDE_INT offset)
 	     the offset does not cause overflow of the final address.  But
 	     we have no way of knowing the address of symbol at compile time
 	     so we can't accurately say if the distance between the PC and
-	     symbol + offset is outside the addressible range of +/-1M in the
-	     TINY code model.  So we rely on images not being greater than
-	     1M and cap the offset at 1M and anything beyond 1M will have to
-	     be loaded using an alternative mechanism.  Furthermore if the
-	     symbol is a weak reference to something that isn't known to
-	     resolve to a symbol in this module, then force to memory.  */
-	  if ((SYMBOL_REF_WEAK (x)
-	       && !aarch64_symbol_binds_local_p (x))
-	      || !IN_RANGE (offset, -1048575, 1048575))
+	     symbol + offset is outside the addressible range of +/-1MB in the
+	     TINY code model.  So we limit the maximum offset to +/-64KB and
+	     assume the offset to the symbol is not larger than +/-(1MB - 64KB).
+	     If offset_within_block_p is true we allow larger offsets.
+	     Furthermore force to memory if the symbol is a weak reference to
+	     something that doesn't resolve to a symbol in this module.  */
+
+	  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))
 	    return SYMBOL_FORCE_TO_MEM;
+	  if (!(IN_RANGE (offset, -0x10000, 0x10000)
+		|| offset_within_block_p (x, offset)))
+	    return SYMBOL_FORCE_TO_MEM;
+
 	  return SYMBOL_TINY_ABSOLUTE;
 
 	case AARCH64_CMODEL_SMALL:
 	  /* Same reasoning as the tiny code model, but the offset cap here is
-	     4G.  */
-	  if ((SYMBOL_REF_WEAK (x)
-	       && !aarch64_symbol_binds_local_p (x))
-	      || !IN_RANGE (offset, HOST_WIDE_INT_C (-4294967263),
-			    HOST_WIDE_INT_C (4294967264)))
+	     1MB, allowing +/-3.9GB for the offset to the symbol.  */
+
+	  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))
 	    return SYMBOL_FORCE_TO_MEM;
+	  if (!(IN_RANGE (offset, -0x100000, 0x100000)
+		|| offset_within_block_p (x, offset)))
+	    return SYMBOL_FORCE_TO_MEM;
+
 	  return SYMBOL_SMALL_ABSOLUTE;
 
 	case AARCH64_CMODEL_TINY_PIC:
@@ -14105,7 +14402,12 @@ aarch64_simd_container_mode (scalar_mode mode, poly_int64 width)
 static machine_mode
 aarch64_preferred_simd_mode (scalar_mode mode)
 {
-  poly_int64 bits = TARGET_SVE ? BITS_PER_SVE_VECTOR : 128;
+  /* If current tuning prefers Advanced SIMD, bypass SVE.  */
+  bool use_sve
+    = TARGET_SVE
+      && !(aarch64_tune_params.extra_tuning_flags
+	   & AARCH64_EXTRA_TUNE_PREFER_ADVSIMD_AUTOVEC);
+  poly_int64 bits = use_sve ? BITS_PER_SVE_VECTOR : 128;
   return aarch64_simd_container_mode (mode, bits);
 }
 
@@ -14114,7 +14416,11 @@ aarch64_preferred_simd_mode (scalar_mode mode)
 static void
 aarch64_autovectorize_vector_sizes (vector_sizes *sizes)
 {
-  if (TARGET_SVE)
+  bool use_sve
+    = TARGET_SVE
+      && !(aarch64_tune_params.extra_tuning_flags
+	   & AARCH64_EXTRA_TUNE_PREFER_ADVSIMD_AUTOVEC);
+  if (use_sve)
     sizes->safe_push (BYTES_PER_SVE_VECTOR);
   sizes->safe_push (16);
   sizes->safe_push (8);
@@ -15426,16 +15732,26 @@ static void
 aarch64_emit_load_exclusive (machine_mode mode, rtx rval,
 			     rtx mem, rtx model_rtx)
 {
-  emit_insn (gen_aarch64_load_exclusive (mode, rval, mem, model_rtx));
+  if (mode == TImode)
+    emit_insn (gen_aarch64_load_exclusive_pair (gen_lowpart (DImode, rval),
+						gen_highpart (DImode, rval),
+						mem, model_rtx));
+  else
+    emit_insn (gen_aarch64_load_exclusive (mode, rval, mem, model_rtx));
 }
 
 /* Emit store exclusive.  */
 
 static void
 aarch64_emit_store_exclusive (machine_mode mode, rtx bval,
-			      rtx rval, rtx mem, rtx model_rtx)
+			      rtx mem, rtx rval, rtx model_rtx)
 {
-  emit_insn (gen_aarch64_store_exclusive (mode, bval, rval, mem, model_rtx));
+  if (mode == TImode)
+    emit_insn (gen_aarch64_store_exclusive_pair
+	       (bval, mem, operand_subword (rval, 0, 0, TImode),
+		operand_subword (rval, 1, 0, TImode), model_rtx));
+  else
+    emit_insn (gen_aarch64_store_exclusive (mode, bval, mem, rval, model_rtx));
 }
 
 /* Mark the previous jump instruction as unlikely.  */
@@ -15447,6 +15763,82 @@ aarch64_emit_unlikely_jump (rtx insn)
   add_reg_br_prob_note (jump, profile_probability::very_unlikely ());
 }
 
+/* We store the names of the various atomic helpers in a 5x4 array.
+   Return the libcall function given MODE, MODEL and NAMES.  */
+
+rtx
+aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
+			const atomic_ool_names *names)
+{
+  memmodel model = memmodel_base (INTVAL (model_rtx));
+  int mode_idx, model_idx;
+
+  switch (mode)
+    {
+    case E_QImode:
+      mode_idx = 0;
+      break;
+    case E_HImode:
+      mode_idx = 1;
+      break;
+    case E_SImode:
+      mode_idx = 2;
+      break;
+    case E_DImode:
+      mode_idx = 3;
+      break;
+    case E_TImode:
+      mode_idx = 4;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  switch (model)
+    {
+    case MEMMODEL_RELAXED:
+      model_idx = 0;
+      break;
+    case MEMMODEL_CONSUME:
+    case MEMMODEL_ACQUIRE:
+      model_idx = 1;
+      break;
+    case MEMMODEL_RELEASE:
+      model_idx = 2;
+      break;
+    case MEMMODEL_ACQ_REL:
+    case MEMMODEL_SEQ_CST:
+      model_idx = 3;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  return init_one_libfunc_visibility (names->str[mode_idx][model_idx],
+				      VISIBILITY_HIDDEN);
+}
+
+#define DEF0(B, N) \
+  { "__aarch64_" #B #N "_relax", \
+    "__aarch64_" #B #N "_acq", \
+    "__aarch64_" #B #N "_rel", \
+    "__aarch64_" #B #N "_acq_rel" }
+
+#define DEF4(B)  DEF0(B, 1), DEF0(B, 2), DEF0(B, 4), DEF0(B, 8), \
+		 { NULL, NULL, NULL, NULL }
+#define DEF5(B)  DEF0(B, 1), DEF0(B, 2), DEF0(B, 4), DEF0(B, 8), DEF0(B, 16)
+
+static const atomic_ool_names aarch64_ool_cas_names = { { DEF5(cas) } };
+const atomic_ool_names aarch64_ool_swp_names = { { DEF4(swp) } };
+const atomic_ool_names aarch64_ool_ldadd_names = { { DEF4(ldadd) } };
+const atomic_ool_names aarch64_ool_ldset_names = { { DEF4(ldset) } };
+const atomic_ool_names aarch64_ool_ldclr_names = { { DEF4(ldclr) } };
+const atomic_ool_names aarch64_ool_ldeor_names = { { DEF4(ldeor) } };
+
+#undef DEF0
+#undef DEF4
+#undef DEF5
+
 /* Expand a compare and swap pattern.  */
 
 void
@@ -15493,6 +15885,17 @@ aarch64_expand_compare_and_swap (rtx operands[])
 						   newval, mod_s));
       cc_reg = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);
     }
+  else if (TARGET_OUTLINE_ATOMICS)
+    {
+      /* Oldval must satisfy compare afterward.  */
+      if (!aarch64_plus_operand (oldval, mode))
+	oldval = force_reg (mode, oldval);
+      rtx func = aarch64_atomic_ool_func (mode, mod_s, &aarch64_ool_cas_names);
+      rval = emit_library_call_value (func, NULL_RTX, LCT_NORMAL, r_mode,
+				      oldval, mode, newval, mode,
+				      XEXP (mem, 0), Pmode);
+      cc_reg = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);
+    }
   else
     {
       /* The oldval predicate varies by mode.  Test it and force to reg.  */
@@ -15538,13 +15941,11 @@ aarch64_split_compare_and_swap (rtx operands[])
   /* Split after prolog/epilog to avoid interactions with shrinkwrapping.  */
   gcc_assert (epilogue_completed);
 
-  rtx rval, mem, oldval, newval, scratch;
+  rtx rval, mem, oldval, newval, scratch, x, model_rtx;
   machine_mode mode;
   bool is_weak;
   rtx_code_label *label1, *label2;
-  rtx x, cond;
   enum memmodel model;
-  rtx model_rtx;
 
   rval = operands[0];
   mem = operands[1];
@@ -15565,7 +15966,8 @@ aarch64_split_compare_and_swap (rtx operands[])
 	CBNZ	scratch, .label1
     .label2:
 	CMP	rval, 0.  */
-  bool strong_zero_p = !is_weak && oldval == const0_rtx;
+  bool strong_zero_p = (!is_weak && !aarch64_track_speculation &&
+			oldval == const0_rtx && mode != TImode);
 
   label1 = NULL;
   if (!is_weak)
@@ -15578,35 +15980,20 @@ aarch64_split_compare_and_swap (rtx operands[])
   /* The initial load can be relaxed for a __sync operation since a final
      barrier will be emitted to stop code hoisting.  */
   if (is_mm_sync (model))
-    aarch64_emit_load_exclusive (mode, rval, mem,
-				 GEN_INT (MEMMODEL_RELAXED));
+    aarch64_emit_load_exclusive (mode, rval, mem, GEN_INT (MEMMODEL_RELAXED));
   else
     aarch64_emit_load_exclusive (mode, rval, mem, model_rtx);
 
   if (strong_zero_p)
-    {
-      if (aarch64_track_speculation)
-	{
-	  /* Emit an explicit compare instruction, so that we can correctly
-	     track the condition codes.  */
-	  rtx cc_reg = aarch64_gen_compare_reg (NE, rval, const0_rtx);
-	  x = gen_rtx_NE (GET_MODE (cc_reg), cc_reg, const0_rtx);
-	}
-      else
-	x = gen_rtx_NE (VOIDmode, rval, const0_rtx);
-
-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
-				gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);
-      aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
-    }
+    x = gen_rtx_NE (VOIDmode, rval, const0_rtx);
   else
     {
-      cond = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);
-      x = gen_rtx_NE (VOIDmode, cond, const0_rtx);
-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
-				gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);
-      aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
+      rtx cc_reg = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);
+      x = gen_rtx_NE (VOIDmode, cc_reg, const0_rtx);
     }
+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
+			    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);
+  aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
 
   aarch64_emit_store_exclusive (mode, scratch, mem, newval, model_rtx);
 
@@ -15627,22 +16014,16 @@ aarch64_split_compare_and_swap (rtx operands[])
       aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));
     }
   else
-    {
-      cond = gen_rtx_REG (CCmode, CC_REGNUM);
-      x = gen_rtx_COMPARE (CCmode, scratch, const0_rtx);
-      emit_insn (gen_rtx_SET (cond, x));
-    }
+    aarch64_gen_compare_reg (NE, scratch, const0_rtx);
 
   emit_label (label2);
+
   /* If we used a CBNZ in the exchange loop emit an explicit compare with RVAL
      to set the condition flags.  If this is not used it will be removed by
      later passes.  */
   if (strong_zero_p)
-    {
-      cond = gen_rtx_REG (CCmode, CC_REGNUM);
-      x = gen_rtx_COMPARE (CCmode, rval, const0_rtx);
-      emit_insn (gen_rtx_SET (cond, x));
-    }
+    aarch64_gen_compare_reg (NE, rval, const0_rtx);
+
   /* Emit any final barrier needed for a __sync operation.  */
   if (is_mm_sync (model))
     aarch64_emit_post_barrier (model);
@@ -16415,7 +16796,8 @@ aarch64_evpc_rev_local (struct expand_vec_perm_d *d)
 
   if (d->vec_flags == VEC_SVE_PRED
       || !d->one_vector_p
-      || !d->perm[0].is_constant (&diff))
+      || !d->perm[0].is_constant (&diff)
+      || !diff)
     return false;
 
   size = (diff + 1) * GET_MODE_UNIT_SIZE (d->vmode);
@@ -17045,6 +17427,8 @@ aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,
 bool
 aarch64_expand_movmem (rtx *operands)
 {
+  /* These need to be signed as we need to perform arithmetic on n as
+     signed operations.  */
   int n, mode_bits;
   rtx dst = operands[0];
   rtx src = operands[1];
@@ -17055,21 +17439,24 @@ aarch64_expand_movmem (rtx *operands)
   /* When optimizing for size, give a better estimate of the length of a
      memcpy call, but use the default otherwise.  Moves larger than 8 bytes
      will always require an even number of instructions to do now.  And each
-     operation requires both a load+store, so devide the max number by 2.  */
-  int max_num_moves = (speed_p ? 16 : AARCH64_CALL_RATIO) / 2;
+     operation requires both a load+store, so divide the max number by 2.  */
+  unsigned int max_num_moves = (speed_p ? 16 : AARCH64_CALL_RATIO) / 2;
 
   /* We can't do anything smart if the amount to copy is not constant.  */
   if (!CONST_INT_P (operands[2]))
     return false;
 
-  n = INTVAL (operands[2]);
+  unsigned HOST_WIDE_INT tmp = INTVAL (operands[2]);
 
   /* Try to keep the number of instructions low.  For all cases we will do at
      most two moves for the residual amount, since we'll always overlap the
      remainder.  */
-  if (((n / 16) + (n % 16 ? 2 : 0)) > max_num_moves)
+  if (((tmp / 16) + (tmp % 16 ? 2 : 0)) > max_num_moves)
     return false;
 
+  /* At this point tmp is known to have to fit inside an int.  */
+  n = tmp;
+
   base = copy_to_mode_reg (Pmode, XEXP (dst, 0));
   dst = adjust_automodify_address (dst, VOIDmode, base, 0);
 
@@ -18900,6 +19287,231 @@ aarch64_file_end_indicate_exec_stack ()
 #undef GNU_PROPERTY_AARCH64_FEATURE_1_BTI
 #undef GNU_PROPERTY_AARCH64_FEATURE_1_AND
 
+/* Helper function for straight line speculation.
+   Return what barrier should be emitted for straight line speculation
+   mitigation.
+   When not mitigating against straight line speculation this function returns
+   an empty string.
+   When mitigating against straight line speculation, use:
+   * SB when the v8.5-A SB extension is enabled.
+   * DSB+ISB otherwise.  */
+const char *
+aarch64_sls_barrier (int mitigation_required)
+{
+  return mitigation_required
+    ? (TARGET_SB ? "sb" : "dsb\tsy\n\tisb")
+    : "";
+}
+
+static GTY (()) tree aarch64_sls_shared_thunks[30];
+static GTY (()) bool aarch64_sls_shared_thunks_needed = false;
+const char *indirect_symbol_names[30] = {
+    "__call_indirect_x0",
+    "__call_indirect_x1",
+    "__call_indirect_x2",
+    "__call_indirect_x3",
+    "__call_indirect_x4",
+    "__call_indirect_x5",
+    "__call_indirect_x6",
+    "__call_indirect_x7",
+    "__call_indirect_x8",
+    "__call_indirect_x9",
+    "__call_indirect_x10",
+    "__call_indirect_x11",
+    "__call_indirect_x12",
+    "__call_indirect_x13",
+    "__call_indirect_x14",
+    "__call_indirect_x15",
+    "", /* "__call_indirect_x16",  */
+    "", /* "__call_indirect_x17",  */
+    "__call_indirect_x18",
+    "__call_indirect_x19",
+    "__call_indirect_x20",
+    "__call_indirect_x21",
+    "__call_indirect_x22",
+    "__call_indirect_x23",
+    "__call_indirect_x24",
+    "__call_indirect_x25",
+    "__call_indirect_x26",
+    "__call_indirect_x27",
+    "__call_indirect_x28",
+    "__call_indirect_x29",
+};
+
+/* Function to create a BLR thunk.  This thunk is used to mitigate straight
+   line speculation.  Instead of a simple BLR that can be speculated past,
+   we emit a BL to this thunk, and this thunk contains a BR to the relevant
+   register.  These thunks have the relevant speculation barries put after
+   their indirect branch so that speculation is blocked.
+
+   We use such a thunk so the speculation barriers are kept off the
+   architecturally executed path in order to reduce the performance overhead.
+
+   When optimizing for size we use stubs shared by the linked object.
+   When optimizing for performance we emit stubs for each function in the hope
+   that the branch predictor can better train on jumps specific for a given
+   function.  */
+rtx
+aarch64_sls_create_blr_label (int regnum)
+{
+  gcc_assert (STUB_REGNUM_P (regnum));
+  if (optimize_function_for_size_p (cfun))
+    {
+      /* For the thunks shared between different functions in this compilation
+	 unit we use a named symbol -- this is just for users to more easily
+	 understand the generated assembly.  */
+      aarch64_sls_shared_thunks_needed = true;
+      const char *thunk_name = indirect_symbol_names[regnum];
+      if (aarch64_sls_shared_thunks[regnum] == NULL)
+	{
+	  /* Build a decl representing this function stub and record it for
+	     later.  We build a decl here so we can use the GCC machinery for
+	     handling sections automatically (through `get_named_section` and
+	     `make_decl_one_only`).  That saves us a lot of trouble handling
+	     the specifics of different output file formats.  */
+	  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+				  get_identifier (thunk_name),
+				  build_function_type_list (void_type_node,
+							    NULL_TREE));
+	  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+					   NULL_TREE, void_type_node);
+	  TREE_PUBLIC (decl) = 1;
+	  TREE_STATIC (decl) = 1;
+	  DECL_IGNORED_P (decl) = 1;
+	  DECL_ARTIFICIAL (decl) = 1;
+	  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
+	  resolve_unique_section (decl, 0, false);
+	  aarch64_sls_shared_thunks[regnum] = decl;
+	}
+
+      return gen_rtx_SYMBOL_REF (Pmode, thunk_name);
+    }
+
+  if (cfun->machine->call_via[regnum] == NULL)
+    cfun->machine->call_via[regnum]
+      = gen_rtx_LABEL_REF (Pmode, gen_label_rtx ());
+  return cfun->machine->call_via[regnum];
+}
+
+/* Helper function for aarch64_sls_emit_blr_function_thunks and
+   aarch64_sls_emit_shared_blr_thunks below.  */
+static void
+aarch64_sls_emit_function_stub (FILE *out_file, int regnum)
+{
+  /* Save in x16 and branch to that function so this transformation does
+     not prevent jumping to `BTI c` instructions.  */
+  asm_fprintf (out_file, "\tmov\tx16, x%d\n", regnum);
+  asm_fprintf (out_file, "\tbr\tx16\n");
+}
+
+/* Emit all BLR stubs for this particular function.
+   Here we emit all the BLR stubs needed for the current function.  Since we
+   emit these stubs in a consecutive block we know there will be no speculation
+   gadgets between each stub, and hence we only emit a speculation barrier at
+   the end of the stub sequences.
+
+   This is called in the TARGET_ASM_FUNCTION_EPILOGUE hook.  */
+void
+aarch64_sls_emit_blr_function_thunks (FILE *out_file)
+{
+  if (! aarch64_harden_sls_blr_p ())
+    return;
+
+  bool any_functions_emitted = false;
+  /* We must save and restore the current function section since this assembly
+     is emitted at the end of the function.  This means it can be emitted *just
+     after* the cold section of a function.  That cold part would be emitted in
+     a different section.  That switch would trigger a `.cfi_endproc` directive
+     to be emitted in the original section and a `.cfi_startproc` directive to
+     be emitted in the new section.  Switching to the original section without
+     restoring would mean that the `.cfi_endproc` emitted as a function ends
+     would happen in a different section -- leaving an unmatched
+     `.cfi_startproc` in the cold text section and an unmatched `.cfi_endproc`
+     in the standard text section.  */
+  section *save_text_section = in_section;
+  switch_to_section (function_section (current_function_decl));
+  for (int regnum = 0; regnum < 30; ++regnum)
+    {
+      rtx specu_label = cfun->machine->call_via[regnum];
+      if (specu_label == NULL)
+	continue;
+
+      targetm.asm_out.print_operand (out_file, specu_label, 0);
+      asm_fprintf (out_file, ":\n");
+      aarch64_sls_emit_function_stub (out_file, regnum);
+      any_functions_emitted = true;
+    }
+  if (any_functions_emitted)
+    /* Can use the SB if needs be here, since this stub will only be used
+      by the current function, and hence for the current target.  */
+    asm_fprintf (out_file, "\t%s\n", aarch64_sls_barrier (true));
+  switch_to_section (save_text_section);
+}
+
+/* Emit shared BLR stubs for the current compilation unit.
+   Over the course of compiling this unit we may have converted some BLR
+   instructions to a BL to a shared stub function.  This is where we emit those
+   stub functions.
+   This function is for the stubs shared between different functions in this
+   compilation unit.  We share when optimizing for size instead of speed.
+
+   This function is called through the TARGET_ASM_FILE_END hook.  */
+void
+aarch64_sls_emit_shared_blr_thunks (FILE *out_file)
+{
+  if (! aarch64_sls_shared_thunks_needed)
+    return;
+
+  for (int regnum = 0; regnum < 30; ++regnum)
+    {
+      tree decl = aarch64_sls_shared_thunks[regnum];
+      if (!decl)
+	continue;
+
+      const char *name = indirect_symbol_names[regnum];
+      switch_to_section (get_named_section (decl, NULL, 0));
+      ASM_OUTPUT_ALIGN (out_file, 2);
+      targetm.asm_out.globalize_label (out_file, name);
+      /* Only emits if the compiler is configured for an assembler that can
+	 handle visibility directives.  */
+      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);
+      ASM_OUTPUT_TYPE_DIRECTIVE (out_file, name, "function");
+      ASM_OUTPUT_LABEL (out_file, name);
+      aarch64_sls_emit_function_stub (out_file, regnum);
+      /* Use the most conservative target to ensure it can always be used by any
+	 function in the translation unit.  */
+      asm_fprintf (out_file, "\tdsb\tsy\n\tisb\n");
+      ASM_DECLARE_FUNCTION_SIZE (out_file, name, decl);
+    }
+}
+
+/* Implement TARGET_ASM_FILE_END.  */
+void
+aarch64_asm_file_end ()
+{
+  aarch64_sls_emit_shared_blr_thunks (asm_out_file);
+  /* Since this function will be called for the ASM_FILE_END hook, we ensure
+     that what would be called otherwise (e.g. `file_end_indicate_exec_stack`
+     for FreeBSD) still gets called.  */
+#ifdef TARGET_ASM_FILE_END
+  TARGET_ASM_FILE_END ();
+#endif
+}
+
+const char *
+aarch64_indirect_call_asm (rtx addr)
+{
+  gcc_assert (REG_P (addr));
+  if (aarch64_harden_sls_blr_p ())
+    {
+      rtx stub_label = aarch64_sls_create_blr_label (REGNO (addr));
+      output_asm_insn ("bl\t%0", &stub_label);
+    }
+  else
+   output_asm_insn ("blr\t%0", &addr);
+  return "";
+}
+
 /* Target-specific selftests.  */
 
 #if CHECKING_P
@@ -19420,6 +20032,12 @@ aarch64_libgcc_floating_mode_supported_p
 #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests
 #endif /* #if CHECKING_P */
 
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END aarch64_asm_file_end
+
+#undef TARGET_ASM_FUNCTION_EPILOGUE
+#define TARGET_ASM_FUNCTION_EPILOGUE aarch64_sls_emit_blr_function_thunks
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-aarch64.h"
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index 772a9729688..af0bc3f1881 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -234,7 +234,9 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_ISA_SHA3	   (aarch64_isa_flags & AARCH64_FL_SHA3)
 #define AARCH64_ISA_F16FML	   (aarch64_isa_flags & AARCH64_FL_F16FML)
 #define AARCH64_ISA_RCPC8_4	   (aarch64_isa_flags & AARCH64_FL_RCPC8_4)
+#define AARCH64_ISA_RNG		   (aarch64_isa_flags & AARCH64_FL_RNG)
 #define AARCH64_ISA_V8_5	   (aarch64_isa_flags & AARCH64_FL_V8_5)
+#define AARCH64_ISA_SB		   (aarch64_isa_flags & AARCH64_FL_SB)
 
 /* Crypto is an optional extension to AdvSIMD.  */
 #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)
@@ -273,9 +275,18 @@ extern unsigned aarch64_architecture_version;
 /* ARMv8.3-A features.  */
 #define TARGET_ARMV8_3	(AARCH64_ISA_V8_3)
 
+/* Javascript conversion instruction from Armv8.3-a.  */
+#define TARGET_JSCVT	(TARGET_FLOAT && AARCH64_ISA_V8_3)
+
 /* Armv8.3-a Complex number extension to AdvSIMD extensions.  */
 #define TARGET_COMPLEX (TARGET_SIMD && TARGET_ARMV8_3)
 
+/* Random number instructions from Armv8.5-a.  */
+#define TARGET_RNG (AARCH64_ISA_RNG)
+
+/* Floating-point rounding instructions from Armv8.5-a.  */
+#define TARGET_FRINT (AARCH64_ISA_V8_5 && TARGET_FLOAT)
+
 /* Make sure this is always defined so we don't have to check for ifdefs
    but rather use normal ifs.  */
 #ifndef TARGET_FIX_ERR_A53_835769_DEFAULT
@@ -285,6 +296,9 @@ extern unsigned aarch64_architecture_version;
 #define TARGET_FIX_ERR_A53_835769_DEFAULT 1
 #endif
 
+/* SB instruction is enabled through +sb.  */
+#define TARGET_SB (AARCH64_ISA_SB)
+
 /* Apply the workaround for Cortex-A53 erratum 835769.  */
 #define TARGET_FIX_ERR_A53_835769	\
   ((aarch64_fix_a53_err835769 == 2)	\
@@ -536,6 +550,16 @@ extern unsigned aarch64_architecture_version;
 #define GP_REGNUM_P(REGNO)						\
   (((unsigned) (REGNO - R0_REGNUM)) <= (R30_REGNUM - R0_REGNUM))
 
+/* Registers known to be preserved over a BL instruction.  This consists of the
+   GENERAL_REGS without x16, x17, and x30.  The x30 register is changed by the
+   BL instruction itself, while the x16 and x17 registers may be used by
+   veneers which can be inserted by the linker.  */
+#define STUB_REGNUM_P(REGNO) \
+  (GP_REGNUM_P (REGNO) \
+   && (REGNO) != R16_REGNUM \
+   && (REGNO) != R17_REGNUM \
+   && (REGNO) != R30_REGNUM) \
+
 #define FP_REGNUM_P(REGNO)			\
   (((unsigned) (REGNO - V0_REGNUM)) <= (V31_REGNUM - V0_REGNUM))
 
@@ -557,6 +581,7 @@ enum reg_class
 {
   NO_REGS,
   TAILCALL_ADDR_REGS,
+  STUB_REGS,
   GENERAL_REGS,
   STACK_REG,
   POINTER_REGS,
@@ -576,6 +601,7 @@ enum reg_class
 {						\
   "NO_REGS",					\
   "TAILCALL_ADDR_REGS",				\
+  "STUB_REGS",					\
   "GENERAL_REGS",				\
   "STACK_REG",					\
   "POINTER_REGS",				\
@@ -592,6 +618,7 @@ enum reg_class
 {									\
   { 0x00000000, 0x00000000, 0x00000000 },	/* NO_REGS */		\
   { 0x00030000, 0x00000000, 0x00000000 },	/* TAILCALL_ADDR_REGS */\
+  { 0x3ffcffff, 0x00000000, 0x00000000 },	/* STUB_REGS */		\
   { 0x7fffffff, 0x00000000, 0x00000003 },	/* GENERAL_REGS */	\
   { 0x80000000, 0x00000000, 0x00000000 },	/* STACK_REG */		\
   { 0xffffffff, 0x00000000, 0x00000003 },	/* POINTER_REGS */	\
@@ -731,6 +758,8 @@ typedef struct GTY (()) machine_function
   struct aarch64_frame frame;
   /* One entry for each hard register.  */
   bool reg_is_wrapped_separately[LAST_SAVED_REGNUM];
+  /* One entry for each general purpose register.  */
+  rtx call_via[SP_REGNUM];
   bool label_is_assembled;
 } machine_function;
 #endif
@@ -931,8 +960,10 @@ typedef struct
 
 #define RETURN_ADDR_RTX aarch64_return_addr
 
-/* BTI c + 3 insns + 2 pointer-sized entries.  */
-#define TRAMPOLINE_SIZE	(TARGET_ILP32 ? 24 : 32)
+/* BTI c + 3 insns
+   + sls barrier of DSB + ISB.
+   + 2 pointer-sized entries.  */
+#define TRAMPOLINE_SIZE	(24 + (TARGET_ILP32 ? 8 : 16))
 
 /* Trampolines contain dwords, so must be dword aligned.  */
 #define TRAMPOLINE_ALIGNMENT 64
@@ -968,7 +999,7 @@ typedef struct
 #define PROFILE_HOOK(LABEL)						\
   {									\
     rtx fun, lr;							\
-    lr = get_hard_reg_initial_val (Pmode, LR_REGNUM);			\
+    lr = aarch64_return_addr_rtx ();					\
     fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_NAME);			\
     emit_library_call (fun, LCT_NORMAL, VOIDmode, lr, Pmode);		\
   }
@@ -1036,12 +1067,14 @@ extern enum aarch64_code_model aarch64_cmodel;
 #define ENDIAN_LANE_N(NUNITS, N) \
   (BYTES_BIG_ENDIAN ? NUNITS - 1 - N : N)
 
-/* Support for a configure-time default CPU, etc.  We currently support
-   --with-arch and --with-cpu.  Both are ignored if either is specified
-   explicitly on the command line at run time.  */
+/* Support for configure-time --with-arch, --with-cpu and --with-tune.
+   --with-arch and --with-cpu are ignored if either -mcpu or -march is used.
+   --with-tune is ignored if either -mtune or -mcpu is used (but is not
+   affected by -march).  */
 #define OPTION_DEFAULT_SPECS				\
   {"arch", "%{!march=*:%{!mcpu=*:-march=%(VALUE)}}" },	\
-  {"cpu",  "%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}" },
+  {"cpu",  "%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}" },   \
+  {"tune", "%{!mcpu=*:%{!mtune=*:-mtune=%(VALUE)}}"},
 
 #define MCPU_TO_MARCH_SPEC \
    " %{mcpu=*:-march=%:rewrite_mcpu(%{mcpu=*:%*})}"
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index cc5a887d404..78288abfd92 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -138,6 +138,11 @@
     UNSPEC_CRC32X
     UNSPEC_FCVTZS
     UNSPEC_FCVTZU
+    UNSPEC_FJCVTZS
+    UNSPEC_FRINT32Z
+    UNSPEC_FRINT32X
+    UNSPEC_FRINT64Z
+    UNSPEC_FRINT64X
     UNSPEC_URECPE
     UNSPEC_FRECPE
     UNSPEC_FRECPS
@@ -246,6 +251,8 @@
     UNSPECV_BTI_C		; Represent BTI c.
     UNSPECV_BTI_J		; Represent BTI j.
     UNSPECV_BTI_JC		; Represent BTI jc.
+    UNSPEC_RNDR			; Represent RNDR
+    UNSPEC_RNDRRS		; Represent RNDRRS
   ]
 )
 
@@ -331,10 +338,25 @@
 ;; Attribute that specifies whether the alternative uses MOVPRFX.
 (define_attr "movprfx" "no,yes" (const_string "no"))
 
+;; Attribute to specify that an alternative has the length of a single
+;; instruction plus a speculation barrier.
+(define_attr "sls_length" "none,retbr,casesi" (const_string "none"))
+
 (define_attr "length" ""
   (cond [(eq_attr "movprfx" "yes")
            (const_int 8)
-        ] (const_int 4)))
+
+	 (eq_attr "sls_length" "retbr")
+	   (cond [(match_test "!aarch64_harden_sls_retbr_p ()") (const_int 4)
+		  (match_test "TARGET_SB") (const_int 8)]
+		 (const_int 12))
+
+	 (eq_attr "sls_length" "casesi")
+	   (cond [(match_test "!aarch64_harden_sls_retbr_p ()") (const_int 16)
+		  (match_test "TARGET_SB") (const_int 20)]
+		 (const_int 24))
+	]
+	  (const_int 4)))
 
 ;; Strictly for compatibility with AArch32 in pipeline models, since AArch64 has
 ;; no predicated insns.
@@ -370,8 +392,12 @@
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:DI 0 "register_operand" "r"))]
   ""
-  "br\\t%0"
-  [(set_attr "type" "branch")]
+  {
+    output_asm_insn ("br\\t%0", operands);
+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
+  }
+  [(set_attr "type" "branch")
+   (set_attr "sls_length" "retbr")]
 )
 
 (define_insn "jump"
@@ -657,7 +683,7 @@
   "*
   return aarch64_output_casesi (operands);
   "
-  [(set_attr "length" "16")
+  [(set_attr "sls_length" "casesi")
    (set_attr "type" "branch")]
 )
 
@@ -736,14 +762,18 @@
   [(return)]
   ""
   {
+    const char *ret = NULL;
     if (aarch64_return_address_signing_enabled ()
 	&& TARGET_ARMV8_3
 	&& !crtl->calls_eh_return)
-      return "retaa";
-
-    return "ret";
+      ret = "retaa";
+    else
+      ret = "ret";
+    output_asm_insn (ret, operands);
+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
   }
-  [(set_attr "type" "branch")]
+  [(set_attr "type" "branch")
+   (set_attr "sls_length" "retbr")]
 )
 
 (define_expand "return"
@@ -755,8 +785,12 @@
 (define_insn "simple_return"
   [(simple_return)]
   "aarch64_use_simple_return_insn_p ()"
-  "ret"
-  [(set_attr "type" "branch")]
+  {
+    output_asm_insn ("ret", operands);
+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
+  }
+  [(set_attr "type" "branch")
+   (set_attr "sls_length" "retbr")]
 )
 
 (define_insn "*cb<optab><mode>1"
@@ -881,15 +915,14 @@
 )
 
 (define_insn "*call_insn"
-  [(call (mem:DI (match_operand:DI 0 "aarch64_call_insn_operand" "r, Usf"))
+  [(call (mem:DI (match_operand:DI 0 "aarch64_call_insn_operand" "Ucr, Usf"))
 	 (match_operand 1 "" ""))
    (clobber (reg:DI LR_REGNUM))]
   ""
   "@
-  blr\\t%0
+  * return aarch64_indirect_call_asm (operands[0]);
   bl\\t%c0"
-  [(set_attr "type" "call, call")]
-)
+  [(set_attr "type" "call, call")])
 
 (define_expand "call_value"
   [(parallel [(set (match_operand 0 "" "")
@@ -907,12 +940,12 @@
 
 (define_insn "*call_value_insn"
   [(set (match_operand 0 "" "")
-	(call (mem:DI (match_operand:DI 1 "aarch64_call_insn_operand" "r, Usf"))
+	(call (mem:DI (match_operand:DI 1 "aarch64_call_insn_operand" "Ucr, Usf"))
 		      (match_operand 2 "" "")))
    (clobber (reg:DI LR_REGNUM))]
   ""
   "@
-  blr\\t%1
+  * return aarch64_indirect_call_asm (operands[1]);
   bl\\t%c1"
   [(set_attr "type" "call, call")]
 )
@@ -947,10 +980,16 @@
 	 (match_operand 1 "" ""))
    (return)]
   "SIBLING_CALL_P (insn)"
-  "@
-   br\\t%0
-   b\\t%c0"
-  [(set_attr "type" "branch, branch")]
+  {
+    if (which_alternative == 0)
+      {
+	output_asm_insn ("br\\t%0", operands);
+	return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
+      }
+    return "b\\t%c0";
+  }
+  [(set_attr "type" "branch, branch")
+   (set_attr "sls_length" "retbr,none")]
 )
 
 (define_insn "*sibcall_value_insn"
@@ -960,10 +999,16 @@
 	      (match_operand 2 "" "")))
    (return)]
   "SIBLING_CALL_P (insn)"
-  "@
-   br\\t%1
-   b\\t%c1"
-  [(set_attr "type" "branch, branch")]
+  {
+    if (which_alternative == 0)
+      {
+	output_asm_insn ("br\\t%1", operands);
+	return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());
+      }
+    return "b\\t%c1";
+  }
+  [(set_attr "type" "branch, branch")
+   (set_attr "sls_length" "retbr,none")]
 )
 
 ;; Call subroutine returning any type.
@@ -6798,6 +6843,16 @@
   [(set_attr "length" "0")]
 )
 
+(define_insn "aarch64_fjcvtzs"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:DF 1 "register_operand" "w")]
+		   UNSPEC_FJCVTZS))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_JSCVT"
+  "fjcvtzs\\t%w0, %d1"
+  [(set_attr "type" "f_cvtf2i")]
+)
+
 ;; Pointer authentication patterns are always provided.  In architecture
 ;; revisions prior to ARMv8.3-A these HINT instructions operate as NOPs.
 ;; This lets the user write portable software which authenticates pointers
@@ -6947,10 +7002,8 @@
    (match_operand 2)]
   ""
 {
-  rtx result;
   machine_mode mode = GET_MODE (operands[0]);
 
-  result = gen_reg_rtx(mode);
   if (aarch64_stack_protector_guard != SSP_GLOBAL)
   {
     /* Generate access through the system register. The
@@ -6975,29 +7028,27 @@
     operands[1] = gen_rtx_MEM (mode, tmp_reg);
   }
   emit_insn ((mode == DImode
-		  ? gen_stack_protect_test_di
-		  : gen_stack_protect_test_si) (result,
-					        operands[0],
-					        operands[1]));
-
-  if (mode == DImode)
-    emit_jump_insn (gen_cbranchdi4 (gen_rtx_EQ (VOIDmode, result, const0_rtx),
-				    result, const0_rtx, operands[2]));
-  else
-    emit_jump_insn (gen_cbranchsi4 (gen_rtx_EQ (VOIDmode, result, const0_rtx),
-				    result, const0_rtx, operands[2]));
+	     ? gen_stack_protect_test_di
+	     : gen_stack_protect_test_si) (operands[0], operands[1]));
+
+  rtx cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);
+  emit_jump_insn (gen_condjump (gen_rtx_EQ (VOIDmode, cc_reg, const0_rtx),
+				cc_reg, operands[2]));
   DONE;
 })
 
+;; DO NOT SPLIT THIS PATTERN.  It is important for security reasons that the
+;; canary value does not live beyond the end of this sequence.
 (define_insn "stack_protect_test_<mode>"
-  [(set (match_operand:PTR 0 "register_operand" "=r")
-	(unspec:PTR [(match_operand:PTR 1 "memory_operand" "m")
-		     (match_operand:PTR 2 "memory_operand" "m")]
-	 UNSPEC_SP_TEST))
+  [(set (reg:CC CC_REGNUM)
+	(unspec:CC [(match_operand:PTR 0 "memory_operand" "m")
+		    (match_operand:PTR 1 "memory_operand" "m")]
+		   UNSPEC_SP_TEST))
+   (clobber (match_scratch:PTR 2 "=&r"))
    (clobber (match_scratch:PTR 3 "=&r"))]
   ""
-  "ldr\t%<w>3, %1\;ldr\t%<w>0, %2\;eor\t%<w>0, %<w>3, %<w>0"
-  [(set_attr "length" "12")
+  "ldr\t%<w>2, %0\;ldr\t%<w>3, %1\;subs\t%<w>2, %<w>2, %<w>3\;mov\t%3, 0"
+  [(set_attr "length" "16")
    (set_attr "type" "multiple")])
 
 ;; Write Floating-point Control Register.
@@ -7225,6 +7276,36 @@
    (set_attr "speculation_barrier" "true")]
 )
 
+(define_insn "aarch64_<frintnzs_op><mode>"
+  [(set (match_operand:VSFDF 0 "register_operand" "=w")
+	(unspec:VSFDF [(match_operand:VSFDF 1 "register_operand" "w")]
+		      FRINTNZX))]
+  "TARGET_FRINT && TARGET_FLOAT
+   && !(VECTOR_MODE_P (<MODE>mode) && !TARGET_SIMD)"
+  "<frintnzs_op>\\t%<v>0<Vmtype>, %<v>1<Vmtype>"
+  [(set_attr "type" "f_rint<stype>")]
+)
+
+(define_insn "aarch64_rndr"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec_volatile:DI [(const_int 0)] UNSPEC_RNDR))
+   (set (reg:CC_Z CC_REGNUM)
+	(unspec_volatile:CC_Z [(const_int 0)] UNSPEC_RNDR))]
+  "TARGET_RNG"
+  "mrs\t%0, RNDR"
+  [(set_attr "type" "mrs")]
+)
+
+(define_insn "aarch64_rndrrs"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec_volatile:DI [(const_int 0)] UNSPEC_RNDRRS))
+   (set (reg:CC_Z CC_REGNUM)
+	(unspec_volatile:CC_Z [(const_int 0)] UNSPEC_RNDRRS))]
+  "TARGET_RNG"
+  "mrs\t%0, RNDRRS"
+  [(set_attr "type" "mrs")]
+)
+
 ;; AdvSIMD Stuff
 (include "aarch64-simd.md")
 
diff --git a/gcc/config/aarch64/aarch64.opt b/gcc/config/aarch64/aarch64.opt
index 3c6d1cc90ad..4beb2d3d243 100644
--- a/gcc/config/aarch64/aarch64.opt
+++ b/gcc/config/aarch64/aarch64.opt
@@ -71,6 +71,10 @@ mgeneral-regs-only
 Target Report RejectNegative Mask(GENERAL_REGS_ONLY) Save
 Generate code which uses only the general registers.
 
+mharden-sls=
+Target RejectNegative Joined Var(aarch64_harden_sls_string)
+Generate code to mitigate against straight line speculation.
+
 mfix-cortex-a53-835769
 Target Report Var(aarch64_fix_a53_err835769) Init(2) Save
 Workaround for ARM Cortex-A53 Erratum number 835769.
@@ -255,3 +259,6 @@ user-land code.
 TargetVariable
 long aarch64_stack_protector_guard_offset = 0
 
+moutline-atomics
+Target Report Mask(OUTLINE_ATOMICS) Save
+Generate local calls to out-of-line atomic operations.
diff --git a/gcc/config/aarch64/arm_acle.h b/gcc/config/aarch64/arm_acle.h
index 534a989c39a..56147352c23 100644
--- a/gcc/config/aarch64/arm_acle.h
+++ b/gcc/config/aarch64/arm_acle.h
@@ -29,6 +29,71 @@
 
 #include <stdint.h>
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8.3-a")
+__extension__ static __inline int32_t __attribute__ ((__always_inline__))
+__jcvt (double __a)
+{
+  return __builtin_aarch64_jcvtzs (__a);
+}
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8.5-a")
+__extension__ static __inline float __attribute__ ((__always_inline__))
+__rint32zf (float __a)
+{
+  return __builtin_aarch64_frint32zsf (__a);
+}
+
+__extension__ static __inline double __attribute__ ((__always_inline__))
+__rint32z (double __a)
+{
+  return __builtin_aarch64_frint32zdf (__a);
+}
+
+__extension__ static __inline float __attribute__ ((__always_inline__))
+__rint64zf (float __a)
+{
+  return __builtin_aarch64_frint64zsf (__a);
+}
+
+__extension__ static __inline double __attribute__ ((__always_inline__))
+__rint64z (double __a)
+{
+  return __builtin_aarch64_frint64zdf (__a);
+}
+
+__extension__ static __inline float __attribute__ ((__always_inline__))
+__rint32xf (float __a)
+{
+  return __builtin_aarch64_frint32xsf (__a);
+}
+
+__extension__ static __inline double __attribute__ ((__always_inline__))
+__rint32x (double __a)
+{
+  return __builtin_aarch64_frint32xdf (__a);
+}
+
+__extension__ static __inline float __attribute__ ((__always_inline__))
+__rint64xf (float __a)
+{
+  return __builtin_aarch64_frint64xsf (__a);
+}
+
+__extension__ static __inline double __attribute__ ((__always_inline__))
+__rint64x (double __a)
+{
+  return __builtin_aarch64_frint64xdf (__a);
+}
+#pragma GCC pop_options
+
+#pragma GCC pop_options
+
 #pragma GCC push_options
 
 #pragma GCC target ("+nothing+crc")
@@ -85,6 +150,24 @@ __crc32d (uint32_t __a, uint64_t __b)
   return __builtin_aarch64_crc32x (__a, __b);
 }
 
+#pragma GCC pop_options
+
+#pragma GCC push_options
+#pragma GCC target ("+nothing+rng")
+__extension__ static __inline int __attribute__ ((__always_inline__))
+__rndr (uint64_t *__res)
+{
+  return __builtin_aarch64_rndr (__res);
+}
+
+__extension__ static __inline int __attribute__ ((__always_inline__))
+__rndrrs (uint64_t *__res)
+{
+  return __builtin_aarch64_rndrrs (__res);
+}
+
+#pragma GCC pop_options
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/gcc/config/aarch64/arm_neon.h b/gcc/config/aarch64/arm_neon.h
index 314ef30187d..3e165c032c5 100644
--- a/gcc/config/aarch64/arm_neon.h
+++ b/gcc/config/aarch64/arm_neon.h
@@ -6055,6 +6055,20 @@ vreinterpretq_u32_p128 (poly128_t __a)
   return (uint32x4_t)__a;
 }
 
+__extension__ extern __inline float64x2_t
+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
+vreinterpretq_f64_p128 (poly128_t __a)
+{
+  return (float64x2_t) __a;
+}
+
+__extension__ extern __inline poly128_t
+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
+vreinterpretq_p128_f64 (float64x2_t __a)
+{
+  return (poly128_t) __a;
+}
+
 /* vset_lane  */
 
 __extension__ extern __inline float16x4_t
@@ -12801,6 +12815,13 @@ vceqq_u64 (uint64x2_t __a, uint64x2_t __b)
   return (__a == __b);
 }
 
+__extension__ extern __inline uint64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vceqq_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+  return (__a == __b);
+}
+
 /* vceq - scalar.  */
 
 __extension__ extern __inline uint32_t
@@ -12910,6 +12931,13 @@ vceqz_u64 (uint64x1_t __a)
   return (__a == __AARCH64_UINT64_C (0));
 }
 
+__extension__ extern __inline uint64x1_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vceqz_p64 (poly64x1_t __a)
+{
+  return (__a == __AARCH64_UINT64_C (0));
+}
+
 __extension__ extern __inline uint32x4_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vceqzq_f32 (float32x4_t __a)
@@ -12987,6 +13015,13 @@ vceqzq_u64 (uint64x2_t __a)
   return (__a == __AARCH64_UINT64_C (0));
 }
 
+__extension__ extern __inline uint64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vceqzq_p64 (poly64x2_t __a)
+{
+  return (__a == __AARCH64_UINT64_C (0));
+}
+
 /* vceqz - scalar.  */
 
 __extension__ extern __inline uint32_t
@@ -14185,6 +14220,48 @@ vclsq_s32 (int32x4_t __a)
   return __builtin_aarch64_clrsbv4si (__a);
 }
 
+__extension__ extern __inline int8x8_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vcls_u8 (uint8x8_t __a)
+{
+  return __builtin_aarch64_clrsbv8qi ((int8x8_t) __a);
+}
+
+__extension__ extern __inline int16x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vcls_u16 (uint16x4_t __a)
+{
+  return __builtin_aarch64_clrsbv4hi ((int16x4_t) __a);
+}
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vcls_u32 (uint32x2_t __a)
+{
+  return __builtin_aarch64_clrsbv2si ((int32x2_t) __a);
+}
+
+__extension__ extern __inline int8x16_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vclsq_u8 (uint8x16_t __a)
+{
+  return __builtin_aarch64_clrsbv16qi ((int8x16_t) __a);
+}
+
+__extension__ extern __inline int16x8_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vclsq_u16 (uint16x8_t __a)
+{
+  return __builtin_aarch64_clrsbv8hi ((int16x8_t) __a);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vclsq_u32 (uint32x4_t __a)
+{
+  return __builtin_aarch64_clrsbv4si ((int32x4_t) __a);
+}
+
 /* vclz.  */
 
 __extension__ extern __inline int8x8_t
@@ -15669,7 +15746,7 @@ vdupq_n_f64 (float64_t __a)
 
 __extension__ extern __inline poly8x16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_p8 (uint32_t __a)
+vdupq_n_p8 (poly8_t __a)
 {
   return (poly8x16_t) {__a, __a, __a, __a, __a, __a, __a, __a,
 		       __a, __a, __a, __a, __a, __a, __a, __a};
@@ -15677,21 +15754,21 @@ vdupq_n_p8 (uint32_t __a)
 
 __extension__ extern __inline poly16x8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_p16 (uint32_t __a)
+vdupq_n_p16 (poly16_t __a)
 {
   return (poly16x8_t) {__a, __a, __a, __a, __a, __a, __a, __a};
 }
 
 __extension__ extern __inline poly64x2_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_p64 (uint64_t __a)
+vdupq_n_p64 (poly64_t __a)
 {
   return (poly64x2_t) {__a, __a};
 }
 
 __extension__ extern __inline int8x16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_s8 (int32_t __a)
+vdupq_n_s8 (int8_t __a)
 {
   return (int8x16_t) {__a, __a, __a, __a, __a, __a, __a, __a,
 		      __a, __a, __a, __a, __a, __a, __a, __a};
@@ -15699,7 +15776,7 @@ vdupq_n_s8 (int32_t __a)
 
 __extension__ extern __inline int16x8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_s16 (int32_t __a)
+vdupq_n_s16 (int16_t __a)
 {
   return (int16x8_t) {__a, __a, __a, __a, __a, __a, __a, __a};
 }
@@ -15720,7 +15797,7 @@ vdupq_n_s64 (int64_t __a)
 
 __extension__ extern __inline uint8x16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_u8 (uint32_t __a)
+vdupq_n_u8 (uint8_t __a)
 {
   return (uint8x16_t) {__a, __a, __a, __a, __a, __a, __a, __a,
 		       __a, __a, __a, __a, __a, __a, __a, __a};
@@ -15728,7 +15805,7 @@ vdupq_n_u8 (uint32_t __a)
 
 __extension__ extern __inline uint16x8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vdupq_n_u16 (uint32_t __a)
+vdupq_n_u16 (uint16_t __a)
 {
   return (uint16x8_t) {__a, __a, __a, __a, __a, __a, __a, __a};
 }
@@ -17968,6 +18045,288 @@ vld1q_u64 (const uint64_t *a)
     __builtin_aarch64_ld1v2di ((const __builtin_aarch64_simd_di *) a);
 }
 
+/* vld1(q)_x4.  */
+
+__extension__ extern __inline int8x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_s8_x4 (const int8_t *__a)
+{
+  union { int8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int8x16x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_s8_x4 (const int8_t *__a)
+{
+  union { int8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v16qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int16x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_s16_x4 (const int16_t *__a)
+{
+  union { int16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int16x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_s16_x4 (const int16_t *__a)
+{
+  union { int16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int32x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_s32_x4 (const int32_t *__a)
+{
+  union { int32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+  = __builtin_aarch64_ld1x4v2si ((const __builtin_aarch64_simd_si *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int32x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_s32_x4 (const int32_t *__a)
+{
+  union { int32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+  = __builtin_aarch64_ld1x4v4si ((const __builtin_aarch64_simd_si *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint8x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_u8_x4 (const uint8_t *__a)
+{
+  union { uint8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint8x16x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_u8_x4 (const uint8_t *__a)
+{
+  union { uint8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v16qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint16x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_u16_x4 (const uint16_t *__a)
+{
+  union { uint16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint16x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_u16_x4 (const uint16_t *__a)
+{
+  union { uint16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint32x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_u32_x4 (const uint32_t *__a)
+{
+  union { uint32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2si ((const __builtin_aarch64_simd_si *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint32x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_u32_x4 (const uint32_t *__a)
+{
+  union { uint32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4si ((const __builtin_aarch64_simd_si *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float16x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_f16_x4 (const float16_t *__a)
+{
+  union { float16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4hf ((const __builtin_aarch64_simd_hf *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float16x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_f16_x4 (const float16_t *__a)
+{
+  union { float16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8hf ((const __builtin_aarch64_simd_hf *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float32x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_f32_x4 (const float32_t *__a)
+{
+  union { float32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2sf ((const __builtin_aarch64_simd_sf *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float32x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_f32_x4 (const float32_t *__a)
+{
+  union { float32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4sf ((const __builtin_aarch64_simd_sf *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly8x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_p8_x4 (const poly8_t *__a)
+{
+  union { poly8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly8x16x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_p8_x4 (const poly8_t *__a)
+{
+  union { poly8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v16qi ((const __builtin_aarch64_simd_qi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly16x4x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_p16_x4 (const poly16_t *__a)
+{
+  union { poly16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v4hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly16x8x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_p16_x4 (const poly16_t *__a)
+{
+  union { poly16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v8hi ((const __builtin_aarch64_simd_hi *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int64x1x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_s64_x4 (const int64_t *__a)
+{
+  union { int64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint64x1x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_u64_x4 (const uint64_t *__a)
+{
+  union { uint64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly64x1x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_p64_x4 (const poly64_t *__a)
+{
+  union { poly64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline int64x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_s64_x4 (const int64_t *__a)
+{
+  union { int64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline uint64x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_u64_x4 (const uint64_t *__a)
+{
+  union { uint64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline poly64x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_p64_x4 (const poly64_t *__a)
+{
+  union { poly64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2di ((const __builtin_aarch64_simd_di *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float64x1x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1_f64_x4 (const float64_t *__a)
+{
+  union { float64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4df ((const __builtin_aarch64_simd_df *) __a);
+  return __au.__i;
+}
+
+__extension__ extern __inline float64x2x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vld1q_f64_x4 (const float64_t *__a)
+{
+  union { float64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __au;
+  __au.__o
+    = __builtin_aarch64_ld1x4v2df ((const __builtin_aarch64_simd_df *) __a);
+  return __au.__i;
+}
+
 /* vld1_dup  */
 
 __extension__ extern __inline float16x4_t
@@ -19462,6 +19821,13 @@ vld4q_p64 (const poly64_t * __a)
   return ret;
 }
 
+__extension__ extern __inline poly128_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vldrq_p128 (const poly128_t * __ptr)
+{
+  return *__ptr;
+}
+
 /* vldn_dup */
 
 __extension__ extern __inline int8x8x2_t
@@ -23811,42 +24177,42 @@ __extension__ extern __inline uint8x8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovun_s16 (int16x8_t __a)
 {
-  return (uint8x8_t) __builtin_aarch64_sqmovunv8hi (__a);
+  return __builtin_aarch64_sqmovunv8hi_us (__a);
 }
 
 __extension__ extern __inline uint16x4_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovun_s32 (int32x4_t __a)
 {
-  return (uint16x4_t) __builtin_aarch64_sqmovunv4si (__a);
+  return __builtin_aarch64_sqmovunv4si_us (__a);
 }
 
 __extension__ extern __inline uint32x2_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovun_s64 (int64x2_t __a)
 {
-  return (uint32x2_t) __builtin_aarch64_sqmovunv2di (__a);
+  return __builtin_aarch64_sqmovunv2di_us (__a);
 }
 
-__extension__ extern __inline int8_t
+__extension__ extern __inline uint8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovunh_s16 (int16_t __a)
 {
-  return (int8_t) __builtin_aarch64_sqmovunhi (__a);
+  return __builtin_aarch64_sqmovunhi_us (__a);
 }
 
-__extension__ extern __inline int16_t
+__extension__ extern __inline uint16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovuns_s32 (int32_t __a)
 {
-  return (int16_t) __builtin_aarch64_sqmovunsi (__a);
+  return __builtin_aarch64_sqmovunsi_us (__a);
 }
 
-__extension__ extern __inline int32_t
+__extension__ extern __inline uint32_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vqmovund_s64 (int64_t __a)
 {
-  return (int32_t) __builtin_aarch64_sqmovundi (__a);
+  return __builtin_aarch64_sqmovundi_us (__a);
 }
 
 /* vqneg */
@@ -24102,28 +24468,28 @@ vqrshld_s64 (int64_t __a, int64_t __b)
 
 __extension__ extern __inline uint8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqrshlb_u8 (uint8_t __a, uint8_t __b)
+vqrshlb_u8 (uint8_t __a, int8_t __b)
 {
   return __builtin_aarch64_uqrshlqi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqrshlh_u16 (uint16_t __a, uint16_t __b)
+vqrshlh_u16 (uint16_t __a, int16_t __b)
 {
   return __builtin_aarch64_uqrshlhi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint32_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqrshls_u32 (uint32_t __a, uint32_t __b)
+vqrshls_u32 (uint32_t __a, int32_t __b)
 {
   return __builtin_aarch64_uqrshlsi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint64_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqrshld_u64 (uint64_t __a, uint64_t __b)
+vqrshld_u64 (uint64_t __a, int64_t __b)
 {
   return __builtin_aarch64_uqrshldi_uus (__a, __b);
 }
@@ -24402,28 +24768,28 @@ vqshld_s64 (int64_t __a, int64_t __b)
 
 __extension__ extern __inline uint8_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqshlb_u8 (uint8_t __a, uint8_t __b)
+vqshlb_u8 (uint8_t __a, int8_t __b)
 {
   return __builtin_aarch64_uqshlqi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint16_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqshlh_u16 (uint16_t __a, uint16_t __b)
+vqshlh_u16 (uint16_t __a, int16_t __b)
 {
   return __builtin_aarch64_uqshlhi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint32_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqshls_u32 (uint32_t __a, uint32_t __b)
+vqshls_u32 (uint32_t __a, int32_t __b)
 {
   return __builtin_aarch64_uqshlsi_uus (__a, __b);
 }
 
 __extension__ extern __inline uint64_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vqshld_u64 (uint64_t __a, uint64_t __b)
+vqshld_u64 (uint64_t __a, int64_t __b)
 {
   return __builtin_aarch64_uqshldi_uus (__a, __b);
 }
@@ -25852,6 +26218,13 @@ vrndmq_f64 (float64x2_t __a)
 
 /* vrndn  */
 
+__extension__ extern __inline float32_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrndns_f32 (float32_t __a)
+{
+  return __builtin_aarch64_frintnsf (__a);
+}
+
 __extension__ extern __inline float32x2_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vrndn_f32 (float32x2_t __a)
@@ -26754,7 +27127,7 @@ vshld_s64 (int64_t __a, int64_t __b)
 
 __extension__ extern __inline uint64_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vshld_u64 (uint64_t __a, uint64_t __b)
+vshld_u64 (uint64_t __a, int64_t __b)
 {
   return __builtin_aarch64_ushldi_uus (__a, __b);
 }
@@ -28596,69 +28969,295 @@ vst1q_p64_x3 (poly64_t * __a, poly64x2x3_t val)
   __builtin_aarch64_st1x3v2di ((__builtin_aarch64_simd_di *) __a, __o);
 }
 
-/* vstn */
+/* vst1(q)_x4.  */
 
 __extension__ extern __inline void
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vst2_s64 (int64_t * __a, int64x1x2_t val)
+vst1_s8_x4 (int8_t * __a, int8x8x4_t val)
 {
-  __builtin_aarch64_simd_oi __o;
-  int64x2x2_t temp;
-  temp.val[0] = vcombine_s64 (val.val[0], vcreate_s64 (__AARCH64_INT64_C (0)));
-  temp.val[1] = vcombine_s64 (val.val[1], vcreate_s64 (__AARCH64_INT64_C (0)));
-  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[0], 0);
-  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[1], 1);
-  __builtin_aarch64_st2di ((__builtin_aarch64_simd_di *) __a, __o);
+  union { int8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
 }
 
 __extension__ extern __inline void
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vst2_u64 (uint64_t * __a, uint64x1x2_t val)
+vst1q_s8_x4 (int8_t * __a, int8x16x4_t val)
 {
-  __builtin_aarch64_simd_oi __o;
-  uint64x2x2_t temp;
-  temp.val[0] = vcombine_u64 (val.val[0], vcreate_u64 (__AARCH64_UINT64_C (0)));
-  temp.val[1] = vcombine_u64 (val.val[1], vcreate_u64 (__AARCH64_UINT64_C (0)));
-  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[0], 0);
-  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[1], 1);
-  __builtin_aarch64_st2di ((__builtin_aarch64_simd_di *) __a, __o);
+  union { int8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v16qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
 }
 
 __extension__ extern __inline void
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vst2_f64 (float64_t * __a, float64x1x2_t val)
+vst1_s16_x4 (int16_t * __a, int16x4x4_t val)
 {
-  __builtin_aarch64_simd_oi __o;
-  float64x2x2_t temp;
-  temp.val[0] = vcombine_f64 (val.val[0], vcreate_f64 (__AARCH64_UINT64_C (0)));
-  temp.val[1] = vcombine_f64 (val.val[1], vcreate_f64 (__AARCH64_UINT64_C (0)));
-  __o = __builtin_aarch64_set_qregoiv2df (__o, (float64x2_t) temp.val[0], 0);
-  __o = __builtin_aarch64_set_qregoiv2df (__o, (float64x2_t) temp.val[1], 1);
-  __builtin_aarch64_st2df ((__builtin_aarch64_simd_df *) __a, __o);
+  union { int16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
 }
 
 __extension__ extern __inline void
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vst2_s8 (int8_t * __a, int8x8x2_t val)
+vst1q_s16_x4 (int16_t * __a, int16x8x4_t val)
 {
-  __builtin_aarch64_simd_oi __o;
-  int8x16x2_t temp;
-  temp.val[0] = vcombine_s8 (val.val[0], vcreate_s8 (__AARCH64_INT64_C (0)));
-  temp.val[1] = vcombine_s8 (val.val[1], vcreate_s8 (__AARCH64_INT64_C (0)));
-  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[0], 0);
-  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[1], 1);
-  __builtin_aarch64_st2v8qi ((__builtin_aarch64_simd_qi *) __a, __o);
+  union { int16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
 }
 
 __extension__ extern __inline void
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
-vst2_p8 (poly8_t * __a, poly8x8x2_t val)
+vst1_s32_x4 (int32_t * __a, int32x2x4_t val)
 {
-  __builtin_aarch64_simd_oi __o;
-  poly8x16x2_t temp;
-  temp.val[0] = vcombine_p8 (val.val[0], vcreate_p8 (__AARCH64_UINT64_C (0)));
-  temp.val[1] = vcombine_p8 (val.val[1], vcreate_p8 (__AARCH64_UINT64_C (0)));
-  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[0], 0);
+  union { int32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2si ((__builtin_aarch64_simd_si *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_s32_x4 (int32_t * __a, int32x4x4_t val)
+{
+  union { int32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4si ((__builtin_aarch64_simd_si *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_u8_x4 (uint8_t * __a, uint8x8x4_t val)
+{
+  union { uint8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_u8_x4 (uint8_t * __a, uint8x16x4_t val)
+{
+  union { uint8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v16qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_u16_x4 (uint16_t * __a, uint16x4x4_t val)
+{
+  union { uint16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_u16_x4 (uint16_t * __a, uint16x8x4_t val)
+{
+  union { uint16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_u32_x4 (uint32_t * __a, uint32x2x4_t val)
+{
+  union { uint32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2si ((__builtin_aarch64_simd_si *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_u32_x4 (uint32_t * __a, uint32x4x4_t val)
+{
+  union { uint32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4si ((__builtin_aarch64_simd_si *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_f16_x4 (float16_t * __a, float16x4x4_t val)
+{
+  union { float16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4hf ((__builtin_aarch64_simd_hf *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_f16_x4 (float16_t * __a, float16x8x4_t val)
+{
+  union { float16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8hf ((__builtin_aarch64_simd_hf *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_f32_x4 (float32_t * __a, float32x2x4_t val)
+{
+  union { float32x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2sf ((__builtin_aarch64_simd_sf *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_f32_x4 (float32_t * __a, float32x4x4_t val)
+{
+  union { float32x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4sf ((__builtin_aarch64_simd_sf *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_p8_x4 (poly8_t * __a, poly8x8x4_t val)
+{
+  union { poly8x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_p8_x4 (poly8_t * __a, poly8x16x4_t val)
+{
+  union { poly8x16x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v16qi ((__builtin_aarch64_simd_qi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_p16_x4 (poly16_t * __a, poly16x4x4_t val)
+{
+  union { poly16x4x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v4hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_p16_x4 (poly16_t * __a, poly16x8x4_t val)
+{
+  union { poly16x8x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v8hi ((__builtin_aarch64_simd_hi *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_s64_x4 (int64_t * __a, int64x1x4_t val)
+{
+  union { int64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_u64_x4 (uint64_t * __a, uint64x1x4_t val)
+{
+  union { uint64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_p64_x4 (poly64_t * __a, poly64x1x4_t val)
+{
+  union { poly64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_s64_x4 (int64_t * __a, int64x2x4_t val)
+{
+  union { int64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_u64_x4 (uint64_t * __a, uint64x2x4_t val)
+{
+  union { uint64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_p64_x4 (poly64_t * __a, poly64x2x4_t val)
+{
+  union { poly64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2di ((__builtin_aarch64_simd_di *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1_f64_x4 (float64_t * __a, float64x1x4_t val)
+{
+  union { float64x1x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4df ((__builtin_aarch64_simd_df *) __a, __u.__o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst1q_f64_x4 (float64_t * __a, float64x2x4_t val)
+{
+  union { float64x2x4_t __i; __builtin_aarch64_simd_xi __o; } __u = { val };
+  __builtin_aarch64_st1x4v2df ((__builtin_aarch64_simd_df *) __a, __u.__o);
+}
+
+/* vstn */
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst2_s64 (int64_t * __a, int64x1x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  int64x2x2_t temp;
+  temp.val[0] = vcombine_s64 (val.val[0], vcreate_s64 (__AARCH64_INT64_C (0)));
+  temp.val[1] = vcombine_s64 (val.val[1], vcreate_s64 (__AARCH64_INT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[1], 1);
+  __builtin_aarch64_st2di ((__builtin_aarch64_simd_di *) __a, __o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst2_u64 (uint64_t * __a, uint64x1x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  uint64x2x2_t temp;
+  temp.val[0] = vcombine_u64 (val.val[0], vcreate_u64 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_u64 (val.val[1], vcreate_u64 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv2di (__o, (int64x2_t) temp.val[1], 1);
+  __builtin_aarch64_st2di ((__builtin_aarch64_simd_di *) __a, __o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst2_f64 (float64_t * __a, float64x1x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  float64x2x2_t temp;
+  temp.val[0] = vcombine_f64 (val.val[0], vcreate_f64 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_f64 (val.val[1], vcreate_f64 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv2df (__o, (float64x2_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv2df (__o, (float64x2_t) temp.val[1], 1);
+  __builtin_aarch64_st2df ((__builtin_aarch64_simd_df *) __a, __o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst2_s8 (int8_t * __a, int8x8x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  int8x16x2_t temp;
+  temp.val[0] = vcombine_s8 (val.val[0], vcreate_s8 (__AARCH64_INT64_C (0)));
+  temp.val[1] = vcombine_s8 (val.val[1], vcreate_s8 (__AARCH64_INT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[0], 0);
+  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[1], 1);
+  __builtin_aarch64_st2v8qi ((__builtin_aarch64_simd_qi *) __a, __o);
+}
+
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vst2_p8 (poly8_t * __a, poly8x8x2_t val)
+{
+  __builtin_aarch64_simd_oi __o;
+  poly8x16x2_t temp;
+  temp.val[0] = vcombine_p8 (val.val[0], vcreate_p8 (__AARCH64_UINT64_C (0)));
+  temp.val[1] = vcombine_p8 (val.val[1], vcreate_p8 (__AARCH64_UINT64_C (0)));
+  __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[0], 0);
   __o = __builtin_aarch64_set_qregoiv16qi (__o, (int8x16_t) temp.val[1], 1);
   __builtin_aarch64_st2v8qi ((__builtin_aarch64_simd_qi *) __a, __o);
 }
@@ -29708,6 +30307,13 @@ vst4q_p64 (poly64_t * __a, poly64x2x4_t val)
   __builtin_aarch64_st4v2di ((__builtin_aarch64_simd_di *) __a, __o);
 }
 
+__extension__ extern __inline void
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vstrq_p128 (poly128_t * __ptr, poly128_t __val)
+{
+  *__ptr = __val;
+}
+
 /* vsub */
 
 __extension__ extern __inline int64_t
@@ -30095,6 +30701,17 @@ vtrn1q_u32 (uint32x4_t __a, uint32x4_t __b)
 #endif
 }
 
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vtrn1q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {3, 1});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {0, 2});
+#endif
+}
+
 __extension__ extern __inline uint64x2_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vtrn1q_u64 (uint64x2_t __a, uint64x2_t __b)
@@ -30365,6 +30982,18 @@ vtrn2q_u64 (uint64x2_t __a, uint64x2_t __b)
 #endif
 }
 
+
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vtrn2q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {2, 0});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {1, 3});
+#endif
+}
+
 __extension__ extern __inline float16x4x2_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vtrn_f16 (float16x4_t __a, float16x4_t __b)
@@ -31011,6 +31640,17 @@ vuzp1q_u64 (uint64x2_t __a, uint64x2_t __b)
 #endif
 }
 
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vuzp1q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {3, 1});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {0, 2});
+#endif
+}
+
 __extension__ extern __inline float16x4_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vuzp2_f16 (float16x4_t __a, float16x4_t __b)
@@ -31270,6 +31910,17 @@ vuzp2q_u64 (uint64x2_t __a, uint64x2_t __b)
 #endif
 }
 
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vuzp2q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {2, 0});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {1, 3});
+#endif
+}
+
 __INTERLEAVE_LIST (uzp)
 
 /* vzip */
@@ -31538,6 +32189,17 @@ vzip1q_u64 (uint64x2_t __a, uint64x2_t __b)
 #endif
 }
 
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vzip1q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {3, 1});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {0, 2});
+#endif
+}
+
 __extension__ extern __inline float16x4_t
 __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
 vzip2_f16 (float16x4_t __a, float16x4_t __b)
@@ -31802,6 +32464,17 @@ vzip2q_u64 (uint64x2_t __a, uint64x2_t __b)
 #endif
 }
 
+__extension__ extern __inline poly64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vzip2q_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+#ifdef __AARCH64EB__
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {2, 0});
+#else
+  return __builtin_shuffle (__a, __b, (poly64x2_t) {1, 3});
+#endif
+}
+
 __INTERLEAVE_LIST (zip)
 
 #undef __INTERLEAVE_LIST
@@ -33961,6 +34634,173 @@ vfmlslq_laneq_high_f16 (float32x4_t __r, float16x8_t __a, float16x8_t __b,
 
 #pragma GCC pop_options
 
+__extension__ extern __inline poly8x8_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vadd_p8 (poly8x8_t __a, poly8x8_t __b)
+{
+  return __a ^ __b;
+}
+
+__extension__ extern __inline poly16x4_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vadd_p16 (poly16x4_t __a, poly16x4_t __b)
+{
+  return __a ^ __b;
+}
+
+__extension__ extern __inline poly64x1_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vadd_p64 (poly64x1_t __a, poly64x1_t __b)
+{
+  return __a ^ __b;
+}
+
+__extension__ extern __inline poly8x16_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vaddq_p8 (poly8x16_t __a, poly8x16_t __b)
+{
+  return __a ^ __b;
+}
+
+__extension__ extern __inline poly16x8_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vaddq_p16 (poly16x8_t __a, poly16x8_t __b)
+{
+  return __a ^__b;
+}
+
+__extension__ extern __inline poly64x2_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vaddq_p64 (poly64x2_t __a, poly64x2_t __b)
+{
+  return __a ^ __b;
+}
+
+__extension__ extern __inline poly128_t
+__attribute ((__always_inline__, __gnu_inline__, __artificial__))
+vaddq_p128 (poly128_t __a, poly128_t __b)
+{
+  return __a ^ __b;
+}
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8.5-a")
+
+__extension__ extern __inline float32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32z_f32 (float32x2_t __a)
+{
+  return __builtin_aarch64_frint32zv2sf (__a);
+}
+
+__extension__ extern __inline float32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32zq_f32 (float32x4_t __a)
+{
+  return __builtin_aarch64_frint32zv4sf (__a);
+}
+
+__extension__ extern __inline float64x1_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32z_f64 (float64x1_t __a)
+{
+  return (float64x1_t)
+	   {__builtin_aarch64_frint32zdf (vget_lane_f64 (__a, 0))};
+}
+
+__extension__ extern __inline float64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32zq_f64 (float64x2_t __a)
+{
+  return __builtin_aarch64_frint32zv2df (__a);
+}
+
+__extension__ extern __inline float32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32x_f32 (float32x2_t __a)
+{
+  return __builtin_aarch64_frint32xv2sf (__a);
+}
+
+__extension__ extern __inline float32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32xq_f32 (float32x4_t __a)
+{
+  return __builtin_aarch64_frint32xv4sf (__a);
+}
+
+__extension__ extern __inline float64x1_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32x_f64 (float64x1_t __a)
+{
+  return (float64x1_t) {__builtin_aarch64_frint32xdf (vget_lane_f64 (__a, 0))};
+}
+
+__extension__ extern __inline float64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd32xq_f64 (float64x2_t __a)
+{
+  return __builtin_aarch64_frint32xv2df (__a);
+}
+
+__extension__ extern __inline float32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64z_f32 (float32x2_t __a)
+{
+  return __builtin_aarch64_frint64zv2sf (__a);
+}
+
+__extension__ extern __inline float32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64zq_f32 (float32x4_t __a)
+{
+  return __builtin_aarch64_frint64zv4sf (__a);
+}
+
+__extension__ extern __inline float64x1_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64z_f64 (float64x1_t __a)
+{
+  return (float64x1_t) {__builtin_aarch64_frint64zdf (vget_lane_f64 (__a, 0))};
+}
+
+__extension__ extern __inline float64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64zq_f64 (float64x2_t __a)
+{
+  return __builtin_aarch64_frint64zv2df (__a);
+}
+
+__extension__ extern __inline float32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64x_f32 (float32x2_t __a)
+{
+  return __builtin_aarch64_frint64xv2sf (__a);
+}
+
+__extension__ extern __inline float32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64xq_f32 (float32x4_t __a)
+{
+  return __builtin_aarch64_frint64xv4sf (__a);
+}
+
+__extension__ extern __inline float64x1_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64x_f64 (float64x1_t __a)
+{
+  return (float64x1_t) {__builtin_aarch64_frint64xdf (vget_lane_f64 (__a, 0))};
+}
+
+__extension__ extern __inline float64x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vrnd64xq_f64 (float64x2_t __a)
+{
+  return __builtin_aarch64_frint64xv2df (__a);
+}
+
+#pragma GCC pop_options
+
 #undef __aarch64_vget_lane_any
 
 #undef __aarch64_vdup_lane_any
diff --git a/gcc/config/aarch64/atomics.md b/gcc/config/aarch64/atomics.md
index 0f357662ac3..e7f3dad652f 100644
--- a/gcc/config/aarch64/atomics.md
+++ b/gcc/config/aarch64/atomics.md
@@ -22,10 +22,10 @@
 
 (define_expand "@atomic_compare_and_swap<mode>"
   [(match_operand:SI 0 "register_operand" "")			;; bool out
-   (match_operand:ALLI 1 "register_operand" "")			;; val out
-   (match_operand:ALLI 2 "aarch64_sync_memory_operand" "")	;; memory
-   (match_operand:ALLI 3 "nonmemory_operand" "")		;; expected
-   (match_operand:ALLI 4 "aarch64_reg_or_zero" "")		;; desired
+   (match_operand:ALLI_TI 1 "register_operand" "")		;; val out
+   (match_operand:ALLI_TI 2 "aarch64_sync_memory_operand" "")	;; memory
+   (match_operand:ALLI_TI 3 "nonmemory_operand" "")		;; expected
+   (match_operand:ALLI_TI 4 "aarch64_reg_or_zero" "")		;; desired
    (match_operand:SI 5 "const_int_operand")			;; is_weak
    (match_operand:SI 6 "const_int_operand")			;; mod_s
    (match_operand:SI 7 "const_int_operand")]			;; mod_f
@@ -38,6 +38,8 @@
 
 (define_mode_attr cas_short_expected_pred
   [(QI "aarch64_reg_or_imm") (HI "aarch64_plushi_operand")])
+(define_mode_attr cas_short_expected_imm
+  [(QI "n") (HI "Uph")])
 
 (define_insn_and_split "@aarch64_compare_and_swap<mode>"
   [(set (reg:CC CC_REGNUM)					;; bool out
@@ -47,7 +49,8 @@
       (match_operand:SHORT 1 "aarch64_sync_memory_operand" "+Q"))) ;; memory
    (set (match_dup 1)
     (unspec_volatile:SHORT
-      [(match_operand:SHORT 2 "<cas_short_expected_pred>" "rn")	;; expected
+      [(match_operand:SHORT 2 "<cas_short_expected_pred>"
+			      "r<cas_short_expected_imm>")	;; expected
        (match_operand:SHORT 3 "aarch64_reg_or_zero" "rZ")	;; desired
        (match_operand:SI 4 "const_int_operand")			;; is_weak
        (match_operand:SI 5 "const_int_operand")			;; mod_s
@@ -88,6 +91,30 @@
   }
 )
 
+(define_insn_and_split "@aarch64_compare_and_swap<mode>"
+  [(set (reg:CC CC_REGNUM)					;; bool out
+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))
+   (set (match_operand:JUST_TI 0 "register_operand" "=&r")	;; val out
+    (match_operand:JUST_TI 1 "aarch64_sync_memory_operand" "+Q")) ;; memory
+   (set (match_dup 1)
+    (unspec_volatile:JUST_TI
+      [(match_operand:JUST_TI 2 "aarch64_reg_or_zero" "rZ")	;; expect
+       (match_operand:JUST_TI 3 "aarch64_reg_or_zero" "rZ")	;; desired
+       (match_operand:SI 4 "const_int_operand")			;; is_weak
+       (match_operand:SI 5 "const_int_operand")			;; mod_s
+       (match_operand:SI 6 "const_int_operand")]		;; mod_f
+      UNSPECV_ATOMIC_CMPSW))
+   (clobber (match_scratch:SI 7 "=&r"))]
+  ""
+  "#"
+  "&& epilogue_completed"
+  [(const_int 0)]
+  {
+    aarch64_split_compare_and_swap (operands);
+    DONE;
+  }
+)
+
 (define_insn "@aarch64_compare_and_swap<mode>_lse"
   [(set (match_operand:SI 0 "register_operand" "+r")		;; val out
     (zero_extend:SI
@@ -133,6 +160,28 @@
     return "casal<atomic_sfx>\t%<w>0, %<w>2, %1";
 })
 
+(define_insn "@aarch64_compare_and_swap<mode>_lse"
+  [(set (match_operand:JUST_TI 0 "register_operand" "+r")	;; val out
+    (match_operand:JUST_TI 1 "aarch64_sync_memory_operand" "+Q")) ;; memory
+   (set (match_dup 1)
+    (unspec_volatile:JUST_TI
+      [(match_dup 0)						;; expect
+       (match_operand:JUST_TI 2 "register_operand" "r")		;; desired
+       (match_operand:SI 3 "const_int_operand")]		;; mod_s
+      UNSPECV_ATOMIC_CMPSW))]
+  "TARGET_LSE"
+{
+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+  if (is_mm_relaxed (model))
+    return "casp\t%0, %R0, %2, %R2, %1";
+  else if (is_mm_acquire (model) || is_mm_consume (model))
+    return "caspa\t%0, %R0, %2, %R2, %1";
+  else if (is_mm_release (model))
+    return "caspl\t%0, %R0, %2, %R2, %1";
+  else
+    return "caspal\t%0, %R0, %2, %R2, %1";
+})
+
 (define_expand "atomic_exchange<mode>"
  [(match_operand:ALLI 0 "register_operand" "")
   (match_operand:ALLI 1 "aarch64_sync_memory_operand" "")
@@ -140,16 +189,27 @@
   (match_operand:SI 3 "const_int_operand" "")]
   ""
   {
-    rtx (*gen) (rtx, rtx, rtx, rtx);
-
     /* Use an atomic SWP when available.  */
     if (TARGET_LSE)
-      gen = gen_aarch64_atomic_exchange<mode>_lse;
+      {
+	emit_insn (gen_aarch64_atomic_exchange<mode>_lse
+		   (operands[0], operands[1], operands[2], operands[3]));
+      }
+    else if (TARGET_OUTLINE_ATOMICS)
+      {
+	machine_mode mode = <MODE>mode;
+	rtx func = aarch64_atomic_ool_func (mode, operands[3],
+					    &aarch64_ool_swp_names);
+	rtx rval = emit_library_call_value (func, operands[0], LCT_NORMAL,
+					    mode, operands[2], mode,
+					    XEXP (operands[1], 0), Pmode);
+        emit_move_insn (operands[0], rval);
+      }
     else
-      gen = gen_aarch64_atomic_exchange<mode>;
-
-    emit_insn (gen (operands[0], operands[1], operands[2], operands[3]));
-
+      {
+	emit_insn (gen_aarch64_atomic_exchange<mode>
+		   (operands[0], operands[1], operands[2], operands[3]));
+      }
     DONE;
   }
 )
@@ -234,6 +294,39 @@
 	  }
 	operands[1] = force_reg (<MODE>mode, operands[1]);
       }
+    else if (TARGET_OUTLINE_ATOMICS)
+      {
+        const atomic_ool_names *names;
+	switch (<CODE>)
+	  {
+	  case MINUS:
+	    operands[1] = expand_simple_unop (<MODE>mode, NEG, operands[1],
+					      NULL, 1);
+	    /* fallthru */
+	  case PLUS:
+	    names = &aarch64_ool_ldadd_names;
+	    break;
+	  case IOR:
+	    names = &aarch64_ool_ldset_names;
+	    break;
+	  case XOR:
+	    names = &aarch64_ool_ldeor_names;
+	    break;
+	  case AND:
+	    operands[1] = expand_simple_unop (<MODE>mode, NOT, operands[1],
+					      NULL, 1);
+	    names = &aarch64_ool_ldclr_names;
+	    break;
+	  default:
+	    gcc_unreachable ();
+	  }
+        machine_mode mode = <MODE>mode;
+	rtx func = aarch64_atomic_ool_func (mode, operands[2], names);
+	emit_library_call_value (func, NULL_RTX, LCT_NORMAL, mode,
+				 operands[1], mode,
+				 XEXP (operands[0], 0), Pmode);
+        DONE;
+      }
     else
       gen = gen_aarch64_atomic_<atomic_optab><mode>;
 
@@ -359,6 +452,40 @@
 	}
       operands[2] = force_reg (<MODE>mode, operands[2]);
     }
+  else if (TARGET_OUTLINE_ATOMICS)
+    {
+      const atomic_ool_names *names;
+      switch (<CODE>)
+	{
+	case MINUS:
+	  operands[2] = expand_simple_unop (<MODE>mode, NEG, operands[2],
+					    NULL, 1);
+	  /* fallthru */
+	case PLUS:
+	  names = &aarch64_ool_ldadd_names;
+	  break;
+	case IOR:
+	  names = &aarch64_ool_ldset_names;
+	  break;
+	case XOR:
+	  names = &aarch64_ool_ldeor_names;
+	  break;
+	case AND:
+	  operands[2] = expand_simple_unop (<MODE>mode, NOT, operands[2],
+					    NULL, 1);
+	  names = &aarch64_ool_ldclr_names;
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+      machine_mode mode = <MODE>mode;
+      rtx func = aarch64_atomic_ool_func (mode, operands[3], names);
+      rtx rval = emit_library_call_value (func, operands[0], LCT_NORMAL, mode,
+					  operands[2], mode,
+					  XEXP (operands[1], 0), Pmode);
+      emit_move_insn (operands[0], rval);
+      DONE;
+    }
   else
     gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>;
 
@@ -448,7 +575,7 @@
 {
   /* Use an atomic load-operate instruction when possible.  In this case
      we will re-compute the result from the original mem value. */
-  if (TARGET_LSE)
+  if (TARGET_LSE || TARGET_OUTLINE_ATOMICS)
     {
       rtx tmp = gen_reg_rtx (<MODE>mode);
       operands[2] = force_reg (<MODE>mode, operands[2]);
@@ -581,6 +708,24 @@
   }
 )
 
+(define_insn "aarch64_load_exclusive_pair"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec_volatile:DI
+	  [(match_operand:TI 2 "aarch64_sync_memory_operand" "Q")
+	   (match_operand:SI 3 "const_int_operand")]
+	  UNSPECV_LX))
+   (set (match_operand:DI 1 "register_operand" "=r")
+	(unspec_volatile:DI [(match_dup 2) (match_dup 3)] UNSPECV_LX))]
+  ""
+  {
+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))
+      return "ldxp\t%0, %1, %2";
+    else
+      return "ldaxp\t%0, %1, %2";
+  }
+)
+
 (define_insn "@aarch64_store_exclusive<mode>"
   [(set (match_operand:SI 0 "register_operand" "=&r")
     (unspec_volatile:SI [(const_int 0)] UNSPECV_SX))
@@ -599,6 +744,25 @@
   }
 )
 
+(define_insn "aarch64_store_exclusive_pair"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(unspec_volatile:SI [(const_int 0)] UNSPECV_SX))
+   (set (match_operand:TI 1 "aarch64_sync_memory_operand" "=Q")
+	(unspec_volatile:TI
+	  [(match_operand:DI 2 "aarch64_reg_or_zero" "rZ")
+	   (match_operand:DI 3 "aarch64_reg_or_zero" "rZ")
+	   (match_operand:SI 4 "const_int_operand")]
+	  UNSPECV_SX))]
+  ""
+  {
+    enum memmodel model = memmodel_from_int (INTVAL (operands[4]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))
+      return "stxp\t%w0, %x2, %x3, %1";
+    else
+      return "stlxp\t%w0, %x2, %x3, %1";
+  }
+)
+
 (define_expand "mem_thread_fence"
   [(match_operand:SI 0 "const_int_operand" "")]
   ""
diff --git a/gcc/config/aarch64/constraints.md b/gcc/config/aarch64/constraints.md
index 21f9549e660..3e170e4c58c 100644
--- a/gcc/config/aarch64/constraints.md
+++ b/gcc/config/aarch64/constraints.md
@@ -24,6 +24,15 @@
 (define_register_constraint "Ucs" "TAILCALL_ADDR_REGS"
   "@internal Registers suitable for an indirect tail call")
 
+(define_register_constraint "Ucr"
+    "aarch64_harden_sls_blr_p () ? STUB_REGS : GENERAL_REGS"
+  "@internal Registers to be used for an indirect call.
+   This is usually the general registers, but when we are hardening against
+   Straight Line Speculation we disallow x16, x17, and x30 so we can use
+   indirection stubs.  These indirection stubs cannot use the above registers
+   since they will be reached by a BL that may have to go through a linker
+   veneer.")
+
 (define_register_constraint "w" "FP_REGS"
   "Floating point and SIMD vector registers.")
 
@@ -220,6 +229,13 @@
   (and (match_code "const_int")
        (match_test "(unsigned) exact_log2 (ival) <= 4")))
 
+(define_constraint "Uph"
+  "@internal
+  A constraint that matches HImode integers zero extendable to
+  SImode plus_operand."
+  (and (match_code "const_int")
+       (match_test "aarch64_plushi_immediate (op, VOIDmode)")))
+
 (define_memory_constraint "Q"
  "A memory address which uses a single base register with no offset."
  (and (match_code "mem")
diff --git a/gcc/config/aarch64/driver-aarch64.c b/gcc/config/aarch64/driver-aarch64.c
index 6f16775f47d..106dc00e9dc 100644
--- a/gcc/config/aarch64/driver-aarch64.c
+++ b/gcc/config/aarch64/driver-aarch64.c
@@ -21,6 +21,7 @@
 
 #include "config.h"
 #define INCLUDE_STRING
+#define INCLUDE_SET
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
@@ -119,9 +120,15 @@ valid_bL_core_p (unsigned int *core, unsigned int bL_core)
 /* Returns the hex integer that is after ':' for the FIELD.
    Returns -1 is returned if there was problem parsing the integer. */
 static unsigned
-parse_field (const char *field)
+parse_field (const std::string &field)
 {
-  const char *rest = strchr (field, ':');
+  const char *rest = strchr (field.c_str (), ':');
+
+  /* The line must be in the format of <name>:<value>, if it's not
+     then we have a weird format.  */
+  if (rest == NULL)
+    return -1;
+
   char *after;
   unsigned fint = strtol (rest + 1, &after, 16);
   if (after == rest + 1)
@@ -129,6 +136,82 @@ parse_field (const char *field)
   return fint;
 }
 
+/* Returns the index of the ':' inside the FIELD which must be found
+   after the value of KEY.  Returns string::npos if line does not contain
+   a field.  */
+
+static size_t
+find_field (const std::string &field, const std::string &key)
+{
+  size_t key_pos, sep_pos;
+  key_pos = field.find (key);
+  if (key_pos == std::string::npos)
+    return std::string::npos;
+
+  sep_pos = field.find (":", key_pos + 1);
+  if (sep_pos == std::string::npos)
+    return std::string::npos;
+
+  return sep_pos;
+}
+
+/* Splits and returns a string based on whitespace and return it as
+   part of a set. Empty strings are ignored.  */
+
+static void
+split_words (const std::string &val, std::set<std::string> &result)
+{
+  size_t cur, prev = 0;
+  std::string word;
+  while ((cur = val.find_first_of (" \n", prev)) != std::string::npos)
+    {
+      word = val.substr (prev, cur - prev);
+      /* Skip adding empty words.  */
+      if (!word.empty ())
+	result.insert (word);
+      prev = cur + 1;
+    }
+
+  if (prev != cur)
+    result.insert (val.substr (prev));
+}
+
+/* Read an entire line from F until '\n' or EOF.  */
+
+static std::string
+readline (FILE *f)
+{
+  char *buf = NULL;
+  int size = 0;
+  int last = 0;
+  const int buf_size = 128;
+
+  if (feof (f))
+    return std::string ();
+
+  do
+    {
+      size += buf_size;
+      buf = (char*) xrealloc (buf, size);
+      gcc_assert (buf);
+      /* If fgets fails it returns NULL, but if it reaches EOF
+	 with 0 characters read it also returns EOF.  However
+	 the condition on the loop would have broken out of the
+	 loop in that case,  and if we are in the first iteration
+	 then the empty string is the correct thing to return.  */
+      if (!fgets (buf + last, buf_size, f))
+	return std::string ();
+      /* If we're not at the end of the line then override the
+	 \0 added by fgets.  */
+      last = strnlen (buf, size) - 1;
+    }
+  while (!feof (f) && buf[last] != '\n');
+
+  std::string result (buf);
+  free (buf);
+  return result;
+}
+
 /*  Return true iff ARR contains CORE, in either of the two elements. */
 
 static bool
@@ -167,7 +250,6 @@ host_detect_local_cpu (int argc, const char **argv)
 {
   const char *res = NULL;
   static const int num_exts = ARRAY_SIZE (aarch64_extensions);
-  char buf[128];
   FILE *f = NULL;
   bool arch = false;
   bool tune = false;
@@ -181,6 +263,9 @@ host_detect_local_cpu (int argc, const char **argv)
   bool processed_exts = false;
   unsigned long extension_flags = 0;
   unsigned long default_flags = 0;
+  std::string buf;
+  size_t sep_pos = -1;
+  char *fcpu_info;
 
   gcc_assert (argc);
 
@@ -198,16 +283,20 @@ host_detect_local_cpu (int argc, const char **argv)
   if (!arch && !tune && !cpu)
     goto not_found;
 
-  f = fopen ("/proc/cpuinfo", "r");
+  fcpu_info = getenv ("GCC_CPUINFO");
+  if (fcpu_info)
+    f = fopen (fcpu_info, "r");
+  else
+    f = fopen ("/proc/cpuinfo", "r");
 
   if (f == NULL)
     goto not_found;
 
   /* Look through /proc/cpuinfo to determine the implementer
      and then the part number that identifies a particular core.  */
-  while (fgets (buf, sizeof (buf), f) != NULL)
+  while (!(buf = readline (f)).empty ())
     {
-      if (strstr (buf, "implementer") != NULL)
+      if (find_field (buf, "implementer") != std::string::npos)
 	{
 	  unsigned cimp = parse_field (buf);
 	  if (cimp == INVALID_IMP)
@@ -219,8 +308,7 @@ host_detect_local_cpu (int argc, const char **argv)
 	  else if (imp != cimp)
 	    goto not_found;
 	}
-
-      if (strstr (buf, "variant") != NULL)
+      else if (find_field (buf, "variant") != std::string::npos)
 	{
 	  unsigned cvariant = parse_field (buf);
 	  if (!contains_core_p (variants, cvariant))
@@ -232,8 +320,7 @@ host_detect_local_cpu (int argc, const char **argv)
 	    }
           continue;
         }
-
-      if (strstr (buf, "part") != NULL)
+      else if (find_field (buf, "part") != std::string::npos)
 	{
 	  unsigned ccore = parse_field (buf);
 	  if (!contains_core_p (cores, ccore))
@@ -245,39 +332,36 @@ host_detect_local_cpu (int argc, const char **argv)
 	    }
 	  continue;
 	}
-      if (!tune && !processed_exts && strstr (buf, "Features") != NULL)
+      else if (!tune && !processed_exts
+	       && (sep_pos = find_field (buf, "Features")) != std::string::npos)
 	{
+	  /* First create the list of features in the buffer.  */
+	  std::set<std::string> features;
+	  /* Drop everything till the :.  */
+	  buf = buf.substr (sep_pos + 1);
+	  split_words (buf, features);
+
 	  for (i = 0; i < num_exts; i++)
 	    {
-	      const char *p = aarch64_extensions[i].feat_string;
+	      const std::string val (aarch64_extensions[i].feat_string);
 
 	      /* If the feature contains no HWCAPS string then ignore it for the
 		 auto detection.  */
-	      if (*p == '\0')
+	      if (val.empty ())
 		continue;
 
 	      bool enabled = true;
 
 	      /* This may be a multi-token feature string.  We need
 		 to match all parts, which could be in any order.  */
-	      size_t len = strlen (buf);
-	      do
-		{
-		  const char *end = strchr (p, ' ');
-		  if (end == NULL)
-		    end = strchr (p, '\0');
-		  if (memmem (buf, len, p, end - p) == NULL)
-		    {
-		      /* Failed to match this token.  Turn off the
-			 features we'd otherwise enable.  */
-		      enabled = false;
-		      break;
-		    }
-		  if (*end == '\0')
-		    break;
-		  p = end + 1;
-		}
-	      while (1);
+	      std::set<std::string> tokens;
+	      split_words (val, tokens);
+	      std::set<std::string>::iterator it;
+
+	      /* Iterate till the first feature isn't found or all of them
+		 are found.  */
+	      for (it = tokens.begin (); enabled && it != tokens.end (); ++it)
+		enabled = enabled && features.count (*it);
 
 	      if (enabled)
 		extension_flags |= aarch64_extensions[i].flag;
diff --git a/gcc/config/aarch64/falkor-tag-collision-avoidance.c b/gcc/config/aarch64/falkor-tag-collision-avoidance.c
index 779dee81f7f..698d1595d0a 100644
--- a/gcc/config/aarch64/falkor-tag-collision-avoidance.c
+++ b/gcc/config/aarch64/falkor-tag-collision-avoidance.c
@@ -537,6 +537,13 @@ valid_src_p (rtx src, rtx_insn *insn, struct loop *loop, bool *pre_post,
   if (!aarch64_classify_address (&addr, XEXP (x, 0), mode, true))
     return false;
 
+  if (addr.type != ADDRESS_REG_IMM
+      && addr.type != ADDRESS_REG_WB
+      && addr.type != ADDRESS_REG_REG
+      && addr.type != ADDRESS_REG_UXTW
+      && addr.type != ADDRESS_REG_SXTW)
+    return false;
+
   unsigned regno = REGNO (addr.base);
   if (global_regs[regno] || fixed_regs[regno])
     return false;
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 6caeeac8086..527e64c561a 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -29,6 +29,9 @@
 ;; Iterator for HI, SI, DI, some instructions can only work on these modes.
 (define_mode_iterator GPI_I16 [(HI "AARCH64_ISA_F16") SI DI])
 
+;; "Iterator" for just TI -- features like @pattern only work with iterators.
+(define_mode_iterator JUST_TI [TI])
+
 ;; Iterator for QI and HI modes
 (define_mode_iterator SHORT [QI HI])
 
@@ -128,6 +131,9 @@
 				  (HF "TARGET_SIMD_F16INST")
 				  SF DF])
 
+;; Scalar and vetor modes for SF, DF.
+(define_mode_iterator VSFDF [V2SF V4SF V2DF DF SF])
+
 ;; Advanced SIMD single Float modes.
 (define_mode_iterator VDQSF [V2SF V4SF])
 
@@ -1614,6 +1620,9 @@
 			    UNSPEC_FCMLA180
 			    UNSPEC_FCMLA270])
 
+(define_int_iterator FRINTNZX [UNSPEC_FRINT32Z UNSPEC_FRINT32X
+			       UNSPEC_FRINT64Z UNSPEC_FRINT64X])
+
 ;; Iterators for atomic operations.
 
 (define_int_iterator ATOMIC_LDOP
@@ -1853,6 +1862,9 @@
 (define_int_attr f16mac1 [(UNSPEC_FMLAL "a") (UNSPEC_FMLSL "s")
 			  (UNSPEC_FMLAL2 "a") (UNSPEC_FMLSL2 "s")])
 
+(define_int_attr frintnzs_op [(UNSPEC_FRINT32Z "frint32z") (UNSPEC_FRINT32X "frint32x")
+			      (UNSPEC_FRINT64Z "frint64z") (UNSPEC_FRINT64X "frint64x")])
+
 ;; The condition associated with an UNSPEC_COND_<xx>.
 (define_int_attr cmp_op [(UNSPEC_COND_LT "lt")
 			 (UNSPEC_COND_LE "le")
diff --git a/gcc/config/aarch64/predicates.md b/gcc/config/aarch64/predicates.md
index 8e1b784217b..4250aecb381 100644
--- a/gcc/config/aarch64/predicates.md
+++ b/gcc/config/aarch64/predicates.md
@@ -32,7 +32,8 @@
 
 (define_predicate "aarch64_general_reg"
   (and (match_operand 0 "register_operand")
-       (match_test "REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS")))
+       (match_test "REGNO_REG_CLASS (REGNO (op)) == STUB_REGS
+		    || REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS")))
 
 ;; Return true if OP a (const_int 0) operand.
 (define_predicate "const0_operand"
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 524379d3763..614a426e989 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -9909,8 +9909,8 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
     = build_fn_decl ("__ieee_set_fp_control",
 		     build_function_type_list (void_type_node, NULL));
   mask = build_int_cst (long_unsigned_type_node, ~SWCR_STATUS_MASK);
-  ld_fenv = build2 (MODIFY_EXPR, long_unsigned_type_node,
-		    fenv_var, build_call_expr (get_fpscr, 0));
+  ld_fenv = build4 (TARGET_EXPR, long_unsigned_type_node, fenv_var,
+		    build_call_expr (get_fpscr, 0), NULL_TREE, NULL_TREE);
   masked_fenv = build2 (BIT_AND_EXPR, long_unsigned_type_node, fenv_var, mask);
   hold_fnclex = build_call_expr (set_fpscr, 1, masked_fenv);
   *hold = build2 (COMPOUND_EXPR, void_type_node,
@@ -9931,8 +9931,8 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
        __atomic_feraiseexcept (new_fenv_var);  */
 
   new_fenv_var = create_tmp_var_raw (long_unsigned_type_node);
-  reload_fenv = build2 (MODIFY_EXPR, long_unsigned_type_node, new_fenv_var,
-			build_call_expr (get_fpscr, 0));
+  reload_fenv = build4 (TARGET_EXPR, long_unsigned_type_node, new_fenv_var,
+			build_call_expr (get_fpscr, 0), NULL_TREE, NULL_TREE);
   restore_fnenv = build_call_expr (set_fpscr, 1, fenv_var);
   atomic_feraiseexcept = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);
   update_call
diff --git a/gcc/config/arc/linux.h b/gcc/config/arc/linux.h
index 270ca907d87..7d07adc4257 100644
--- a/gcc/config/arc/linux.h
+++ b/gcc/config/arc/linux.h
@@ -29,7 +29,8 @@ along with GCC; see the file COPYING3.  If not see
     }						\
   while (0)
 
-#define GLIBC_DYNAMIC_LINKER   "/lib/ld-linux-arc.so.2"
+#define GLIBC_DYNAMIC_LINKER					\
+  "/lib/ld-linux-arc%{mbig-endian:eb}%{mcpu=arc700:700}.so.2"
 #define UCLIBC_DYNAMIC_LINKER  "/lib/ld-uClibc.so.0"
 
 /* Note that the default is to link against dynamic libraries, if they are
diff --git a/gcc/config/arm/arm-builtins.c b/gcc/config/arm/arm-builtins.c
index 55bbb487097..ba74ab832da 100644
--- a/gcc/config/arm/arm-builtins.c
+++ b/gcc/config/arm/arm-builtins.c
@@ -3292,8 +3292,9 @@ arm_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   mask = build_int_cst (unsigned_type_node,
 			~((ARM_FE_ALL_EXCEPT << ARM_FE_EXCEPT_SHIFT)
 			  | ARM_FE_ALL_EXCEPT));
-  ld_fenv = build2 (MODIFY_EXPR, unsigned_type_node,
-		    fenv_var, build_call_expr (get_fpscr, 0));
+  ld_fenv = build4 (TARGET_EXPR, unsigned_type_node,
+		    fenv_var, build_call_expr (get_fpscr, 0),
+		    NULL_TREE, NULL_TREE);
   masked_fenv = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_var, mask);
   hold_fnclex = build_call_expr (set_fpscr, 1, masked_fenv);
   *hold = build2 (COMPOUND_EXPR, void_type_node,
@@ -3314,8 +3315,8 @@ arm_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
        __atomic_feraiseexcept (new_fenv_var);  */
 
   new_fenv_var = create_tmp_var_raw (unsigned_type_node);
-  reload_fenv = build2 (MODIFY_EXPR, unsigned_type_node, new_fenv_var,
-			build_call_expr (get_fpscr, 0));
+  reload_fenv = build4 (TARGET_EXPR, unsigned_type_node, new_fenv_var,
+			build_call_expr (get_fpscr, 0), NULL_TREE, NULL_TREE);
   restore_fnenv = build_call_expr (set_fpscr, 1, fenv_var);
   atomic_feraiseexcept = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);
   update_call = build_call_expr (atomic_feraiseexcept, 1,
diff --git a/gcc/config/arm/arm-cpus.in b/gcc/config/arm/arm-cpus.in
index 3a55f6ac6d2..f87044fd25c 100644
--- a/gcc/config/arm/arm-cpus.in
+++ b/gcc/config/arm/arm-cpus.in
@@ -1362,6 +1362,30 @@ begin cpu cortex-a76.cortex-a55
  costs cortex_a57
 end cpu cortex-a76.cortex-a55
 
+# Armv8.4 A-profile Architecture Processors
+begin cpu neoverse-v1
+  cname neoversev1
+  tune for cortex-a57
+  tune flags LDSCHED
+  architecture armv8.4-a+fp16
+  option crypto add FP_ARMv8 CRYPTO
+  costs cortex_a57
+  vendor 41
+  part 0xd40
+end cpu neoverse-v1
+
+# Armv8.5 A-profile Architecture Processors
+begin cpu neoverse-n2
+  cname neoversen2
+  tune for cortex-a57
+  tune flags LDSCHED
+  architecture armv8.5-a+fp16
+  option crypto add FP_ARMv8 CRYPTO
+  costs cortex_a57
+  vendor 41
+  part 0xd49
+end cpu neoverse-n2
+
 # V8 M-profile implementations.
 begin cpu cortex-m23
  cname cortexm23
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 98beb6109b9..3e8bba5caea 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -575,4 +575,6 @@ void arm_parse_option_features (sbitmap, const cpu_arch_option *,
 
 void arm_initialize_isa (sbitmap, const enum isa_feature *);
 
+const char * arm_gen_far_branch (rtx *, int, const char * , const char *);
+
 #endif /* ! GCC_ARM_PROTOS_H */
diff --git a/gcc/config/arm/arm-tables.opt b/gcc/config/arm/arm-tables.opt
index bba54aea3d6..5befadddf9e 100644
--- a/gcc/config/arm/arm-tables.opt
+++ b/gcc/config/arm/arm-tables.opt
@@ -243,6 +243,12 @@ Enum(processor_type) String(cortex-a75.cortex-a55) Value( TARGET_CPU_cortexa75co
 EnumValue
 Enum(processor_type) String(cortex-a76.cortex-a55) Value( TARGET_CPU_cortexa76cortexa55)
 
+EnumValue
+Enum(processor_type) String(neoverse-v1) Value( TARGET_CPU_neoversev1)
+
+EnumValue
+Enum(processor_type) String(neoverse-n2) Value( TARGET_CPU_neoversen2)
+
 EnumValue
 Enum(processor_type) String(cortex-m23) Value( TARGET_CPU_cortexm23)
 
diff --git a/gcc/config/arm/arm-tune.md b/gcc/config/arm/arm-tune.md
index b9dfb66ec84..102765e6568 100644
--- a/gcc/config/arm/arm-tune.md
+++ b/gcc/config/arm/arm-tune.md
@@ -45,6 +45,6 @@
 	cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,
 	cortexa73cortexa53,cortexa55,cortexa75,
 	cortexa76,neoversen1,cortexa75cortexa55,
-	cortexa76cortexa55,cortexm23,cortexm33,
-	cortexr52"
+	cortexa76cortexa55,neoversev1,neoversen2,
+	cortexm23,cortexm33,cortexr52"
 	(const (symbol_ref "((enum attr_tune) arm_tune)")))
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index cdfc0f9e72f..4679da75dd8 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -12730,7 +12730,9 @@ neon_vector_mem_operand (rtx op, int type, bool strict)
   /* Allow post-increment by register for VLDn */
   if (type == 2 && GET_CODE (ind) == POST_MODIFY
       && GET_CODE (XEXP (ind, 1)) == PLUS
-      && REG_P (XEXP (XEXP (ind, 1), 1)))
+      && REG_P (XEXP (XEXP (ind, 1), 1))
+      && REG_P (XEXP (ind, 0))
+      && rtx_equal_p (XEXP (ind, 0), XEXP (XEXP (ind, 1), 0)))
      return true;
 
   /* Match:
@@ -18408,6 +18410,7 @@ output_move_double (rtx *operands, bool emit, int *count)
   if (code0 == REG)
     {
       unsigned int reg0 = REGNO (operands[0]);
+      const bool can_ldrd = TARGET_LDRD && (TARGET_THUMB2 || (reg0 % 2 == 0));
 
       otherops[0] = gen_rtx_REG (SImode, 1 + reg0);
 
@@ -18419,7 +18422,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 
 	  if (emit)
 	    {
-	      if (TARGET_LDRD
+	      if (can_ldrd
 		  && !(fix_cm3_ldrd && reg0 == REGNO(XEXP (operands[1], 0))))
 		output_asm_insn ("ldrd%?\t%0, [%m1]", operands);
 	      else
@@ -18428,7 +18431,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  break;
 
 	case PRE_INC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (can_ldrd);
 	  if (emit)
 	    output_asm_insn ("ldrd%?\t%0, [%m1, #8]!", operands);
 	  break;
@@ -18436,7 +18439,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	case PRE_DEC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (can_ldrd)
 		output_asm_insn ("ldrd%?\t%0, [%m1, #-8]!", operands);
 	      else
 		output_asm_insn ("ldmdb%?\t%m1!, %M0", operands);
@@ -18446,7 +18449,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	case POST_INC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (can_ldrd)
 		output_asm_insn ("ldrd%?\t%0, [%m1], #8", operands);
 	      else
 		output_asm_insn ("ldmia%?\t%m1!, %M0", operands);
@@ -18454,7 +18457,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  break;
 
 	case POST_DEC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (can_ldrd);
 	  if (emit)
 	    output_asm_insn ("ldrd%?\t%0, [%m1], #-8", operands);
 	  break;
@@ -18476,6 +18479,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 		  /* Registers overlap so split out the increment.  */
 		  if (emit)
 		    {
+		      gcc_assert (can_ldrd);
 		      output_asm_insn ("add%?\t%1, %1, %2", otherops);
 		      output_asm_insn ("ldrd%?\t%0, [%1] @split", otherops);
 		    }
@@ -18487,10 +18491,11 @@ output_move_double (rtx *operands, bool emit, int *count)
 		  /* Use a single insn if we can.
 		     FIXME: IWMMXT allows offsets larger than ldrd can
 		     handle, fix these up with a pair of ldr.  */
-		  if (TARGET_THUMB2
+		  if (can_ldrd
+		      && (TARGET_THUMB2
 		      || !CONST_INT_P (otherops[2])
 		      || (INTVAL (otherops[2]) > -256
-			  && INTVAL (otherops[2]) < 256))
+			  && INTVAL (otherops[2]) < 256)))
 		    {
 		      if (emit)
 			output_asm_insn ("ldrd%?\t%0, [%1, %2]!", otherops);
@@ -18513,10 +18518,11 @@ output_move_double (rtx *operands, bool emit, int *count)
 	      /* Use a single insn if we can.
 		 FIXME: IWMMXT allows offsets larger than ldrd can handle,
 		 fix these up with a pair of ldr.  */
-	      if (TARGET_THUMB2
+	      if (can_ldrd
+		  && (TARGET_THUMB2
 		  || !CONST_INT_P (otherops[2])
 		  || (INTVAL (otherops[2]) > -256
-		      && INTVAL (otherops[2]) < 256))
+		      && INTVAL (otherops[2]) < 256)))
 		{
 		  if (emit)
 		    output_asm_insn ("ldrd%?\t%0, [%1], %2", otherops);
@@ -18547,7 +18553,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  operands[1] = otherops[0];
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (can_ldrd)
 		output_asm_insn ("ldrd%?\t%0, [%1]", operands);
 	      else
 		output_asm_insn ("ldmia%?\t%1, %M0", operands);
@@ -18592,7 +18598,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 		    }
 		  otherops[0] = gen_rtx_REG(SImode, REGNO(operands[0]) + 1);
 		  operands[1] = otherops[0];
-		  if (TARGET_LDRD
+		  if (can_ldrd
 		      && (REG_P (otherops[2])
 			  || TARGET_THUMB2
 			  || (CONST_INT_P (otherops[2])
@@ -18653,7 +18659,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	      if (count)
 		*count = 2;
 
-	      if (TARGET_LDRD)
+	      if (can_ldrd)
 		return "ldrd%?\t%0, [%1]";
 
 	      return "ldmia%?\t%1, %M0";
@@ -31803,6 +31809,39 @@ arm_emit_speculation_barrier_function ()
   emit_library_call (speculation_barrier_libfunc, LCT_NORMAL, VOIDmode);
 }
 
+/* Generate code to enable conditional branches in functions over 1 MiB.
+   Parameters are:
+     operands: is the operands list of the asm insn (see arm_cond_branch or
+       arm_cond_branch_reversed).
+     pos_label: is an index into the operands array where operands[pos_label] is
+       the asm label of the final jump destination.
+     dest: is a string which is used to generate the asm label of the intermediate
+       destination
+   branch_format: is a string denoting the intermediate branch format, e.g.
+     "beq", "bne", etc.  */
+
+const char *
+arm_gen_far_branch (rtx * operands, int pos_label, const char * dest,
+		    const char * branch_format)
+{
+  rtx_code_label * tmp_label = gen_label_rtx ();
+  char label_buf[256];
+  char buffer[128];
+  ASM_GENERATE_INTERNAL_LABEL (label_buf, dest , \
+			CODE_LABEL_NUMBER (tmp_label));
+  const char *label_ptr = arm_strip_name_encoding (label_buf);
+  rtx dest_label = operands[pos_label];
+  operands[pos_label] = tmp_label;
+
+  snprintf (buffer, sizeof (buffer), "%s%s", branch_format , label_ptr);
+  output_asm_insn (buffer, operands);
+
+  snprintf (buffer, sizeof (buffer), "b\t%%l0%d\n%s:", pos_label, label_ptr);
+  operands[pos_label] = dest_label;
+  output_asm_insn (buffer, operands);
+  return "";
+}
+
 #if CHECKING_P
 namespace selftest {
 
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 53e54874c12..b5df489dca4 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -6362,16 +6362,21 @@
 
 (define_insn "*movsi_compare0"
   [(set (reg:CC CC_REGNUM)
-	(compare:CC (match_operand:SI 1 "s_register_operand" "0,r")
+	(compare:CC (match_operand:SI 1 "s_register_operand" "0,0,l,rk,rk")
 		    (const_int 0)))
-   (set (match_operand:SI 0 "s_register_operand" "=r,r")
+   (set (match_operand:SI 0 "s_register_operand" "=l,rk,l,r,rk")
 	(match_dup 1))]
   "TARGET_32BIT"
   "@
    cmp%?\\t%0, #0
+   cmp%?\\t%0, #0
+   subs%?\\t%0, %1, #0
+   subs%?\\t%0, %1, #0
    subs%?\\t%0, %1, #0"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_imm,alus_imm")]
+   (set_attr "arch" "t2,*,t2,t2,a")
+   (set_attr "type" "alus_imm")
+   (set_attr "length" "2,4,2,4,4")]
 )
 
 ;; Subroutine to store a half word from a register into memory.
@@ -7308,9 +7313,15 @@
 ;; And for backward branches we have 
 ;;   (neg_range - neg_base_offs + pc_offs) = (neg_range - (-2 or -4) + 4).
 ;;
+;; In 16-bit Thumb these ranges are:
 ;; For a 'b'       pos_range = 2046, neg_range = -2048 giving (-2040->2048).
 ;; For a 'b<cond>' pos_range = 254,  neg_range = -256  giving (-250 ->256).
 
+;; In 32-bit Thumb these ranges are:
+;; For a 'b'       +/- 16MB is not checked for.
+;; For a 'b<cond>' pos_range = 1048574,  neg_range = -1048576  giving
+;; (-1048568 -> 1048576).
+
 (define_expand "cbranchsi4"
   [(set (pc) (if_then_else
 	      (match_operator 0 "expandable_comparison_operator"
@@ -7568,23 +7579,50 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   "TARGET_32BIT"
-  "*
-  if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)
+  {
+    if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)
     {
       arm_ccfsm_state += 2;
-      return \"\";
+      return "";
     }
-  return \"b%d1\\t%l0\";
-  "
+    switch (get_attr_length (insn))
+      {
+	case 2: /* Thumb2 16-bit b{cond}.  */
+	case 4: /* Thumb2 32-bit b{cond} or A32 b{cond}.  */
+	  return "b%d1\t%l0";
+	  break;
+
+	/* Thumb2 b{cond} out of range.  Use 16-bit b{cond} and
+	   unconditional branch b.  */
+	default: return arm_gen_far_branch (operands, 0, "Lbcond", "b%D1\t");
+      }
+  }
   [(set_attr "conds" "use")
    (set_attr "type" "branch")
    (set (attr "length")
-	(if_then_else
-	   (and (match_test "TARGET_THUMB2")
-		(and (ge (minus (match_dup 0) (pc)) (const_int -250))
-		     (le (minus (match_dup 0) (pc)) (const_int 256))))
-	   (const_int 2)
-	   (const_int 4)))]
+    (if_then_else (match_test "!TARGET_THUMB2")
+
+      ;;Target is not Thumb2, therefore is A32.  Generate b{cond}.
+      (const_int 4)
+
+      ;; Check if target is within 16-bit Thumb2 b{cond} range.
+      (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -250))
+		         (le (minus (match_dup 0) (pc)) (const_int 256)))
+
+	;; Target is Thumb2, within narrow range.
+	;; Generate b{cond}.
+	(const_int 2)
+
+	;; Check if target is within 32-bit Thumb2 b{cond} range.
+	(if_then_else (and (ge (minus (match_dup 0) (pc))(const_int -1048568))
+			   (le (minus (match_dup 0) (pc)) (const_int 1048576)))
+
+	  ;; Target is Thumb2, within wide range.
+	  ;; Generate b{cond}
+	  (const_int 4)
+	  ;; Target is Thumb2, out of range.
+	  ;; Generate narrow b{cond} and unconditional branch b.
+	  (const_int 6)))))]
 )
 
 (define_insn "*arm_cond_branch_reversed"
@@ -7594,23 +7632,50 @@
 		      (pc)
 		      (label_ref (match_operand 0 "" ""))))]
   "TARGET_32BIT"
-  "*
-  if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)
-    {
-      arm_ccfsm_state += 2;
-      return \"\";
-    }
-  return \"b%D1\\t%l0\";
-  "
-  [(set_attr "conds" "use")
+  {
+    if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)
+      {
+	arm_ccfsm_state += 2;
+	return "";
+      }
+    switch (get_attr_length (insn))
+      {
+	case 2: /* Thumb2 16-bit b{cond}.  */
+	case 4: /* Thumb2 32-bit b{cond} or A32 b{cond}.  */
+	  return "b%D1\t%l0";
+	  break;
+
+	/* Thumb2 b{cond} out of range.  Use 16-bit b{cond} and
+	   unconditional branch b.  */
+	default: return arm_gen_far_branch (operands, 0, "Lbcond", "b%d1\t");
+      }
+  }
+[(set_attr "conds" "use")
    (set_attr "type" "branch")
    (set (attr "length")
-	(if_then_else
-	   (and (match_test "TARGET_THUMB2")
-		(and (ge (minus (match_dup 0) (pc)) (const_int -250))
-		     (le (minus (match_dup 0) (pc)) (const_int 256))))
-	   (const_int 2)
-	   (const_int 4)))]
+    (if_then_else (match_test "!TARGET_THUMB2")
+
+      ;;Target is not Thumb2, therefore is A32.  Generate b{cond}.
+      (const_int 4)
+
+      ;; Check if target is within 16-bit Thumb2 b{cond} range.
+      (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -250))
+			 (le (minus (match_dup 0) (pc)) (const_int 256)))
+
+	;; Target is Thumb2, within narrow range.
+	;; Generate b{cond}.
+	(const_int 2)
+
+	;; Check if target is within 32-bit Thumb2 b{cond} range.
+	(if_then_else (and (ge (minus (match_dup 0) (pc))(const_int -1048568))
+			   (le (minus (match_dup 0) (pc)) (const_int 1048576)))
+
+	  ;; Target is Thumb2, within wide range.
+	  ;; Generate b{cond}.
+	  (const_int 4)
+	  ;; Target is Thumb2, out of range.
+	  ;; Generate narrow b{cond} and unconditional branch b.
+	  (const_int 6)))))]
 )
 
 
@@ -8898,6 +8963,8 @@
   [(set_attr "arch" "t1,32")]
 )
 
+;; DO NOT SPLIT THIS PATTERN.  It is important for security reasons that the
+;; canary value does not live beyond the end of this sequence.
 (define_insn "arm_stack_protect_test_insn"
   [(set (reg:CC_Z CC_REGNUM)
 	(compare:CC_Z (unspec:SI [(match_operand:SI 1 "memory_operand" "m,m")
@@ -8907,8 +8974,8 @@
    (clobber (match_operand:SI 0 "register_operand" "=&l,&r"))
    (clobber (match_dup 2))]
   "TARGET_32BIT"
-  "ldr\t%0, [%2]\;ldr\t%2, %1\;eors\t%0, %2, %0"
-  [(set_attr "length" "8,12")
+  "ldr\t%0, [%2]\;ldr\t%2, %1\;eors\t%0, %2, %0\;mov\t%2, #0"
+  [(set_attr "length" "12,16")
    (set_attr "conds" "set")
    (set_attr "type" "multiple")
    (set_attr "arch" "t,32")]
diff --git a/gcc/config/arm/driver-arm.c b/gcc/config/arm/driver-arm.c
index a13f905e9f8..7d5d82ec7e6 100644
--- a/gcc/config/arm/driver-arm.c
+++ b/gcc/config/arm/driver-arm.c
@@ -61,6 +61,7 @@ host_detect_local_cpu (int argc, const char **argv)
   FILE *f = NULL;
   bool arch;
   const struct vendor_cpu *cpu_table = NULL;
+  char *fcpu_info = NULL;
 
   if (argc < 1)
     goto not_found;
@@ -69,7 +70,12 @@ host_detect_local_cpu (int argc, const char **argv)
   if (!arch && strcmp (argv[0], "cpu") != 0 && strcmp (argv[0], "tune"))
     goto not_found;
 
-  f = fopen ("/proc/cpuinfo", "r");
+  fcpu_info = getenv ("GCC_CPUINFO");
+  if (fcpu_info)
+    f = fopen (fcpu_info, "r");
+  else
+    f = fopen ("/proc/cpuinfo", "r");
+
   if (f == NULL)
     goto not_found;
 
diff --git a/gcc/config/arm/thumb1.md b/gcc/config/arm/thumb1.md
index 041e2db343f..8f051f87c0f 100644
--- a/gcc/config/arm/thumb1.md
+++ b/gcc/config/arm/thumb1.md
@@ -70,6 +70,7 @@
   "TARGET_THUMB1
    && arm_disable_literal_pool
    && GET_CODE (operands[1]) == CONST_INT
+   && !TARGET_HAVE_MOVT
    && !satisfies_constraint_I (operands[1])"
   [(clobber (const_int 0))]
   "
@@ -696,18 +697,59 @@
   "TARGET_THUMB1
    && (   register_operand (operands[0], SImode)
        || register_operand (operands[1], SImode))"
-  "@
-   movs	%0, %1
-   movs	%0, %1
-   movw	%0, %1
-   #
-   #
-   ldmia\\t%1, {%0}
-   stmia\\t%0, {%1}
-   movs\\t%0, #:upper8_15:%1; lsls\\t%0, #8; adds\\t%0, #:upper0_7:%1; lsls\\t%0, #8; adds\\t%0, #:lower8_15:%1; lsls\\t%0, #8; adds\\t%0, #:lower0_7:%1
-   ldr\\t%0, %1
-   str\\t%1, %0
-   mov\\t%0, %1"
+{
+  switch (which_alternative)
+    {
+      default:
+      case 0: return "movs\t%0, %1";
+      case 1: return "movs\t%0, %1";
+      case 2: return "movw\t%0, %1";
+      case 3: return "#";
+      case 4: return "#";
+      case 5: return "ldmia\t%1, {%0}";
+      case 6: return "stmia\t%0, {%1}";
+      case 7:
+      /* pure-code alternative: build the constant byte by byte,
+	 instead of loading it from a constant pool.  */
+	{
+	  int i;
+	  HOST_WIDE_INT op1 = INTVAL (operands[1]);
+	  bool mov_done_p = false;
+	  rtx ops[2];
+	  ops[0] = operands[0];
+
+	  /* Emit upper 3 bytes if needed.  */
+	  for (i = 0; i < 3; i++)
+	    {
+	       int byte = (op1 >> (8 * (3 - i))) & 0xff;
+
+	      if (byte)
+		{
+		  ops[1] = GEN_INT (byte);
+		  if (mov_done_p)
+		    output_asm_insn ("adds\t%0, %1", ops);
+		  else
+		    output_asm_insn ("movs\t%0, %1", ops);
+		  mov_done_p = true;
+		}
+
+	      if (mov_done_p)
+		output_asm_insn ("lsls\t%0, #8", ops);
+	    }
+
+	  /* Emit lower byte if needed.  */
+	  ops[1] = GEN_INT (op1 & 0xff);
+	  if (!mov_done_p)
+	    output_asm_insn ("movs\t%0, %1", ops);
+	  else if (op1 & 0xff)
+	    output_asm_insn ("adds\t%0, %1", ops);
+	  return "";
+	}
+      case 8: return "ldr\t%0, %1";
+      case 9: return "str\t%1, %0";
+      case 10: return "mov\t%0, %1";
+    }
+}
   [(set_attr "length" "2,2,4,4,4,2,2,14,2,2,2")
    (set_attr "type" "mov_reg,mov_imm,mov_imm,multiple,multiple,load_4,store_4,alu_sreg,load_4,store_4,mov_reg")
    (set_attr "pool_range" "*,*,*,*,*,*,*, *,1018,*,*")
@@ -2020,6 +2062,8 @@
   [(set_attr "type" "mov_reg")]
 )
 
+;; DO NOT SPLIT THIS PATTERN.  It is important for security reasons that the
+;; canary value does not live beyond the end of this sequence.
 (define_insn "thumb1_stack_protect_test_insn"
   [(set (match_operand:SI 0 "register_operand" "=&l")
 	(unspec:SI [(match_operand:SI 1 "memory_operand" "m")
@@ -2027,9 +2071,9 @@
 	 UNSPEC_SP_TEST))
    (clobber (match_dup 2))]
   "TARGET_THUMB1"
-  "ldr\t%0, [%2]\;ldr\t%2, %1\;eors\t%0, %2, %0"
-  [(set_attr "length" "8")
-   (set_attr "conds" "set")
+  "ldr\t%0, [%2]\;ldr\t%2, %1\;eors\t%0, %2, %0\;movs\t%2, #0"
+  [(set_attr "length" "10")
+   (set_attr "conds" "clob")
    (set_attr "type" "multiple")]
 )
 
diff --git a/gcc/config/i386/avx2intrin.h b/gcc/config/i386/avx2intrin.h
index c9b6f9bc868..abae781deda 100644
--- a/gcc/config/i386/avx2intrin.h
+++ b/gcc/config/i386/avx2intrin.h
@@ -1670,234 +1670,246 @@ _mm256_mask_i64gather_epi32 (__m128i __src, int const *__base,
 #else /* __OPTIMIZE__ */
 #define _mm_i32gather_pd(BASE, INDEX, SCALE)				\
   (__m128d) __builtin_ia32_gathersiv2df ((__v2df) _mm_setzero_pd (),	\
-					 (double const *)BASE,		\
-					 (__v4si)(__m128i)INDEX,	\
-					 (__v2df)_mm_set1_pd(		\
-					   (double)(long long int) -1), \
-					 (int)SCALE)
-
-#define _mm_mask_i32gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m128d) __builtin_ia32_gathersiv2df ((__v2df)(__m128d)SRC,	 \
-					 (double const *)BASE,	 \
-					 (__v4si)(__m128i)INDEX, \
-					 (__v2df)(__m128d)MASK,	 \
-					 (int)SCALE)
+					 (double const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v2df)			\
+					 _mm_cmpeq_pd (_mm_setzero_pd (),\
+						       _mm_setzero_pd ()),\
+					 (int) (SCALE))
+
+#define _mm_mask_i32gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 	\
+  (__m128d) __builtin_ia32_gathersiv2df ((__v2df)(__m128d) (SRC),	\
+					 (double const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v2df)(__m128d) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm256_i32gather_pd(BASE, INDEX, SCALE)				\
   (__m256d) __builtin_ia32_gathersiv4df ((__v4df) _mm256_setzero_pd (),	\
-					 (double const *)BASE,		\
-					 (__v4si)(__m128i)INDEX,	\
-					 (__v4df)_mm256_set1_pd(	\
-					   (double)(long long int) -1), \
-					 (int)SCALE)
-
-#define _mm256_mask_i32gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m256d) __builtin_ia32_gathersiv4df ((__v4df)(__m256d)SRC,	 \
-					 (double const *)BASE,	 \
-					 (__v4si)(__m128i)INDEX, \
-					 (__v4df)(__m256d)MASK,	 \
-					 (int)SCALE)
+					 (double const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v4df)			\
+					 _mm256_cmp_pd (_mm256_setzero_pd (),\
+							_mm256_setzero_pd (),\
+							_CMP_EQ_OQ),	\
+					 (int) (SCALE))
+
+#define _mm256_mask_i32gather_pd(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m256d) __builtin_ia32_gathersiv4df ((__v4df)(__m256d) (SRC),	\
+					 (double const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v4df)(__m256d) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm_i64gather_pd(BASE, INDEX, SCALE)				\
   (__m128d) __builtin_ia32_gatherdiv2df ((__v2df) _mm_setzero_pd (),	\
-					 (double const *)BASE,		\
-					 (__v2di)(__m128i)INDEX,	\
-					 (__v2df)_mm_set1_pd(		\
-					   (double)(long long int) -1), \
-					 (int)SCALE)
-
-#define _mm_mask_i64gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m128d) __builtin_ia32_gatherdiv2df ((__v2df)(__m128d)SRC,	 \
-					 (double const *)BASE,	 \
-					 (__v2di)(__m128i)INDEX, \
-					 (__v2df)(__m128d)MASK,	 \
-					 (int)SCALE)
+					 (double const *) (BASE),	\
+					 (__v2di)(__m128i) (INDEX),	\
+					 (__v2df)			\
+					 _mm_cmpeq_pd (_mm_setzero_pd (),\
+						       _mm_setzero_pd ()),\
+					 (int) (SCALE))
+
+#define _mm_mask_i64gather_pd(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m128d) __builtin_ia32_gatherdiv2df ((__v2df)(__m128d) (SRC),	\
+					 (double const *) (BASE),	\
+					 (__v2di)(__m128i) (INDEX),	\
+					 (__v2df)(__m128d) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm256_i64gather_pd(BASE, INDEX, SCALE)				\
   (__m256d) __builtin_ia32_gatherdiv4df ((__v4df) _mm256_setzero_pd (),	\
-					 (double const *)BASE,		\
-					 (__v4di)(__m256i)INDEX,	\
-					 (__v4df)_mm256_set1_pd(	\
-					   (double)(long long int) -1), \
-					 (int)SCALE)
-
-#define _mm256_mask_i64gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m256d) __builtin_ia32_gatherdiv4df ((__v4df)(__m256d)SRC,	 \
-					 (double const *)BASE,	 \
-					 (__v4di)(__m256i)INDEX, \
-					 (__v4df)(__m256d)MASK,	 \
-					 (int)SCALE)
+					 (double const *) (BASE),	\
+					 (__v4di)(__m256i) (INDEX),	\
+					 (__v4df)			\
+					 _mm256_cmp_pd (_mm256_setzero_pd (),\
+							_mm256_setzero_pd (),\
+							_CMP_EQ_OQ),	\
+					 (int) (SCALE))
+
+#define _mm256_mask_i64gather_pd(SRC, BASE, INDEX, MASK, SCALE)	 	\
+  (__m256d) __builtin_ia32_gatherdiv4df ((__v4df)(__m256d) (SRC),	\
+					 (double const *) (BASE),	\
+					 (__v4di)(__m256i) (INDEX),	\
+					 (__v4df)(__m256d) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm_i32gather_ps(BASE, INDEX, SCALE)				\
   (__m128) __builtin_ia32_gathersiv4sf ((__v4sf) _mm_setzero_ps (),	\
-					(float const *)BASE,		\
-					(__v4si)(__m128i)INDEX,		\
-					_mm_set1_ps ((float)(int) -1),	\
-					(int)SCALE)
-
-#define _mm_mask_i32gather_ps(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m128) __builtin_ia32_gathersiv4sf ((__v4sf)(__m128)SRC,	 \
-					(float const *)BASE,	 \
-					(__v4si)(__m128i)INDEX,	 \
-					(__v4sf)(__m128)MASK,	 \
-					(int)SCALE)
-
-#define _mm256_i32gather_ps(BASE, INDEX, SCALE)			       \
-  (__m256) __builtin_ia32_gathersiv8sf ((__v8sf) _mm256_setzero_ps (), \
-					(float const *)BASE,	       \
-					(__v8si)(__m256i)INDEX,	       \
-					(__v8sf)_mm256_set1_ps (       \
-					  (float)(int) -1),	       \
-					(int)SCALE)
-
-#define _mm256_mask_i32gather_ps(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m256) __builtin_ia32_gathersiv8sf ((__v8sf)(__m256)SRC,	\
-					(float const *)BASE,	\
-					(__v8si)(__m256i)INDEX, \
-					(__v8sf)(__m256)MASK,	\
-					(int)SCALE)
+					(float const *) (BASE),		\
+					(__v4si)(__m128i) (INDEX),	\
+					(__v4sf)			\
+					_mm_cmpeq_ps (_mm_setzero_ps (),\
+						      _mm_setzero_ps ()),\
+					(int) (SCALE))
+
+#define _mm_mask_i32gather_ps(SRC, BASE, INDEX, MASK, SCALE)	 	\
+  (__m128) __builtin_ia32_gathersiv4sf ((__v4sf)(__m128) (SRC),		\
+					(float const *) (BASE),		\
+					(__v4si)(__m128i) (INDEX),	\
+					(__v4sf)(__m128) (MASK),	\
+					(int) (SCALE))
+
+#define _mm256_i32gather_ps(BASE, INDEX, SCALE)				\
+  (__m256) __builtin_ia32_gathersiv8sf ((__v8sf) _mm256_setzero_ps (),	\
+					(float const *) (BASE),		\
+					(__v8si)(__m256i) (INDEX),	\
+					(__v8sf)			\
+					_mm256_cmp_ps (_mm256_setzero_ps (),\
+						       _mm256_setzero_ps (),\
+						       _CMP_EQ_OQ),	\
+					(int) (SCALE))
+
+#define _mm256_mask_i32gather_ps(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m256) __builtin_ia32_gathersiv8sf ((__v8sf)(__m256) (SRC),		\
+					(float const *) (BASE),		\
+					(__v8si)(__m256i) (INDEX),	\
+					(__v8sf)(__m256) (MASK),	\
+					(int) (SCALE))
 
 #define _mm_i64gather_ps(BASE, INDEX, SCALE)				\
   (__m128) __builtin_ia32_gatherdiv4sf ((__v4sf) _mm_setzero_pd (),	\
-					(float const *)BASE,		\
-					(__v2di)(__m128i)INDEX,		\
-					(__v4sf)_mm_set1_ps (		\
-					  (float)(int) -1),		\
-					(int)SCALE)
-
-#define _mm_mask_i64gather_ps(SRC, BASE, INDEX, MASK, SCALE)	 \
-  (__m128) __builtin_ia32_gatherdiv4sf ((__v4sf)(__m128)SRC,	 \
-					(float const *)BASE,	 \
-					(__v2di)(__m128i)INDEX,	 \
-					(__v4sf)(__m128)MASK,	 \
-					(int)SCALE)
+					(float const *) (BASE),		\
+					(__v2di)(__m128i) (INDEX),	\
+					(__v4sf)			\
+					_mm_cmpeq_ps (_mm_setzero_ps (),\
+						      _mm_setzero_ps ()),\
+					(int) (SCALE))
+
+#define _mm_mask_i64gather_ps(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m128) __builtin_ia32_gatherdiv4sf ((__v4sf)(__m128) (SRC),		\
+					(float const *) (BASE),		\
+					(__v2di)(__m128i) (INDEX),	\
+					(__v4sf)(__m128) (MASK),	\
+					(int) (SCALE))
 
 #define _mm256_i64gather_ps(BASE, INDEX, SCALE)				\
   (__m128) __builtin_ia32_gatherdiv4sf256 ((__v4sf) _mm_setzero_ps (),	\
-					   (float const *)BASE,		\
-					   (__v4di)(__m256i)INDEX,	\
-					   (__v4sf)_mm_set1_ps(		\
-					     (float)(int) -1),		\
-					   (int)SCALE)
-
-#define _mm256_mask_i64gather_ps(SRC, BASE, INDEX, MASK, SCALE)	   \
-  (__m128) __builtin_ia32_gatherdiv4sf256 ((__v4sf)(__m128)SRC,	   \
-					   (float const *)BASE,	   \
-					   (__v4di)(__m256i)INDEX, \
-					   (__v4sf)(__m128)MASK,   \
-					   (int)SCALE)
+					   (float const *) (BASE),	\
+					   (__v4di)(__m256i) (INDEX),	\
+					   (__v4sf)			\
+					   _mm_cmpeq_ps (_mm_setzero_ps (),\
+							 _mm_setzero_ps ()),\
+					   (int) (SCALE))
+
+#define _mm256_mask_i64gather_ps(SRC, BASE, INDEX, MASK, SCALE)	   	\
+  (__m128) __builtin_ia32_gatherdiv4sf256 ((__v4sf)(__m128) (SRC),	\
+					   (float const *) (BASE),	\
+					   (__v4di)(__m256i) (INDEX),	\
+					   (__v4sf)(__m128) (MASK),	\
+					   (int) (SCALE))
 
 #define _mm_i32gather_epi64(BASE, INDEX, SCALE)				\
   (__m128i) __builtin_ia32_gathersiv2di ((__v2di) _mm_setzero_si128 (), \
-					 (long long const *)BASE,	\
-					 (__v4si)(__m128i)INDEX,	\
+					 (long long const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
 					 (__v2di)_mm_set1_epi64x (-1),	\
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm_mask_i32gather_epi64(SRC, BASE, INDEX, MASK, SCALE)	  \
-  (__m128i) __builtin_ia32_gathersiv2di ((__v2di)(__m128i)SRC,	  \
-					 (long long const *)BASE, \
-					 (__v4si)(__m128i)INDEX,  \
-					 (__v2di)(__m128i)MASK,	  \
-					 (int)SCALE)
+#define _mm_mask_i32gather_epi64(SRC, BASE, INDEX, MASK, SCALE)	  	\
+  (__m128i) __builtin_ia32_gathersiv2di ((__v2di)(__m128i) (SRC),	\
+					 (long long const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v2di)(__m128i) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm256_i32gather_epi64(BASE, INDEX, SCALE)			   \
   (__m256i) __builtin_ia32_gathersiv4di ((__v4di) _mm256_setzero_si256 (), \
-					 (long long const *)BASE,	   \
-					 (__v4si)(__m128i)INDEX,	   \
+					 (long long const *) (BASE),	   \
+					 (__v4si)(__m128i) (INDEX),	   \
 					 (__v4di)_mm256_set1_epi64x (-1),  \
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm256_mask_i32gather_epi64(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m256i) __builtin_ia32_gathersiv4di ((__v4di)(__m256i)SRC,	   \
-					 (long long const *)BASE,  \
-					 (__v4si)(__m128i)INDEX,   \
-					 (__v4di)(__m256i)MASK,	   \
-					 (int)SCALE)
+#define _mm256_mask_i32gather_epi64(SRC, BASE, INDEX, MASK, SCALE)	\
+  (__m256i) __builtin_ia32_gathersiv4di ((__v4di)(__m256i) (SRC),	\
+					 (long long const *) (BASE),	\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__v4di)(__m256i) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm_i64gather_epi64(BASE, INDEX, SCALE)				\
   (__m128i) __builtin_ia32_gatherdiv2di ((__v2di) _mm_setzero_si128 (), \
-					 (long long const *)BASE,	\
-					 (__v2di)(__m128i)INDEX,	\
+					 (long long const *) (BASE),	\
+					 (__v2di)(__m128i) (INDEX),	\
 					 (__v2di)_mm_set1_epi64x (-1),	\
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm_mask_i64gather_epi64(SRC, BASE, INDEX, MASK, SCALE)	  \
-  (__m128i) __builtin_ia32_gatherdiv2di ((__v2di)(__m128i)SRC,	  \
-					 (long long const *)BASE, \
-					 (__v2di)(__m128i)INDEX,  \
-					 (__v2di)(__m128i)MASK,	  \
-					 (int)SCALE)
+#define _mm_mask_i64gather_epi64(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m128i) __builtin_ia32_gatherdiv2di ((__v2di)(__m128i) (SRC),	\
+					 (long long const *) (BASE),	\
+					 (__v2di)(__m128i) (INDEX),	\
+					 (__v2di)(__m128i) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm256_i64gather_epi64(BASE, INDEX, SCALE)			   \
   (__m256i) __builtin_ia32_gatherdiv4di ((__v4di) _mm256_setzero_si256 (), \
-					 (long long const *)BASE,	   \
-					 (__v4di)(__m256i)INDEX,	   \
+					 (long long const *) (BASE),	   \
+					 (__v4di)(__m256i) (INDEX),	   \
 					 (__v4di)_mm256_set1_epi64x (-1),  \
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm256_mask_i64gather_epi64(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m256i) __builtin_ia32_gatherdiv4di ((__v4di)(__m256i)SRC,	   \
-					 (long long const *)BASE,  \
-					 (__v4di)(__m256i)INDEX,   \
-					 (__v4di)(__m256i)MASK,	   \
-					 (int)SCALE)
+#define _mm256_mask_i64gather_epi64(SRC, BASE, INDEX, MASK, SCALE) 	\
+  (__m256i) __builtin_ia32_gatherdiv4di ((__v4di)(__m256i) (SRC),	\
+					 (long long const *) (BASE),	\
+					 (__v4di)(__m256i) (INDEX),	\
+					 (__v4di)(__m256i) (MASK),	\
+					 (int) (SCALE))
 
 #define _mm_i32gather_epi32(BASE, INDEX, SCALE)				\
   (__m128i) __builtin_ia32_gathersiv4si ((__v4si) _mm_setzero_si128 (),	\
-					 (int const *)BASE,		\
-					 (__v4si)(__m128i)INDEX,	\
+					 (int const *) (BASE),		\
+					 (__v4si)(__m128i) (INDEX),	\
 					 (__v4si)_mm_set1_epi32 (-1),	\
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm_mask_i32gather_epi32(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m128i) __builtin_ia32_gathersiv4si ((__v4si)(__m128i)SRC,	\
-					(int const *)BASE,	\
-					(__v4si)(__m128i)INDEX, \
-					(__v4si)(__m128i)MASK,	\
-					(int)SCALE)
+#define _mm_mask_i32gather_epi32(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m128i) __builtin_ia32_gathersiv4si ((__v4si)(__m128i) (SRC),	\
+					(int const *) (BASE),		\
+					(__v4si)(__m128i) (INDEX),	\
+					(__v4si)(__m128i) (MASK),	\
+					(int) (SCALE))
 
 #define _mm256_i32gather_epi32(BASE, INDEX, SCALE)			   \
   (__m256i) __builtin_ia32_gathersiv8si ((__v8si) _mm256_setzero_si256 (), \
-					 (int const *)BASE,		   \
-					 (__v8si)(__m256i)INDEX,	   \
+					 (int const *) (BASE),		   \
+					 (__v8si)(__m256i) (INDEX),	   \
 					 (__v8si)_mm256_set1_epi32 (-1),   \
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm256_mask_i32gather_epi32(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m256i) __builtin_ia32_gathersiv8si ((__v8si)(__m256i)SRC,	   \
-					(int const *)BASE,	   \
-					(__v8si)(__m256i)INDEX,	   \
-					(__v8si)(__m256i)MASK,	   \
-					(int)SCALE)
+#define _mm256_mask_i32gather_epi32(SRC, BASE, INDEX, MASK, SCALE)	\
+  (__m256i) __builtin_ia32_gathersiv8si ((__v8si)(__m256i) (SRC),	\
+					(int const *) (BASE),	   	\
+					(__v8si)(__m256i) (INDEX),	\
+					(__v8si)(__m256i) (MASK),	\
+					(int) (SCALE))
 
 #define _mm_i64gather_epi32(BASE, INDEX, SCALE)				\
   (__m128i) __builtin_ia32_gatherdiv4si ((__v4si) _mm_setzero_si128 (),	\
-					 (int const *)BASE,		\
-					 (__v2di)(__m128i)INDEX,	\
+					 (int const *) (BASE),		\
+					 (__v2di)(__m128i) (INDEX),	\
 					 (__v4si)_mm_set1_epi32 (-1),	\
-					 (int)SCALE)
+					 (int) (SCALE))
 
-#define _mm_mask_i64gather_epi32(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m128i) __builtin_ia32_gatherdiv4si ((__v4si)(__m128i)SRC,	\
-					(int const *)BASE,	\
-					(__v2di)(__m128i)INDEX, \
-					(__v4si)(__m128i)MASK,	\
-					(int)SCALE)
+#define _mm_mask_i64gather_epi32(SRC, BASE, INDEX, MASK, SCALE)		\
+  (__m128i) __builtin_ia32_gatherdiv4si ((__v4si)(__m128i) (SRC),	\
+					(int const *) (BASE),		\
+					(__v2di)(__m128i) (INDEX),	\
+					(__v4si)(__m128i) (MASK),	\
+					(int) (SCALE))
 
 #define _mm256_i64gather_epi32(BASE, INDEX, SCALE)			   \
   (__m128i) __builtin_ia32_gatherdiv4si256 ((__v4si) _mm_setzero_si128 (), \
-					    (int const *)BASE,		   \
-					    (__v4di)(__m256i)INDEX,	   \
+					    (int const *) (BASE),	   \
+					    (__v4di)(__m256i) (INDEX),	   \
 					    (__v4si)_mm_set1_epi32(-1),	   \
-					    (int)SCALE)
-
-#define _mm256_mask_i64gather_epi32(SRC, BASE, INDEX, MASK, SCALE) \
-  (__m128i) __builtin_ia32_gatherdiv4si256 ((__v4si)(__m128i)SRC,  \
-					   (int const *)BASE,	   \
-					   (__v4di)(__m256i)INDEX, \
-					   (__v4si)(__m128i)MASK,  \
-					   (int)SCALE)
+					    (int) (SCALE))
+
+#define _mm256_mask_i64gather_epi32(SRC, BASE, INDEX, MASK, SCALE)	\
+  (__m128i) __builtin_ia32_gatherdiv4si256 ((__v4si)(__m128i) (SRC),	\
+					   (int const *) (BASE),	\
+					   (__v4di)(__m256i) (INDEX),	\
+					   (__v4si)(__m128i) (MASK),	\
+					   (int) (SCALE))
 #endif  /* __OPTIMIZE__ */
 
 #ifdef __DISABLE_AVX2__
diff --git a/gcc/config/i386/avx512bwintrin.h b/gcc/config/i386/avx512bwintrin.h
index cf5f885086d..70bf19eadc7 100644
--- a/gcc/config/i386/avx512bwintrin.h
+++ b/gcc/config/i386/avx512bwintrin.h
@@ -3128,16 +3128,16 @@ _mm512_bsrli_epi128 (__m512i __A, const int __N)
 #define _mm512_alignr_epi8(X, Y, N)						    \
   ((__m512i) __builtin_ia32_palignr512 ((__v8di)(__m512i)(X),			    \
 					(__v8di)(__m512i)(Y),			    \
-					(int)(N * 8)))
+					(int)((N) * 8)))
 
 #define _mm512_mask_alignr_epi8(W, U, X, Y, N)					    \
   ((__m512i) __builtin_ia32_palignr512_mask ((__v8di)(__m512i)(X),		    \
-					    (__v8di)(__m512i)(Y), (int)(N * 8),	    \
+					    (__v8di)(__m512i)(Y), (int)((N) * 8),   \
 					    (__v8di)(__m512i)(W), (__mmask64)(U)))
 
 #define _mm512_maskz_alignr_epi8(U, X, Y, N)					    \
   ((__m512i) __builtin_ia32_palignr512_mask ((__v8di)(__m512i)(X),		    \
-					     (__v8di)(__m512i)(Y), (int)(N * 8),    \
+					     (__v8di)(__m512i)(Y), (int)((N) * 8),  \
 					     (__v8di)(__m512i)			    \
 					     _mm512_setzero_si512 (),		    \
 					     (__mmask64)(U)))
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index e35eedb9268..6ca90d344e9 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -8542,22 +8542,22 @@ _mm512_maskz_cvtps_ph (__mmask16 __W, __m512 __A, const int __I)
     (__m512)__builtin_ia32_vcvtph2ps512_mask((__v16hi)(A), (__v16sf)_mm512_setzero_ps(), U, B)
 
 #define _mm512_cvt_roundps_ph(A, I)						 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)_mm256_undefined_si256 (), -1))
 #define _mm512_cvtps_ph(A, I)						 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)_mm256_undefined_si256 (), -1))
 #define _mm512_mask_cvt_roundps_ph(U, W, A, I)				 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)(__m256i)(U), (__mmask16) (W)))
 #define _mm512_mask_cvtps_ph(U, W, A, I)				 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)(__m256i)(U), (__mmask16) (W)))
 #define _mm512_maskz_cvt_roundps_ph(W, A, I)					 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)_mm256_setzero_si256 (), (__mmask16) (W)))
 #define _mm512_maskz_cvtps_ph(W, A, I)					 \
-  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) A, (int) (I),\
+  ((__m256i) __builtin_ia32_vcvtps2ph512_mask ((__v16sf)(__m512) (A), (int) (I),\
     (__v16hi)_mm256_setzero_si256 (), (__mmask16) (W)))
 #endif
 
@@ -9946,32 +9946,32 @@ _mm_mask_cmp_round_ss_mask (__mmask8 __M, __m128 __X, __m128 __Y,
 #define _mm512_mask_cmp_epi64_mask(M, X, Y, P)				\
   ((__mmask8) __builtin_ia32_cmpq512_mask ((__v8di)(__m512i)(X),	\
 					   (__v8di)(__m512i)(Y), (int)(P),\
-					   (__mmask8)M))
+					   (__mmask8)(M)))
 
 #define _mm512_mask_cmp_epi32_mask(M, X, Y, P)				\
   ((__mmask16) __builtin_ia32_cmpd512_mask ((__v16si)(__m512i)(X),	\
 					    (__v16si)(__m512i)(Y), (int)(P), \
-					    (__mmask16)M))
+					    (__mmask16)(M)))
 
 #define _mm512_mask_cmp_epu64_mask(M, X, Y, P)				\
   ((__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di)(__m512i)(X),	\
 					    (__v8di)(__m512i)(Y), (int)(P),\
-					    (__mmask8)M))
+					    (__mmask8)(M)))
 
 #define _mm512_mask_cmp_epu32_mask(M, X, Y, P)				\
   ((__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si)(__m512i)(X),	\
 					     (__v16si)(__m512i)(Y), (int)(P), \
-					     (__mmask16)M))
+					     (__mmask16)(M)))
 
 #define _mm512_mask_cmp_round_pd_mask(M, X, Y, P, R)			\
   ((__mmask8) __builtin_ia32_cmppd512_mask ((__v8df)(__m512d)(X),	\
 					    (__v8df)(__m512d)(Y), (int)(P),\
-					    (__mmask8)M, R))
+					    (__mmask8)(M), R))
 
 #define _mm512_mask_cmp_round_ps_mask(M, X, Y, P, R)			\
   ((__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf)(__m512)(X),	\
 					     (__v16sf)(__m512)(Y), (int)(P),\
-					     (__mmask16)M, R))
+					     (__mmask16)(M), R))
 
 #define _mm_cmp_round_sd_mask(X, Y, P, R)				\
   ((__mmask8) __builtin_ia32_cmpsd_mask ((__v2df)(__m128d)(X),		\
@@ -10333,179 +10333,189 @@ _mm512_mask_i64scatter_epi64 (void *__addr, __mmask8 __mask,
 #else
 #define _mm512_i32gather_ps(INDEX, ADDR, SCALE)				\
   (__m512) __builtin_ia32_gathersiv16sf ((__v16sf)_mm512_undefined_ps(),\
-					 (void const *)ADDR,		\
-					 (__v16si)(__m512i)INDEX,	\
-					 (__mmask16)0xFFFF, (int)SCALE)
+					 (void const *) (ADDR),		\
+					 (__v16si)(__m512i) (INDEX),	\
+					 (__mmask16)0xFFFF,		\
+					 (int) (SCALE))
 
 #define _mm512_mask_i32gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512) __builtin_ia32_gathersiv16sf ((__v16sf)(__m512)V1OLD,	\
-					 (void const *)ADDR,		\
-					 (__v16si)(__m512i)INDEX,	\
-					 (__mmask16)MASK, (int)SCALE)
+  (__m512) __builtin_ia32_gathersiv16sf ((__v16sf)(__m512) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v16si)(__m512i) (INDEX),	\
+					 (__mmask16) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm512_i32gather_pd(INDEX, ADDR, SCALE)				\
   (__m512d) __builtin_ia32_gathersiv8df ((__v8df)_mm512_undefined_pd(),	\
-					 (void const *)ADDR,		\
-					 (__v8si)(__m256i)INDEX,	\
-					 (__mmask8)0xFF, (int)SCALE)
+					 (void const *) (ADDR),		\
+					 (__v8si)(__m256i) (INDEX),	\
+					 (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i32gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512d) __builtin_ia32_gathersiv8df ((__v8df)(__m512d)V1OLD,	\
-					 (void const *)ADDR,		\
-					 (__v8si)(__m256i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m512d) __builtin_ia32_gathersiv8df ((__v8df)(__m512d) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8si)(__m256i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm512_i64gather_ps(INDEX, ADDR, SCALE)				\
   (__m256) __builtin_ia32_gatherdiv16sf ((__v8sf)_mm256_undefined_ps(),	\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)0xFF, (int)SCALE)
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i64gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256) __builtin_ia32_gatherdiv16sf ((__v8sf)(__m256)V1OLD,		\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m256) __builtin_ia32_gatherdiv16sf ((__v8sf)(__m256) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm512_i64gather_pd(INDEX, ADDR, SCALE)				\
   (__m512d) __builtin_ia32_gatherdiv8df ((__v8df)_mm512_undefined_pd(),	\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)0xFF, (int)SCALE)
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i64gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512d) __builtin_ia32_gatherdiv8df ((__v8df)(__m512d)V1OLD,	\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m512d) __builtin_ia32_gatherdiv8df ((__v8df)(__m512d) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm512_i32gather_epi32(INDEX, ADDR, SCALE)			\
-  (__m512i) __builtin_ia32_gathersiv16si ((__v16si)_mm512_undefined_epi32 (),	\
-					  (void const *)ADDR,		\
-					  (__v16si)(__m512i)INDEX,	\
-					  (__mmask16)0xFFFF, (int)SCALE)
+  (__m512i) __builtin_ia32_gathersiv16si ((__v16si)_mm512_undefined_epi32 (),\
+					  (void const *) (ADDR),	\
+					  (__v16si)(__m512i) (INDEX),	\
+					  (__mmask16)0xFFFF,		\
+					  (int) (SCALE))
 
 #define _mm512_mask_i32gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512i) __builtin_ia32_gathersiv16si ((__v16si)(__m512i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v16si)(__m512i)INDEX,	\
-					  (__mmask16)MASK, (int)SCALE)
+  (__m512i) __builtin_ia32_gathersiv16si ((__v16si)(__m512i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v16si)(__m512i) (INDEX),	\
+					  (__mmask16) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm512_i32gather_epi64(INDEX, ADDR, SCALE)			\
-  (__m512i) __builtin_ia32_gathersiv8di ((__v8di)_mm512_undefined_epi32 (),	\
-					 (void const *)ADDR,		\
-					 (__v8si)(__m256i)INDEX,	\
-					 (__mmask8)0xFF, (int)SCALE)
+  (__m512i) __builtin_ia32_gathersiv8di ((__v8di)_mm512_undefined_epi32 (),\
+					 (void const *) (ADDR),		\
+					 (__v8si)(__m256i) (INDEX),	\
+					 (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i32gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512i) __builtin_ia32_gathersiv8di ((__v8di)(__m512i)V1OLD,	\
-					 (void const *)ADDR,		\
-					 (__v8si)(__m256i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
-
-#define _mm512_i64gather_epi32(INDEX, ADDR, SCALE)			  \
-  (__m256i) __builtin_ia32_gatherdiv16si ((__v8si)_mm256_undefined_si256(), \
-					  (void const *)ADDR,		  \
-					  (__v8di)(__m512i)INDEX,	  \
-					  (__mmask8)0xFF, (int)SCALE)
+  (__m512i) __builtin_ia32_gathersiv8di ((__v8di)(__m512i) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8si)(__m256i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
+
+#define _mm512_i64gather_epi32(INDEX, ADDR, SCALE)			   \
+  (__m256i) __builtin_ia32_gatherdiv16si ((__v8si)_mm256_undefined_si256(),\
+					  (void const *) (ADDR),	   \
+					  (__v8di)(__m512i) (INDEX),	   \
+					  (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i64gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256i) __builtin_ia32_gatherdiv16si ((__v8si)(__m256i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v8di)(__m512i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256i) __builtin_ia32_gatherdiv16si ((__v8si)(__m256i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v8di)(__m512i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm512_i64gather_epi64(INDEX, ADDR, SCALE)			\
-  (__m512i) __builtin_ia32_gatherdiv8di ((__v8di)_mm512_undefined_epi32 (),	\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)0xFF, (int)SCALE)
+  (__m512i) __builtin_ia32_gatherdiv8di ((__v8di)_mm512_undefined_epi32 (),\
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8)0xFF, (int) (SCALE))
 
 #define _mm512_mask_i64gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m512i) __builtin_ia32_gatherdiv8di ((__v8di)(__m512i)V1OLD,	\
-					 (void const *)ADDR,		\
-					 (__v8di)(__m512i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m512i) __builtin_ia32_gatherdiv8di ((__v8di)(__m512i) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8di)(__m512i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm512_i32scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv16sf ((void *)ADDR, (__mmask16)0xFFFF,	\
-				 (__v16si)(__m512i)INDEX,		\
-				 (__v16sf)(__m512)V1, (int)SCALE)
+  __builtin_ia32_scattersiv16sf ((void *) (ADDR), (__mmask16)0xFFFF,	\
+				 (__v16si)(__m512i) (INDEX),		\
+				 (__v16sf)(__m512) (V1), (int) (SCALE))
 
 #define _mm512_mask_i32scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv16sf ((void *)ADDR, (__mmask16)MASK,		\
-				 (__v16si)(__m512i)INDEX,		\
-				 (__v16sf)(__m512)V1, (int)SCALE)
+  __builtin_ia32_scattersiv16sf ((void *) (ADDR), (__mmask16) (MASK),	\
+				 (__v16si)(__m512i) (INDEX),		\
+				 (__v16sf)(__m512) (V1), (int) (SCALE))
 
 #define _mm512_i32scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv8df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8df)(__m512d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8df)(__m512d) (V1), (int) (SCALE))
 
 #define _mm512_mask_i32scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv8df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8df)(__m512d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8df)(__m512d) (V1), (int) (SCALE))
 
 #define _mm512_i64scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv16sf ((void *)ADDR, (__mmask8)0xFF,		\
-				 (__v8di)(__m512i)INDEX,		\
-				 (__v8sf)(__m256)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv16sf ((void *) (ADDR), (__mmask8)0xFF,	\
+				 (__v8di)(__m512i) (INDEX),		\
+				 (__v8sf)(__m256) (V1), (int) (SCALE))
 
 #define _mm512_mask_i64scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv16sf ((void *)ADDR, (__mmask16)MASK,		\
-				 (__v8di)(__m512i)INDEX,		\
-				 (__v8sf)(__m256)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv16sf ((void *) (ADDR), (__mmask16) (MASK),	\
+				 (__v8di)(__m512i) (INDEX),		\
+				 (__v8sf)(__m256) (V1), (int) (SCALE))
 
 #define _mm512_i64scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv8df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8di)(__m512i)INDEX,			\
-				(__v8df)(__m512d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8di)(__m512i) (INDEX),		\
+				(__v8df)(__m512d) (V1), (int) (SCALE))
 
 #define _mm512_mask_i64scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv8df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8di)(__m512i)INDEX,			\
-				(__v8df)(__m512d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8di)(__m512i) (INDEX),		\
+				(__v8df)(__m512d) (V1), (int) (SCALE))
 
 #define _mm512_i32scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv16si ((void *)ADDR, (__mmask16)0xFFFF,	\
-				 (__v16si)(__m512i)INDEX,		\
-				 (__v16si)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv16si ((void *) (ADDR), (__mmask16)0xFFFF,	\
+				 (__v16si)(__m512i) (INDEX),		\
+				 (__v16si)(__m512i) (V1), (int) (SCALE))
 
 #define _mm512_mask_i32scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scattersiv16si ((void *)ADDR, (__mmask16)MASK,		\
-				 (__v16si)(__m512i)INDEX,		\
-				 (__v16si)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv16si ((void *) (ADDR), (__mmask16) (MASK),	\
+				 (__v16si)(__m512i) (INDEX),		\
+				 (__v16si)(__m512i) (V1), (int) (SCALE))
 
 #define _mm512_i32scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv8di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8di)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8di)(__m512i) (V1), (int) (SCALE))
 
 #define _mm512_mask_i32scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scattersiv8di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8di)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8di)(__m512i) (V1), (int) (SCALE))
 
 #define _mm512_i64scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv16si ((void *)ADDR, (__mmask8)0xFF,		\
-				 (__v8di)(__m512i)INDEX,		\
-				 (__v8si)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv16si ((void *) (ADDR), (__mmask8)0xFF,	\
+				 (__v8di)(__m512i) (INDEX),		\
+				 (__v8si)(__m256i) (V1), (int) (SCALE))
 
 #define _mm512_mask_i64scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scatterdiv16si ((void *)ADDR, (__mmask8)MASK,		\
-				 (__v8di)(__m512i)INDEX,		\
-				 (__v8si)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv16si ((void *) (ADDR), (__mmask8) (MASK),	\
+				 (__v8di)(__m512i) (INDEX),		\
+				 (__v8si)(__m256i) (V1), (int) (SCALE))
 
 #define _mm512_i64scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv8di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8di)(__m512i)INDEX,			\
-				(__v8di)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8di)(__m512i) (INDEX),		\
+				(__v8di)(__m512i) (V1), (int) (SCALE))
 
 #define _mm512_mask_i64scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scatterdiv8di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8di)(__m512i)INDEX,			\
-				(__v8di)(__m512i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8di)(__m512i) (INDEX),		\
+				(__v8di)(__m512i) (V1), (int) (SCALE))
 #endif
 
 extern __inline __m512d
@@ -14874,6 +14884,88 @@ _mm512_mask_cmp_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y, const int __P)
 						  _MM_FROUND_CUR_DIRECTION);
 }
 
+extern __inline __mmask8
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_cmp_sd_mask (__m128d __X, __m128d __Y, const int __P)
+{
+  return (__mmask8) __builtin_ia32_cmpsd_mask ((__v2df) __X,
+					       (__v2df) __Y, __P,
+					       (__mmask8) -1,
+					       _MM_FROUND_CUR_DIRECTION);
+}
+
+extern __inline __mmask8
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_mask_cmp_sd_mask (__mmask8 __M, __m128d __X, __m128d __Y, const int __P)
+{
+  return (__mmask8) __builtin_ia32_cmpsd_mask ((__v2df) __X,
+					       (__v2df) __Y, __P,
+					       (__mmask8) __M,
+					       _MM_FROUND_CUR_DIRECTION);
+}
+
+extern __inline __mmask8
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_cmp_ss_mask (__m128 __X, __m128 __Y, const int __P)
+{
+  return (__mmask8) __builtin_ia32_cmpss_mask ((__v4sf) __X,
+					       (__v4sf) __Y, __P,
+					       (__mmask8) -1,
+					       _MM_FROUND_CUR_DIRECTION);
+}
+
+extern __inline __mmask8
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_mask_cmp_ss_mask (__mmask8 __M, __m128 __X, __m128 __Y, const int __P)
+{
+  return (__mmask8) __builtin_ia32_cmpss_mask ((__v4sf) __X,
+					       (__v4sf) __Y, __P,
+					       (__mmask8) __M,
+					       _MM_FROUND_CUR_DIRECTION);
+}
+
+#else
+#define _mm512_cmp_pd_mask(X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmppd512_mask ((__v8df)(__m512d)(X),	\
+					    (__v8df)(__m512d)(Y), (int)(P),\
+					    (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
+
+#define _mm512_cmp_ps_mask(X, Y, P)					\
+  ((__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf)(__m512)(X),	\
+					     (__v16sf)(__m512)(Y), (int)(P),\
+					     (__mmask16)-1,_MM_FROUND_CUR_DIRECTION))
+
+#define _mm512_mask_cmp_pd_mask(M, X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmppd512_mask ((__v8df)(__m512d)(X),	\
+					    (__v8df)(__m512d)(Y), (int)(P),\
+					    (__mmask8)(M), _MM_FROUND_CUR_DIRECTION))
+
+#define _mm512_mask_cmp_ps_mask(M, X, Y, P)					\
+  ((__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf)(__m512)(X),	\
+					     (__v16sf)(__m512)(Y), (int)(P),\
+					     (__mmask16)(M),_MM_FROUND_CUR_DIRECTION))
+
+#define _mm_cmp_sd_mask(X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmpsd_mask ((__v2df)(__m128d)(X),		\
+					 (__v2df)(__m128d)(Y), (int)(P),\
+					 (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
+
+#define _mm_mask_cmp_sd_mask(M, X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmpsd_mask ((__v2df)(__m128d)(X),		\
+					 (__v2df)(__m128d)(Y), (int)(P),\
+					 M,_MM_FROUND_CUR_DIRECTION))
+
+#define _mm_cmp_ss_mask(X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmpss_mask ((__v4sf)(__m128)(X),		\
+					 (__v4sf)(__m128)(Y), (int)(P), \
+					 (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
+
+#define _mm_mask_cmp_ss_mask(M, X, Y, P)					\
+  ((__mmask8) __builtin_ia32_cmpss_mask ((__v4sf)(__m128)(X),		\
+					 (__v4sf)(__m128)(Y), (int)(P), \
+					 M,_MM_FROUND_CUR_DIRECTION))
+#endif
+
 extern __inline __mmask8
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm512_cmpeq_pd_mask (__m512d __X, __m512d __Y)
@@ -15194,88 +15286,6 @@ _mm512_mask_cmpord_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
 						   _MM_FROUND_CUR_DIRECTION);
 }
 
-extern __inline __mmask8
-__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm_cmp_sd_mask (__m128d __X, __m128d __Y, const int __P)
-{
-  return (__mmask8) __builtin_ia32_cmpsd_mask ((__v2df) __X,
-					       (__v2df) __Y, __P,
-					       (__mmask8) -1,
-					       _MM_FROUND_CUR_DIRECTION);
-}
-
-extern __inline __mmask8
-__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_cmp_sd_mask (__mmask8 __M, __m128d __X, __m128d __Y, const int __P)
-{
-  return (__mmask8) __builtin_ia32_cmpsd_mask ((__v2df) __X,
-					       (__v2df) __Y, __P,
-					       (__mmask8) __M,
-					       _MM_FROUND_CUR_DIRECTION);
-}
-
-extern __inline __mmask8
-__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm_cmp_ss_mask (__m128 __X, __m128 __Y, const int __P)
-{
-  return (__mmask8) __builtin_ia32_cmpss_mask ((__v4sf) __X,
-					       (__v4sf) __Y, __P,
-					       (__mmask8) -1,
-					       _MM_FROUND_CUR_DIRECTION);
-}
-
-extern __inline __mmask8
-__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm_mask_cmp_ss_mask (__mmask8 __M, __m128 __X, __m128 __Y, const int __P)
-{
-  return (__mmask8) __builtin_ia32_cmpss_mask ((__v4sf) __X,
-					       (__v4sf) __Y, __P,
-					       (__mmask8) __M,
-					       _MM_FROUND_CUR_DIRECTION);
-}
-
-#else
-#define _mm512_cmp_pd_mask(X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmppd512_mask ((__v8df)(__m512d)(X),	\
-					    (__v8df)(__m512d)(Y), (int)(P),\
-					    (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm512_cmp_ps_mask(X, Y, P)					\
-  ((__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf)(__m512)(X),	\
-					     (__v16sf)(__m512)(Y), (int)(P),\
-					     (__mmask16)-1,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm512_mask_cmp_pd_mask(M, X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmppd512_mask ((__v8df)(__m512d)(X),	\
-					    (__v8df)(__m512d)(Y), (int)(P),\
-					    (__mmask8)M, _MM_FROUND_CUR_DIRECTION))
-
-#define _mm512_mask_cmp_ps_mask(M, X, Y, P)					\
-  ((__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf)(__m512)(X),	\
-					     (__v16sf)(__m512)(Y), (int)(P),\
-					     (__mmask16)M,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm_cmp_sd_mask(X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmpsd_mask ((__v2df)(__m128d)(X),		\
-					 (__v2df)(__m128d)(Y), (int)(P),\
-					 (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm_mask_cmp_sd_mask(M, X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmpsd_mask ((__v2df)(__m128d)(X),		\
-					 (__v2df)(__m128d)(Y), (int)(P),\
-					 M,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm_cmp_ss_mask(X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmpss_mask ((__v4sf)(__m128)(X),		\
-					 (__v4sf)(__m128)(Y), (int)(P), \
-					 (__mmask8)-1,_MM_FROUND_CUR_DIRECTION))
-
-#define _mm_mask_cmp_ss_mask(M, X, Y, P)					\
-  ((__mmask8) __builtin_ia32_cmpss_mask ((__v4sf)(__m128)(X),		\
-					 (__v4sf)(__m128)(Y), (int)(P), \
-					 M,_MM_FROUND_CUR_DIRECTION))
-#endif
-
 extern __inline __mmask16
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm512_kmov (__mmask16 __A)
diff --git a/gcc/config/i386/avx512pfintrin.h b/gcc/config/i386/avx512pfintrin.h
index 83556cb9fd4..a3cadc6841b 100644
--- a/gcc/config/i386/avx512pfintrin.h
+++ b/gcc/config/i386/avx512pfintrin.h
@@ -192,68 +192,73 @@ _mm512_mask_prefetch_i64scatter_ps (void *__addr, __mmask8 __mask,
 
 #else
 #define _mm512_prefetch_i32gather_pd(INDEX, ADDR, SCALE, HINT)		     \
-  __builtin_ia32_gatherpfdpd ((__mmask8)0xFF, (__v8si)(__m256i)INDEX,	     \
-			      (void const *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfdpd ((__mmask8)0xFF, (__v8si)(__m256i) (INDEX),     \
+			      (void const *) (ADDR), (int) (SCALE),	     \
+			      (int) (HINT))
 
 #define _mm512_prefetch_i32gather_ps(INDEX, ADDR, SCALE, HINT)		     \
-  __builtin_ia32_gatherpfdps ((__mmask16)0xFFFF, (__v16si)(__m512i)INDEX,    \
-			      (void const *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfdps ((__mmask16)0xFFFF, (__v16si)(__m512i) (INDEX), \
+			      (void const *) (ADDR), (int) (SCALE),	     \
+			      (int) (HINT))
 
 #define _mm512_mask_prefetch_i32gather_pd(INDEX, MASK, ADDR, SCALE, HINT)    \
-  __builtin_ia32_gatherpfdpd ((__mmask8)MASK, (__v8si)(__m256i)INDEX,	     \
-			      (void const *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfdpd ((__mmask8) (MASK), (__v8si)(__m256i) (INDEX),  \
+			      (void const *) (ADDR), (int) (SCALE),	     \
+			      (int) (HINT))
 
 #define _mm512_mask_prefetch_i32gather_ps(INDEX, MASK, ADDR, SCALE, HINT)    \
-  __builtin_ia32_gatherpfdps ((__mmask16)MASK, (__v16si)(__m512i)INDEX,      \
-			      (void const *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfdps ((__mmask16) (MASK), (__v16si)(__m512i) (INDEX),\
+			      (void const *) (ADDR), (int) (SCALE),	     \
+			      (int) (HINT))
 
 #define _mm512_prefetch_i64gather_pd(INDEX, ADDR, SCALE, HINT)		     \
-  __builtin_ia32_gatherpfqpd ((__mmask8)0xFF, (__v8di)(__m512i)INDEX,	     \
-			      (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfqpd ((__mmask8)0xFF, (__v8di)(__m512i) (INDEX),     \
+			      (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_prefetch_i64gather_ps(INDEX, ADDR, SCALE, HINT)		     \
-  __builtin_ia32_gatherpfqps ((__mmask8)0xFF, (__v8di)(__m512i)INDEX,	     \
-			      (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfqps ((__mmask8)0xFF, (__v8di)(__m512i) (INDEX),     \
+			      (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i64gather_pd(INDEX, MASK, ADDR, SCALE, HINT)    \
-  __builtin_ia32_gatherpfqpd ((__mmask8)MASK, (__v8di)(__m512i)INDEX,	     \
-			      (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfqpd ((__mmask8) (MASK), (__v8di)(__m512i) (INDEX),  \
+			      (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i64gather_ps(INDEX, MASK, ADDR, SCALE, HINT)    \
-  __builtin_ia32_gatherpfqps ((__mmask8)MASK, (__v8di)(__m512i)INDEX,	     \
-			      (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_gatherpfqps ((__mmask8) (MASK), (__v8di)(__m512i) (INDEX),  \
+			      (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_prefetch_i32scatter_pd(ADDR, INDEX, SCALE, HINT)              \
-  __builtin_ia32_scatterpfdpd ((__mmask8)0xFF, (__v8si)(__m256i)INDEX,       \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfdpd ((__mmask8)0xFF, (__v8si)(__m256i) (INDEX),    \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_prefetch_i32scatter_ps(ADDR, INDEX, SCALE, HINT)              \
-  __builtin_ia32_scatterpfdps ((__mmask16)0xFFFF, (__v16si)(__m512i)INDEX,   \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfdps ((__mmask16)0xFFFF, (__v16si)(__m512i) (INDEX),\
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i32scatter_pd(ADDR, MASK, INDEX, SCALE, HINT)   \
-  __builtin_ia32_scatterpfdpd ((__mmask8)MASK, (__v8si)(__m256i)INDEX,       \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfdpd ((__mmask8) (MASK), (__v8si)(__m256i) (INDEX), \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i32scatter_ps(ADDR, MASK, INDEX, SCALE, HINT)   \
-  __builtin_ia32_scatterpfdps ((__mmask16)MASK, (__v16si)(__m512i)INDEX,     \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfdps ((__mmask16) (MASK),			     \
+			       (__v16si)(__m512i) (INDEX),		     \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_prefetch_i64scatter_pd(ADDR, INDEX, SCALE, HINT)              \
-  __builtin_ia32_scatterpfqpd ((__mmask8)0xFF, (__v8di)(__m512i)INDEX,	     \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfqpd ((__mmask8)0xFF, (__v8di)(__m512i) (INDEX),    \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_prefetch_i64scatter_ps(ADDR, INDEX, SCALE, HINT)              \
-  __builtin_ia32_scatterpfqps ((__mmask8)0xFF, (__v8di)(__m512i)INDEX,	     \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfqps ((__mmask8)0xFF, (__v8di)(__m512i) (INDEX),    \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i64scatter_pd(ADDR, MASK, INDEX, SCALE, HINT)   \
-  __builtin_ia32_scatterpfqpd ((__mmask8)MASK, (__v8di)(__m512i)INDEX,	     \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfqpd ((__mmask8) (MASK), (__v8di)(__m512i) (INDEX), \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 
 #define _mm512_mask_prefetch_i64scatter_ps(ADDR, MASK, INDEX, SCALE, HINT)   \
-  __builtin_ia32_scatterpfqps ((__mmask8)MASK, (__v8di)(__m512i)INDEX,	     \
-			       (void *)ADDR, (int)SCALE, (int)HINT)
+  __builtin_ia32_scatterpfqps ((__mmask8) (MASK), (__v8di)(__m512i) (INDEX), \
+			       (void *) (ADDR), (int) (SCALE), (int) (HINT))
 #endif
 
 #ifdef __DISABLE_AVX512PF__
diff --git a/gcc/config/i386/avx512vlbwintrin.h b/gcc/config/i386/avx512vlbwintrin.h
index 2dd73ffbd93..cbba242a047 100644
--- a/gcc/config/i386/avx512vlbwintrin.h
+++ b/gcc/config/i386/avx512vlbwintrin.h
@@ -1787,7 +1787,7 @@ _mm_maskz_slli_epi16 (__mmask8 __U, __m128i __A, int __B)
 #else
 #define _mm256_mask_alignr_epi8(W, U, X, Y, N)					    \
   ((__m256i) __builtin_ia32_palignr256_mask ((__v4di)(__m256i)(X),		    \
-					    (__v4di)(__m256i)(Y), (int)(N * 8),	    \
+					    (__v4di)(__m256i)(Y), (int)((N) * 8),   \
 					    (__v4di)(__m256i)(X), (__mmask32)(U)))
 
 #define _mm256_mask_srli_epi16(W, U, A, B)                              \
@@ -1864,18 +1864,18 @@ _mm_maskz_slli_epi16 (__mmask8 __U, __m128i __A, int __B)
 
 #define _mm256_maskz_alignr_epi8(U, X, Y, N)					    \
   ((__m256i) __builtin_ia32_palignr256_mask ((__v4di)(__m256i)(X),		    \
-					    (__v4di)(__m256i)(Y), (int)(N * 8),	    \
+					    (__v4di)(__m256i)(Y), (int)((N) * 8),   \
 					    (__v4di)(__m256i)_mm256_setzero_si256 (),   \
 					    (__mmask32)(U)))
 
 #define _mm_mask_alignr_epi8(W, U, X, Y, N)					    \
   ((__m128i) __builtin_ia32_palignr128_mask ((__v2di)(__m128i)(X),		    \
-					    (__v2di)(__m128i)(Y), (int)(N * 8),	    \
+					    (__v2di)(__m128i)(Y), (int)((N) * 8),   \
 					    (__v2di)(__m128i)(X), (__mmask16)(U)))
 
 #define _mm_maskz_alignr_epi8(U, X, Y, N)					    \
   ((__m128i) __builtin_ia32_palignr128_mask ((__v2di)(__m128i)(X),		    \
-					    (__v2di)(__m128i)(Y), (int)(N * 8),	    \
+					    (__v2di)(__m128i)(Y), (int)((N) * 8),   \
 					    (__v2di)(__m128i)_mm_setzero_si128 (),  \
 					    (__mmask16)(U)))
 
@@ -2033,7 +2033,7 @@ _mm_maskz_slli_epi16 (__mmask8 __U, __m128i __A, int __B)
 #define _mm256_mask_cmp_epu8_mask(M, X, Y, P)				\
   ((__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi)(__m256i)(X),	\
 					    (__v32qi)(__m256i)(Y), (int)(P),\
-					    (__mmask32)M))
+					    (__mmask32)(M)))
 #endif
 
 extern __inline __mmask32
diff --git a/gcc/config/i386/avx512vlintrin.h b/gcc/config/i386/avx512vlintrin.h
index 3eaf817f898..c34890a8375 100644
--- a/gcc/config/i386/avx512vlintrin.h
+++ b/gcc/config/i386/avx512vlintrin.h
@@ -12972,260 +12972,276 @@ _mm256_permutex_pd (__m256d __X, const int __M)
                                           (__mmask8)(U)))
 
 #define _mm256_mmask_i32gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256) __builtin_ia32_gather3siv8sf ((__v8sf)(__m256)V1OLD,		\
-					 (void const *)ADDR,		\
-					 (__v8si)(__m256i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m256) __builtin_ia32_gather3siv8sf ((__v8sf)(__m256) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v8si)(__m256i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm_mmask_i32gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)		\
-  (__m128) __builtin_ia32_gather3siv4sf ((__v4sf)(__m128)V1OLD,		\
-					 (void const *)ADDR,		\
-					 (__v4si)(__m128i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m128) __builtin_ia32_gather3siv4sf ((__v4sf)(__m128) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v4si)(__m128i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm256_mmask_i32gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256d) __builtin_ia32_gather3siv4df ((__v4df)(__m256d)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4si)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256d) __builtin_ia32_gather3siv4df ((__v4df)(__m256d) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4si)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i32gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)		\
-  (__m128d) __builtin_ia32_gather3siv2df ((__v2df)(__m128d)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4si)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128d) __builtin_ia32_gather3siv2df ((__v2df)(__m128d) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4si)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_mmask_i64gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128) __builtin_ia32_gather3div8sf ((__v4sf)(__m128)V1OLD,		\
-					 (void const *)ADDR,		\
-					 (__v4di)(__m256i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m128) __builtin_ia32_gather3div8sf ((__v4sf)(__m128) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v4di)(__m256i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm_mmask_i64gather_ps(V1OLD, MASK, INDEX, ADDR, SCALE)		\
-  (__m128) __builtin_ia32_gather3div4sf ((__v4sf)(__m128)V1OLD,		\
-					 (void const *)ADDR,		\
-					 (__v2di)(__m128i)INDEX,	\
-					 (__mmask8)MASK, (int)SCALE)
+  (__m128) __builtin_ia32_gather3div4sf ((__v4sf)(__m128) (V1OLD),	\
+					 (void const *) (ADDR),		\
+					 (__v2di)(__m128i) (INDEX),	\
+					 (__mmask8) (MASK),		\
+					 (int) (SCALE))
 
 #define _mm256_mmask_i64gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256d) __builtin_ia32_gather3div4df ((__v4df)(__m256d)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4di)(__m256i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256d) __builtin_ia32_gather3div4df ((__v4df)(__m256d) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4di)(__m256i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i64gather_pd(V1OLD, MASK, INDEX, ADDR, SCALE)		\
-  (__m128d) __builtin_ia32_gather3div2df ((__v2df)(__m128d)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v2di)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128d) __builtin_ia32_gather3div2df ((__v2df)(__m128d) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v2di)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_mmask_i32gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256i) __builtin_ia32_gather3siv8si ((__v8si)(__m256i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v8si)(__m256i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256i) __builtin_ia32_gather3siv8si ((__v8si)(__m256i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v8si)(__m256i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i32gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128i) __builtin_ia32_gather3siv4si ((__v4si)(__m128i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4si)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128i) __builtin_ia32_gather3siv4si ((__v4si)(__m128i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4si)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_mmask_i32gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256i) __builtin_ia32_gather3siv4di ((__v4di)(__m256i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4si)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256i) __builtin_ia32_gather3siv4di ((__v4di)(__m256i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4si)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i32gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128i) __builtin_ia32_gather3siv2di ((__v2di)(__m128i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4si)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128i) __builtin_ia32_gather3siv2di ((__v2di)(__m128i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4si)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_mmask_i64gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128i) __builtin_ia32_gather3div8si ((__v4si)(__m128i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4di)(__m256i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128i) __builtin_ia32_gather3div8si ((__v4si)(__m128i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4di)(__m256i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i64gather_epi32(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128i) __builtin_ia32_gather3div4si ((__v4si)(__m128i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v2di)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128i) __builtin_ia32_gather3div4si ((__v4si)(__m128i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v2di)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_mmask_i64gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m256i) __builtin_ia32_gather3div4di ((__v4di)(__m256i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v4di)(__m256i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m256i) __builtin_ia32_gather3div4di ((__v4di)(__m256i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v4di)(__m256i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm_mmask_i64gather_epi64(V1OLD, MASK, INDEX, ADDR, SCALE)	\
-  (__m128i) __builtin_ia32_gather3div2di ((__v2di)(__m128i)V1OLD,	\
-					  (void const *)ADDR,		\
-					  (__v2di)(__m128i)INDEX,	\
-					  (__mmask8)MASK, (int)SCALE)
+  (__m128i) __builtin_ia32_gather3div2di ((__v2di)(__m128i) (V1OLD),	\
+					  (void const *) (ADDR),	\
+					  (__v2di)(__m128i) (INDEX),	\
+					  (__mmask8) (MASK),		\
+					  (int) (SCALE))
 
 #define _mm256_i32scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv8sf ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8sf)(__m256)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8sf ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8sf)(__m256) (V1), (int) (SCALE))
 
 #define _mm256_mask_i32scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv8sf ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8sf)(__m256)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8sf ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8sf)(__m256) (V1), (int) (SCALE))
 
 #define _mm_i32scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv4sf ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4sf ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm_mask_i32scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv4sf ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4sf ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm256_i32scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv4df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4df)(__m256d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4df)(__m256d) (V1), (int) (SCALE))
 
 #define _mm256_mask_i32scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv4df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4df)(__m256d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4df)(__m256d) (V1), (int) (SCALE))
 
 #define _mm_i32scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv2df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v2df)(__m128d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv2df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v2df)(__m128d) (V1), (int) (SCALE))
 
 #define _mm_mask_i32scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv2df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v2df)(__m128d)V1, (int)SCALE)
+  __builtin_ia32_scattersiv2df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v2df)(__m128d) (V1), (int) (SCALE))
 
 #define _mm256_i64scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv8sf ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8sf ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm256_mask_i64scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv8sf ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8sf ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm_i64scatter_ps(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv4sf ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4sf ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm_mask_i64scatter_ps(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv4sf ((void *)ADDR, (__mmask8)MASK,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v4sf)(__m128)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4sf ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v4sf)(__m128) (V1), (int) (SCALE))
 
 #define _mm256_i64scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv4df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4df)(__m256d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4df)(__m256d) (V1), (int) (SCALE))
 
 #define _mm256_mask_i64scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv4df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4df)(__m256d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4df)(__m256d) (V1), (int) (SCALE))
 
 #define _mm_i64scatter_pd(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv2df ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v2df)(__m128d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv2df ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v2df)(__m128d) (V1), (int) (SCALE))
 
 #define _mm_mask_i64scatter_pd(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv2df ((void *)ADDR, (__mmask8)MASK,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v2df)(__m128d)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv2df ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v2df)(__m128d) (V1), (int) (SCALE))
 
 #define _mm256_i32scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv8si ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8si)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8si ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8si)(__m256i) (V1), (int) (SCALE))
 
 #define _mm256_mask_i32scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scattersiv8si ((void *)ADDR, (__mmask8)MASK,		\
-				(__v8si)(__m256i)INDEX,			\
-				(__v8si)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv8si ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v8si)(__m256i) (INDEX),		\
+				(__v8si)(__m256i) (V1), (int) (SCALE))
 
 #define _mm_i32scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv4si ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4si ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm_mask_i32scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv4si ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4si ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm256_i32scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv4di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4di)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4di)(__m256i) (V1), (int) (SCALE))
 
 #define _mm256_mask_i32scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scattersiv4di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v4di)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv4di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v4di)(__m256i) (V1), (int) (SCALE))
 
 #define _mm_i32scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scattersiv2di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v2di)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv2di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v2di)(__m128i) (V1), (int) (SCALE))
 
 #define _mm_mask_i32scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scattersiv2di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4si)(__m128i)INDEX,			\
-				(__v2di)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scattersiv2di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4si)(__m128i) (INDEX),		\
+				(__v2di)(__m128i) (V1), (int) (SCALE))
 
 #define _mm256_i64scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv8si ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8si ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm256_mask_i64scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scatterdiv8si ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv8si ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm_i64scatter_epi32(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv4si ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4si ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm_mask_i64scatter_epi32(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv4si ((void *)ADDR, (__mmask8)MASK,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v4si)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4si ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v4si)(__m128i) (V1), (int) (SCALE))
 
 #define _mm256_i64scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv4di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4di)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4di)(__m256i) (V1), (int) (SCALE))
 
 #define _mm256_mask_i64scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)	\
-  __builtin_ia32_scatterdiv4di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v4di)(__m256i)INDEX,			\
-				(__v4di)(__m256i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv4di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v4di)(__m256i) (INDEX),		\
+				(__v4di)(__m256i) (V1), (int) (SCALE))
 
 #define _mm_i64scatter_epi64(ADDR, INDEX, V1, SCALE)			\
-  __builtin_ia32_scatterdiv2di ((void *)ADDR, (__mmask8)0xFF,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v2di)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv2di ((void *) (ADDR), (__mmask8)0xFF,	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v2di)(__m128i) (V1), (int) (SCALE))
 
 #define _mm_mask_i64scatter_epi64(ADDR, MASK, INDEX, V1, SCALE)		\
-  __builtin_ia32_scatterdiv2di ((void *)ADDR, (__mmask8)MASK,		\
-				(__v2di)(__m128i)INDEX,			\
-				(__v2di)(__m128i)V1, (int)SCALE)
+  __builtin_ia32_scatterdiv2di ((void *) (ADDR), (__mmask8) (MASK),	\
+				(__v2di)(__m128i) (INDEX),		\
+				(__v2di)(__m128i) (V1), (int) (SCALE))
 
 #define _mm256_mask_shuffle_epi32(W, U, X, C)                                       \
   ((__m256i)  __builtin_ia32_pshufd256_mask ((__v8si)(__m256i)(X), (int)(C),        \
@@ -13422,19 +13438,19 @@ _mm256_permutex_pd (__m256d __X, const int __M)
         (__mmask8)(U)))
 
 #define _mm_mask_cvtps_ph(W, U, A, I)						\
-  ((__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf)(__m128) A, (int) (I),      \
+  ((__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf)(__m128) (A), (int) (I),	\
       (__v8hi)(__m128i) (W), (__mmask8) (U)))
 
 #define _mm_maskz_cvtps_ph(U, A, I)						\
-  ((__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf)(__m128) A, (int) (I),      \
+  ((__m128i) __builtin_ia32_vcvtps2ph_mask ((__v4sf)(__m128) (A), (int) (I),	\
       (__v8hi)(__m128i) _mm_setzero_si128 (), (__mmask8) (U)))
 
 #define _mm256_mask_cvtps_ph(W, U, A, I)					\
-  ((__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf)(__m256) A, (int) (I),	\
+  ((__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf)(__m256) (A), (int) (I),	\
       (__v8hi)(__m128i) (W), (__mmask8) (U)))
 
 #define _mm256_maskz_cvtps_ph(U, A, I)						\
-  ((__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf)(__m256) A, (int) (I),   \
+  ((__m128i) __builtin_ia32_vcvtps2ph256_mask ((__v8sf)(__m256) (A), (int) (I),	\
       (__v8hi)(__m128i) _mm_setzero_si128 (), (__mmask8) (U)))
 
 #define _mm256_mask_srai_epi32(W, U, A, B)				\
diff --git a/gcc/config/i386/cpuid.h b/gcc/config/i386/cpuid.h
index 2775e705c70..e4199422aae 100644
--- a/gcc/config/i386/cpuid.h
+++ b/gcc/config/i386/cpuid.h
@@ -188,28 +188,28 @@
 /* At least one cpu (Winchip 2) does not set %ebx and %ecx
    for cpuid leaf 1. Forcibly zero the two registers before
    calling cpuid as a precaution.  */
-#define __cpuid(level, a, b, c, d)			\
-  do {							\
-    if (__builtin_constant_p (level) && (level) != 1)	\
-      __asm__ ("cpuid\n\t"				\
-	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
-	      : "0" (level));				\
-    else						\
-      __asm__ ("cpuid\n\t"				\
-	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
-	      : "0" (level), "1" (0), "2" (0));		\
+#define __cpuid(level, a, b, c, d)					\
+  do {									\
+    if (__builtin_constant_p (level) && (level) != 1)			\
+      __asm__ __volatile__ ("cpuid\n\t"					\
+			    : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+			    : "0" (level));				\
+    else								\
+      __asm__ __volatile__ ("cpuid\n\t"					\
+			    : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+			    : "0" (level), "1" (0), "2" (0));		\
   } while (0)
 #else
-#define __cpuid(level, a, b, c, d)			\
-  __asm__ ("cpuid\n\t"					\
-	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
-	   : "0" (level))
+#define __cpuid(level, a, b, c, d)					\
+  __asm__ __volatile__ ("cpuid\n\t"					\
+			: "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+			: "0" (level))
 #endif
 
-#define __cpuid_count(level, count, a, b, c, d)		\
-  __asm__ ("cpuid\n\t"					\
-	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
-	   : "0" (level), "2" (count))
+#define __cpuid_count(level, count, a, b, c, d)				\
+  __asm__ __volatile__ ("cpuid\n\t"					\
+			: "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+			: "0" (level), "2" (count))
 
 
 /* Return highest supported input value for cpuid instruction.  ext can
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
index bdb36f00959..c099a6238d8 100644
--- a/gcc/config/i386/darwin.h
+++ b/gcc/config/i386/darwin.h
@@ -239,6 +239,16 @@ along with GCC; see the file COPYING3.  If not see
 #undef TARGET_ASM_OUTPUT_IDENT
 #define TARGET_ASM_OUTPUT_IDENT default_asm_output_ident_directive
 
+/* We always want jump tables in the text section:
+   * for PIC code, we need the subtracted symbol to be defined at
+     assembly-time.
+   * for mdynamic-no-pic, we cannot support jump tables in the .const
+     section for weak functions, this looks to ld64 like direct access
+     to the weak symbol from an anonymous atom.  */
+
+#undef JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
 /* Darwin profiling -- call mcount.  */
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO)				\
diff --git a/gcc/config/i386/driver-i386.c b/gcc/config/i386/driver-i386.c
index 75f70269517..db8b4fa8aab 100644
--- a/gcc/config/i386/driver-i386.c
+++ b/gcc/config/i386/driver-i386.c
@@ -420,6 +420,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)
   unsigned int has_avx5124fmaps = 0, has_avx5124vnniw = 0;
   unsigned int has_gfni = 0, has_avx512vbmi2 = 0;
   unsigned int has_avx512bitalg = 0;
+  unsigned int has_avx512vpopcntdq = 0;
   unsigned int has_shstk = 0;
   unsigned int has_avx512vnni = 0, has_vaes = 0;
   unsigned int has_vpclmulqdq = 0;
@@ -523,6 +524,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)
       has_vaes = ecx & bit_VAES;
       has_vpclmulqdq = ecx & bit_VPCLMULQDQ;
       has_avx512bitalg = ecx & bit_AVX512BITALG;
+      has_avx512vpopcntdq = ecx & bit_AVX512VPOPCNTDQ;
       has_movdiri = ecx & bit_MOVDIRI;
       has_movdir64b = ecx & bit_MOVDIR64B;
       has_cldemote = ecx & bit_CLDEMOTE;
@@ -765,9 +767,12 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	case 0x37:
 	case 0x4a:
 	case 0x4d:
-	case 0x5a:
 	case 0x5d:
 	  /* Silvermont.  */
+	case 0x4c:
+	case 0x5a:
+	case 0x75:
+	  /* Airmont.  */
 	  cpu = "silvermont";
 	  break;
 	case 0x5c:
@@ -779,6 +784,12 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	  /* Goldmont Plus.  */
 	  cpu = "goldmont-plus";
 	  break;
+	case 0x86:
+	case 0x96:
+	case 0x9c:
+	  /* Tremont.  */
+	  cpu = "tremont";
+	  break;
 	case 0x0f:
 	  /* Merom.  */
 	case 0x17:
@@ -829,6 +840,9 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	case 0x8e:
 	case 0x9e:
 	  /* Kaby Lake.  */
+	case 0xa5:
+	case 0xa6:
+	  /* Comet Lake.  */
 	  cpu = "skylake";
 	  break;
 	case 0x55:
@@ -839,6 +853,22 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	    /* Skylake with AVX-512.  */
 	    cpu = "skylake-avx512";
 	  break;
+	case 0x6a:
+	case 0x6c:
+	  /* Ice Lake server.  */
+	  cpu = "icelake-server";
+	  break;
+	case 0x7e:
+	case 0x7d:
+	case 0x9d:
+	  /* Ice Lake client.  */
+	  cpu = "icelake-client";
+	  break;
+	case 0x8c:
+	case 0x8d:
+	  /* Tiger Lake.  */
+	  cpu = "tigerlake";
+	  break;
 	case 0x57:
 	  /* Knights Landing.  */
 	  cpu = "knl";
@@ -1138,6 +1168,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)
       const char *vaes = has_vaes ? " -mvaes" : " -mno-vaes";
       const char *vpclmulqdq = has_vpclmulqdq ? " -mvpclmulqdq" : " -mno-vpclmulqdq";
       const char *avx512bitalg = has_avx512bitalg ? " -mavx512bitalg" : " -mno-avx512bitalg";
+      const char *avx512vpopcntdq = has_avx512vpopcntdq ? " -mavx512vpopcntdq" : " -mno-avx512vpopcntdq";
       const char *movdiri = has_movdiri ? " -mmovdiri" : " -mno-movdiri";
       const char *movdir64b = has_movdir64b ? " -mmovdir64b" : " -mno-movdir64b";
       const char *waitpkg = has_waitpkg ? " -mwaitpkg" : " -mno-waitpkg";
@@ -1156,9 +1187,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 			avx512ifma, avx512vbmi, avx5124fmaps, avx5124vnniw,
 			clwb, mwaitx, clzero, pku, rdpid, gfni, shstk,
 			avx512vbmi2, avx512vnni, vaes, vpclmulqdq,
-			avx512bitalg, movdiri, movdir64b, waitpkg, cldemote,
-			ptwrite,
-			NULL);
+			avx512bitalg, avx512vpopcntdq, movdiri, movdir64b,
+			waitpkg, cldemote, ptwrite, NULL);
     }
 
 done:
diff --git a/gcc/config/i386/f16cintrin.h b/gcc/config/i386/f16cintrin.h
index 57c0da1fab7..257b3a27d9b 100644
--- a/gcc/config/i386/f16cintrin.h
+++ b/gcc/config/i386/f16cintrin.h
@@ -84,10 +84,10 @@ _mm256_cvtps_ph (__m256 __A, const int __I)
     }))
 
 #define _mm_cvtps_ph(A, I) \
-  ((__m128i) __builtin_ia32_vcvtps2ph ((__v4sf)(__m128) A, (int) (I)))
+  ((__m128i) __builtin_ia32_vcvtps2ph ((__v4sf)(__m128) (A), (int) (I)))
 
 #define _mm256_cvtps_ph(A, I) \
-  ((__m128i) __builtin_ia32_vcvtps2ph256 ((__v8sf)(__m256) A, (int) (I)))
+  ((__m128i) __builtin_ia32_vcvtps2ph256 ((__v8sf)(__m256) (A), (int) (I)))
 #endif /* __OPTIMIZE */
 
 #ifdef __DISABLE_F16C__
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index 5dedeb2d18b..2f57d19bea2 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -799,7 +799,7 @@ BDESC (OPTION_MASK_ISA_SSE2, 0, CODE_FOR_sse2_pshufhw, "__builtin_ia32_pshufhw",
 
 BDESC (OPTION_MASK_ISA_SSE2, 0, CODE_FOR_sse2_vmsqrtv2df2, "__builtin_ia32_sqrtsd", IX86_BUILTIN_SQRTSD, UNKNOWN, (int) V2DF_FTYPE_V2DF_VEC_MERGE)
 
-BDESC (OPTION_MASK_ISA_SSE, 0, CODE_FOR_sse2_movq128, "__builtin_ia32_movq128", IX86_BUILTIN_MOVQ128, UNKNOWN, (int) V2DI_FTYPE_V2DI)
+BDESC (OPTION_MASK_ISA_SSE2, 0, CODE_FOR_sse2_movq128, "__builtin_ia32_movq128", IX86_BUILTIN_MOVQ128, UNKNOWN, (int) V2DI_FTYPE_V2DI)
 
 /* SSE2 MMX */
 BDESC (OPTION_MASK_ISA_SSE2 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_mmx_addv1di3, "__builtin_ia32_paddq", IX86_BUILTIN_PADDQ, UNKNOWN, (int) V1DI_FTYPE_V1DI_V1DI)
diff --git a/gcc/config/i386/i386-c.c b/gcc/config/i386/i386-c.c
index 5e7e46fcebe..f06fea1a8a5 100644
--- a/gcc/config/i386/i386-c.c
+++ b/gcc/config/i386/i386-c.c
@@ -675,6 +675,8 @@ ix86_target_macros (void)
       cpp_assert (parse_in, "cpu=i386");
       cpp_assert (parse_in, "machine=i386");
       builtin_define_std ("i386");
+      cpp_define (parse_in, "_ILP32");
+      cpp_define (parse_in, "__ILP32__");
     }
 
   if (!TARGET_80387)
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 1bca5a7eea6..592455ef6d4 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -2535,7 +2535,12 @@ rest_of_insert_endbranch (void)
       && (!flag_manual_endbr
 	  || lookup_attribute ("cf_check",
 			       DECL_ATTRIBUTES (cfun->decl)))
-      && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
+      && (!cgraph_node::get (cfun->decl)->only_called_directly_p ()
+	  || ix86_cmodel == CM_LARGE
+	  || ix86_cmodel == CM_LARGE_PIC
+	  || flag_force_indirect_call
+	  || (TARGET_DLLIMPORT_DECL_ATTRIBUTES
+	      && DECL_DLLIMPORT_P (cfun->decl))))
     {
       /* Queue ENDBR insertion to x86_function_profiler.  */
       if (crtl->profile && flag_fentry)
@@ -4053,6 +4058,15 @@ ix86_option_override_internal (bool main_args_p,
 	if (((processor_alias_table[i].flags & PTA_PTWRITE) != 0)
 	    && !(opts->x_ix86_isa_flags2_explicit & OPTION_MASK_ISA_PTWRITE))
 	  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_PTWRITE;
+	if (((processor_alias_table[i].flags & PTA_MOVDIRI) != 0)
+	    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_MOVDIRI))
+	  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_MOVDIRI;
+	if (((processor_alias_table[i].flags & PTA_MOVDIR64B) != 0)
+	    && !(opts->x_ix86_isa_flags2_explicit & OPTION_MASK_ISA_MOVDIR64B))
+	  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_MOVDIR64B;
+	if (((processor_alias_table[i].flags & PTA_CLDEMOTE) != 0)
+	    && !(opts->x_ix86_isa_flags2_explicit & OPTION_MASK_ISA_CLDEMOTE))
+	  opts->x_ix86_isa_flags2 |= OPTION_MASK_ISA_CLDEMOTE;
 
 	if ((processor_alias_table[i].flags
 	   & (PTA_PREFETCH_SSE | PTA_SSE)) != 0)
@@ -5802,6 +5816,8 @@ ix86_set_indirect_branch_type (tree fndecl)
 		? "thunk-extern" : "thunk"));
 
       if (cfun->machine->indirect_branch_type != indirect_branch_keep
+	  && (cfun->machine->indirect_branch_type
+	      != indirect_branch_thunk_extern)
 	  && (flag_cf_protection & CF_RETURN))
 	error ("%<-mindirect-branch%> and %<-fcf-protection%> are not "
 	       "compatible");
@@ -5845,6 +5861,8 @@ ix86_set_indirect_branch_type (tree fndecl)
 		? "thunk-extern" : "thunk"));
 
       if (cfun->machine->function_return_type != indirect_branch_keep
+	  && (cfun->machine->function_return_type
+	      != indirect_branch_thunk_extern)
 	  && (flag_cf_protection & CF_RETURN))
 	error ("%<-mfunction-return%> and %<-fcf-protection%> are not "
 	       "compatible");
@@ -11474,11 +11492,6 @@ ix86_compute_frame_layout (void)
   offset += frame->nregs * UNITS_PER_WORD;
   frame->reg_save_offset = offset;
 
-  /* On SEH target, registers are pushed just before the frame pointer
-     location.  */
-  if (TARGET_SEH)
-    frame->hard_frame_pointer_offset = offset;
-
   /* Calculate the size of the va-arg area (not including padding, if any).  */
   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;
 
@@ -11641,14 +11654,22 @@ ix86_compute_frame_layout (void)
      the unwind data structure.  */
   if (TARGET_SEH)
     {
-      HOST_WIDE_INT diff;
+      /* Force the frame pointer to point at or below the lowest register save
+	 area, see the SEH code in config/i386/winnt.c for the rationale.  */
+      frame->hard_frame_pointer_offset = frame->sse_reg_save_offset;
 
-      /* If we can leave the frame pointer where it is, do so.  Also, returns
-	 the establisher frame for __builtin_frame_address (0).  */
-      diff = frame->stack_pointer_offset - frame->hard_frame_pointer_offset;
-      if (diff <= SEH_MAX_FRAME_SIZE
-	  && (diff > 240 || (diff & 15) != 0)
-	  && !crtl->accesses_prior_frames)
+      /* If we can leave the frame pointer where it is, do so.  Also, return
+	 the establisher frame for __builtin_frame_address (0) or else if the
+	 frame overflows the SEH maximum frame size.  */
+      const HOST_WIDE_INT diff
+	= frame->stack_pointer_offset - frame->hard_frame_pointer_offset;
+      if (diff <= 255)
+	{
+	  /* The resulting diff will be a multiple of 16 lower than 255,
+	     i.e. at most 240 as required by the unwind data structure.  */
+	  frame->hard_frame_pointer_offset += (diff & 15);
+	}
+      else if (diff <= SEH_MAX_FRAME_SIZE && !crtl->accesses_prior_frames)
 	{
 	  /* Ideally we'd determine what portion of the local stack frame
 	     (within the constraint of the lowest 240) is most heavily used.
@@ -11657,6 +11678,8 @@ ix86_compute_frame_layout (void)
 	     frame that is addressable with 8-bit offsets.  */
 	  frame->hard_frame_pointer_offset = frame->stack_pointer_offset - 128;
 	}
+      else
+	frame->hard_frame_pointer_offset = frame->hfp_save_offset;
     }
 }
 
@@ -12274,10 +12297,12 @@ ix86_update_stack_boundary (void)
 static rtx
 ix86_get_drap_rtx (void)
 {
-  /* We must use DRAP if there are outgoing arguments on stack and
+  /* We must use DRAP if there are outgoing arguments on stack or
+     the stack pointer register is clobbered by asm statment and
      ACCUMULATE_OUTGOING_ARGS is false.  */
   if (ix86_force_drap
-      || (cfun->machine->outgoing_args_on_stack
+      || ((cfun->machine->outgoing_args_on_stack
+	   || crtl->sp_is_clobbered_by_asm)
 	  && !ACCUMULATE_OUTGOING_ARGS))
     crtl->need_drap = true;
 
@@ -13459,17 +13484,6 @@ ix86_expand_prologue (void)
       insn = emit_insn (gen_push (hard_frame_pointer_rtx));
       RTX_FRAME_RELATED_P (insn) = 1;
 
-      /* Push registers now, before setting the frame pointer
-	 on SEH target.  */
-      if (!int_registers_saved
-	  && TARGET_SEH
-	  && !frame.save_regs_using_mov)
-	{
-	  ix86_emit_save_regs ();
-	  int_registers_saved = true;
-	  gcc_assert (m->fs.sp_offset == frame.reg_save_offset);
-	}
-
       if (m->fs.sp_offset == frame.hard_frame_pointer_offset)
 	{
 	  insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
@@ -14347,8 +14361,13 @@ ix86_expand_epilogue (int style)
 	      t = plus_constant (Pmode, t, m->fs.fp_offset - UNITS_PER_WORD);
 	      emit_insn (gen_rtx_SET (sa, t));
 
-	      t = gen_frame_mem (Pmode, hard_frame_pointer_rtx);
-	      insn = emit_move_insn (hard_frame_pointer_rtx, t);
+	      /* NB: eh_return epilogues must restore the frame pointer
+		 in word_mode since the upper 32 bits of RBP register
+		 can have any values.  */
+	      t = gen_frame_mem (word_mode, hard_frame_pointer_rtx);
+	      rtx frame_reg = gen_rtx_REG (word_mode,
+					   HARD_FRAME_POINTER_REGNUM);
+	      insn = emit_move_insn (frame_reg, t);
 
 	      /* Note that we use SA as a temporary CFA, as the return
 		 address is at the proper place relative to it.  We
@@ -14363,7 +14382,7 @@ ix86_expand_epilogue (int style)
 	      add_reg_note (insn, REG_CFA_DEF_CFA,
 			    plus_constant (Pmode, sa, UNITS_PER_WORD));
 	      ix86_add_queued_cfa_restore_notes (insn);
-	      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);
+	      add_reg_note (insn, REG_CFA_RESTORE, frame_reg);
 	      RTX_FRAME_RELATED_P (insn) = 1;
 
 	      m->fs.cfa_reg = sa;
@@ -44150,43 +44169,51 @@ emit_reduc_half (rtx dest, rtx src, int i)
       break;
     case E_V64QImode:
     case E_V32HImode:
+      if (i < 64)
+	{
+	  d = gen_reg_rtx (V4TImode);
+	  tem = gen_avx512bw_lshrv4ti3 (d, gen_lowpart (V4TImode, src),
+					GEN_INT (i / 2));
+	  break;
+	}
+      /* FALLTHRU */
     case E_V16SImode:
     case E_V16SFmode:
     case E_V8DImode:
     case E_V8DFmode:
       if (i > 128)
 	tem = gen_avx512f_shuf_i32x4_1 (gen_lowpart (V16SImode, dest),
-				      gen_lowpart (V16SImode, src),
-				      gen_lowpart (V16SImode, src),
-				      GEN_INT (0x4 + (i == 512 ? 4 : 0)),
-				      GEN_INT (0x5 + (i == 512 ? 4 : 0)),
-				      GEN_INT (0x6 + (i == 512 ? 4 : 0)),
-				      GEN_INT (0x7 + (i == 512 ? 4 : 0)),
-				      GEN_INT (0xC), GEN_INT (0xD),
-				      GEN_INT (0xE), GEN_INT (0xF),
-				      GEN_INT (0x10), GEN_INT (0x11),
-				      GEN_INT (0x12), GEN_INT (0x13),
-				      GEN_INT (0x14), GEN_INT (0x15),
-				      GEN_INT (0x16), GEN_INT (0x17));
+					gen_lowpart (V16SImode, src),
+					gen_lowpart (V16SImode, src),
+					GEN_INT (0x4 + (i == 512 ? 4 : 0)),
+					GEN_INT (0x5 + (i == 512 ? 4 : 0)),
+					GEN_INT (0x6 + (i == 512 ? 4 : 0)),
+					GEN_INT (0x7 + (i == 512 ? 4 : 0)),
+					GEN_INT (0xC), GEN_INT (0xD),
+					GEN_INT (0xE), GEN_INT (0xF),
+					GEN_INT (0x10), GEN_INT (0x11),
+					GEN_INT (0x12), GEN_INT (0x13),
+					GEN_INT (0x14), GEN_INT (0x15),
+					GEN_INT (0x16), GEN_INT (0x17));
       else
 	tem = gen_avx512f_pshufd_1 (gen_lowpart (V16SImode, dest),
-				   gen_lowpart (V16SImode, src),
-				   GEN_INT (i == 128 ? 0x2 : 0x1),
-				   GEN_INT (0x3),
-				   GEN_INT (0x3),
-				   GEN_INT (0x3),
-				   GEN_INT (i == 128 ? 0x6 : 0x5),
-				   GEN_INT (0x7),
-				   GEN_INT (0x7),
-				   GEN_INT (0x7),
-				   GEN_INT (i == 128 ? 0xA : 0x9),
-				   GEN_INT (0xB),
-				   GEN_INT (0xB),
-				   GEN_INT (0xB),
-				   GEN_INT (i == 128 ? 0xE : 0xD),
-				   GEN_INT (0xF),
-				   GEN_INT (0xF),
-				   GEN_INT (0xF));
+				    gen_lowpart (V16SImode, src),
+				    GEN_INT (i == 128 ? 0x2 : 0x1),
+				    GEN_INT (0x3),
+				    GEN_INT (0x3),
+				    GEN_INT (0x3),
+				    GEN_INT (i == 128 ? 0x6 : 0x5),
+				    GEN_INT (0x7),
+				    GEN_INT (0x7),
+				    GEN_INT (0x7),
+				    GEN_INT (i == 128 ? 0xA : 0x9),
+				    GEN_INT (0xB),
+				    GEN_INT (0xB),
+				    GEN_INT (0xB),
+				    GEN_INT (i == 128 ? 0xE : 0xD),
+				    GEN_INT (0xF),
+				    GEN_INT (0xF),
+				    GEN_INT (0xF));
       break;
     default:
       gcc_unreachable ();
@@ -44391,40 +44418,18 @@ ix86_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &/*inputs*/,
 	  continue;
 	}
 
-      if (dest_mode == DImode && !TARGET_64BIT)
-	dest_mode = SImode;
-
-      if (dest_mode != QImode)
-	{
-	  rtx destqi = gen_reg_rtx (QImode);
-	  emit_insn (gen_rtx_SET (destqi, x));
-
-	  if (TARGET_ZERO_EXTEND_WITH_AND
-	      && optimize_function_for_speed_p (cfun))
-	    {
-	      x = force_reg (dest_mode, const0_rtx);
-
-	      emit_insn (gen_movstrictqi (gen_lowpart (QImode, x), destqi));
-	    }
-	  else
-	    {
-	      x = gen_rtx_ZERO_EXTEND (dest_mode, destqi);
-	      if (dest_mode == GET_MODE (dest)
-		  && !register_operand (dest, GET_MODE (dest)))
-		x = force_reg (dest_mode, x);
-	    }
-	}
-
-      if (dest_mode != GET_MODE (dest))
+      if (dest_mode == QImode)
+	emit_insn (gen_rtx_SET (dest, x));
+      else
 	{
-	  rtx tmp = gen_reg_rtx (SImode);
+	  rtx reg = gen_reg_rtx (QImode);
+	  emit_insn (gen_rtx_SET (reg, x));
 
-	  emit_insn (gen_rtx_SET (tmp, x));
-	  emit_insn (gen_zero_extendsidi2 (dest, tmp));
+	  reg = convert_to_mode (dest_mode, reg, 1);
+	  emit_move_insn (dest, reg);
 	}
-      else
-	emit_insn (gen_rtx_SET (dest, x));
     }
+
   rtx_insn *seq = get_insns ();
   end_sequence ();
 
@@ -45457,7 +45462,7 @@ ix86_expand_rint (rtx operand0, rtx operand1)
         return copysign (xa, operand1);
    */
   machine_mode mode = GET_MODE (operand0);
-  rtx res, xa, TWO52, two52, mask;
+  rtx res, xa, TWO52, mask;
   rtx_code_label *label;
 
   res = gen_reg_rtx (mode);
@@ -45470,16 +45475,18 @@ ix86_expand_rint (rtx operand0, rtx operand1)
   TWO52 = ix86_gen_TWO52 (mode);
   label = ix86_expand_sse_compare_and_jump (UNLE, TWO52, xa, false);
 
-  two52 = TWO52;
   if (flag_rounding_math)
     {
-      two52 = gen_reg_rtx (mode);
-      ix86_sse_copysign_to_positive (two52, TWO52, res, mask);
+      ix86_sse_copysign_to_positive (TWO52, TWO52, res, mask);
       xa = res;
     }
 
-  xa = expand_simple_binop (mode, PLUS, xa, two52, NULL_RTX, 0, OPTAB_DIRECT);
-  xa = expand_simple_binop (mode, MINUS, xa, two52, xa, 0, OPTAB_DIRECT);
+  xa = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);
+  xa = expand_simple_binop (mode, MINUS, xa, TWO52, xa, 0, OPTAB_DIRECT);
+
+  /* Remove the sign with FE_DOWNWARD, where x - x = -0.0.  */
+  if (HONOR_SIGNED_ZEROS (mode) && flag_rounding_math)
+    xa = ix86_expand_sse_fabs (xa, NULL);
 
   ix86_sse_copysign_to_positive (res, xa, res, mask);
 
@@ -45500,12 +45507,14 @@ ix86_expand_floorceildf_32 (rtx operand0, rtx operand1, bool do_floor)
           return x;
         xa = xa + TWO52 - TWO52;
         x2 = copysign (xa, x);
+
      Compensate.  Floor:
         if (x2 > x)
           x2 -= 1;
      Compensate.  Ceil:
         if (x2 < x)
           x2 += 1;
+
 	if (HONOR_SIGNED_ZEROS (mode))
 	  x2 = copysign (x2, x);
 	return x2;
@@ -45542,8 +45551,14 @@ ix86_expand_floorceildf_32 (rtx operand0, rtx operand1, bool do_floor)
   emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
   tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,
 			     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);
-  if (!do_floor && HONOR_SIGNED_ZEROS (mode))
-    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
+  if (HONOR_SIGNED_ZEROS (mode))
+    {
+      /* Remove the sign with FE_DOWNWARD, where x - x = -0.0.  */
+      if (do_floor && flag_rounding_math)
+	tmp = ix86_expand_sse_fabs (tmp, NULL);
+
+      ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
+    }
   emit_move_insn (res, tmp);
 
   emit_label (label);
@@ -45562,12 +45577,14 @@ ix86_expand_floorceil (rtx operand0, rtx operand1, bool do_floor)
         if (!isless (xa, TWO52))
           return x;
 	x2 = (double)(long)x;
+
      Compensate.  Floor:
 	if (x2 > x)
 	  x2 -= 1;
      Compensate.  Ceil:
 	if (x2 < x)
 	  x2 += 1;
+
 	if (HONOR_SIGNED_ZEROS (mode))
 	  return copysign (x2, x);
 	return x2;
@@ -45602,10 +45619,15 @@ ix86_expand_floorceil (rtx operand0, rtx operand1, bool do_floor)
   emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
   tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,
 			     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);
-  emit_move_insn (res, tmp);
-
   if (HONOR_SIGNED_ZEROS (mode))
-    ix86_sse_copysign_to_positive (res, res, force_reg (mode, operand1), mask);
+    {
+      /* Remove the sign with FE_DOWNWARD, where x - x = -0.0.  */
+      if (do_floor && flag_rounding_math)
+	tmp = ix86_expand_sse_fabs (tmp, NULL);
+
+      ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
+    }
+  emit_move_insn (res, tmp);
 
   emit_label (label);
   LABEL_NUSES (label) = 1;
@@ -45736,7 +45758,7 @@ void
 ix86_expand_truncdf_32 (rtx operand0, rtx operand1)
 {
   machine_mode mode = GET_MODE (operand0);
-  rtx xa, mask, TWO52, one, res, smask, tmp;
+  rtx xa, xa2, TWO52, tmp, one, res, mask;
   rtx_code_label *label;
 
   /* C code for SSE variant we expand below.
@@ -45759,28 +45781,29 @@ ix86_expand_truncdf_32 (rtx operand0, rtx operand1)
   emit_move_insn (res, operand1);
 
   /* xa = abs (operand1) */
-  xa = ix86_expand_sse_fabs (res, &smask);
+  xa = ix86_expand_sse_fabs (res, &mask);
 
   /* if (!isless (xa, TWO52)) goto label; */
   label = ix86_expand_sse_compare_and_jump (UNLE, TWO52, xa, false);
 
-  /* res = xa + TWO52 - TWO52; */
-  tmp = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);
-  tmp = expand_simple_binop (mode, MINUS, tmp, TWO52, tmp, 0, OPTAB_DIRECT);
-  emit_move_insn (res, tmp);
+  /* xa2 = xa + TWO52 - TWO52; */
+  xa2 = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);
+  xa2 = expand_simple_binop (mode, MINUS, xa2, TWO52, xa2, 0, OPTAB_DIRECT);
 
   /* generate 1.0 */
   one = force_reg (mode, const_double_from_real_value (dconst1, mode));
 
-  /* Compensate: res = xa2 - (res > xa ? 1 : 0)  */
-  mask = ix86_expand_sse_compare_mask (UNGT, res, xa, false);
-  emit_insn (gen_rtx_SET (mask, gen_rtx_AND (mode, mask, one)));
+  /* Compensate: xa2 = xa2 - (xa2 > xa ? 1 : 0)  */
+  tmp = ix86_expand_sse_compare_mask (UNGT, xa2, xa, false);
+  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
   tmp = expand_simple_binop (mode, MINUS,
-			     res, mask, NULL_RTX, 0, OPTAB_DIRECT);
-  emit_move_insn (res, tmp);
+			     xa2, tmp, NULL_RTX, 0, OPTAB_DIRECT);
+  /* Remove the sign with FE_DOWNWARD, where x - x = -0.0.  */
+  if (HONOR_SIGNED_ZEROS (mode) && flag_rounding_math)
+    tmp = ix86_expand_sse_fabs (tmp, NULL);
 
-  /* res = copysign (res, operand1) */
-  ix86_sse_copysign_to_positive (res, res, force_reg (mode, operand1), smask);
+  /* res = copysign (xa2, operand1) */
+  ix86_sse_copysign_to_positive (res, tmp, res, mask);
 
   emit_label (label);
   LABEL_NUSES (label) = 1;
@@ -46667,7 +46690,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)
 	      /* vpshufb only works intra lanes, it is not
 		 possible to shuffle bytes in between the lanes.  */
 	      for (i = 0; i < nelt; ++i)
-		if ((d->perm[i] ^ i) & (nelt / 4))
+		if ((d->perm[i] ^ i) & (3 * nelt / 4))
 		  return false;
 	    }
 	}
@@ -50265,7 +50288,9 @@ ix86_get_mask_mode (poly_uint64 nunits, poly_uint64 vector_size)
   if ((TARGET_AVX512F && vector_size == 64)
       || (TARGET_AVX512VL && (vector_size == 32 || vector_size == 16)))
     {
-      if (elem_size == 4 || elem_size == 8 || TARGET_AVX512BW)
+      if (elem_size == 4
+	  || elem_size == 8
+	  || (TARGET_AVX512BW && (elem_size == 1 || elem_size == 2)))
 	return smallest_int_mode_for_size (nunits);
     }
 
@@ -50919,11 +50944,12 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
       *clear = build_call_expr (fnclex, 0);
       tree sw_var = create_tmp_var_raw (short_unsigned_type_node);
       tree fnstsw_call = build_call_expr (fnstsw, 0);
-      tree sw_mod = build2 (MODIFY_EXPR, short_unsigned_type_node,
-			    sw_var, fnstsw_call);
+      tree sw_mod = build4 (TARGET_EXPR, short_unsigned_type_node, sw_var,
+			    fnstsw_call, NULL_TREE, NULL_TREE);
       tree exceptions_x87 = fold_convert (integer_type_node, sw_var);
-      tree update_mod = build2 (MODIFY_EXPR, integer_type_node,
-				exceptions_var, exceptions_x87);
+      tree update_mod = build4 (TARGET_EXPR, integer_type_node,
+				exceptions_var, exceptions_x87,
+				NULL_TREE, NULL_TREE);
       *update = build2 (COMPOUND_EXPR, integer_type_node,
 			sw_mod, update_mod);
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
@@ -50936,15 +50962,17 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
       tree stmxcsr = ix86_builtins[IX86_BUILTIN_STMXCSR];
       tree ldmxcsr = ix86_builtins[IX86_BUILTIN_LDMXCSR];
       tree stmxcsr_hold_call = build_call_expr (stmxcsr, 0);
-      tree hold_assign_orig = build2 (MODIFY_EXPR, unsigned_type_node,
-				      mxcsr_orig_var, stmxcsr_hold_call);
+      tree hold_assign_orig = build4 (TARGET_EXPR, unsigned_type_node,
+				      mxcsr_orig_var, stmxcsr_hold_call,
+				      NULL_TREE, NULL_TREE);
       tree hold_mod_val = build2 (BIT_IOR_EXPR, unsigned_type_node,
 				  mxcsr_orig_var,
 				  build_int_cst (unsigned_type_node, 0x1f80));
       hold_mod_val = build2 (BIT_AND_EXPR, unsigned_type_node, hold_mod_val,
 			     build_int_cst (unsigned_type_node, 0xffffffc0));
-      tree hold_assign_mod = build2 (MODIFY_EXPR, unsigned_type_node,
-				     mxcsr_mod_var, hold_mod_val);
+      tree hold_assign_mod = build4 (TARGET_EXPR, unsigned_type_node,
+				     mxcsr_mod_var, hold_mod_val,
+				     NULL_TREE, NULL_TREE);
       tree ldmxcsr_hold_call = build_call_expr (ldmxcsr, 1, mxcsr_mod_var);
       tree hold_all = build2 (COMPOUND_EXPR, unsigned_type_node,
 			      hold_assign_orig, hold_assign_mod);
@@ -50973,8 +51001,8 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 			    exceptions_assign);
 	}
       else
-	*update = build2 (MODIFY_EXPR, integer_type_node,
-			  exceptions_var, exceptions_sse);
+	*update = build4 (TARGET_EXPR, integer_type_node, exceptions_var,
+			  exceptions_sse, NULL_TREE, NULL_TREE);
       tree ldmxcsr_update_call = build_call_expr (ldmxcsr, 1, mxcsr_orig_var);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update,
 			ldmxcsr_update_call);
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 14e5a392f62..d138dfac05c 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2232,11 +2232,10 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];
 
 /* Under some conditions we need jump tables in the text section,
    because the assembler cannot handle label differences between
-   sections.  This is the case for x86_64 on Mach-O for example.  */
+   sections.  */
 
 #define JUMP_TABLES_IN_TEXT_SECTION \
-  (flag_pic && ((TARGET_MACHO && TARGET_64BIT) \
-   || (!TARGET_64BIT && !HAVE_AS_GOTOFF_IN_DATA)))
+  (flag_pic && !(TARGET_64BIT || HAVE_AS_GOTOFF_IN_DATA))
 
 /* Switch to init or fini section via SECTION_OP, emit a call to FUNC,
    and switch back.  For x86 we do this only to save a few bytes that
@@ -2380,6 +2379,9 @@ const wide_int_bitmask PTA_PCONFIG (0, HOST_WIDE_INT_1U << 7);
 const wide_int_bitmask PTA_WBNOINVD (0, HOST_WIDE_INT_1U << 8);
 const wide_int_bitmask PTA_WAITPKG (0, HOST_WIDE_INT_1U << 9);
 const wide_int_bitmask PTA_PTWRITE (0, HOST_WIDE_INT_1U << 10);
+const wide_int_bitmask PTA_MOVDIRI (0, HOST_WIDE_INT_1U << 13);
+const wide_int_bitmask PTA_MOVDIR64B (0, HOST_WIDE_INT_1U << 14);
+const wide_int_bitmask PTA_CLDEMOTE (0, HOST_WIDE_INT_1U << 16);
 
 const wide_int_bitmask PTA_CORE2 = PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2
   | PTA_SSE3 | PTA_SSSE3 | PTA_CX16 | PTA_FXSR;
@@ -2392,8 +2394,8 @@ const wide_int_bitmask PTA_IVYBRIDGE = PTA_SANDYBRIDGE | PTA_FSGSBASE
   | PTA_RDRND | PTA_F16C;
 const wide_int_bitmask PTA_HASWELL = PTA_IVYBRIDGE | PTA_AVX2 | PTA_BMI
   | PTA_BMI2 | PTA_LZCNT | PTA_FMA | PTA_MOVBE | PTA_HLE;
-const wide_int_bitmask PTA_BROADWELL = PTA_HASWELL | PTA_ADX | PTA_PRFCHW
-  | PTA_RDSEED;
+const wide_int_bitmask PTA_BROADWELL = PTA_HASWELL | PTA_ADX | PTA_RDSEED
+  | PTA_PRFCHW;
 const wide_int_bitmask PTA_SKYLAKE = PTA_BROADWELL | PTA_AES | PTA_CLFLUSHOPT
   | PTA_XSAVEC | PTA_XSAVES | PTA_SGX;
 const wide_int_bitmask PTA_SKYLAKE_AVX512 = PTA_SKYLAKE | PTA_AVX512F
@@ -2405,20 +2407,21 @@ const wide_int_bitmask PTA_CANNONLAKE = PTA_SKYLAKE | PTA_AVX512F
   | PTA_AVX512VBMI | PTA_AVX512IFMA | PTA_SHA;
 const wide_int_bitmask PTA_ICELAKE_CLIENT = PTA_CANNONLAKE | PTA_AVX512VNNI
   | PTA_GFNI | PTA_VAES | PTA_AVX512VBMI2 | PTA_VPCLMULQDQ | PTA_AVX512BITALG
-  | PTA_RDPID | PTA_CLWB | PTA_AVX512VPOPCNTDQ;
+  | PTA_RDPID | PTA_AVX512VPOPCNTDQ;
 const wide_int_bitmask PTA_ICELAKE_SERVER = PTA_ICELAKE_CLIENT | PTA_PCONFIG
-  | PTA_WBNOINVD;
+  | PTA_WBNOINVD | PTA_CLWB;
 const wide_int_bitmask PTA_KNL = PTA_BROADWELL | PTA_AVX512PF | PTA_AVX512ER
-  | PTA_AVX512F | PTA_AVX512CD;
+  | PTA_AVX512F | PTA_AVX512CD | PTA_PREFETCHWT1;
 const wide_int_bitmask PTA_BONNELL = PTA_CORE2 | PTA_MOVBE;
-const wide_int_bitmask PTA_SILVERMONT = PTA_WESTMERE | PTA_MOVBE | PTA_RDRND;
+const wide_int_bitmask PTA_SILVERMONT = PTA_WESTMERE | PTA_MOVBE | PTA_RDRND
+  | PTA_PRFCHW;
 const wide_int_bitmask PTA_GOLDMONT = PTA_SILVERMONT | PTA_AES | PTA_SHA | PTA_XSAVE
   | PTA_RDSEED | PTA_XSAVEC | PTA_XSAVES | PTA_CLFLUSHOPT | PTA_XSAVEOPT
   | PTA_FSGSBASE;
 const wide_int_bitmask PTA_GOLDMONT_PLUS = PTA_GOLDMONT | PTA_RDPID
   | PTA_SGX | PTA_PTWRITE;
 const wide_int_bitmask PTA_TREMONT = PTA_GOLDMONT_PLUS | PTA_CLWB
-  | PTA_GFNI;
+  | PTA_GFNI | PTA_MOVDIRI | PTA_MOVDIR64B | PTA_CLDEMOTE | PTA_WAITPKG;
 const wide_int_bitmask PTA_KNM = PTA_KNL | PTA_AVX5124VNNIW
   | PTA_AVX5124FMAPS | PTA_AVX512VPOPCNTDQ;
 
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 698c31a0a97..8ae7ea68c16 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -185,6 +185,10 @@
 
   ;; IRET support
   UNSPEC_INTERRUPT_RETURN
+
+  ;; For MOVDIRI and MOVDIR64B support
+  UNSPEC_MOVDIRI
+  UNSPEC_MOVDIR64B
 ])
 
 (define_c_enum "unspecv" [
@@ -279,10 +283,6 @@
   UNSPECV_SETSSBSY
   UNSPECV_CLRSSBSY
 
-  ;; For MOVDIRI and MOVDIR64B support
-  UNSPECV_MOVDIRI
-  UNSPECV_MOVDIR64B
-
   ;; For WAITPKG support
   UNSPECV_UMWAIT
   UNSPECV_UMONITOR
@@ -18158,8 +18158,11 @@
       emit_insn (tmp);
 
       /* Compare and jump over adjustment code.  */
-      noadj_label = gen_label_rtx ();
+      tmp = gen_rtx_COMPARE (CCZmode, reg_ssp, const0_rtx);
       flags = gen_rtx_REG (CCZmode, FLAGS_REG);
+      emit_insn (gen_rtx_SET (flags, tmp));
+
+      noadj_label = gen_label_rtx ();
       tmp = gen_rtx_EQ (VOIDmode, flags, const0_rtx);
       tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,
 				  gen_rtx_LABEL_REF (VOIDmode, noadj_label),
@@ -20425,17 +20428,17 @@
 ;; MOVDIRI and MOVDIR64B
 
 (define_insn "movdiri<mode>"
-  [(unspec_volatile:SWI48 [(match_operand:SWI48 0 "memory_operand" "m")
-			   (match_operand:SWI48 1 "register_operand" "r")]
-			  UNSPECV_MOVDIRI)]
+  [(set (match_operand:SWI48 0 "memory_operand" "=m")
+	(unspec:SWI48 [(match_operand:SWI48 1 "register_operand" "r")]
+		      UNSPEC_MOVDIRI))]
   "TARGET_MOVDIRI"
   "movdiri\t{%1, %0|%0, %1}"
   [(set_attr "type" "other")])
 
 (define_insn "movdir64b_<mode>"
-  [(unspec_volatile:XI [(match_operand:P 0 "register_operand" "r")
-			(match_operand:XI 1 "memory_operand")]
-		       UNSPECV_MOVDIR64B)]
+  [(set (mem:XI (match_operand:P 0 "register_operand" "r"))
+	(unspec:XI [(match_operand:XI 1 "memory_operand" "m")]
+		   UNSPEC_MOVDIR64B))]
   "TARGET_MOVDIR64B"
   "movdir64b\t{%1, %0|%0, %1}"
   [(set_attr "type" "other")])
diff --git a/gcc/config/i386/pconfigintrin.h b/gcc/config/i386/pconfigintrin.h
index d2a3261e470..709119e999c 100644
--- a/gcc/config/i386/pconfigintrin.h
+++ b/gcc/config/i386/pconfigintrin.h
@@ -1,3 +1,26 @@
+/* Copyright (C) 2018-2020 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
 #ifndef _IMMINTRIN_H_INCLUDED
 #error "Never use <pconfigintrin.h> directly; include <immintrin.h> instead."
 #endif
diff --git a/gcc/config/i386/shaintrin.h b/gcc/config/i386/shaintrin.h
index 3ab222fa77c..5741c7f6611 100644
--- a/gcc/config/i386/shaintrin.h
+++ b/gcc/config/i386/shaintrin.h
@@ -64,8 +64,8 @@ _mm_sha1rnds4_epu32 (__m128i __A, __m128i __B, const int __I)
 }
 #else
 #define _mm_sha1rnds4_epu32(A, B, I)				    \
-  ((__m128i) __builtin_ia32_sha1rnds4 ((__v4si)(__m128i)A,	    \
-				       (__v4si)(__m128i)B, (int)I))
+  ((__m128i) __builtin_ia32_sha1rnds4 ((__v4si)(__m128i)(A),	    \
+				       (__v4si)(__m128i)(B), (int)(I)))
 #endif
 
 extern __inline __m128i
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 18cc39ae521..3b51fef56f2 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -1829,7 +1829,7 @@
 	     (match_operand:<ssescalarmode> 1 "memory_operand" "m"))
 	  (match_operand:VF_AVX512 2 "register_operand" "v")))]
   "TARGET_AVX512F && <mask_mode512bit_condition>"
-  "vmul<ssemodesuffix>\t{%1<avx512bcst>, %2, %0<mask_operand3>|%0<mask_operand3>, %2, %1<<avx512bcst>>}"
+  "vmul<ssemodesuffix>\t{%1<avx512bcst>, %2, %0<mask_operand3>|%0<mask_operand3>, %2, %1<avx512bcst>}"
   [(set_attr "prefix" "evex")
    (set_attr "type" "ssemul")
    (set_attr "mode" "<MODE>")])
@@ -1899,7 +1899,7 @@
 	  (vec_duplicate:VF_AVX512
 	     (match_operand:<ssescalarmode> 2 "memory_operand" "m"))))]
   "TARGET_AVX512F && <mask_mode512bit_condition>"
-  "vdiv<ssemodesuffix>\t{%2<avx512bcst>, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2<<avx512bcst>>}"
+  "vdiv<ssemodesuffix>\t{%2<avx512bcst>, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2<avx512bcst>}"
   [(set_attr "prefix" "evex")
     (set_attr "type" "ssediv")
    (set_attr "mode" "<MODE>")])
@@ -2625,8 +2625,8 @@
 ;; Modes handled by reduc_sm{in,ax}* patterns.
 (define_mode_iterator REDUC_SSE_SMINMAX_MODE
   [(V4SF "TARGET_SSE") (V2DF "TARGET_SSE")
-   (V2DI "TARGET_SSE4_2") (V4SI "TARGET_SSE") (V8HI "TARGET_SSE")
-   (V16QI "TARGET_SSE")])
+   (V4SI "TARGET_SSE2") (V8HI "TARGET_SSE2") (V16QI "TARGET_SSE2")
+   (V2DI "TARGET_SSE4_2")])
 
 (define_expand "reduc_<code>_scal_<mode>"
   [(smaxmin:REDUC_SSE_SMINMAX_MODE
@@ -8288,7 +8288,8 @@
 })
 
 (define_insn "vec_extract_lo_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "nonimmediate_operand" "=v,v,m")
+  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>"
+					  "=v,v,<store_mask_constraint>")
 	(vec_select:<ssehalfvecmode>
 	  (match_operand:V16FI 1 "<store_mask_predicate>"
 				 "v,<store_mask_constraint>,v")
@@ -8345,7 +8346,8 @@
 })
 
 (define_insn "vec_extract_lo_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=v,v,m")
+  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>"
+					  "=v,v,<store_mask_constraint>")
 	(vec_select:<ssehalfvecmode>
 	  (match_operand:VI8F_256 1 "<store_mask_predicate>"
 				    "v,<store_mask_constraint>,v")
@@ -8355,7 +8357,7 @@
    && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>)
-    return "vextract<shuffletype>64x2\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}";
+    return "vextract<shuffletype>64x2\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
   else
     return "#";
 }
@@ -15538,22 +15540,6 @@
 		(ssse3_plusminus:HI
 		  (vec_select:HI (match_dup 1) (parallel [(const_int 6)]))
 		  (vec_select:HI (match_dup 1) (parallel [(const_int 7)])))))
-	    (vec_concat:V4HI
-	      (vec_concat:V2HI
-		(ssse3_plusminus:HI
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 8)]))
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 9)])))
-		(ssse3_plusminus:HI
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 10)]))
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 11)]))))
-	      (vec_concat:V2HI
-		(ssse3_plusminus:HI
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 12)]))
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 13)])))
-		(ssse3_plusminus:HI
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 14)]))
-		  (vec_select:HI (match_dup 1) (parallel [(const_int 15)]))))))
-	  (vec_concat:V8HI
 	    (vec_concat:V4HI
 	      (vec_concat:V2HI
 		(ssse3_plusminus:HI
@@ -15570,7 +15556,23 @@
 		  (vec_select:HI (match_dup 2) (parallel [(const_int 5)])))
 		(ssse3_plusminus:HI
 		  (vec_select:HI (match_dup 2) (parallel [(const_int 6)]))
-		  (vec_select:HI (match_dup 2) (parallel [(const_int 7)])))))
+		  (vec_select:HI (match_dup 2) (parallel [(const_int 7)]))))))
+	  (vec_concat:V8HI
+	    (vec_concat:V4HI
+	      (vec_concat:V2HI
+		(ssse3_plusminus:HI
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 8)]))
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 9)])))
+		(ssse3_plusminus:HI
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 10)]))
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 11)]))))
+	      (vec_concat:V2HI
+		(ssse3_plusminus:HI
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 12)]))
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 13)])))
+		(ssse3_plusminus:HI
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 14)]))
+		  (vec_select:HI (match_dup 1) (parallel [(const_int 15)])))))
 	    (vec_concat:V4HI
 	      (vec_concat:V2HI
 		(ssse3_plusminus:HI
@@ -15684,14 +15686,6 @@
 	      (plusminus:SI
 		(vec_select:SI (match_dup 1) (parallel [(const_int 2)]))
 		(vec_select:SI (match_dup 1) (parallel [(const_int 3)]))))
-	    (vec_concat:V2SI
-	      (plusminus:SI
-		(vec_select:SI (match_dup 1) (parallel [(const_int 4)]))
-		(vec_select:SI (match_dup 1) (parallel [(const_int 5)])))
-	      (plusminus:SI
-		(vec_select:SI (match_dup 1) (parallel [(const_int 6)]))
-		(vec_select:SI (match_dup 1) (parallel [(const_int 7)])))))
-	  (vec_concat:V4SI
 	    (vec_concat:V2SI
 	      (plusminus:SI
 		(vec_select:SI
@@ -15700,7 +15694,15 @@
 		(vec_select:SI (match_dup 2) (parallel [(const_int 1)])))
 	      (plusminus:SI
 		(vec_select:SI (match_dup 2) (parallel [(const_int 2)]))
-		(vec_select:SI (match_dup 2) (parallel [(const_int 3)]))))
+		(vec_select:SI (match_dup 2) (parallel [(const_int 3)])))))
+	  (vec_concat:V4SI
+	    (vec_concat:V2SI
+	      (plusminus:SI
+		(vec_select:SI (match_dup 1) (parallel [(const_int 4)]))
+		(vec_select:SI (match_dup 1) (parallel [(const_int 5)])))
+	      (plusminus:SI
+		(vec_select:SI (match_dup 1) (parallel [(const_int 6)]))
+		(vec_select:SI (match_dup 1) (parallel [(const_int 7)]))))
 	    (vec_concat:V2SI
 	      (plusminus:SI
 		(vec_select:SI (match_dup 2) (parallel [(const_int 4)]))
diff --git a/gcc/config/i386/wbnoinvdintrin.h b/gcc/config/i386/wbnoinvdintrin.h
index 5393698c6bb..94e58e9ce43 100644
--- a/gcc/config/i386/wbnoinvdintrin.h
+++ b/gcc/config/i386/wbnoinvdintrin.h
@@ -1,3 +1,26 @@
+/* Copyright (C) 2018-2020 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
 #ifndef _IMMINTRIN_H_INCLUDED
 #error "Never use <wbnoinvdintrin.h> directly; include <immintrin.h> instead."
 #endif
diff --git a/gcc/config/i386/winnt.c b/gcc/config/i386/winnt.c
index 1b439552f9c..9374c73e1d0 100644
--- a/gcc/config/i386/winnt.c
+++ b/gcc/config/i386/winnt.c
@@ -830,9 +830,20 @@ i386_pe_asm_lto_end (void)
 
 struct seh_frame_state
 {
-  /* SEH records saves relative to the "current" stack pointer, whether
-     or not there's a frame pointer in place.  This tracks the current
-     stack pointer offset from the CFA.  */
+  /* SEH records offsets relative to the lowest address of the fixed stack
+     allocation.  If there is no frame pointer, these offsets are from the
+     stack pointer; if there is a frame pointer, these offsets are from the
+     value of the stack pointer when the frame pointer was established, i.e.
+     the frame pointer minus the offset in the .seh_setframe directive.
+
+     We do not distinguish these two cases, i.e. we consider that the offsets
+     are always relative to the "current" stack pointer.  This means that we
+     need to perform the fixed stack allocation before establishing the frame
+     pointer whenever there are registers to be saved, and this is guaranteed
+     by the prologue provided that we force the frame pointer to point at or
+     below the lowest used register save area, see ix86_compute_frame_layout.
+
+     This tracks the current stack pointer offset from the CFA.  */
   HOST_WIDE_INT sp_offset;
 
   /* The CFA is located at CFA_REG + CFA_OFFSET.  */
@@ -1231,6 +1242,10 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)
   seh = cfun->machine->seh;
   if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)
     {
+      /* See ix86_seh_fixup_eh_fallthru for the rationale.  */
+      rtx_insn *prev = prev_active_insn (insn);
+      if (prev && !insn_nothrow_p (prev))
+	fputs ("\tnop\n", asm_out_file);
       fputs ("\t.seh_endproc\n", asm_out_file);
       seh->in_cold_section = true;
       return;
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 84a8cae22e4..d0dc2fb6a40 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -296,7 +296,7 @@ static size_t n_deferred_plabels = 0;
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK pa_asm_output_mi_thunk
 #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true
 
 #undef TARGET_ASM_FILE_END
 #define TARGET_ASM_FILE_END pa_file_end
@@ -8338,12 +8338,15 @@ pa_is_function_label_plus_const (rtx op)
 	  && GET_CODE (XEXP (op, 1)) == CONST_INT);
 }
 
-/* Output assembly code for a thunk to FUNCTION.  */
+/* Output the assembler code for a thunk function.  THUNK_DECL is the
+   declaration for the thunk function itself, FUNCTION is the decl for
+   the target function.  DELTA is an immediate constant offset to be
+   added to THIS.  If VCALL_OFFSET is nonzero, the word at
+   *(*this + vcall_offset) should be added to THIS.  */
 
 static void
 pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,
-			HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,
-			tree function)
+			HOST_WIDE_INT vcall_offset, tree function)
 {
   static unsigned int current_thunk_number;
   int val_14 = VAL_14_BITS_P (delta);
@@ -8357,201 +8360,386 @@ pa_asm_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,
 
   final_start_function (emit_barrier (), file, 1);
 
-  /* Output the thunk.  We know that the function is in the same
-     translation unit (i.e., the same space) as the thunk, and that
-     thunks are output after their method.  Thus, we don't need an
-     external branch to reach the function.  With SOM and GAS,
-     functions and thunks are effectively in different sections.
-     Thus, we can always use a IA-relative branch and the linker
-     will add a long branch stub if necessary.
-
-     However, we have to be careful when generating PIC code on the
-     SOM port to ensure that the sequence does not transfer to an
-     import stub for the target function as this could clobber the
-     return value saved at SP-24.  This would also apply to the
-     32-bit linux port if the multi-space model is implemented.  */
-  if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME
-       && !(flag_pic && TREE_PUBLIC (function))
-       && (TARGET_GAS || last_address < 262132))
-      || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME
-	  && ((targetm_common.have_named_sections
-	       && DECL_SECTION_NAME (thunk_fndecl) != NULL
-	       /* The GNU 64-bit linker has rather poor stub management.
-		  So, we use a long branch from thunks that aren't in
-		  the same section as the target function.  */
-	       && ((!TARGET_64BIT
-		    && (DECL_SECTION_NAME (thunk_fndecl)
-			!= DECL_SECTION_NAME (function)))
-		   || ((DECL_SECTION_NAME (thunk_fndecl)
-			== DECL_SECTION_NAME (function))
-		       && last_address < 262132)))
-	      /* In this case, we need to be able to reach the start of
-		 the stub table even though the function is likely closer
-		 and can be jumped to directly.  */
-	      || (targetm_common.have_named_sections
-		  && DECL_SECTION_NAME (thunk_fndecl) == NULL
-		  && DECL_SECTION_NAME (function) == NULL
-		  && total_code_bytes < MAX_PCREL17F_OFFSET)
-	      /* Likewise.  */
-	      || (!targetm_common.have_named_sections
-		  && total_code_bytes < MAX_PCREL17F_OFFSET))))
-    {
-      if (!val_14)
-	output_asm_insn ("addil L'%2,%%r26", xoperands);
-
-      output_asm_insn ("b %0", xoperands);
-
-      if (val_14)
-	{
-	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
-	  nbytes += 8;
+  if (!vcall_offset)
+    {
+      /* Output the thunk.  We know that the function is in the same
+	 translation unit (i.e., the same space) as the thunk, and that
+	 thunks are output after their method.  Thus, we don't need an
+	 external branch to reach the function.  With SOM and GAS,
+	 functions and thunks are effectively in different sections.
+	 Thus, we can always use a IA-relative branch and the linker
+	 will add a long branch stub if necessary.
+
+	 However, we have to be careful when generating PIC code on the
+	 SOM port to ensure that the sequence does not transfer to an
+	 import stub for the target function as this could clobber the
+	 return value saved at SP-24.  This would also apply to the
+	32-bit linux port if the multi-space model is implemented.  */
+      if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME
+	   && !(flag_pic && TREE_PUBLIC (function))
+	   && (TARGET_GAS || last_address < 262132))
+	  || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME
+	      && ((targetm_common.have_named_sections
+		   && DECL_SECTION_NAME (thunk_fndecl) != NULL
+		   /* The GNU 64-bit linker has rather poor stub management.
+		      So, we use a long branch from thunks that aren't in
+		      the same section as the target function.  */
+		    && ((!TARGET_64BIT
+			 && (DECL_SECTION_NAME (thunk_fndecl)
+			     != DECL_SECTION_NAME (function)))
+			|| ((DECL_SECTION_NAME (thunk_fndecl)
+			     == DECL_SECTION_NAME (function))
+			    && last_address < 262132)))
+		  /* In this case, we need to be able to reach the start of
+		     the stub table even though the function is likely closer
+		     and can be jumped to directly.  */
+		  || (targetm_common.have_named_sections
+		      && DECL_SECTION_NAME (thunk_fndecl) == NULL
+		      && DECL_SECTION_NAME (function) == NULL
+		      && total_code_bytes < MAX_PCREL17F_OFFSET)
+		  /* Likewise.  */
+		  || (!targetm_common.have_named_sections
+		      && total_code_bytes < MAX_PCREL17F_OFFSET))))
+	{
+	  if (!val_14)
+	    output_asm_insn ("addil L'%2,%%r26", xoperands);
+
+	  output_asm_insn ("b %0", xoperands);
+
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	      nbytes += 8;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	      nbytes += 12;
+	    }
 	}
-      else
+      else if (TARGET_64BIT)
 	{
-	  output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
-	  nbytes += 12;
-	}
-    }
-  else if (TARGET_64BIT)
-    {
-      rtx xop[4];
+	  rtx xop[4];
 
-      /* We only have one call-clobbered scratch register, so we can't
-         make use of the delay slot if delta doesn't fit in 14 bits.  */
-      if (!val_14)
+	  /* We only have one call-clobbered scratch register, so we can't
+	     make use of the delay slot if delta doesn't fit in 14 bits.  */
+	  if (!val_14)
+	    {
+	      output_asm_insn ("addil L'%2,%%r26", xoperands);
+	      output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	    }
+
+	  /* Load function address into %r1.  */
+	  xop[0] = xoperands[0];
+	  xop[1] = gen_rtx_REG (Pmode, 1);
+	  xop[2] = xop[1];
+	  pa_output_pic_pcrel_sequence (xop);
+
+	  if (val_14)
+	    {
+	      output_asm_insn ("bv %%r0(%%r1)", xoperands);
+	      output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	      nbytes += 20;
+	    }
+	  else
+	    {
+	      output_asm_insn ("bv,n %%r0(%%r1)", xoperands);
+	      nbytes += 24;
+	    }
+	}
+      else if (TARGET_PORTABLE_RUNTIME)
 	{
-	  output_asm_insn ("addil L'%2,%%r26", xoperands);
-	  output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	  output_asm_insn ("ldil L'%0,%%r1", xoperands);
+	  output_asm_insn ("ldo R'%0(%%r1),%%r22", xoperands);
+
+	  if (!val_14)
+	    output_asm_insn ("ldil L'%2,%%r26", xoperands);
+
+	  output_asm_insn ("bv %%r0(%%r22)", xoperands);
+
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	      nbytes += 16;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldo R'%2(%%r26),%%r26", xoperands);
+	      nbytes += 20;
+	    }
 	}
+      else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))
+	{
+	  /* The function is accessible from outside this module.  The only
+	     way to avoid an import stub between the thunk and function is to
+	     call the function directly with an indirect sequence similar to
+	     that used by $$dyncall.  This is possible because $$dyncall acts
+	     as the import stub in an indirect call.  */
+	  ASM_GENERATE_INTERNAL_LABEL (label, "LTHN", current_thunk_number);
+	  xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);
+	  output_asm_insn ("addil LT'%3,%%r19", xoperands);
+	  output_asm_insn ("ldw RT'%3(%%r1),%%r22", xoperands);
+	  output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
+	  output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
+	  output_asm_insn ("depi 0,31,2,%%r22", xoperands);
+	  output_asm_insn ("ldw 4(%%sr0,%%r22),%%r19", xoperands);
+	  output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
+
+	  if (!val_14)
+	    {
+	      output_asm_insn ("addil L'%2,%%r26", xoperands);
+	      nbytes += 4;
+	    }
 
-      /* Load function address into %r1.  */
-      xop[0] = xoperands[0];
-      xop[1] = gen_rtx_REG (Pmode, 1);
-      xop[2] = xop[1];
-      pa_output_pic_pcrel_sequence (xop);
+	  if (TARGET_PA_20)
+	    {
+	      output_asm_insn ("bve (%%r22)", xoperands);
+	      nbytes += 36;
+	    }
+	  else if (TARGET_NO_SPACE_REGS)
+	    {
+	      output_asm_insn ("be 0(%%sr4,%%r22)", xoperands);
+	      nbytes += 36;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldsid (%%sr0,%%r22),%%r21", xoperands);
+	      output_asm_insn ("mtsp %%r21,%%sr0", xoperands);
+	      output_asm_insn ("be 0(%%sr0,%%r22)", xoperands);
+	      nbytes += 44;
+	    }
 
-      if (val_14)
-	{
-	  output_asm_insn ("bv %%r0(%%r1)", xoperands);
-	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
-	  nbytes += 20;
+	  if (val_14)
+	    output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	  else
+	    output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
 	}
-      else
+      else if (flag_pic)
 	{
-	  output_asm_insn ("bv,n %%r0(%%r1)", xoperands);
-	  nbytes += 24;
-	}
-    }
-  else if (TARGET_PORTABLE_RUNTIME)
-    {
-      output_asm_insn ("ldil L'%0,%%r1", xoperands);
-      output_asm_insn ("ldo R'%0(%%r1),%%r22", xoperands);
+	  rtx xop[4];
 
-      if (!val_14)
-	output_asm_insn ("ldil L'%2,%%r26", xoperands);
+	  /* Load function address into %r22.  */
+	  xop[0] = xoperands[0];
+	  xop[1] = gen_rtx_REG (Pmode, 1);
+	  xop[2] = gen_rtx_REG (Pmode, 22);
+	  pa_output_pic_pcrel_sequence (xop);
 
-      output_asm_insn ("bv %%r0(%%r22)", xoperands);
+	  if (!val_14)
+	    output_asm_insn ("addil L'%2,%%r26", xoperands);
 
-      if (val_14)
-	{
-	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
-	  nbytes += 16;
+	  output_asm_insn ("bv %%r0(%%r22)", xoperands);
+
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	      nbytes += 20;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	      nbytes += 24;
+	    }
 	}
       else
 	{
-	  output_asm_insn ("ldo R'%2(%%r26),%%r26", xoperands);
-	  nbytes += 20;
+	  if (!val_14)
+	    output_asm_insn ("addil L'%2,%%r26", xoperands);
+
+	  output_asm_insn ("ldil L'%0,%%r22", xoperands);
+	  output_asm_insn ("be R'%0(%%sr4,%%r22)", xoperands);
+
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	      nbytes += 12;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	      nbytes += 16;
+	    }
 	}
     }
-  else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))
+  else
     {
-      /* The function is accessible from outside this module.  The only
-	 way to avoid an import stub between the thunk and function is to
-	 call the function directly with an indirect sequence similar to
-	 that used by $$dyncall.  This is possible because $$dyncall acts
-	 as the import stub in an indirect call.  */
-      ASM_GENERATE_INTERNAL_LABEL (label, "LTHN", current_thunk_number);
-      xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);
-      output_asm_insn ("addil LT'%3,%%r19", xoperands);
-      output_asm_insn ("ldw RT'%3(%%r1),%%r22", xoperands);
-      output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
-      output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
-      output_asm_insn ("depi 0,31,2,%%r22", xoperands);
-      output_asm_insn ("ldw 4(%%sr0,%%r22),%%r19", xoperands);
-      output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
+      rtx xop[4];
 
-      if (!val_14)
+      /* Add DELTA to THIS.  */
+      if (val_14)
 	{
-	  output_asm_insn ("addil L'%2,%%r26", xoperands);
+	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
 	  nbytes += 4;
 	}
-
-      if (TARGET_PA_20)
+      else
 	{
-	  output_asm_insn ("bve (%%r22)", xoperands);
-	  nbytes += 36;
+	  output_asm_insn ("addil L'%2,%%r26", xoperands);
+	  output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	  nbytes += 8;
 	}
-      else if (TARGET_NO_SPACE_REGS)
+
+      if (TARGET_64BIT)
 	{
-	  output_asm_insn ("be 0(%%sr4,%%r22)", xoperands);
-	  nbytes += 36;
+	  /* Load *(THIS + DELTA) to %r1.  */
+	  output_asm_insn ("ldd 0(%%r26),%%r1", xoperands);
+
+	  val_14 = VAL_14_BITS_P (vcall_offset);
+	  xoperands[2] = GEN_INT (vcall_offset);
+
+	  /* Load  *(*(THIS + DELTA) + VCALL_OFFSET) to %r1.  */
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldd %2(%%r1),%%r1", xoperands);
+	      nbytes += 8;
+	    }
+	  else
+	    {
+	      output_asm_insn ("addil L'%2,%%r1", xoperands);
+	      output_asm_insn ("ldd R'%2(%%r1),%%r1", xoperands);
+	      nbytes += 12;
+	    }
 	}
       else
 	{
-	  output_asm_insn ("ldsid (%%sr0,%%r22),%%r21", xoperands);
-	  output_asm_insn ("mtsp %%r21,%%sr0", xoperands);
-	  output_asm_insn ("be 0(%%sr0,%%r22)", xoperands);
-	  nbytes += 44;
-	}
-
-      if (val_14)
-	output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
-      else
-	output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
-    }
-  else if (flag_pic)
-    {
-      rtx xop[4];
-
-      /* Load function address into %r22.  */
-      xop[0] = xoperands[0];
-      xop[1] = gen_rtx_REG (Pmode, 1);
-      xop[2] = gen_rtx_REG (Pmode, 22);
-      pa_output_pic_pcrel_sequence (xop);
+	  /* Load *(THIS + DELTA) to %r1.  */
+	  output_asm_insn ("ldw 0(%%r26),%%r1", xoperands);
 
-      if (!val_14)
-	output_asm_insn ("addil L'%2,%%r26", xoperands);
+	  val_14 = VAL_14_BITS_P (vcall_offset);
+	  xoperands[2] = GEN_INT (vcall_offset);
 
-      output_asm_insn ("bv %%r0(%%r22)", xoperands);
+	  /* Load  *(*(THIS + DELTA) + VCALL_OFFSET) to %r1.  */
+	  if (val_14)
+	    {
+	      output_asm_insn ("ldw %2(%%r1),%%r1", xoperands);
+	      nbytes += 8;
+	    }
+	  else
+	    {
+	      output_asm_insn ("addil L'%2,%%r1", xoperands);
+	      output_asm_insn ("ldw R'%2(%%r1),%%r1", xoperands);
+	      nbytes += 12;
+	    }
+	}
 
-      if (val_14)
+      /* Branch to FUNCTION and add %r1 to THIS in delay slot if possible.  */
+      if ((!TARGET_LONG_CALLS && TARGET_SOM && !TARGET_PORTABLE_RUNTIME
+	   && !(flag_pic && TREE_PUBLIC (function))
+	   && (TARGET_GAS || last_address < 262132))
+	  || (!TARGET_LONG_CALLS && !TARGET_SOM && !TARGET_PORTABLE_RUNTIME
+	      && ((targetm_common.have_named_sections
+		   && DECL_SECTION_NAME (thunk_fndecl) != NULL
+		   /* The GNU 64-bit linker has rather poor stub management.
+		      So, we use a long branch from thunks that aren't in
+		      the same section as the target function.  */
+		    && ((!TARGET_64BIT
+			 && (DECL_SECTION_NAME (thunk_fndecl)
+			     != DECL_SECTION_NAME (function)))
+			|| ((DECL_SECTION_NAME (thunk_fndecl)
+			     == DECL_SECTION_NAME (function))
+			    && last_address < 262132)))
+		  /* In this case, we need to be able to reach the start of
+		     the stub table even though the function is likely closer
+		     and can be jumped to directly.  */
+		  || (targetm_common.have_named_sections
+		      && DECL_SECTION_NAME (thunk_fndecl) == NULL
+		      && DECL_SECTION_NAME (function) == NULL
+		      && total_code_bytes < MAX_PCREL17F_OFFSET)
+		  /* Likewise.  */
+		  || (!targetm_common.have_named_sections
+		      && total_code_bytes < MAX_PCREL17F_OFFSET))))
 	{
-	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
-	  nbytes += 20;
+	  nbytes += 4;
+	  output_asm_insn ("b %0", xoperands);
+
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
 	}
-      else
+      else if (TARGET_64BIT)
 	{
-	  output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
-	  nbytes += 24;
-	}
-    }
-  else
-    {
-      if (!val_14)
-	output_asm_insn ("addil L'%2,%%r26", xoperands);
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
 
-      output_asm_insn ("ldil L'%0,%%r22", xoperands);
-      output_asm_insn ("be R'%0(%%sr4,%%r22)", xoperands);
+	  /* Load function address into %r1.  */
+	  nbytes += 16;
+	  xop[0] = xoperands[0];
+	  xop[1] = gen_rtx_REG (Pmode, 1);
+	  xop[2] = xop[1];
+	  pa_output_pic_pcrel_sequence (xop);
 
-      if (val_14)
+	  output_asm_insn ("bv,n %%r0(%%r1)", xoperands);
+	}
+      else if (TARGET_PORTABLE_RUNTIME)
 	{
-	  output_asm_insn ("ldo %2(%%r26),%%r26", xoperands);
+	  /* Load function address into %r22.  */
 	  nbytes += 12;
+	  output_asm_insn ("ldil L'%0,%%r22", xoperands);
+	  output_asm_insn ("ldo R'%0(%%r22),%%r22", xoperands);
+
+	  output_asm_insn ("bv %%r0(%%r22)", xoperands);
+
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
+	}
+      else if (TARGET_SOM && flag_pic && TREE_PUBLIC (function))
+	{
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
+
+	  /* The function is accessible from outside this module.  The only
+	     way to avoid an import stub between the thunk and function is to
+	     call the function directly with an indirect sequence similar to
+	     that used by $$dyncall.  This is possible because $$dyncall acts
+	     as the import stub in an indirect call.  */
+	  ASM_GENERATE_INTERNAL_LABEL (label, "LTHN", current_thunk_number);
+	  xoperands[3] = gen_rtx_SYMBOL_REF (Pmode, label);
+	  output_asm_insn ("addil LT'%3,%%r19", xoperands);
+	  output_asm_insn ("ldw RT'%3(%%r1),%%r22", xoperands);
+	  output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
+	  output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
+	  output_asm_insn ("depi 0,31,2,%%r22", xoperands);
+	  output_asm_insn ("ldw 4(%%sr0,%%r22),%%r19", xoperands);
+	  output_asm_insn ("ldw 0(%%sr0,%%r22),%%r22", xoperands);
+
+	  if (TARGET_PA_20)
+	    {
+	      output_asm_insn ("bve,n (%%r22)", xoperands);
+	      nbytes += 32;
+	    }
+	  else if (TARGET_NO_SPACE_REGS)
+	    {
+	      output_asm_insn ("be,n 0(%%sr4,%%r22)", xoperands);
+	      nbytes += 32;
+	    }
+	  else
+	    {
+	      output_asm_insn ("ldsid (%%sr0,%%r22),%%r21", xoperands);
+	      output_asm_insn ("mtsp %%r21,%%sr0", xoperands);
+	      output_asm_insn ("be,n 0(%%sr0,%%r22)", xoperands);
+	      nbytes += 40;
+	    }
 	}
-      else
+      else if (flag_pic)
 	{
-	  output_asm_insn ("ldo R'%2(%%r1),%%r26", xoperands);
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
+
+	  /* Load function address into %r1.  */
 	  nbytes += 16;
+	  xop[0] = xoperands[0];
+	  xop[1] = gen_rtx_REG (Pmode, 1);
+	  xop[2] = xop[1];
+	  pa_output_pic_pcrel_sequence (xop);
+
+	  output_asm_insn ("bv,n %%r0(%%r1)", xoperands);
+	}
+      else
+	{
+	  /* Load function address into %r22.  */
+	  nbytes += 8;
+	  output_asm_insn ("ldil L'%0,%%r22", xoperands);
+	  output_asm_insn ("be R'%0(%%sr4,%%r22)", xoperands);
+
+	  /* Add *(*(THIS + DELTA) + VCALL_OFFSET) to THIS.  */
+	  output_asm_insn ("addl %%r1,%%r26,%%r26", xoperands);
 	}
     }
 
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index 24739e56f97..3c9f249c920 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -171,6 +171,7 @@ do {								\
      builtin_assert("machine=hppa");				\
      builtin_define("__hppa");					\
      builtin_define("__hppa__");				\
+     builtin_define("__BIG_ENDIAN__");				\
      if (TARGET_PA_20)						\
        builtin_define("_PA_RISC2_0");				\
      else if (TARGET_PA_11)					\
diff --git a/gcc/config/pdp11/pdp11.c b/gcc/config/pdp11/pdp11.c
index 5f530a43000..1be79e1964c 100644
--- a/gcc/config/pdp11/pdp11.c
+++ b/gcc/config/pdp11/pdp11.c
@@ -744,6 +744,7 @@ void
 pdp11_asm_output_var (FILE *file, const char *name, int size,
 		      int align, bool global)
 {
+  switch_to_section (data_section);
   if (align > 8)
     fprintf (file, "\t.even\n");
   if (TARGET_DEC_ASM)
@@ -764,8 +765,8 @@ pdp11_asm_output_var (FILE *file, const char *name, int size,
 	{
 	  fprintf (file, ".globl ");
 	  assemble_name (file, name);
+	  fprintf (file, "\n");
 	}
-      fprintf (file, "\n");
       assemble_name (file, name);
       fputs (":", file);
       ASM_OUTPUT_SKIP (file, size);
diff --git a/gcc/config/riscv/riscv-builtins.c b/gcc/config/riscv/riscv-builtins.c
index 548267179a1..13926ffe10d 100644
--- a/gcc/config/riscv/riscv-builtins.c
+++ b/gcc/config/riscv/riscv-builtins.c
@@ -283,8 +283,8 @@ riscv_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   tree fsflags = GET_BUILTIN_DECL (CODE_FOR_riscv_fsflags);
   tree old_flags = create_tmp_var_raw (RISCV_ATYPE_USI);
 
-  *hold = build2 (MODIFY_EXPR, RISCV_ATYPE_USI, old_flags,
-		  build_call_expr (frflags, 0));
+  *hold = build4 (TARGET_EXPR, RISCV_ATYPE_USI, old_flags,
+		  build_call_expr (frflags, 0), NULL_TREE, NULL_TREE);
   *clear = build_call_expr (fsflags, 1, old_flags);
   *update = NULL_TREE;
 }
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index b3297a38114..c4ed898de66 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -2906,7 +2906,7 @@ riscv_legitimize_call_address (rtx addr)
 {
   if (!call_insn_operand (addr, VOIDmode))
     {
-      rtx reg = RISCV_PROLOGUE_TEMP (Pmode);
+      rtx reg = RISCV_CALL_ADDRESS_TEMP (Pmode);
       riscv_emit_move (reg, addr);
       return reg;
     }
@@ -2917,9 +2917,9 @@ riscv_legitimize_call_address (rtx addr)
    Assume that the areas do not overlap.  */
 
 static void
-riscv_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)
+riscv_block_move_straight (rtx dest, rtx src, unsigned HOST_WIDE_INT length)
 {
-  HOST_WIDE_INT offset, delta;
+  unsigned HOST_WIDE_INT offset, delta;
   unsigned HOST_WIDE_INT bits;
   int i;
   enum machine_mode mode;
@@ -2965,8 +2965,8 @@ riscv_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)
    register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */
 
 static void
-riscv_adjust_block_mem (rtx mem, HOST_WIDE_INT length,
-		       rtx *loop_reg, rtx *loop_mem)
+riscv_adjust_block_mem (rtx mem, unsigned HOST_WIDE_INT length,
+			rtx *loop_reg, rtx *loop_mem)
 {
   *loop_reg = copy_addr_to_reg (XEXP (mem, 0));
 
@@ -2981,11 +2981,11 @@ riscv_adjust_block_mem (rtx mem, HOST_WIDE_INT length,
    the memory regions do not overlap.  */
 
 static void
-riscv_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,
-		      HOST_WIDE_INT bytes_per_iter)
+riscv_block_move_loop (rtx dest, rtx src, unsigned HOST_WIDE_INT length,
+		       unsigned HOST_WIDE_INT bytes_per_iter)
 {
   rtx label, src_reg, dest_reg, final_src, test;
-  HOST_WIDE_INT leftover;
+  unsigned HOST_WIDE_INT leftover;
 
   leftover = length % bytes_per_iter;
   length -= leftover;
@@ -3032,16 +3032,17 @@ riscv_expand_block_move (rtx dest, rtx src, rtx length)
 {
   if (CONST_INT_P (length))
     {
-      HOST_WIDE_INT factor, align;
+      unsigned HOST_WIDE_INT hwi_length = UINTVAL (length);
+      unsigned HOST_WIDE_INT factor, align;
 
       align = MIN (MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), BITS_PER_WORD);
       factor = BITS_PER_WORD / align;
 
       if (optimize_function_for_size_p (cfun)
-	  && INTVAL (length) * factor * UNITS_PER_WORD > MOVE_RATIO (false))
+	  && hwi_length * factor * UNITS_PER_WORD > MOVE_RATIO (false))
 	return false;
 
-      if (INTVAL (length) <= RISCV_MAX_MOVE_BYTES_STRAIGHT / factor)
+      if (hwi_length <= (RISCV_MAX_MOVE_BYTES_STRAIGHT / factor))
 	{
 	  riscv_block_move_straight (dest, src, INTVAL (length));
 	  return true;
@@ -3051,7 +3052,8 @@ riscv_expand_block_move (rtx dest, rtx src, rtx length)
 	  unsigned min_iter_words
 	    = RISCV_MAX_MOVE_BYTES_PER_LOOP_ITER / UNITS_PER_WORD;
 	  unsigned iter_words = min_iter_words;
-	  HOST_WIDE_INT bytes = INTVAL (length), words = bytes / UNITS_PER_WORD;
+	  unsigned HOST_WIDE_INT bytes = hwi_length;
+	  unsigned HOST_WIDE_INT words = bytes / UNITS_PER_WORD;
 
 	  /* Lengthen the loop body if it shortens the tail.  */
 	  for (unsigned i = min_iter_words; i < min_iter_words * 2 - 1; i++)
@@ -3466,18 +3468,18 @@ riscv_compute_frame_info (void)
 {
   struct riscv_frame_info *frame;
   HOST_WIDE_INT offset;
-  bool interrupt_save_t1 = false;
+  bool interrupt_save_prologue_temp = false;
   unsigned int regno, i, num_x_saved = 0, num_f_saved = 0;
 
   frame = &cfun->machine->frame;
 
   /* In an interrupt function, if we have a large frame, then we need to
-     save/restore t1.  We check for this before clearing the frame struct.  */
+     save/restore t0.  We check for this before clearing the frame struct.  */
   if (cfun->machine->interrupt_handler_p)
     {
       HOST_WIDE_INT step1 = riscv_first_stack_step (frame);
       if (! SMALL_OPERAND (frame->total_size - step1))
-	interrupt_save_t1 = true;
+	interrupt_save_prologue_temp = true;
     }
 
   memset (frame, 0, sizeof (*frame));
@@ -3487,7 +3489,8 @@ riscv_compute_frame_info (void)
       /* Find out which GPRs we need to save.  */
       for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)
 	if (riscv_save_reg_p (regno)
-	    || (interrupt_save_t1 && (regno == T1_REGNUM)))
+	    || (interrupt_save_prologue_temp
+		&& (regno == RISCV_PROLOGUE_TEMP_REGNUM)))
 	  frame->mask |= 1 << (regno - GP_REG_FIRST), num_x_saved++;
 
       /* If this function calls eh_return, we must also save and restore the
@@ -4621,9 +4624,9 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 
       rtx target_function = force_reg (Pmode, XEXP (DECL_RTL (fndecl), 0));
       /* lui     t2, hi(chain)
-	 lui     t1, hi(func)
+	 lui     t0, hi(func)
 	 addi    t2, t2, lo(chain)
-	 jr      r1, lo(func)
+	 jr      t0, lo(func)
       */
       unsigned HOST_WIDE_INT lui_hi_chain_code, lui_hi_func_code;
       unsigned HOST_WIDE_INT lo_chain_code, lo_func_code;
@@ -4648,7 +4651,7 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
       mem = adjust_address (m_tramp, SImode, 0);
       riscv_emit_move (mem, lui_hi_chain);
 
-      /* Gen lui t1, hi(func).  */
+      /* Gen lui t0, hi(func).  */
       rtx hi_func = riscv_force_binary (SImode, PLUS, target_function,
 					fixup_value);
       hi_func = riscv_force_binary (SImode, AND, hi_func,
@@ -4675,7 +4678,7 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
       mem = adjust_address (m_tramp, SImode, 2 * GET_MODE_SIZE (SImode));
       riscv_emit_move (mem, addi_lo_chain);
 
-      /* Gen jr r1, lo(func).  */
+      /* Gen jr t0, lo(func).  */
       rtx lo_func = riscv_force_binary (SImode, AND, target_function,
 					imm12_mask);
       lo_func = riscv_force_binary (SImode, ASHIFT, lo_func, GEN_INT (20));
@@ -4694,9 +4697,9 @@ riscv_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
       target_function_offset = static_chain_offset + GET_MODE_SIZE (ptr_mode);
 
       /* auipc   t2, 0
-	 l[wd]   t1, target_function_offset(t2)
+	 l[wd]   t0, target_function_offset(t2)
 	 l[wd]   t2, static_chain_offset(t2)
-	 jr      t1
+	 jr      t0
       */
       trampoline[0] = OPCODE_AUIPC | (STATIC_CHAIN_REGNUM << SHIFT_RD);
       trampoline[1] = (Pmode == DImode ? OPCODE_LD : OPCODE_LW)
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index 5130dc826d7..701f5ea1544 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -306,9 +306,13 @@ along with GCC; see the file COPYING3.  If not see
    The epilogue temporary mustn't conflict with the return registers,
    the frame pointer, the EH stack adjustment, or the EH data registers. */
 
-#define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST + 1)
+#define RISCV_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST)
 #define RISCV_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, RISCV_PROLOGUE_TEMP_REGNUM)
 
+#define RISCV_CALL_ADDRESS_TEMP_REGNUM (GP_TEMP_FIRST + 1)
+#define RISCV_CALL_ADDRESS_TEMP(MODE) \
+  gen_rtx_REG (MODE, RISCV_CALL_ADDRESS_TEMP_REGNUM)
+
 #define MCOUNT_NAME "_mcount"
 
 #define NO_PROFILE_COUNTERS 1
diff --git a/gcc/config/rs6000/aix61.h b/gcc/config/rs6000/aix61.h
index 57ea9ecfc47..8101d0b0c0a 100644
--- a/gcc/config/rs6000/aix61.h
+++ b/gcc/config/rs6000/aix61.h
@@ -49,8 +49,8 @@ do {									\
     }									\
   if (rs6000_current_cmodel != CMODEL_SMALL)				\
     {									\
-      TARGET_NO_FP_IN_TOC = 0;						\
-      TARGET_NO_SUM_IN_TOC = 0;						\
+      TARGET_NO_FP_IN_TOC = 1;						\
+      TARGET_NO_SUM_IN_TOC = 1;						\
     }									\
   if (rs6000_current_cmodel == CMODEL_MEDIUM)				\
     {									\
@@ -154,6 +154,7 @@ do {									\
    %{!maix64:%{!shared:%{g*:-lg}}}\
    %{fprofile-arcs|fprofile-generate*|coverage:-lpthreads}\
    %{mpe:-L%R/usr/lpp/ppe.poe/lib -lmpi -lvtd}\
+   %{mlong-double-128:-lc128}\
    %{pthread:-lpthreads} -lc"
 
 #undef LINK_SPEC
diff --git a/gcc/config/rs6000/aix71.h b/gcc/config/rs6000/aix71.h
index 263cc42b9dd..f29ce8f6ba0 100644
--- a/gcc/config/rs6000/aix71.h
+++ b/gcc/config/rs6000/aix71.h
@@ -49,8 +49,8 @@ do {									\
     }									\
   if (rs6000_current_cmodel != CMODEL_SMALL)				\
     {									\
-      TARGET_NO_FP_IN_TOC = 0;						\
-      TARGET_NO_SUM_IN_TOC = 0;						\
+      TARGET_NO_FP_IN_TOC = 1;						\
+      TARGET_NO_SUM_IN_TOC = 1;						\
     }									\
   if (rs6000_current_cmodel == CMODEL_MEDIUM)				\
     {									\
@@ -162,6 +162,7 @@ do {									\
    %{!maix64:%{!shared:%{g*:-lg}}}\
    %{fprofile-arcs|fprofile-generate*|coverage:-lpthreads}\
    %{mpe:-L%R/usr/lpp/ppe.poe/lib -lmpi -lvtd}\
+   %{mlong-double-128:-lc128}\
    %{pthread:-lpthreads} -lc"
 
 #undef LINK_SPEC
diff --git a/gcc/config/rs6000/aix72.h b/gcc/config/rs6000/aix72.h
index 065e1ebeadc..0ef62d41796 100644
--- a/gcc/config/rs6000/aix72.h
+++ b/gcc/config/rs6000/aix72.h
@@ -49,8 +49,8 @@ do {									\
     }									\
   if (rs6000_current_cmodel != CMODEL_SMALL)				\
     {									\
-      TARGET_NO_FP_IN_TOC = 0;						\
-      TARGET_NO_SUM_IN_TOC = 0;						\
+      TARGET_NO_FP_IN_TOC = 1;						\
+      TARGET_NO_SUM_IN_TOC = 1;						\
     }									\
   if (rs6000_current_cmodel == CMODEL_MEDIUM)				\
     {									\
@@ -163,6 +163,7 @@ do {									\
    %{!maix64:%{!shared:%{g*:-lg}}}\
    %{fprofile-arcs|fprofile-generate*|coverage:-lpthreads}\
    %{mpe:-L%R/usr/lpp/ppe.poe/lib -lmpi -lvtd}\
+   %{mlong-double-128:-lc128}\
    %{pthread:-lpthreads} -lc"
 
 #undef LINK_SPEC
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index d66ae7ca2c7..cb887eba521 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -159,6 +159,7 @@
 #define vec_vmsumubm __builtin_vec_vmsumubm
 #define vec_vmsumshs __builtin_vec_vmsumshs
 #define vec_vmsumuhs __builtin_vec_vmsumuhs
+#define vec_vmsumudm __builtin_vec_vmsumudm
 #define vec_vmulesb __builtin_vec_vmulesb
 #define vec_vmulesh __builtin_vec_vmulesh
 #define vec_vmuleuh __builtin_vec_vmuleuh
@@ -180,7 +181,7 @@
 #define vec_recipdiv __builtin_vec_recipdiv
 #define vec_rlmi __builtin_vec_rlmi
 #define vec_vrlnm __builtin_vec_rlnm
-#define vec_rlnm(a,b,c) (__builtin_vec_rlnm((a),((b)<<8)|(c)))
+#define vec_rlnm(a,b,c) (__builtin_vec_rlnm((a),((c)<<8)|(b)))
 #define vec_rsqrt __builtin_vec_rsqrt
 #define vec_rsqrte __builtin_vec_rsqrte
 #define vec_signed __builtin_vec_vsigned
@@ -431,7 +432,7 @@
 #define vec_first_match_or_eos_index __builtin_vec_first_match_or_eos_index
 #define vec_first_mismatch_index __builtin_vec_first_mismatch_index
 #define vec_first_mismatch_or_eos_index __builtin_vec_first_mismatch_or_eos_index
-#define vec_pack_to_short_fp32 __builtin_vec_convert_4f32_8i16
+#define vec_pack_to_short_fp32 __builtin_vec_convert_4f32_8f16
 #define vec_parity_lsbb __builtin_vec_vparity_lsbb
 #define vec_vctz __builtin_vec_vctz
 #define vec_cnttz __builtin_vec_vctz
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 654d756647c..a84c12ff5ed 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -21,6 +21,7 @@
 (define_c_enum "unspec"
   [UNSPEC_VCMPBFP
    UNSPEC_VMSUMU
+   UNSPEC_VMSUMUDM
    UNSPEC_VMSUMM
    UNSPEC_VMSUMSHM
    UNSPEC_VMSUMUHS
@@ -80,6 +81,7 @@
    UNSPEC_VUPKHPX
    UNSPEC_VUPKLPX
    UNSPEC_CONVERT_4F32_8I16
+   UNSPEC_CONVERT_4F32_8F16
    UNSPEC_DST
    UNSPEC_DSTT
    UNSPEC_DSTST
@@ -795,6 +797,16 @@
   "vmsumu<VI_char>m %0,%1,%2,%3"
   [(set_attr "type" "veccomplex")])
 
+(define_insn "altivec_vmsumudm"
+  [(set (match_operand:V1TI 0 "register_operand" "=v")
+	(unspec:V1TI [(match_operand:V2DI 1 "register_operand" "v")
+		      (match_operand:V2DI 2 "register_operand" "v")
+		      (match_operand:V1TI 3 "register_operand" "v")]
+		     UNSPEC_VMSUMUDM))]
+  "TARGET_P8_VECTOR"
+  "vmsumudm %0,%1,%2,%3"
+  [(set_attr "type" "veccomplex")])
+
 (define_insn "altivec_vmsumm<VI_char>m"
   [(set (match_operand:V4SI 0 "register_operand" "=v")
         (unspec:V4SI [(match_operand:VIshort 1 "register_operand" "v")
@@ -3042,6 +3054,37 @@
   DONE;
 })
 
+;; Convert two vector F32 to packed vector F16.
+;; This builtin packs 32-bit floating-point values into a packed
+;; 16-bit floating point values (stored in 16bit integer type).
+;; (vector unsigned short r = vec_pack_to_short_fp32 (a, b);
+;; The expected codegen for this builtin is
+;;    xvcvsphp t, a
+;;    xvcvsphp u, b
+;;    if (little endian)
+;;      vpkuwum r, t, u
+;;    else
+;;      vpkuwum r, u, t
+
+(define_expand "convert_4f32_8f16"
+  [(set (match_operand:V8HI 0 "register_operand" "=v")
+	(unspec:V8HI [(match_operand:V4SF 1 "register_operand" "v")
+		      (match_operand:V4SF 2 "register_operand" "v")]
+		     UNSPEC_CONVERT_4F32_8F16))]
+  "TARGET_P9_VECTOR"
+{
+  rtx rtx_tmp_hi = gen_reg_rtx (V4SImode);
+  rtx rtx_tmp_lo = gen_reg_rtx (V4SImode);
+
+  emit_insn (gen_vsx_xvcvsphp (rtx_tmp_hi, operands[1]));
+  emit_insn (gen_vsx_xvcvsphp (rtx_tmp_lo, operands[2]));
+  if (!BYTES_BIG_ENDIAN)
+    emit_insn (gen_altivec_vpkuwum (operands[0], rtx_tmp_hi, rtx_tmp_lo));
+  else
+    emit_insn (gen_altivec_vpkuwum (operands[0], rtx_tmp_lo, rtx_tmp_hi));
+  DONE;
+})
+
 ;; Generate
 ;;    xxlxor/vxor SCRATCH0,SCRATCH0,SCRATCH0
 ;;    vsubu?m SCRATCH2,SCRATCH1,%1
diff --git a/gcc/config/rs6000/emmintrin.h b/gcc/config/rs6000/emmintrin.h
index 30975090a2d..32c5fa0cb08 100644
--- a/gcc/config/rs6000/emmintrin.h
+++ b/gcc/config/rs6000/emmintrin.h
@@ -2033,7 +2033,8 @@ _mm_min_epu8 (__m128i __A, __m128i __B)
 #ifdef _ARCH_PWR8
 /* Intrinsic functions that require PowerISA 2.07 minimum.  */
 
-/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */
+/* Return a mask created from the most significant bit of each 8-bit
+   element in A.  */
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_epi8 (__m128i __A)
 {
diff --git a/gcc/config/rs6000/freebsd64.h b/gcc/config/rs6000/freebsd64.h
index 98b1cfd50dc..347c2d10868 100644
--- a/gcc/config/rs6000/freebsd64.h
+++ b/gcc/config/rs6000/freebsd64.h
@@ -160,8 +160,8 @@ extern int dot_symbols;
 #define ASM_SPEC64 "-a64"
 
 #define ASM_SPEC_COMMON "%(asm_cpu) \
-%{,assembler|,assembler-with-cpp: %{mregnames} %{mno-regnames}} \
-%{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian}"
+%{,assembler|,assembler-with-cpp: %{mregnames} %{mno-regnames}}" \
+  ENDIAN_SELECT(" -mbig", " -mlittle", DEFAULT_ASM_ENDIAN)
 
 #undef	SUBSUBTARGET_EXTRA_SPECS
 #define SUBSUBTARGET_EXTRA_SPECS					\
@@ -183,9 +183,15 @@ extern int dot_symbols;
     %{static:-Bstatic}} \
   %{symbolic:-Bsymbolic}"
 
+#undef  DEFAULT_ASM_ENDIAN
 #define LINK_OS_FREEBSD_SPEC32 "-melf32ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
-  
+#if (TARGET_DEFAULT & MASK_LITTLE_ENDIAN)
+#define DEFAULT_ASM_ENDIAN " -mlittle"
+#define LINK_OS_FREEBSD_SPEC64 "-melf64lppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
+#else
+#define DEFAULT_ASM_ENDIAN " -mbig"
 #define LINK_OS_FREEBSD_SPEC64 "-melf64ppc_fbsd " LINK_OS_FREEBSD_SPEC_DEF
+#endif
 
 #undef	MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS { "m64" }
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 0feee7cafca..bc929d5e6f6 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -947,6 +947,7 @@ BU_ALTIVEC_3 (VMLADDUHM,      "vmladduhm",      CONST, 	fmav8hi4)
 BU_ALTIVEC_3 (VMSUMUBM,       "vmsumubm",       CONST, 	altivec_vmsumubm)
 BU_ALTIVEC_3 (VMSUMMBM,       "vmsummbm",       CONST, 	altivec_vmsummbm)
 BU_ALTIVEC_3 (VMSUMUHM,       "vmsumuhm",       CONST, 	altivec_vmsumuhm)
+BU_ALTIVEC_3 (VMSUMUDM,       "vmsumudm",       CONST, 	altivec_vmsumudm)
 BU_ALTIVEC_3 (VMSUMSHM,       "vmsumshm",       CONST, 	altivec_vmsumshm)
 BU_ALTIVEC_3 (VMSUMUHS,       "vmsumuhs",       SAT,   	altivec_vmsumuhs)
 BU_ALTIVEC_3 (VMSUMSHS,       "vmsumshs",       SAT,   	altivec_vmsumshs)
@@ -1000,8 +1001,26 @@ BU_ALTIVEC_2 (VADDUHS,	      "vadduhs",	CONST,	altivec_vadduhs)
 BU_ALTIVEC_2 (VADDSHS,	      "vaddshs",	CONST,	altivec_vaddshs)
 BU_ALTIVEC_2 (VADDUWS,	      "vadduws",	CONST,	altivec_vadduws)
 BU_ALTIVEC_2 (VADDSWS,	      "vaddsws",	CONST,	altivec_vaddsws)
-BU_ALTIVEC_2 (VAND,	      "vand",		CONST,	andv4si3)
-BU_ALTIVEC_2 (VANDC,	      "vandc",		CONST,	andcv4si3)
+BU_ALTIVEC_2 (VAND_V16QI_UNS, "vand_v16qi_uns",	CONST,	andv16qi3)
+BU_ALTIVEC_2 (VAND_V16QI,     "vand_v16qi",	CONST,	andv16qi3)
+BU_ALTIVEC_2 (VAND_V8HI_UNS,  "vand_v8hi_uns",	CONST,	andv8hi3)
+BU_ALTIVEC_2 (VAND_V8HI,      "vand_v8hi",	CONST,	andv8hi3)
+BU_ALTIVEC_2 (VAND_V4SI_UNS,  "vand_v4si_uns",	CONST,	andv4si3)
+BU_ALTIVEC_2 (VAND_V4SI,      "vand_v4si",	CONST,	andv4si3)
+BU_ALTIVEC_2 (VAND_V2DI_UNS,  "vand_v2di_uns",	CONST,	andv2di3)
+BU_ALTIVEC_2 (VAND_V2DI,      "vand_v2di",	CONST,	andv2di3)
+BU_ALTIVEC_2 (VAND_V4SF,      "vand_v4sf",	CONST,	andv4sf3)
+BU_ALTIVEC_2 (VAND_V2DF,      "vand_v2df",	CONST,	andv2df3)
+BU_ALTIVEC_2 (VANDC_V16QI_UNS,"vandc_v16qi_uns",CONST,	andcv16qi3)
+BU_ALTIVEC_2 (VANDC_V16QI,    "vandc_v16qi",	CONST,	andcv16qi3)
+BU_ALTIVEC_2 (VANDC_V8HI_UNS, "vandc_v8hi_uns",	CONST,	andcv8hi3)
+BU_ALTIVEC_2 (VANDC_V8HI,     "vandc_v8hi",	CONST,	andcv8hi3)
+BU_ALTIVEC_2 (VANDC_V4SI_UNS, "vandc_v4si_uns",	CONST,	andcv4si3)
+BU_ALTIVEC_2 (VANDC_V4SI,     "vandc_v4si",	CONST,	andcv4si3)
+BU_ALTIVEC_2 (VANDC_V2DI_UNS, "vandc_v2di_uns",	CONST,	andcv2di3)
+BU_ALTIVEC_2 (VANDC_V2DI,     "vandc_v2di",	CONST,	andcv2di3)
+BU_ALTIVEC_2 (VANDC_V4SF,     "vandc_v4sf",	CONST,	andcv4sf3)
+BU_ALTIVEC_2 (VANDC_V2DF,     "vandc_v2df",	CONST,	andcv2df3)
 BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	uavgv16qi3_ceil)
 BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	avgv16qi3_ceil)
 BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	uavgv8hi3_ceil)
@@ -1057,8 +1076,27 @@ BU_ALTIVEC_2 (VMULOUH,	      "vmulouh",	CONST,	vec_widen_umult_odd_v8hi)
 BU_ALTIVEC_2 (VMULOSH,	      "vmulosh",	CONST,	vec_widen_smult_odd_v8hi)
 BU_P8V_AV_2 (VMULOUW,	      "vmulouw",	CONST,	vec_widen_umult_odd_v4si)
 BU_P8V_AV_2 (VMULOSW,	      "vmulosw",	CONST,	vec_widen_smult_odd_v4si)
-BU_ALTIVEC_2 (VNOR,	      "vnor",		CONST,	norv4si3)
-BU_ALTIVEC_2 (VOR,	      "vor",		CONST,	iorv4si3)
+BU_ALTIVEC_2 (VNOR_V16QI_UNS, "vnor_v16qi_uns",	CONST,	norv16qi3)
+BU_ALTIVEC_2 (VNOR_V16QI,     "vnor_v16qi",	CONST,	norv16qi3)
+BU_ALTIVEC_2 (VNOR_V8HI_UNS,  "vnor_v8hi_uns",	CONST,	norv8hi3)
+BU_ALTIVEC_2 (VNOR_V8HI,      "vnor_v8hi",	CONST,	norv8hi3)
+BU_ALTIVEC_2 (VNOR_V4SI_UNS,  "vnor_v4si_uns",	CONST,	norv4si3)
+BU_ALTIVEC_2 (VNOR_V4SI,      "vnor_v4si",	CONST,	norv4si3)
+BU_ALTIVEC_2 (VNOR_V2DI_UNS,  "vnor_v2di_uns",	CONST,	norv2di3)
+BU_ALTIVEC_2 (VNOR_V2DI,      "vnor_v2di",	CONST,	norv2di3)
+BU_ALTIVEC_2 (VNOR_V4SF,      "vnor_v4sf",	CONST,	norv4sf3)
+BU_ALTIVEC_2 (VNOR_V2DF,      "vnor_v2df",	CONST,	norv2df3)
+BU_ALTIVEC_2 (VOR_V16QI_UNS,  "vor_v16qi_uns",	CONST,	iorv16qi3)
+BU_ALTIVEC_2 (VOR_V16QI,      "vor_v16qi",	CONST,	iorv16qi3)
+BU_ALTIVEC_2 (VOR_V8HI_UNS,   "vor_v8hi_uns",	CONST,	iorv8hi3)
+BU_ALTIVEC_2 (VOR_V8HI,       "vor_v8hi",	CONST,	iorv8hi3)
+BU_ALTIVEC_2 (VOR_V4SI_UNS,   "vor_v4si_uns",	CONST,	iorv4si3)
+BU_ALTIVEC_2 (VOR_V4SI,       "vor_v4si",	CONST,	iorv4si3)
+BU_ALTIVEC_2 (VOR_V2DI_UNS,   "vor_v2di_uns",	CONST,	iorv2di3)
+BU_ALTIVEC_2 (VOR_V2DI,       "vor_v2di",	CONST,	iorv2di3)
+BU_ALTIVEC_2 (VOR_V4SF,       "vor_v4sf",	CONST,	iorv4sf3)
+BU_ALTIVEC_2 (VOR_V2DF,	      "vor_v2df",	CONST,	iorv2df3)
+
 BU_ALTIVEC_2 (VPKUHUM,	      "vpkuhum",	CONST,	altivec_vpkuhum)
 BU_ALTIVEC_2 (VPKUWUM,	      "vpkuwum",	CONST,	altivec_vpkuwum)
 BU_ALTIVEC_2 (VPKPX,	      "vpkpx",		CONST,	altivec_vpkpx)
@@ -1105,7 +1143,17 @@ BU_ALTIVEC_2 (VSUM4SHS,	      "vsum4shs",	CONST,	altivec_vsum4shs)
 BU_ALTIVEC_2 (VSUM2SWS,	      "vsum2sws",	CONST,	altivec_vsum2sws)
 BU_ALTIVEC_2 (VSUMSWS,	      "vsumsws",	CONST,	altivec_vsumsws)
 BU_ALTIVEC_2 (VSUMSWS_BE,     "vsumsws_be",	CONST,	altivec_vsumsws_direct)
-BU_ALTIVEC_2 (VXOR,	      "vxor",		CONST,	xorv4si3)
+BU_ALTIVEC_2 (VXOR_V16QI_UNS, "vxor_v16qi_uns",	CONST,	xorv16qi3)
+BU_ALTIVEC_2 (VXOR_V16QI,     "vxor_v16qi",	CONST,	xorv16qi3)
+BU_ALTIVEC_2 (VXOR_V8HI_UNS,  "vxor_v8hi_uns",	CONST,	xorv8hi3)
+BU_ALTIVEC_2 (VXOR_V8HI,      "vxor_v8hi",	CONST,	xorv8hi3)
+BU_ALTIVEC_2 (VXOR_V4SI_UNS,  "vxor_v4si_uns",	CONST,	xorv4si3)
+BU_ALTIVEC_2 (VXOR_V4SI,      "vxor_v4si",	CONST,	xorv4si3)
+BU_ALTIVEC_2 (VXOR_V2DI_UNS,  "vxor_v2di_uns",	CONST,	xorv2di3)
+BU_ALTIVEC_2 (VXOR_V2DI,      "vxor_v2di",	CONST,	xorv2di3)
+BU_ALTIVEC_2 (VXOR_V4SF,      "vxor_v4sf",	CONST,	xorv4sf3)
+BU_ALTIVEC_2 (VXOR_V2DF,      "vxor_v2df",	CONST,	xorv2df3)
+
 BU_ALTIVEC_2 (COPYSIGN_V4SF,  "copysignfp",	CONST,	vector_copysignv4sf3)
 
 /* Altivec ABS functions.  */
@@ -1257,6 +1305,7 @@ BU_ALTIVEC_OVERLOAD_3 (VMSUMSHM,   "vmsumshm")
 BU_ALTIVEC_OVERLOAD_3 (VMSUMSHS,   "vmsumshs")
 BU_ALTIVEC_OVERLOAD_3 (VMSUMUBM,   "vmsumubm")
 BU_ALTIVEC_OVERLOAD_3 (VMSUMUHM,   "vmsumuhm")
+BU_ALTIVEC_OVERLOAD_3 (VMSUMUDM,   "vmsumudm")
 BU_ALTIVEC_OVERLOAD_3 (VMSUMUHS,   "vmsumuhs")
 
 /* Altivec DST overloaded builtins.  */
@@ -1923,26 +1972,41 @@ BU_P8V_AV_2 (VSUBCUQ,		"vsubcuq",	CONST,	altivec_vsubcuq)
 BU_P8V_AV_2 (VSUBUDM,		"vsubudm",	CONST,	subv2di3)
 BU_P8V_AV_2 (VSUBUQM,		"vsubuqm",	CONST,	altivec_vsubuqm)
 
+BU_P8V_AV_2 (EQV_V16QI_UNS,	"eqv_v16qi_uns",CONST,	eqvv16qi3)
 BU_P8V_AV_2 (EQV_V16QI,		"eqv_v16qi",	CONST,	eqvv16qi3)
+BU_P8V_AV_2 (EQV_V8HI_UNS,	"eqv_v8hi_uns",	CONST,	eqvv8hi3)
 BU_P8V_AV_2 (EQV_V8HI,		"eqv_v8hi",	CONST,	eqvv8hi3)
+BU_P8V_AV_2 (EQV_V4SI_UNS,	"eqv_v4si_uns",	CONST,	eqvv4si3)
 BU_P8V_AV_2 (EQV_V4SI,		"eqv_v4si",	CONST,	eqvv4si3)
+BU_P8V_AV_2 (EQV_V2DI_UNS,	"eqv_v2di_uns",	CONST,	eqvv2di3)
 BU_P8V_AV_2 (EQV_V2DI,		"eqv_v2di",	CONST,	eqvv2di3)
+BU_P8V_AV_2 (EQV_V1TI_UNS,	"eqv_v1ti_uns",	CONST,	eqvv1ti3)
 BU_P8V_AV_2 (EQV_V1TI,		"eqv_v1ti",	CONST,	eqvv1ti3)
 BU_P8V_AV_2 (EQV_V4SF,		"eqv_v4sf",	CONST,	eqvv4sf3)
 BU_P8V_AV_2 (EQV_V2DF,		"eqv_v2df",	CONST,	eqvv2df3)
 
-BU_P8V_AV_2 (NAND_V16QI,	"nand_v16qi",	CONST,	nandv16qi3)
-BU_P8V_AV_2 (NAND_V8HI,		"nand_v8hi",	CONST,	nandv8hi3)
-BU_P8V_AV_2 (NAND_V4SI,		"nand_v4si",	CONST,	nandv4si3)
-BU_P8V_AV_2 (NAND_V2DI,		"nand_v2di",	CONST,	nandv2di3)
-BU_P8V_AV_2 (NAND_V1TI,		"nand_v1ti",	CONST,	nandv1ti3)
-BU_P8V_AV_2 (NAND_V4SF,		"nand_v4sf",	CONST,	nandv4sf3)
-BU_P8V_AV_2 (NAND_V2DF,		"nand_v2df",	CONST,	nandv2df3)
-
+BU_P8V_AV_2 (NAND_V16QI_UNS,	"nand_v16qi_uns", CONST,	nandv16qi3)
+BU_P8V_AV_2 (NAND_V16QI,	"nand_v16qi",	  CONST,	nandv16qi3)
+BU_P8V_AV_2 (NAND_V8HI_UNS,	"nand_v8hi_uns",  CONST,	nandv8hi3)
+BU_P8V_AV_2 (NAND_V8HI,		"nand_v8hi",	  CONST,	nandv8hi3)
+BU_P8V_AV_2 (NAND_V4SI_UNS,	"nand_v4si_uns",  CONST,	nandv4si3)
+BU_P8V_AV_2 (NAND_V4SI,		"nand_v4si",	  CONST,	nandv4si3)
+BU_P8V_AV_2 (NAND_V2DI_UNS,	"nand_v2di_uns",  CONST,	nandv2di3)
+BU_P8V_AV_2 (NAND_V2DI,		"nand_v2di",	  CONST,	nandv2di3)
+BU_P8V_AV_2 (NAND_V1TI_UNS,	"nand_v1ti_uns",  CONST,	nandv1ti3)
+BU_P8V_AV_2 (NAND_V1TI,		"nand_v1ti",	  CONST,	nandv1ti3)
+BU_P8V_AV_2 (NAND_V4SF,		"nand_v4sf",	  CONST,	nandv4sf3)
+BU_P8V_AV_2 (NAND_V2DF,		"nand_v2df",	  CONST,	nandv2df3)
+
+BU_P8V_AV_2 (ORC_V16QI_UNS,	"orc_v16qi_uns",CONST,	orcv16qi3)
 BU_P8V_AV_2 (ORC_V16QI,		"orc_v16qi",	CONST,	orcv16qi3)
+BU_P8V_AV_2 (ORC_V8HI_UNS,	"orc_v8hi_uns",	CONST,	orcv8hi3)
 BU_P8V_AV_2 (ORC_V8HI,		"orc_v8hi",	CONST,	orcv8hi3)
+BU_P8V_AV_2 (ORC_V4SI_UNS,	"orc_v4si_uns",	CONST,	orcv4si3)
 BU_P8V_AV_2 (ORC_V4SI,		"orc_v4si",	CONST,	orcv4si3)
+BU_P8V_AV_2 (ORC_V2DI_UNS,	"orc_v2di_uns",	CONST,	orcv2di3)
 BU_P8V_AV_2 (ORC_V2DI,		"orc_v2di",	CONST,	orcv2di3)
+BU_P8V_AV_2 (ORC_V1TI_UNS,	"orc_v1ti_uns",	CONST,	orcv1ti3)
 BU_P8V_AV_2 (ORC_V1TI,		"orc_v1ti",	CONST,	orcv1ti3)
 BU_P8V_AV_2 (ORC_V4SF,		"orc_v4sf",	CONST,	orcv4sf3)
 BU_P8V_AV_2 (ORC_V2DF,		"orc_v2df",	CONST,	orcv2df3)
@@ -2032,6 +2096,7 @@ BU_P8V_OVERLOAD_3 (VPERMXOR,   "vpermxor")
 BU_P9V_AV_2 (VSLV,		"vslv",			CONST, vslv)
 BU_P9V_AV_2 (VSRV,		"vsrv",			CONST, vsrv)
 BU_P9V_AV_2 (CONVERT_4F32_8I16, "convert_4f32_8i16", CONST, convert_4f32_8i16)
+BU_P9V_AV_2 (CONVERT_4F32_8F16, "convert_4f32_8f16", CONST, convert_4f32_8f16)
 
 BU_P9V_AV_2 (VFIRSTMATCHINDEX_V16QI, "first_match_index_v16qi",
 	     CONST, first_match_index_v16qi)
@@ -2062,6 +2127,7 @@ BU_P9V_AV_2 (VFIRSTMISMATCHOREOSINDEX_V4SI, "first_mismatch_or_eos_index_v4si",
 BU_P9V_OVERLOAD_2 (VSLV,	"vslv")
 BU_P9V_OVERLOAD_2 (VSRV,	"vsrv")
 BU_P9V_OVERLOAD_2 (CONVERT_4F32_8I16, "convert_4f32_8i16")
+BU_P9V_OVERLOAD_2 (CONVERT_4F32_8F16, "convert_4f32_8f16")
 
 /* 2 argument vector functions added in ISA 3.0 (power9). */
 BU_P9V_AV_2 (VADUB,		"vadub",		CONST,  vaduv16qi3)
diff --git a/gcc/config/rs6000/rs6000-c.c b/gcc/config/rs6000/rs6000-c.c
index 7c28d4d8176..16d68a083cb 100644
--- a/gcc/config/rs6000/rs6000-c.c
+++ b/gcc/config/rs6000/rs6000-c.c
@@ -1121,142 +1121,145 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_VADDUBS, ALTIVEC_BUILTIN_VADDUBS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_AVG, ALTIVEC_BUILTIN_VAVGUB,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_AVG, ALTIVEC_BUILTIN_VAVGSB,
@@ -2312,110 +2315,112 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
   { ALTIVEC_BUILTIN_VEC_NEARBYINT, VSX_BUILTIN_XVRSPI,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },
 
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_PACK, ALTIVEC_BUILTIN_VPKUHUM,
     RS6000_BTI_V16QI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACK, ALTIVEC_BUILTIN_VPKUHUM,
@@ -2452,6 +2457,8 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
 
   { P9V_BUILTIN_VEC_CONVERT_4F32_8I16, P9V_BUILTIN_CONVERT_4F32_8I16,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
+  { P9V_BUILTIN_VEC_CONVERT_4F32_8F16, P9V_BUILTIN_CONVERT_4F32_8F16,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
 
   { P9V_BUILTIN_VEC_VFIRSTMATCHINDEX, P9V_BUILTIN_VFIRSTMATCHINDEX_V16QI,
     RS6000_BTI_UINTSI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
@@ -3281,73 +3288,79 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     ~RS6000_BTI_unsigned_V16QI, 0 },
   { VSX_BUILTIN_VEC_XL_BE, VSX_BUILTIN_LD_ELEMREV_V16QI,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SF, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
-    RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
-    RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI,
+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
 
   /* Ternary AltiVec/VSX builtins.  */
@@ -3547,6 +3560,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V4SI },
   { ALTIVEC_BUILTIN_VEC_MSUM, ALTIVEC_BUILTIN_VMSUMSHM,
     RS6000_BTI_V4SI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V4SI },
+
+  { ALTIVEC_BUILTIN_VEC_MSUM, ALTIVEC_BUILTIN_VMSUMUDM,
+    RS6000_BTI_V1TI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V1TI },
+  { ALTIVEC_BUILTIN_VEC_MSUM, ALTIVEC_BUILTIN_VMSUMUDM,
+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V1TI },
+
   { ALTIVEC_BUILTIN_VEC_VMSUMSHM, ALTIVEC_BUILTIN_VMSUMSHM,
     RS6000_BTI_V4SI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V4SI },
   { ALTIVEC_BUILTIN_VEC_VMSUMUHM, ALTIVEC_BUILTIN_VMSUMUHM,
@@ -4587,15 +4606,15 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_bool_V16QI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
@@ -4604,15 +4623,15 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_bool_V8HI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
@@ -4621,15 +4640,15 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_bool_V4SI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
@@ -4638,15 +4657,15 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_bool_V2DI, 0 },
-  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,
+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
   { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SF,
@@ -4660,16 +4679,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_bool_V16QI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
@@ -4677,16 +4696,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_bool_V8HI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -4694,16 +4713,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_bool_V4SI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
@@ -4711,16 +4730,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_bool_V2DI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
-  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,
+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
@@ -4733,16 +4752,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_bool_V16QI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI_UNS,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_unsigned_V16QI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI_UNS,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },
@@ -4750,16 +4769,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
     RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_bool_V8HI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI_UNS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,
     RS6000_BTI_unsigned_V8HI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI_UNS,
     RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_bool_V8HI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -4767,16 +4786,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_bool_V4SI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI_UNS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI_UNS,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
@@ -4784,16 +4803,16 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_bool_V2DI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI_UNS,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,
     RS6000_BTI_unsigned_V2DI, 0 },
-  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,
+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI_UNS,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
@@ -6853,6 +6872,19 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
 	  arg = fold_convert (type, arg);
 	}
 
+      /* For P9V_BUILTIN_VEC_LXVL, convert any const * to its non constant
+	 equivalent to simplify the overload matching below.  */
+      if (fcode == P9V_BUILTIN_VEC_LXVL)
+	{
+	  if (POINTER_TYPE_P (type)
+	      && TYPE_READONLY (TREE_TYPE (type)))
+	    {
+	      type = build_pointer_type (build_qualified_type (
+						TREE_TYPE (type),0));
+	      arg = fold_convert (type, arg);
+	    }
+	}
+
       args[n] = arg;
       types[n] = type;
     }
diff --git a/gcc/config/rs6000/rs6000-cpus.def b/gcc/config/rs6000/rs6000-cpus.def
index d0d69beafd4..47a5d0576d0 100644
--- a/gcc/config/rs6000/rs6000-cpus.def
+++ b/gcc/config/rs6000/rs6000-cpus.def
@@ -88,6 +88,10 @@
 				 | OPTION_MASK_FLOAT128_KEYWORD		\
 				 | OPTION_MASK_P8_VECTOR)
 
+/* Flags that need to be turned off if -mno-altivec.  */
+#define OTHER_ALTIVEC_MASKS	(OTHER_VSX_VECTOR_MASKS			\
+				 | OPTION_MASK_VSX)
+
 #define POWERPC_7400_MASK	(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)
 
 /* Deal with ports that do not have -mstrict-align.  */
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 87d60078bb0..62250433c16 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -1218,7 +1218,7 @@ struct processor_costs power8_cost = {
   COSTS_N_INSNS (17),	/* ddiv */
   128,			/* cache line size */
   32,			/* l1 cache */
-  256,			/* l2 cache */
+  512,			/* l2 cache */
   12,			/* prefetch streams */
   COSTS_N_INSNS (3),	/* SF->DF convert */
 };
@@ -4099,6 +4099,14 @@ rs6000_option_override_internal (bool global_init_p)
       rs6000_isa_flags &= ~OPTION_MASK_CRYPTO;
     }
 
+  if (!TARGET_FPRND && TARGET_VSX)
+    {
+      if (rs6000_isa_flags_explicit & OPTION_MASK_FPRND)
+	/* TARGET_VSX = 1 implies Power 7 and newer */
+	error ("%qs requires %qs", "-mvsx", "-mfprnd");
+      rs6000_isa_flags &= ~OPTION_MASK_FPRND;
+    }
+
   if (TARGET_DIRECT_MOVE && !TARGET_VSX)
     {
       if (rs6000_isa_flags_explicit & OPTION_MASK_DIRECT_MOVE)
@@ -4715,11 +4723,6 @@ rs6000_option_override_internal (bool global_init_p)
 		  str_align_loops = "16";
 		}
 	    }
-
-	  if (flag_align_jumps && !str_align_jumps)
-	    str_align_jumps = "16";
-	  if (flag_align_loops && !str_align_loops)
-	    str_align_loops = "16";
 	}
 
       /* Arrange to save and restore machine status around nested functions.  */
@@ -7044,18 +7047,25 @@ rs6000_adjust_vec_address (rtx scalar_reg,
     element_offset = GEN_INT (INTVAL (element) * scalar_size);
   else
     {
+      /* Mask the element to make sure the element number is between 0 and the
+	 maximum number of elements - 1 so that we don't generate an address
+	 outside the vector.  */
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (GET_MODE (mem)) - 1);
+      rtx and_op = gen_rtx_AND (Pmode, element, num_ele_m1);
+      emit_insn (gen_rtx_SET (base_tmp, and_op));
+
       int byte_shift = exact_log2 (scalar_size);
       gcc_assert (byte_shift >= 0);
 
       if (byte_shift == 0)
-	element_offset = element;
+	element_offset = base_tmp;
 
       else
 	{
 	  if (TARGET_POWERPC64)
-	    emit_insn (gen_ashldi3 (base_tmp, element, GEN_INT (byte_shift)));
+	    emit_insn (gen_ashldi3 (base_tmp, base_tmp, GEN_INT (byte_shift)));
 	  else
-	    emit_insn (gen_ashlsi3 (base_tmp, element, GEN_INT (byte_shift)));
+	    emit_insn (gen_ashlsi3 (base_tmp, base_tmp, GEN_INT (byte_shift)));
 
 	  element_offset = base_tmp;
 	}
@@ -8361,7 +8371,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
 	low_int = 0;
       high_int = INTVAL (XEXP (x, 1)) - low_int;
       sum = force_operand (gen_rtx_PLUS (Pmode, XEXP (x, 0),
-					 GEN_INT (high_int)), 0);
+					 gen_int_mode (high_int, Pmode)), 0);
       return plus_constant (Pmode, sum, low_int);
     }
   else if (GET_CODE (x) == PLUS
@@ -15721,7 +15731,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* Flavors of vec_and.  */
-    case ALTIVEC_BUILTIN_VAND:
+    case ALTIVEC_BUILTIN_VAND_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V16QI:
+    case ALTIVEC_BUILTIN_VAND_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V8HI:
+    case ALTIVEC_BUILTIN_VAND_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V4SI:
+    case ALTIVEC_BUILTIN_VAND_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V2DI:
+    case ALTIVEC_BUILTIN_VAND_V4SF:
+    case ALTIVEC_BUILTIN_VAND_V2DF:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15730,7 +15749,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* Flavors of vec_andc.  */
-    case ALTIVEC_BUILTIN_VANDC:
+    case ALTIVEC_BUILTIN_VANDC_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V16QI:
+    case ALTIVEC_BUILTIN_VANDC_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V8HI:
+    case ALTIVEC_BUILTIN_VANDC_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V4SI:
+    case ALTIVEC_BUILTIN_VANDC_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V2DI:
+    case ALTIVEC_BUILTIN_VANDC_V4SF:
+    case ALTIVEC_BUILTIN_VANDC_V2DF:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15744,12 +15772,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       return true;
     /* Flavors of vec_nand.  */
     case P8V_BUILTIN_VEC_NAND:
+    case P8V_BUILTIN_NAND_V16QI_UNS:
     case P8V_BUILTIN_NAND_V16QI:
+    case P8V_BUILTIN_NAND_V8HI_UNS:
     case P8V_BUILTIN_NAND_V8HI:
+    case P8V_BUILTIN_NAND_V4SI_UNS:
     case P8V_BUILTIN_NAND_V4SI:
+    case P8V_BUILTIN_NAND_V2DI_UNS:
+    case P8V_BUILTIN_NAND_V2DI:
     case P8V_BUILTIN_NAND_V4SF:
     case P8V_BUILTIN_NAND_V2DF:
-    case P8V_BUILTIN_NAND_V2DI:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15762,7 +15794,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* Flavors of vec_or.  */
-    case ALTIVEC_BUILTIN_VOR:
+    case ALTIVEC_BUILTIN_VOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V16QI:
+    case ALTIVEC_BUILTIN_VOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V8HI:
+    case ALTIVEC_BUILTIN_VOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V4SI:
+    case ALTIVEC_BUILTIN_VOR_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V2DI:
+    case ALTIVEC_BUILTIN_VOR_V4SF:
+    case ALTIVEC_BUILTIN_VOR_V2DF:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15771,12 +15812,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* flavors of vec_orc.  */
+    case P8V_BUILTIN_ORC_V16QI_UNS:
     case P8V_BUILTIN_ORC_V16QI:
+    case P8V_BUILTIN_ORC_V8HI_UNS:
     case P8V_BUILTIN_ORC_V8HI:
+    case P8V_BUILTIN_ORC_V4SI_UNS:
     case P8V_BUILTIN_ORC_V4SI:
+    case P8V_BUILTIN_ORC_V2DI_UNS:
+    case P8V_BUILTIN_ORC_V2DI:
     case P8V_BUILTIN_ORC_V4SF:
     case P8V_BUILTIN_ORC_V2DF:
-    case P8V_BUILTIN_ORC_V2DI:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15789,7 +15834,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* Flavors of vec_xor.  */
-    case ALTIVEC_BUILTIN_VXOR:
+    case ALTIVEC_BUILTIN_VXOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V16QI:
+    case ALTIVEC_BUILTIN_VXOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V8HI:
+    case ALTIVEC_BUILTIN_VXOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V4SI:
+    case ALTIVEC_BUILTIN_VXOR_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V2DI:
+    case ALTIVEC_BUILTIN_VXOR_V4SF:
+    case ALTIVEC_BUILTIN_VXOR_V2DF:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -15798,7 +15852,16 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
       gsi_replace (gsi, g, true);
       return true;
     /* Flavors of vec_nor.  */
-    case ALTIVEC_BUILTIN_VNOR:
+    case ALTIVEC_BUILTIN_VNOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V16QI:
+    case ALTIVEC_BUILTIN_VNOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V8HI:
+    case ALTIVEC_BUILTIN_VNOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V4SI:
+    case ALTIVEC_BUILTIN_VNOR_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V2DI:
+    case ALTIVEC_BUILTIN_VNOR_V4SF:
+    case ALTIVEC_BUILTIN_VNOR_V2DF:
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
       lhs = gimple_call_lhs (stmt);
@@ -16767,7 +16830,7 @@ rs6000_init_builtins (void)
 
   V2DI_type_node = rs6000_vector_type (TARGET_POWERPC64 ? "__vector long"
 				       : "__vector long long",
-				       intDI_type_node, 2);
+				       long_long_integer_type_node, 2);
   V2DF_type_node = rs6000_vector_type ("__vector double", double_type_node, 2);
   V4SI_type_node = rs6000_vector_type ("__vector signed int",
 				       intSI_type_node, 4);
@@ -16786,7 +16849,7 @@ rs6000_init_builtins (void)
   unsigned_V2DI_type_node = rs6000_vector_type (TARGET_POWERPC64
 				       ? "__vector unsigned long"
 				       : "__vector unsigned long long",
-				       unsigned_intDI_type_node, 2);
+				       long_long_unsigned_type_node, 2);
 
   opaque_V4SI_type_node = build_opaque_vector_type (intSI_type_node, 4);
 
@@ -17019,10 +17082,28 @@ rs6000_init_builtins (void)
   def_builtin ("__builtin_cpu_is", ftype, RS6000_BUILTIN_CPU_IS);
   def_builtin ("__builtin_cpu_supports", ftype, RS6000_BUILTIN_CPU_SUPPORTS);
 
-  /* AIX libm provides clog as __clog.  */
-  if (TARGET_XCOFF &&
-      (tdecl = builtin_decl_explicit (BUILT_IN_CLOG)) != NULL_TREE)
-    set_user_assembler_name (tdecl, "__clog");
+  if (TARGET_XCOFF)
+    {
+      /* AIX libm provides clog as __clog.  */
+      if ((tdecl = builtin_decl_explicit (BUILT_IN_CLOG)) != NULL_TREE)
+	set_user_assembler_name (tdecl, "__clog");
+
+      /* When long double is 64 bit, some long double builtins of libc
+	 functions (like __builtin_frexpl) must call the double version
+	 (frexp) not the long double version (frexpl) that expects a 128 bit
+	 argument.  */
+      if (! TARGET_LONG_DOUBLE_128)
+	{
+	  if ((tdecl = builtin_decl_explicit (BUILT_IN_FMODL)) != NULL_TREE)
+	    set_user_assembler_name (tdecl, "fmod");
+	  if ((tdecl = builtin_decl_explicit (BUILT_IN_FREXPL)) != NULL_TREE)
+	    set_user_assembler_name (tdecl, "frexp");
+	  if ((tdecl = builtin_decl_explicit (BUILT_IN_LDEXPL)) != NULL_TREE)
+	    set_user_assembler_name (tdecl, "ldexp");
+	  if ((tdecl = builtin_decl_explicit (BUILT_IN_MODFL)) != NULL_TREE)
+	    set_user_assembler_name (tdecl, "modf");
+	}
+    }
 
 #ifdef SUBTARGET_INIT_BUILTINS
   SUBTARGET_INIT_BUILTINS;
@@ -17056,7 +17137,6 @@ altivec_init_builtins (void)
   size_t i;
   tree ftype;
   tree decl;
-  HOST_WIDE_INT builtin_mask = rs6000_builtin_mask;
 
   tree pvoid_type_node = build_pointer_type (void_type_node);
 
@@ -17418,17 +17498,8 @@ altivec_init_builtins (void)
   d = bdesc_dst;
   for (i = 0; i < ARRAY_SIZE (bdesc_dst); i++, d++)
     {
-      HOST_WIDE_INT mask = d->mask;
-
       /* It is expected that these dst built-in functions may have
 	 d->icode equal to CODE_FOR_nothing.  */
-      if ((mask & builtin_mask) != mask)
-	{
-	  if (TARGET_DEBUG_BUILTIN)
-	    fprintf (stderr, "altivec_init_builtins, skip dst %s\n",
-		     d->name);
-	  continue;
-	}
       def_builtin (d->name, void_ftype_pcvoid_int_int, d->code);
     }
 
@@ -17438,15 +17509,6 @@ altivec_init_builtins (void)
     {
       machine_mode mode1;
       tree type;
-      HOST_WIDE_INT mask = d->mask;
-
-      if ((mask & builtin_mask) != mask)
-	{
-	  if (TARGET_DEBUG_BUILTIN)
-	    fprintf (stderr, "altivec_init_builtins, skip predicate %s\n",
-		     d->name);
-	  continue;
-	}
 
       if (rs6000_overloaded_builtin_p (d->code))
 	mode1 = VOIDmode;
@@ -17493,15 +17555,6 @@ altivec_init_builtins (void)
     {
       machine_mode mode0;
       tree type;
-      HOST_WIDE_INT mask = d->mask;
-
-      if ((mask & builtin_mask) != mask)
-	{
-	  if (TARGET_DEBUG_BUILTIN)
-	    fprintf (stderr, "altivec_init_builtins, skip abs %s\n",
-		     d->name);
-	  continue;
-	}
 
       /* Cannot define builtin if the instruction is disabled.  */
       gcc_assert (d->icode != CODE_FOR_nothing);
@@ -17881,6 +17934,41 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     case ALTIVEC_BUILTIN_VMINUW:
     case P8V_BUILTIN_VMAXUD:
     case P8V_BUILTIN_VMINUD:
+    case ALTIVEC_BUILTIN_VAND_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VAND_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VANDC_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VNOR_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VOR_V2DI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V16QI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V8HI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V4SI_UNS:
+    case ALTIVEC_BUILTIN_VXOR_V2DI_UNS:
+    case P8V_BUILTIN_EQV_V16QI_UNS:
+    case P8V_BUILTIN_EQV_V8HI_UNS:
+    case P8V_BUILTIN_EQV_V4SI_UNS:
+    case P8V_BUILTIN_EQV_V2DI_UNS:
+    case P8V_BUILTIN_EQV_V1TI_UNS:
+    case P8V_BUILTIN_NAND_V16QI_UNS:
+    case P8V_BUILTIN_NAND_V8HI_UNS:
+    case P8V_BUILTIN_NAND_V4SI_UNS:
+    case P8V_BUILTIN_NAND_V2DI_UNS:
+    case P8V_BUILTIN_NAND_V1TI_UNS:
+    case P8V_BUILTIN_ORC_V16QI_UNS:
+    case P8V_BUILTIN_ORC_V8HI_UNS:
+    case P8V_BUILTIN_ORC_V4SI_UNS:
+    case P8V_BUILTIN_ORC_V2DI_UNS:
+    case P8V_BUILTIN_ORC_V1TI_UNS:
       h.uns_p[0] = 1;
       h.uns_p[1] = 1;
       h.uns_p[2] = 1;
@@ -20926,6 +21014,9 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)
 
 static rs6000_stack_t stack_info;
 
+/* Set if HARD_FRAM_POINTER_REGNUM is really needed.  */
+static bool frame_pointer_needed_indeed = false;
+
 /* Function to init struct machine_function.
    This will be called, via a pointer variable,
    from push_function_context.  */
@@ -23092,7 +23183,11 @@ rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)
   if (rtx_equal_p (op0, true_cond) && rtx_equal_p (op1, false_cond))
     ;
 
-  else if (rtx_equal_p (op1, true_cond) && rtx_equal_p (op0, false_cond))
+  /* Only when NaNs and signed-zeros are not in effect, smax could be
+     used for `op0 < op1 ? op1 : op0`, and smin could be used for
+     `op0 > op1 ? op1 : op0`.  */
+  else if (rtx_equal_p (op1, true_cond) && rtx_equal_p (op0, false_cond)
+	   && !HONOR_NANS (compare_mode) && !HONOR_SIGNED_ZEROS (compare_mode))
     max_p = !max_p;
 
   else
@@ -26856,9 +26951,9 @@ static void
 rs6000_emit_prologue_components (sbitmap components)
 {
   rs6000_stack_t *info = rs6000_stack_info ();
-  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed
-			     ? HARD_FRAME_POINTER_REGNUM
-			     : STACK_POINTER_REGNUM);
+  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed_indeed
+				      ? HARD_FRAME_POINTER_REGNUM
+				      : STACK_POINTER_REGNUM);
 
   machine_mode reg_mode = Pmode;
   int reg_size = TARGET_32BIT ? 4 : 8;
@@ -26936,9 +27031,9 @@ static void
 rs6000_emit_epilogue_components (sbitmap components)
 {
   rs6000_stack_t *info = rs6000_stack_info ();
-  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed
-			     ? HARD_FRAME_POINTER_REGNUM
-			     : STACK_POINTER_REGNUM);
+  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed_indeed
+				      ? HARD_FRAME_POINTER_REGNUM
+				      : STACK_POINTER_REGNUM);
 
   machine_mode reg_mode = Pmode;
   int reg_size = TARGET_32BIT ? 4 : 8;
@@ -27116,7 +27211,10 @@ rs6000_emit_prologue (void)
                            && (lookup_attribute ("no_split_stack",
                                                  DECL_ATTRIBUTES (cfun->decl))
                                == NULL));
- 
+
+  frame_pointer_needed_indeed
+    = frame_pointer_needed && df_regs_ever_live_p (HARD_FRAME_POINTER_REGNUM);
+
   /* Offset to top of frame for frame_reg and sp respectively.  */
   HOST_WIDE_INT frame_off = 0;
   HOST_WIDE_INT sp_off = 0;
@@ -27778,7 +27876,7 @@ rs6000_emit_prologue (void)
     }
 
   /* Set frame pointer, if needed.  */
-  if (frame_pointer_needed)
+  if (frame_pointer_needed_indeed)
     {
       insn = emit_move_insn (gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM),
 			     sp_reg_rtx);
@@ -28622,7 +28720,7 @@ rs6000_emit_epilogue (int sibcall)
     }
   /* If we have a frame pointer, we can restore the old stack pointer
      from it.  */
-  else if (frame_pointer_needed)
+  else if (frame_pointer_needed_indeed)
     {
       frame_reg_rtx = sp_reg_rtx;
       if (DEFAULT_ABI == ABI_V4)
@@ -33063,8 +33161,9 @@ rs6000_longcall_ref (rtx call_ref, rtx arg)
       rtx reg = gen_rtx_REG (Pmode, regno);
       rtx hi = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, base, call_ref, arg),
 			       UNSPEC_PLT16_HA);
-      rtx lo = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, reg, call_ref, arg),
-			       UNSPEC_PLT16_LO);
+      rtx lo = gen_rtx_UNSPEC_VOLATILE (Pmode,
+					gen_rtvec (3, reg, call_ref, arg),
+					UNSPECV_PLT16_LO);
       emit_insn (gen_rtx_SET (reg, hi));
       emit_insn (gen_rtx_SET (reg, lo));
       return reg;
@@ -37399,6 +37498,7 @@ rs6000_disable_incompatible_switches (void)
     { OPTION_MASK_P9_VECTOR,	OTHER_P9_VECTOR_MASKS,	"power9-vector"	},
     { OPTION_MASK_P8_VECTOR,	OTHER_P8_VECTOR_MASKS,	"power8-vector"	},
     { OPTION_MASK_VSX,		OTHER_VSX_VECTOR_MASKS,	"vsx"		},
+    { OPTION_MASK_ALTIVEC,	OTHER_ALTIVEC_MASKS,	"altivec"	},
   };
 
   for (i = 0; i < ARRAY_SIZE (flags); i++)
@@ -39268,7 +39368,9 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 
       tree fenv_var = create_tmp_var_raw (double_type_node);
       TREE_ADDRESSABLE (fenv_var) = 1;
-      tree fenv_addr = build1 (ADDR_EXPR, double_ptr_type_node, fenv_var);
+      tree fenv_addr = build1 (ADDR_EXPR, double_ptr_type_node,
+			       build4 (TARGET_EXPR, double_type_node, fenv_var,
+				       void_node, NULL_TREE, NULL_TREE));
 
       *hold = build_call_expr (atomic_hold_decl, 1, fenv_addr);
       *clear = build_call_expr (atomic_clear_decl, 0);
@@ -39291,12 +39393,13 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 
   /* Mask to clear everything except for the rounding modes and non-IEEE
      arithmetic flag.  */
-  const unsigned HOST_WIDE_INT hold_exception_mask =
-    HOST_WIDE_INT_C (0xffffffff00000007);
+  const unsigned HOST_WIDE_INT hold_exception_mask
+    = HOST_WIDE_INT_C (0xffffffff00000007);
 
   tree fenv_var = create_tmp_var_raw (double_type_node);
 
-  tree hold_mffs = build2 (MODIFY_EXPR, void_type_node, fenv_var, call_mffs);
+  tree hold_mffs = build4 (TARGET_EXPR, double_type_node, fenv_var, call_mffs,
+			   NULL_TREE, NULL_TREE);
 
   tree fenv_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, fenv_var);
   tree fenv_llu_and = build2 (BIT_AND_EXPR, uint64_type_node, fenv_llu,
@@ -39320,12 +39423,13 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 
   /* Mask to clear everything except for the rounding modes and non-IEEE
      arithmetic flag.  */
-  const unsigned HOST_WIDE_INT clear_exception_mask =
-    HOST_WIDE_INT_C (0xffffffff00000000);
+  const unsigned HOST_WIDE_INT clear_exception_mask
+    = HOST_WIDE_INT_C (0xffffffff00000000);
 
   tree fenv_clear = create_tmp_var_raw (double_type_node);
 
-  tree clear_mffs = build2 (MODIFY_EXPR, void_type_node, fenv_clear, call_mffs);
+  tree clear_mffs = build4 (TARGET_EXPR, double_type_node, fenv_clear,
+			    call_mffs, NULL_TREE, NULL_TREE);
 
   tree fenv_clean_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, fenv_clear);
   tree fenv_clear_llu_and = build2 (BIT_AND_EXPR, uint64_type_node,
@@ -39350,13 +39454,14 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
                                 (*(uint64_t*)fenv_var 0x1ff80fff);
      __builtin_mtfsf (0xff, fenv_update);  */
 
-  const unsigned HOST_WIDE_INT update_exception_mask =
-    HOST_WIDE_INT_C (0xffffffff1fffff00);
-  const unsigned HOST_WIDE_INT new_exception_mask =
-    HOST_WIDE_INT_C (0x1ff80fff);
+  const unsigned HOST_WIDE_INT update_exception_mask
+    = HOST_WIDE_INT_C (0xffffffff1fffff00);
+  const unsigned HOST_WIDE_INT new_exception_mask
+    = HOST_WIDE_INT_C (0x1ff80fff);
 
   tree old_fenv = create_tmp_var_raw (double_type_node);
-  tree update_mffs = build2 (MODIFY_EXPR, void_type_node, old_fenv, call_mffs);
+  tree update_mffs = build4 (TARGET_EXPR, double_type_node, old_fenv,
+			     call_mffs, NULL_TREE, NULL_TREE);
 
   tree old_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, old_fenv);
   tree old_llu_and = build2 (BIT_AND_EXPR, uint64_type_node, old_llu,
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index a768f5dd511..db7ed60a2cf 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -152,7 +152,6 @@
    UNSPEC_SI_FROM_SF
    UNSPEC_PLTSEQ
    UNSPEC_PLT16_HA
-   UNSPEC_PLT16_LO
   ])
 
 ;;
@@ -181,6 +180,7 @@
    UNSPECV_MTFSB1		; Set FPSCR Field bit to 1
    UNSPECV_SPLIT_STACK_RETURN   ; A camouflaged return
    UNSPECV_SPEC_BARRIER         ; Speculation barrier
+   UNSPECV_PLT16_LO
   ])
 
 
@@ -10162,10 +10162,10 @@
 
 (define_insn "*pltseq_plt16_lo_<mode>"
   [(set (match_operand:P 0 "gpc_reg_operand" "=r")
-	(unspec:P [(match_operand:P 1 "gpc_reg_operand" "b")
-		   (match_operand:P 2 "symbol_ref_operand" "s")
-		   (match_operand:P 3 "" "")]
-		  UNSPEC_PLT16_LO))]
+	(unspec_volatile:P [(match_operand:P 1 "gpc_reg_operand" "b")
+			    (match_operand:P 2 "symbol_ref_operand" "s")
+			    (match_operand:P 3 "" "")]
+			   UNSPECV_PLT16_LO))]
   "TARGET_PLTSEQ"
 {
   return rs6000_pltseq_template (operands, 2);
@@ -13430,18 +13430,19 @@
 
   if (!TARGET_P9_MISC)
     {
-       rtx tmp_di = gen_reg_rtx (DImode);
-       rtx tmp_df = gen_reg_rtx (DFmode);
+      rtx tmp1 = gen_reg_rtx (DFmode);
 
-       /* The mffs instruction reads the entire FPSCR.  Emulate the mffsl
-          instruction using the mffs instruction and masking off the bits
-          the mmsl instruciton actually reads.  */
-       emit_insn (gen_rs6000_mffs (tmp_df));
-       tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);
-       emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0x70007f0ffLL)));
+      /* The mffs instruction reads the entire FPSCR.  Emulate the mffsl
+	 instruction using the mffs instruction and masking the result.  */
+      emit_insn (gen_rs6000_mffs (tmp1));
 
-       operands[0] = simplify_gen_subreg (DFmode, tmp_di, DImode, 0);
-       DONE;
+      rtx tmp1di = simplify_gen_subreg (DImode, tmp1, DFmode, 0);
+      rtx tmp2 = gen_reg_rtx (DImode);
+      emit_insn (gen_anddi3 (tmp2, tmp1di, GEN_INT (0x70007f0ffLL)));
+
+      rtx tmp2df = simplify_gen_subreg (DFmode, tmp2, DImode, 0);
+      emit_move_insn (operands[0], tmp2df);
+      DONE;
     }
 
     emit_insn (gen_rs6000_mffsl_hw (operands[0]));
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index 0b62dd04bde..f90489c0203 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -1322,7 +1322,8 @@
   emit_move_insn (zero_reg, CONST0_RTX (<MODE>mode));
   if (!BYTES_BIG_ENDIAN)
     {
-      byteshift_val = 16 - byteshift_val;
+      /* Note, byteshift_val can be 0!  */
+      byteshift_val = -byteshift_val & 15;
       op1 = zero_reg;
       op2 = operands[1];
     }
diff --git a/gcc/config/rs6000/vsx.md b/gcc/config/rs6000/vsx.md
index 607c0cd33f2..2e998a3a990 100644
--- a/gcc/config/rs6000/vsx.md
+++ b/gcc/config/rs6000/vsx.md
@@ -386,6 +386,7 @@
    UNSPEC_VSX_SIGN_EXTEND
    UNSPEC_VSX_XVCVSPSXWS
    UNSPEC_VSX_XVCVSPSXDS
+   UNSPEC_VSX_XVCVSPHP
    UNSPEC_VSX_VSLO
    UNSPEC_VSX_EXTRACT
    UNSPEC_VSX_SXEXPDP
@@ -2223,6 +2224,15 @@
   "xvcvhpsp %x0,%x1"
   [(set_attr "type" "vecfloat")])
 
+;; Generate xvcvsphp
+(define_insn "vsx_xvcvsphp"
+  [(set (match_operand:V4SI 0 "register_operand" "=wa")
+	(unspec:V4SI [(match_operand:V4SF 1 "vsx_register_operand" "wa")]
+		     UNSPEC_VSX_XVCVSPHP))]
+  "TARGET_P9_VECTOR"
+  "xvcvsphp %x0,%x1"
+[(set_attr "type" "vecfloat")])
+
 ;; xscvdpsp used for splat'ing a scalar to V4SF, knowing that the internal SF
 ;; format of scalars is actually DF.
 (define_insn "vsx_xscvdpsp_scalar"
@@ -3292,14 +3302,14 @@
   "vslo %0,%1,%2"
   [(set_attr "type" "vecperm")])
 
-;; Variable V2DI/V2DF extract
+;; Variable V2DI/V2DF extract from a register
 (define_insn_and_split "vsx_extract_<mode>_var"
-  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=v,<VSa>,r")
-	(unspec:<VS_scalar> [(match_operand:VSX_D 1 "input_operand" "v,m,m")
-			     (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=v")
+	(unspec:<VS_scalar> [(match_operand:VSX_D 1 "gpc_reg_operand" "v")
+			     (match_operand:DI 2 "gpc_reg_operand" "r")]
 			    UNSPEC_VSX_EXTRACT))
-   (clobber (match_scratch:DI 3 "=r,&b,&b"))
-   (clobber (match_scratch:V2DI 4 "=&v,X,X"))]
+   (clobber (match_scratch:DI 3 "=r"))
+   (clobber (match_scratch:V2DI 4 "=&v"))]
   "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT"
   "#"
   "&& reload_completed"
@@ -3310,6 +3320,23 @@
   DONE;
 })
 
+;; Variable V2DI/V2DF extract from memory
+(define_insn_and_split "*vsx_extract_<mode>_var_load"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=wa,r")
+	(unspec:<VS_scalar> [(match_operand:VSX_D 1 "memory_operand" "Q,Q")
+			     (match_operand:DI 2 "gpc_reg_operand" "r,r")]
+			    UNSPEC_VSX_EXTRACT))
+   (clobber (match_scratch:DI 3 "=&b,&b"))]
+  "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (match_dup 4))]
+{
+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],
+					   operands[3], <VS_scalar>mode);
+}
+  [(set_attr "type" "fpload,load")])
+
 ;; Extract a SF element from V4SF
 (define_insn_and_split "vsx_extract_v4sf"
   [(set (match_operand:SF 0 "vsx_register_operand" "=ww")
@@ -3361,14 +3388,14 @@
   [(set_attr "type" "fpload,fpload,fpload,load")
    (set_attr "length" "8")])
 
-;; Variable V4SF extract
+;; Variable V4SF extract from a register
 (define_insn_and_split "vsx_extract_v4sf_var"
-  [(set (match_operand:SF 0 "gpc_reg_operand" "=ww,ww,?r")
-	(unspec:SF [(match_operand:V4SF 1 "input_operand" "v,m,m")
-		    (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
+  [(set (match_operand:SF 0 "gpc_reg_operand" "=wa")
+	(unspec:SF [(match_operand:V4SF 1 "gpc_reg_operand" "v")
+		    (match_operand:DI 2 "gpc_reg_operand" "r")]
 		   UNSPEC_VSX_EXTRACT))
-   (clobber (match_scratch:DI 3 "=r,&b,&b"))
-   (clobber (match_scratch:V2DI 4 "=&v,X,X"))]
+   (clobber (match_scratch:DI 3 "=r"))
+   (clobber (match_scratch:V2DI 4 "=&v"))]
   "VECTOR_MEM_VSX_P (V4SFmode) && TARGET_DIRECT_MOVE_64BIT"
   "#"
   "&& reload_completed"
@@ -3379,6 +3406,23 @@
   DONE;
 })
 
+;; Variable V4SF extract from memory
+(define_insn_and_split "*vsx_extract_v4sf_var_load"
+  [(set (match_operand:SF 0 "gpc_reg_operand" "=wa,?r")
+	(unspec:SF [(match_operand:V4SF 1 "memory_operand" "Q,Q")
+		    (match_operand:DI 2 "gpc_reg_operand" "r,r")]
+		   UNSPEC_VSX_EXTRACT))
+   (clobber (match_scratch:DI 3 "=&b,&b"))]
+  "VECTOR_MEM_VSX_P (V4SFmode) && TARGET_DIRECT_MOVE_64BIT"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (match_dup 4))]
+{
+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],
+					   operands[3], SFmode);
+}
+  [(set_attr "type" "fpload,load")])
+
 ;; Expand the builtin form of xxpermdi to canonical rtl.
 (define_expand "vsx_xxpermdi_<mode>"
   [(match_operand:VSX_L 0 "vsx_register_operand")
@@ -3720,15 +3764,15 @@
   [(set_attr "type" "load")
    (set_attr "length" "8")])
 
-;; Variable V16QI/V8HI/V4SI extract
+;; Variable V16QI/V8HI/V4SI extract from a register
 (define_insn_and_split "vsx_extract_<mode>_var"
-  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r")
 	(unspec:<VS_scalar>
-	 [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
-	  (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
+	 [(match_operand:VSX_EXTRACT_I 1 "gpc_reg_operand" "wK,v")
+	  (match_operand:DI 2 "gpc_reg_operand" "r,r")]
 	 UNSPEC_VSX_EXTRACT))
-   (clobber (match_scratch:DI 3 "=r,r,&b"))
-   (clobber (match_scratch:V2DI 4 "=X,&v,X"))]
+   (clobber (match_scratch:DI 3 "=r,r"))
+   (clobber (match_scratch:V2DI 4 "=X,&v"))]
   "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT"
   "#"
   "&& reload_completed"
@@ -3739,6 +3783,24 @@
   DONE;
 })
 
+;; Variable V16QI/V8HI/V4SI extract from memory
+(define_insn_and_split "*vsx_extract_<mode>_var_load"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r")
+	(unspec:<VS_scalar>
+	 [(match_operand:VSX_EXTRACT_I 1 "memory_operand" "Q")
+	  (match_operand:DI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_VSX_EXTRACT))
+   (clobber (match_scratch:DI 3 "=&b"))]
+  "VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (match_dup 4))]
+{
+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],
+					   operands[3], <VS_scalar>mode);
+}
+  [(set_attr "type" "load")])
+
 (define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
   [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
 	(zero_extend:<VS_scalar>
@@ -4794,8 +4856,8 @@
   rtx cmp_result = gen_reg_rtx (<MODE>mode);
   rtx not_result = gen_reg_rtx (<MODE>mode);
 
-  emit_insn (gen_vcmpnez<VSX_EXTRACT_WIDTH> (cmp_result, operands[1],
-					     operands[2]));
+  emit_insn (gen_vcmpne<VSX_EXTRACT_WIDTH> (cmp_result, operands[1],
+					    operands[2]));
   emit_insn (gen_one_cmpl<mode>2 (not_result, cmp_result));
 
   sh = GET_MODE_SIZE (GET_MODE_INNER (<MODE>mode)) / 2;
diff --git a/gcc/config/s390/constraints.md b/gcc/config/s390/constraints.md
index 4055cbc7c68..ec2a13499e7 100644
--- a/gcc/config/s390/constraints.md
+++ b/gcc/config/s390/constraints.md
@@ -38,6 +38,8 @@
 ;;              matching K constraint
 ;;         jm6: An integer operand with the lowest order 6 bits all ones.
 ;;         jdd: A constant operand that fits into the data section.
+;;         j>f: An integer operand whose lower 32 bits are greater than or equal to 15
+;;         jb4: An unsigned constant 4 bit operand.
 ;;    t -- Access registers 36 and 37.
 ;;    v -- Vector registers v0-v31.
 ;;    C -- A signed 8-bit constant (-128..127)
@@ -413,7 +415,7 @@
 
 
 ;;
-;; Vector constraints follow.
+;; Vector and scalar constraints for constant values follow.
 ;;
 
 (define_constraint "j00"
@@ -450,6 +452,16 @@
   "@internal An integer operand with the lowest order 6 bits all ones."
   (match_operand 0 "const_int_6bitset_operand"))
 
+(define_constraint "j>f"
+  "@internal An integer operand whose lower 32 bits are greater than or equal to 15."
+  (and (match_code "const_int")
+       (match_test "(unsigned int)(ival & 0xffffffff) >= 15")))
+
+(define_constraint "jb4"
+  "@internal Constant unsigned integer 4 bit value"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 15")))
+
 ;;
 ;; Memory constraints follow.
 ;;
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
index 53398a98e9e..9e868b7c818 100644
--- a/gcc/config/s390/s390-builtin-types.def
+++ b/gcc/config/s390/s390-builtin-types.def
@@ -301,6 +301,7 @@ DEF_FN_TYPE_3 (BT_FN_UV16QI_UV2DI_UV2DI_UV16QI, BT_UV16QI, BT_UV2DI, BT_UV2DI, B
 DEF_FN_TYPE_3 (BT_FN_UV16QI_UV8HI_UV8HI_INTPTR, BT_UV16QI, BT_UV8HI, BT_UV8HI, BT_INTPTR)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_ULONGLONG_INT, BT_UV2DI, BT_UV2DI, BT_ULONGLONG, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UV2DI_INT, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_UV2DI_UV2DI_UV2DI_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI, BT_UV2DI)
 DEF_FN_TYPE_3 (BT_FN_UV2DI_UV4SI_UV4SI_UV2DI, BT_UV2DI, BT_UV4SI, BT_UV4SI, BT_UV2DI)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UV2DI_UV2DI_INTPTR, BT_UV4SI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
 DEF_FN_TYPE_3 (BT_FN_UV4SI_UV4SI_UINT_INT, BT_UV4SI, BT_UV4SI, BT_UINT, BT_INT)
@@ -322,6 +323,7 @@ DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_DBL_INT, BT_V2DF, BT_V2DF, BT_DBL, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_UCHAR_UCHAR, BT_V2DF, BT_V2DF, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_UINT_UINT, BT_V2DF, BT_V2DF, BT_UINT, BT_UINT)
 DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_V2DF_INT, BT_V2DF, BT_V2DF, BT_V2DF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_V2DF_UV2DI, BT_V2DF, BT_V2DF, BT_V2DF, BT_UV2DI)
 DEF_FN_TYPE_3 (BT_FN_V2DF_V2DF_V2DF_V2DF, BT_V2DF, BT_V2DF, BT_V2DF, BT_V2DF)
 DEF_FN_TYPE_3 (BT_FN_V2DI_UV2DI_UV2DI_INTPTR, BT_V2DI, BT_UV2DI, BT_UV2DI, BT_INTPTR)
 DEF_FN_TYPE_3 (BT_FN_V2DI_V2DF_INT_INTPTR, BT_V2DI, BT_V2DF, BT_INT, BT_INTPTR)
@@ -332,6 +334,7 @@ DEF_FN_TYPE_3 (BT_FN_V4SF_V2DF_INT_INT, BT_V4SF, BT_V2DF, BT_INT, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V4SF_V4SF_FLT_INT, BT_V4SF, BT_V4SF, BT_FLT, BT_INT)
 DEF_FN_TYPE_3 (BT_FN_V4SF_V4SF_UCHAR_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR, BT_UCHAR)
 DEF_FN_TYPE_3 (BT_FN_V4SF_V4SF_V4SF_INT, BT_V4SF, BT_V4SF, BT_V4SF, BT_INT)
+DEF_FN_TYPE_3 (BT_FN_V4SF_V4SF_V4SF_UV4SI, BT_V4SF, BT_V4SF, BT_V4SF, BT_UV4SI)
 DEF_FN_TYPE_3 (BT_FN_V4SF_V4SF_V4SF_V4SF, BT_V4SF, BT_V4SF, BT_V4SF, BT_V4SF)
 DEF_FN_TYPE_3 (BT_FN_V4SI_UV4SI_UV4SI_INTPTR, BT_V4SI, BT_UV4SI, BT_UV4SI, BT_INTPTR)
 DEF_FN_TYPE_3 (BT_FN_V4SI_V2DI_V2DI_INTPTR, BT_V4SI, BT_V2DI, BT_V2DI, BT_INTPTR)
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index 3f39b9d3b88..b31abc6af9b 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -687,36 +687,41 @@ B_DEF      (s390_vsceg,                 vec_scatter_elementv2di,0,
 
 /* First two operands are swapped in s390-c.c */
 OB_DEF     (s390_vec_sel,               s390_vec_sel_b8_a,  s390_vec_sel_dbl_b, B_VX,               BT_FN_OV4SI_OV4SI_OV4SI_OV4SI)
-OB_DEF_VAR (s390_vec_sel_b8_a,          s390_vsel,          0,                  0,                  BT_OV_BV16QI_BV16QI_BV16QI_UV16QI)
-OB_DEF_VAR (s390_vec_sel_b8_b,          s390_vsel,          0,                  0,                  BT_OV_BV16QI_BV16QI_BV16QI_BV16QI)
-OB_DEF_VAR (s390_vec_sel_s8_a,          s390_vsel,          0,                  0,                  BT_OV_V16QI_V16QI_V16QI_UV16QI)
-OB_DEF_VAR (s390_vec_sel_s8_b,          s390_vsel,          0,                  0,                  BT_OV_V16QI_V16QI_V16QI_BV16QI)
-OB_DEF_VAR (s390_vec_sel_u8_a,          s390_vsel,          0,                  0,                  BT_OV_UV16QI_UV16QI_UV16QI_UV16QI)
-OB_DEF_VAR (s390_vec_sel_u8_b,          s390_vsel,          0,                  0,                  BT_OV_UV16QI_UV16QI_UV16QI_BV16QI)
-OB_DEF_VAR (s390_vec_sel_b16_a,         s390_vsel,          0,                  0,                  BT_OV_BV8HI_BV8HI_BV8HI_UV8HI)
-OB_DEF_VAR (s390_vec_sel_b16_b,         s390_vsel,          0,                  0,                  BT_OV_BV8HI_BV8HI_BV8HI_BV8HI)
-OB_DEF_VAR (s390_vec_sel_s16_a,         s390_vsel,          0,                  0,                  BT_OV_V8HI_V8HI_V8HI_UV8HI)
-OB_DEF_VAR (s390_vec_sel_s16_b,         s390_vsel,          0,                  0,                  BT_OV_V8HI_V8HI_V8HI_BV8HI)
-OB_DEF_VAR (s390_vec_sel_u16_a,         s390_vsel,          0,                  0,                  BT_OV_UV8HI_UV8HI_UV8HI_UV8HI)
-OB_DEF_VAR (s390_vec_sel_u16_b,         s390_vsel,          0,                  0,                  BT_OV_UV8HI_UV8HI_UV8HI_BV8HI)
-OB_DEF_VAR (s390_vec_sel_b32_a,         s390_vsel,          0,                  0,                  BT_OV_BV4SI_BV4SI_BV4SI_UV4SI)
-OB_DEF_VAR (s390_vec_sel_b32_b,         s390_vsel,          0,                  0,                  BT_OV_BV4SI_BV4SI_BV4SI_BV4SI)
-OB_DEF_VAR (s390_vec_sel_s32_a,         s390_vsel,          0,                  0,                  BT_OV_V4SI_V4SI_V4SI_UV4SI)
-OB_DEF_VAR (s390_vec_sel_s32_b,         s390_vsel,          0,                  0,                  BT_OV_V4SI_V4SI_V4SI_BV4SI)
-OB_DEF_VAR (s390_vec_sel_u32_a,         s390_vsel,          0,                  0,                  BT_OV_UV4SI_UV4SI_UV4SI_UV4SI)
-OB_DEF_VAR (s390_vec_sel_u32_b,         s390_vsel,          0,                  0,                  BT_OV_UV4SI_UV4SI_UV4SI_BV4SI)
-OB_DEF_VAR (s390_vec_sel_b64_a,         s390_vsel,          0,                  0,                  BT_OV_BV2DI_BV2DI_BV2DI_UV2DI)
-OB_DEF_VAR (s390_vec_sel_b64_b,         s390_vsel,          0,                  0,                  BT_OV_BV2DI_BV2DI_BV2DI_BV2DI)
-OB_DEF_VAR (s390_vec_sel_s64_a,         s390_vsel,          0,                  0,                  BT_OV_V2DI_V2DI_V2DI_UV2DI)
-OB_DEF_VAR (s390_vec_sel_s64_b,         s390_vsel,          0,                  0,                  BT_OV_V2DI_V2DI_V2DI_BV2DI)
-OB_DEF_VAR (s390_vec_sel_u64_a,         s390_vsel,          0,                  0,                  BT_OV_UV2DI_UV2DI_UV2DI_UV2DI)
-OB_DEF_VAR (s390_vec_sel_u64_b,         s390_vsel,          0,                  0,                  BT_OV_UV2DI_UV2DI_UV2DI_BV2DI)
-OB_DEF_VAR (s390_vec_sel_flt_a,         s390_vsel,          B_VXE,              0,                  BT_OV_V4SF_V4SF_V4SF_UV4SI)
-OB_DEF_VAR (s390_vec_sel_flt_b,         s390_vsel,          B_VXE,              0,                  BT_OV_V4SF_V4SF_V4SF_BV4SI)
-OB_DEF_VAR (s390_vec_sel_dbl_a,         s390_vsel,          0,                  0,                  BT_OV_V2DF_V2DF_V2DF_UV2DI)
-OB_DEF_VAR (s390_vec_sel_dbl_b,         s390_vsel,          0,                  0,                  BT_OV_V2DF_V2DF_V2DF_BV2DI)
-
-B_DEF      (s390_vsel,                  vec_selv16qi,       0,                  B_VX,               0,                  BT_FN_UV16QI_UV16QI_UV16QI_UV16QI)
+OB_DEF_VAR (s390_vec_sel_b8_a,          s390_vselb,         0,                  0,                  BT_OV_BV16QI_BV16QI_BV16QI_UV16QI)
+OB_DEF_VAR (s390_vec_sel_b8_b,          s390_vselb,         0,                  0,                  BT_OV_BV16QI_BV16QI_BV16QI_BV16QI)
+OB_DEF_VAR (s390_vec_sel_s8_a,          s390_vselb,         0,                  0,                  BT_OV_V16QI_V16QI_V16QI_UV16QI)
+OB_DEF_VAR (s390_vec_sel_s8_b,          s390_vselb,         0,                  0,                  BT_OV_V16QI_V16QI_V16QI_BV16QI)
+OB_DEF_VAR (s390_vec_sel_u8_a,          s390_vselb,         0,                  0,                  BT_OV_UV16QI_UV16QI_UV16QI_UV16QI)
+OB_DEF_VAR (s390_vec_sel_u8_b,          s390_vselb,         0,                  0,                  BT_OV_UV16QI_UV16QI_UV16QI_BV16QI)
+OB_DEF_VAR (s390_vec_sel_b16_a,         s390_vselh,         0,                  0,                  BT_OV_BV8HI_BV8HI_BV8HI_UV8HI)
+OB_DEF_VAR (s390_vec_sel_b16_b,         s390_vselh,         0,                  0,                  BT_OV_BV8HI_BV8HI_BV8HI_BV8HI)
+OB_DEF_VAR (s390_vec_sel_s16_a,         s390_vselh,         0,                  0,                  BT_OV_V8HI_V8HI_V8HI_UV8HI)
+OB_DEF_VAR (s390_vec_sel_s16_b,         s390_vselh,         0,                  0,                  BT_OV_V8HI_V8HI_V8HI_BV8HI)
+OB_DEF_VAR (s390_vec_sel_u16_a,         s390_vselh,         0,                  0,                  BT_OV_UV8HI_UV8HI_UV8HI_UV8HI)
+OB_DEF_VAR (s390_vec_sel_u16_b,         s390_vselh,         0,                  0,                  BT_OV_UV8HI_UV8HI_UV8HI_BV8HI)
+OB_DEF_VAR (s390_vec_sel_b32_a,         s390_vself,         0,                  0,                  BT_OV_BV4SI_BV4SI_BV4SI_UV4SI)
+OB_DEF_VAR (s390_vec_sel_b32_b,         s390_vself,         0,                  0,                  BT_OV_BV4SI_BV4SI_BV4SI_BV4SI)
+OB_DEF_VAR (s390_vec_sel_s32_a,         s390_vself,         0,                  0,                  BT_OV_V4SI_V4SI_V4SI_UV4SI)
+OB_DEF_VAR (s390_vec_sel_s32_b,         s390_vself,         0,                  0,                  BT_OV_V4SI_V4SI_V4SI_BV4SI)
+OB_DEF_VAR (s390_vec_sel_u32_a,         s390_vself,         0,                  0,                  BT_OV_UV4SI_UV4SI_UV4SI_UV4SI)
+OB_DEF_VAR (s390_vec_sel_u32_b,         s390_vself,         0,                  0,                  BT_OV_UV4SI_UV4SI_UV4SI_BV4SI)
+OB_DEF_VAR (s390_vec_sel_b64_a,         s390_vselg,         0,                  0,                  BT_OV_BV2DI_BV2DI_BV2DI_UV2DI)
+OB_DEF_VAR (s390_vec_sel_b64_b,         s390_vselg,         0,                  0,                  BT_OV_BV2DI_BV2DI_BV2DI_BV2DI)
+OB_DEF_VAR (s390_vec_sel_s64_a,         s390_vselg,         0,                  0,                  BT_OV_V2DI_V2DI_V2DI_UV2DI)
+OB_DEF_VAR (s390_vec_sel_s64_b,         s390_vselg,         0,                  0,                  BT_OV_V2DI_V2DI_V2DI_BV2DI)
+OB_DEF_VAR (s390_vec_sel_u64_a,         s390_vselg,         0,                  0,                  BT_OV_UV2DI_UV2DI_UV2DI_UV2DI)
+OB_DEF_VAR (s390_vec_sel_u64_b,         s390_vselg,         0,                  0,                  BT_OV_UV2DI_UV2DI_UV2DI_BV2DI)
+OB_DEF_VAR (s390_vec_sel_flt_a,         s390_vself_flt,     B_VXE,              0,                  BT_OV_V4SF_V4SF_V4SF_UV4SI)
+OB_DEF_VAR (s390_vec_sel_flt_b,         s390_vself_flt,     B_VXE,              0,                  BT_OV_V4SF_V4SF_V4SF_BV4SI)
+OB_DEF_VAR (s390_vec_sel_dbl_a,         s390_vselg_dbl,     0,                  0,                  BT_OV_V2DF_V2DF_V2DF_UV2DI)
+OB_DEF_VAR (s390_vec_sel_dbl_b,         s390_vselg_dbl,     0,                  0,                  BT_OV_V2DF_V2DF_V2DF_BV2DI)
+
+B_DEF      (s390_vselb,                 vselv16qi,          0,                  B_VX,               0,                  BT_FN_UV16QI_UV16QI_UV16QI_UV16QI)
+B_DEF      (s390_vselh,                 vselv8hi,           0,                  B_VX,               0,                  BT_FN_UV8HI_UV8HI_UV8HI_UV8HI)
+B_DEF      (s390_vself,                 vselv4si,           0,                  B_VX,               0,                  BT_FN_UV4SI_UV4SI_UV4SI_UV4SI)
+B_DEF      (s390_vselg,                 vselv2di,           0,                  B_VX,               0,                  BT_FN_UV2DI_UV2DI_UV2DI_UV2DI)
+B_DEF      (s390_vself_flt,             vselv4sf,           0,                  B_VXE,              0,                  BT_FN_V4SF_V4SF_V4SF_UV4SI)
+B_DEF      (s390_vselg_dbl,             vselv2df,           0,                  B_VX,               0,                  BT_FN_V2DF_V2DF_V2DF_UV2DI)
 
 OB_DEF     (s390_vec_extend_s64,        s390_vec_extend_s64_s8,s390_vec_extend_s64_s32,B_VX,        BT_FN_OV4SI_OV4SI)
 OB_DEF_VAR (s390_vec_extend_s64_s8,     s390_vsegb,         0,                  0,                  BT_OV_V2DI_V16QI)
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index db3f94978ec..71c0ec0178a 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -7766,15 +7766,13 @@ print_operand (FILE *file, rtx x, int code)
   switch (code)
     {
     case 'A':
-#ifdef HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS
-      if (TARGET_Z14 && MEM_P (x))
+      if (TARGET_VECTOR_LOADSTORE_ALIGNMENT_HINTS && MEM_P (x))
 	{
 	  if (MEM_ALIGN (x) >= 128)
 	    fprintf (file, ",4");
 	  else if (MEM_ALIGN (x) == 64)
 	    fprintf (file, ",3");
 	}
-#endif
       return;
     case 'C':
       fprintf (file, s390_branch_condition_mnemonic (x, FALSE));
@@ -15870,12 +15868,13 @@ s390_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 
      fenv_var = __builtin_s390_efpc ();
      __builtin_s390_sfpc (fenv_var & mask) */
-  tree old_fpc = build2 (MODIFY_EXPR, unsigned_type_node, fenv_var, call_efpc);
-  tree new_fpc =
-    build2 (BIT_AND_EXPR, unsigned_type_node, fenv_var,
-	    build_int_cst (unsigned_type_node,
-			   ~(FPC_DXC_MASK | FPC_FLAGS_MASK |
-			     FPC_EXCEPTION_MASK)));
+  tree old_fpc = build4 (TARGET_EXPR, unsigned_type_node, fenv_var, call_efpc,
+			 NULL_TREE, NULL_TREE);
+  tree new_fpc
+    = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_var,
+	      build_int_cst (unsigned_type_node,
+			     ~(FPC_DXC_MASK | FPC_FLAGS_MASK
+			       | FPC_EXCEPTION_MASK)));
   tree set_new_fpc = build_call_expr (sfpc, 1, new_fpc);
   *hold = build2 (COMPOUND_EXPR, void_type_node, old_fpc, set_new_fpc);
 
@@ -15894,8 +15893,8 @@ s390_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
   __atomic_feraiseexcept ((old_fpc & FPC_FLAGS_MASK) >> FPC_FLAGS_SHIFT);  */
 
   old_fpc = create_tmp_var_raw (unsigned_type_node);
-  tree store_old_fpc = build2 (MODIFY_EXPR, void_type_node,
-			       old_fpc, call_efpc);
+  tree store_old_fpc = build4 (TARGET_EXPR, void_type_node, old_fpc, call_efpc,
+			       NULL_TREE, NULL_TREE);
 
   set_new_fpc = build_call_expr (sfpc, 1, fenv_var);
 
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index f7023d985f1..bd5316ffe94 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -167,6 +167,13 @@ enum processor_flags
 	(TARGET_VX && TARGET_CPU_VXE2)
 #define TARGET_VXE2_P(opts)						\
 	(TARGET_VX_P (opts) && TARGET_CPU_VXE2_P (opts))
+#if defined(HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS_ON_Z13)
+#define TARGET_VECTOR_LOADSTORE_ALIGNMENT_HINTS TARGET_Z13
+#elif defined(HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS)
+#define TARGET_VECTOR_LOADSTORE_ALIGNMENT_HINTS TARGET_Z14
+#else
+#define TARGET_VECTOR_LOADSTORE_ALIGNMENT_HINTS 0
+#endif
 
 #ifdef HAVE_AS_MACHINE_MACHINEMODE
 #define S390_USE_TARGET_ATTRIBUTE 1
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index 21375970c91..d7a4ae64c36 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -111,8 +111,10 @@ __lcbb(const void *ptr, int bndry)
 #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)
 #define vec_doublee(X) __builtin_s390_vfll((X))
 #define vec_floate(X) __builtin_s390_vflr((X), 0, 0)
-#define vec_load_len_r(X,Y) __builtin_s390_vlrl((Y),(X))
-#define vec_store_len_r(X,Y) __builtin_s390_vstrl((Y),(X))
+#define vec_load_len_r(X,L)				\
+  (__vector unsigned char)__builtin_s390_vlrlr((L),(X))
+#define vec_store_len_r(X,Y,L) \
+  __builtin_s390_vstrlr((__vector signed char)(X),(L),(Y))
 
 #define vec_all_nan(a)						\
   __extension__ ({						\
diff --git a/gcc/config/s390/vector.md b/gcc/config/s390/vector.md
index 6ca503b0d44..7c1edf03027 100644
--- a/gcc/config/s390/vector.md
+++ b/gcc/config/s390/vector.md
@@ -855,7 +855,7 @@
 
 (define_expand "popcountv8hi2_vx"
   [(set (match_dup 2)
-	(unspec:V16QI [(subreg:V16QI (match_operand:V8HI 1 "register_operand" "v") 0)]
+	(unspec:V16QI [(match_operand:V8HI 1 "register_operand" "v")]
 		      UNSPEC_POPCNT))
    ; Make a copy of the result
    (set (match_dup 3) (match_dup 2))
@@ -887,6 +887,8 @@
 ]
   "TARGET_VX && !TARGET_VXE"
 {
+  operands[1] = simplify_gen_subreg (V16QImode, operands[1],
+				     V8HImode, 0);
   operands[2] = gen_reg_rtx (V16QImode);
   operands[3] = gen_reg_rtx (V16QImode);
   operands[4] = gen_reg_rtx (V16QImode);
@@ -895,20 +897,21 @@
 
 (define_expand "popcountv4si2_vx"
   [(set (match_dup 2)
-	(unspec:V16QI [(subreg:V16QI (match_operand:V4SI 1 "register_operand" "v") 0)]
+	(unspec:V16QI [(match_operand:V4SI 1 "register_operand" "v")]
 		      UNSPEC_POPCNT))
    (set (match_operand:V4SI 0 "register_operand" "=v")
 	(unspec:V4SI [(match_dup 2) (match_dup 3)]
 		     UNSPEC_VEC_VSUM))]
   "TARGET_VX && !TARGET_VXE"
 {
+  operands[1] = simplify_gen_subreg (V16QImode, operands[1], V4SImode, 0);
   operands[2] = gen_reg_rtx (V16QImode);
   operands[3] = force_reg (V16QImode, CONST0_RTX (V16QImode));
 })
 
 (define_expand "popcountv2di2_vx"
   [(set (match_dup 2)
-	(unspec:V16QI [(subreg:V16QI (match_operand:V2DI 1 "register_operand" "v") 0)]
+	(unspec:V16QI [(match_operand:V2DI 1 "register_operand" "v")]
 		      UNSPEC_POPCNT))
    (set (match_dup 3)
 	(unspec:V4SI [(match_dup 2) (match_dup 4)]
@@ -918,6 +921,7 @@
 		     UNSPEC_VEC_VSUMG))]
   "TARGET_VX && !TARGET_VXE"
 {
+  operands[1] = simplify_gen_subreg (V16QImode, operands[1], V2DImode, 0);
   operands[2] = gen_reg_rtx (V16QImode);
   operands[3] = gen_reg_rtx (V4SImode);
   operands[4] = force_reg (V16QImode, CONST0_RTX (V16QImode));
diff --git a/gcc/config/s390/vx-builtins.md b/gcc/config/s390/vx-builtins.md
index 5ec3fb4fe58..5b6246adc9f 100644
--- a/gcc/config/s390/vx-builtins.md
+++ b/gcc/config/s390/vx-builtins.md
@@ -202,16 +202,34 @@
   "vlbb\t%v0,%1,%2"
   [(set_attr "op_type" "VRX")])
 
-(define_insn "vlrlrv16qi"
-  [(set (match_operand:V16QI              0 "register_operand"  "=v,v")
-	(unspec:V16QI [(match_operand:BLK 2 "memory_operand"     "Q,Q")
-		       (match_operand:SI  1 "nonmemory_operand"  "d,C")]
+; Vector load rightmost with length
+
+(define_expand "vlrlrv16qi"
+  [(set (match_operand:V16QI              0 "register_operand"  "")
+	(unspec:V16QI [(match_operand:BLK 2 "memory_operand"    "")
+		       (match_operand:SI  1 "nonmemory_operand" "")]
+		      UNSPEC_VEC_LOAD_LEN_R))]
+  "TARGET_VXE"
+{
+  /* vlrlr sets all length values beyond 15 to 15.  Emulate the same
+     behavior for immediate length operands.  vlrl would trigger a
+     SIGILL for too large immediate operands.  */
+  if (CONST_INT_P (operands[1])
+      && (UINTVAL (operands[1]) & 0xffffffff) > 15)
+    operands[1] = GEN_INT (15);
+})
+
+(define_insn "*vlrlrv16qi"
+  [(set (match_operand:V16QI              0 "register_operand"  "=v,  v,  v")
+	(unspec:V16QI [(match_operand:BLK 2 "memory_operand"     "Q,  R,  Q")
+		       (match_operand:SI  1 "nonmemory_operand"  "d,j>f,jb4")]
 		      UNSPEC_VEC_LOAD_LEN_R))]
   "TARGET_VXE"
   "@
    vlrlr\t%v0,%1,%2
+   vl\t%v0,%2%A2
    vlrl\t%v0,%2,%1"
-  [(set_attr "op_type" "VRS,VSI")])
+  [(set_attr "op_type" "VRS,VRX,VSI")])
 
 
 ; FIXME: The following two patterns might using vec_merge. But what is
@@ -499,23 +517,22 @@
 
 ; Vector select
 
-; Operand 3 selects bits from either OP1 (0) or OP2 (1)
+; for all b in bits op0[b] = op3[b] == 0 ? op2[b] : op1[b]
+; implemented as: op0 = (op1 & op3) | (op2 & ~op3)
 
-; Comparison operator should not matter as long as we always use the same ?!
+; Used to expand the vec_sel builtin. Operands op1 and op2 already got
+; swapped in s390-c.c when we get here.
 
-; Operands 1 and 2 are swapped in order to match the altivec builtin.
-; If operand 3 is a const_int bitmask this would be vec_merge
-(define_expand "vec_sel<mode>"
-  [(set (match_operand:V_HW 0 "register_operand" "")
-	(if_then_else:V_HW
-	 (eq (match_operand:<tointvec> 3 "register_operand"  "")
-	     (match_dup 4))
-	 (match_operand:V_HW 2 "register_operand"  "")
-	 (match_operand:V_HW 1 "register_operand"  "")))]
+(define_insn "vsel<mode>"
+  [(set (match_operand:V_HW                      0 "register_operand" "=v")
+	(ior:V_HW
+	 (and:V_HW (match_operand:V_HW           1 "register_operand"  "v")
+		   (match_operand:V_HW           3 "register_operand"  "v"))
+	 (and:V_HW (not:V_HW (match_dup 3))
+		   (match_operand:V_HW           2 "register_operand"  "v"))))]
   "TARGET_VX"
-{
-  operands[4] = CONST0_RTX (<tointvec>mode);
-})
+  "vsel\t%v0,%1,%2,%3"
+  [(set_attr "op_type" "VRR")])
 
 
 ; Vector sign extend to doubleword
@@ -546,16 +563,32 @@
 
 ; Vector store rightmost with length
 
-(define_insn "vstrlrv16qi"
-  [(set (match_operand:BLK                2 "memory_operand"    "=Q,Q")
-	(unspec:BLK [(match_operand:V16QI 0 "register_operand"   "v,v")
-		     (match_operand:SI    1 "nonmemory_operand"  "d,C")]
+(define_expand "vstrlrv16qi"
+  [(set (match_operand:BLK                2 "memory_operand"    "")
+	(unspec:BLK [(match_operand:V16QI 0 "register_operand"  "")
+		     (match_operand:SI    1 "nonmemory_operand" "")]
+		    UNSPEC_VEC_STORE_LEN_R))]
+  "TARGET_VXE"
+{
+  /* vstrlr sets all length values beyond 15 to 15.  Emulate the same
+     behavior for immediate length operands.  vstrl would trigger a
+     SIGILL for too large immediate operands.  */
+  if (CONST_INT_P (operands[1])
+      && (UINTVAL (operands[1]) & 0xffffffff) > 15)
+    operands[1] = GEN_INT (15);
+})
+
+(define_insn "*vstrlrv16qi"
+  [(set (match_operand:BLK                2 "memory_operand"    "=Q,  R,  Q")
+	(unspec:BLK [(match_operand:V16QI 0 "register_operand"   "v,  v,  v")
+		     (match_operand:SI    1 "nonmemory_operand"  "d,j>f,jb4")]
 		    UNSPEC_VEC_STORE_LEN_R))]
   "TARGET_VXE"
   "@
-   vstrlr\t%v0,%2,%1
-   vstrl\t%v0,%1,%2"
-  [(set_attr "op_type" "VRS,VSI")])
+   vstrlr\t%v0,%1,%2
+   vst\t%v0,%2%A2
+   vstrl\t%v0,%2,%1"
+  [(set_attr "op_type" "VRS,VRX,VSI")])
 
 
 
diff --git a/gcc/config/sparc/predicates.md b/gcc/config/sparc/predicates.md
index ee475800cfc..a0b498cb8f4 100644
--- a/gcc/config/sparc/predicates.md
+++ b/gcc/config/sparc/predicates.md
@@ -296,6 +296,8 @@
   if (arith_double_operand (op, mode))
     return true;
 
+  /* Turning an add/sub instruction into the other changes the Carry flag
+     so the 4096 trick cannot be used for double operations in 32-bit mode.  */
   return TARGET_ARCH64 && const_4096_operand (op, mode);
 })
 
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index ef1adb69ede..f1c120c4860 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -86,7 +86,6 @@ extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);
 extern rtx widen_mem_for_ldd_peep (rtx, rtx, machine_mode);
 extern int empty_delay_slot (rtx_insn *);
 extern int emit_cbcond_nop (rtx_insn *);
-extern int eligible_for_call_delay (rtx_insn *);
 extern int eligible_for_return_delay (rtx_insn *);
 extern int eligible_for_sibcall_delay (rtx_insn *);
 extern int emit_move_sequence (rtx, machine_mode);
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index a993aab7639..0553dc501e6 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -3962,41 +3962,6 @@ emit_cbcond_nop (rtx_insn *insn)
   return 1;
 }
 
-/* Return nonzero if TRIAL can go into the call delay slot.  */
-
-int
-eligible_for_call_delay (rtx_insn *trial)
-{
-  rtx pat;
-
-  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)
-    return 0;
-
-  /* The only problematic cases are TLS sequences with Sun as/ld.  */
-  if ((TARGET_GNU_TLS && HAVE_GNU_LD) || !TARGET_TLS)
-    return 1;
-
-  pat = PATTERN (trial);
-
-  /* We must reject tgd_add{32|64}, i.e.
-       (set (reg) (plus (reg) (unspec [(reg) (symbol_ref)] UNSPEC_TLSGD)))
-     and tldm_add{32|64}, i.e.
-       (set (reg) (plus (reg) (unspec [(reg) (symbol_ref)] UNSPEC_TLSLDM)))
-     for Sun as/ld.  */
-  if (GET_CODE (pat) == SET
-      && GET_CODE (SET_SRC (pat)) == PLUS)
-    {
-      rtx unspec = XEXP (SET_SRC (pat), 1);
-
-      if (GET_CODE (unspec) == UNSPEC
-	  && (XINT (unspec, 1) == UNSPEC_TLSGD
-	      || XINT (unspec, 1) == UNSPEC_TLSLDM))
-	return 0;
-    }
-
-  return 1;
-}
-
 /* Return nonzero if TRIAL, an insn, can be combined with a 'restore'
    instruction.  RETURN_P is true if the v9 variant 'return' is to be
    considered in the test too.
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 0a6e27ffa83..d9ef79c13cc 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -561,9 +561,9 @@
    (set_attr "type" "multi")])
 
 ;; Attributes for branch scheduling
-(define_attr "in_call_delay" "false,true"
-  (symbol_ref "(eligible_for_call_delay (insn)
-		? IN_CALL_DELAY_TRUE : IN_CALL_DELAY_FALSE)"))
+(define_attr "tls_delay_slot" "false,true"
+  (symbol_ref "((TARGET_GNU_TLS && HAVE_GNU_LD) != 0
+		? TLS_DELAY_SLOT_TRUE : TLS_DELAY_SLOT_FALSE)"))
 
 (define_attr "in_sibcall_delay" "false,true"
   (symbol_ref "(eligible_for_sibcall_delay (insn)
@@ -613,27 +613,24 @@
 	   (const_string "true")
 	] (const_string "false")))
 
-(define_delay (eq_attr "type" "call")
-  [(eq_attr "in_call_delay" "true") (nil) (nil)])
-
 (define_delay (eq_attr "type" "sibcall")
   [(eq_attr "in_sibcall_delay" "true") (nil) (nil)])
 
 (define_delay (eq_attr "type" "return")
   [(eq_attr "in_return_delay" "true") (nil) (nil)])
 
-(define_delay (and (eq_attr "type" "branch")
-	      (not (eq_attr "branch_type" "icc")))
-  [(eq_attr "in_branch_delay" "true") (nil) (eq_attr "in_branch_delay" "true")])
-
-(define_delay (and (eq_attr "type" "branch")
-	      (eq_attr "branch_type" "icc"))
-  [(eq_attr "in_branch_delay" "true") (nil)
-  (eq_attr "in_integer_branch_annul_delay" "true")])
-
-(define_delay (eq_attr "type" "uncond_branch")
+(define_delay (ior (eq_attr "type" "call") (eq_attr "type" "uncond_branch"))
   [(eq_attr "in_branch_delay" "true") (nil) (nil)])
 
+(define_delay (and (eq_attr "type" "branch") (not (eq_attr "branch_type" "icc")))
+  [(eq_attr "in_branch_delay" "true")
+   (nil)
+   (eq_attr "in_branch_delay" "true")])
+
+(define_delay (and (eq_attr "type" "branch") (eq_attr "branch_type" "icc"))
+  [(eq_attr "in_branch_delay" "true")
+   (nil)
+   (eq_attr "in_integer_branch_annul_delay" "true")])
 
 ;; Include SPARC DFA schedulers
 
@@ -3771,10 +3768,13 @@ visl")
     }
 })
 
+;; Turning an add/sub instruction into the other changes the Carry flag
+;; so the 4096 trick cannot be used for operations in CCXCmode.
+
 (define_expand "uaddvdi4"
   [(parallel [(set (reg:CCXC CC_REG)
 		   (compare:CCXC (plus:DI (match_operand:DI 1 "register_operand")
-					  (match_operand:DI 2 "arith_add_operand"))
+					  (match_operand:DI 2 "arith_double_operand"))
 			         (match_dup 1)))
 	      (set (match_operand:DI 0 "register_operand")
 		   (plus:DI (match_dup 1) (match_dup 2)))])
@@ -3793,10 +3793,13 @@ visl")
     }
 })
 
+;; Turning an add/sub instruction into the other does not change the Overflow
+;; flag so the 4096 trick can be used for operations in CCXVmode.
+
 (define_expand "addvdi4"
   [(parallel [(set (reg:CCXV CC_REG)
 		   (compare:CCXV (plus:DI (match_operand:DI 1 "register_operand")
-					  (match_operand:DI 2 "arith_add_operand"))
+					  (match_operand:DI 2 "arith_double_add_operand"))
 			         (unspec:DI [(match_dup 1) (match_dup 2)]
 					    UNSPEC_ADDV)))
 	      (set (match_operand:DI 0 "register_operand")
@@ -3969,9 +3972,10 @@ visl")
   ""
   "@
    add\t%1, %2, %0
-   sub\t%1, -%2, %0"
-  [(set_attr "type" "*,*")
-   (set_attr "fptype" "*,*")])
+   sub\t%1, -%2, %0")
+
+;; Turning an add/sub instruction into the other changes the Carry flag
+;; so the 4096 trick cannot be used for operations in CCCmode.
 
 (define_expand "uaddvsi4"
   [(parallel [(set (reg:CCC CC_REG)
@@ -3985,10 +3989,13 @@ visl")
 			   (pc)))]
  "")
 
+;; Turning an add/sub instruction into the other does not change the Overflow
+;; flag so the 4096 trick can be used for operations in CCVmode.
+
 (define_expand "addvsi4"
   [(parallel [(set (reg:CCV CC_REG)
 		   (compare:CCV (plus:SI (match_operand:SI 1 "register_operand")
-					 (match_operand:SI 2 "arith_operand"))
+					 (match_operand:SI 2 "arith_add_operand"))
 			        (unspec:SI [(match_dup 1) (match_dup 2)]
 					   UNSPEC_ADDV)))
 	      (set (match_operand:SI 0 "register_operand")
@@ -4097,42 +4104,50 @@ visl")
 
 (define_insn "*cmp_ccv_plus"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (plus:SI (match_operand:SI 0 "register_operand" "%r")
-			      (match_operand:SI 1 "arith_operand" "rI"))
+	(compare:CCV (plus:SI (match_operand:SI 0 "register_operand" "%r,r")
+			      (match_operand:SI 1 "arith_add_operand" "rI,O"))
 		     (unspec:SI [(match_dup 0) (match_dup 1)] UNSPEC_ADDV)))]
   ""
-  "addcc\t%0, %1, %%g0"
+  "@
+   addcc\t%0, %1, %%g0
+   subcc\t%0, -%1, %%g0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccxv_plus"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (plus:DI (match_operand:DI 0 "register_operand" "%r")
-			       (match_operand:DI 1 "arith_operand" "rI"))
+	(compare:CCXV (plus:DI (match_operand:DI 0 "register_operand" "%r,r")
+			       (match_operand:DI 1 "arith_add_operand" "rI,O"))
 		      (unspec:DI [(match_dup 0) (match_dup 1)] UNSPEC_ADDV)))]
   "TARGET_ARCH64"
-  "addcc\t%0, %1, %%g0"
+  "@
+   addcc\t%0, %1, %%g0
+   subcc\t%0, -%1, %%g0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccv_plus_set"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (plus:SI (match_operand:SI 1 "register_operand" "%r")
-			      (match_operand:SI 2 "arith_operand" "rI"))
+	(compare:CCV (plus:SI (match_operand:SI 1 "register_operand" "%r,r")
+			      (match_operand:SI 2 "arith_add_operand" "rI,O"))
 		     (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_ADDV)))
-   (set (match_operand:SI 0 "register_operand" "=r")
+   (set (match_operand:SI 0 "register_operand" "=r,r")
 	(plus:SI (match_dup 1) (match_dup 2)))]
   ""
-  "addcc\t%1, %2, %0"
+  "@
+   addcc\t%1, %2, %0
+   subcc\t%1, -%2, %0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccxv_plus_set"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (plus:DI (match_operand:DI 1 "register_operand" "%r")
-			       (match_operand:DI 2 "arith_operand" "rI"))
+	(compare:CCXV (plus:DI (match_operand:DI 1 "register_operand" "%r,r")
+			       (match_operand:DI 2 "arith_add_operand" "rI,O"))
 		      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_ADDV)))
-   (set (match_operand:DI 0 "register_operand" "=r")
+   (set (match_operand:DI 0 "register_operand" "=r,r")
 	(plus:DI (match_dup 1) (match_dup 2)))]
   "TARGET_ARCH64"
-  "addcc\t%1, %2, %0"
+  "@
+   addcc\t%1, %2, %0
+   subcc\t%1, -%2, %0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccv_plus_sltu_set"
@@ -4164,10 +4179,13 @@ visl")
     }
 })
 
+;; Turning an add/sub instruction into the other changes the Carry flag
+;; so the 4096 trick cannot be used for operations in CCXmode.
+
 (define_expand "usubvdi4"
   [(parallel [(set (reg:CCX CC_REG)
 		   (compare:CCX (match_operand:DI 1 "register_or_zero_operand")
-				(match_operand:DI 2 "arith_add_operand")))
+				(match_operand:DI 2 "arith_double_operand")))
 	      (set (match_operand:DI 0 "register_operand")
 		   (minus:DI (match_dup 1) (match_dup 2)))])
    (set (pc) (if_then_else (ltu (reg:CCX CC_REG) (const_int 0))
@@ -4191,10 +4209,13 @@ visl")
     }
 })
 
+;; Turning an add/sub instruction into the other does not change the Overflow
+;; flag so the 4096 trick can be used for operations in CCXVmode.
+
 (define_expand "subvdi4"
   [(parallel [(set (reg:CCXV CC_REG)
 		   (compare:CCXV (minus:DI (match_operand:DI 1 "register_operand")
-					   (match_operand:DI 2 "arith_add_operand"))
+					   (match_operand:DI 2 "arith_double_add_operand"))
 			         (unspec:DI [(match_dup 1) (match_dup 2)]
 					    UNSPEC_SUBV)))
 	      (set (match_operand:DI 0 "register_operand")
@@ -4365,9 +4386,10 @@ visl")
   ""
   "@
    sub\t%1, %2, %0
-   add\t%1, -%2, %0"
-  [(set_attr "type" "*,*")
-   (set_attr "fptype" "*,*")])
+   add\t%1, -%2, %0")
+
+;; Turning an add/sub instruction into the other changes the Carry flag
+;; so the 4096 trick cannot be used for operations in CCmode.
 
 (define_expand "usubvsi4"
   [(parallel [(set (reg:CC CC_REG)
@@ -4387,10 +4409,13 @@ visl")
     }
 })
 
+;; Turning an add/sub instruction into the other does not change the Overflow
+;; flag so the 4096 trick can be used for operations in CCVmode.
+
 (define_expand "subvsi4"
   [(parallel [(set (reg:CCV CC_REG)
 		   (compare:CCV (minus:SI (match_operand:SI 1 "register_operand")
-					  (match_operand:SI 2 "arith_operand"))
+					  (match_operand:SI 2 "arith_add_operand"))
 			        (unspec:SI [(match_dup 1) (match_dup 2)]
 					   UNSPEC_SUBV)))
 	      (set (match_operand:SI 0 "register_operand")
@@ -4483,42 +4508,50 @@ visl")
 
 (define_insn "*cmp_ccv_minus"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (minus:SI (match_operand:SI 0 "register_or_zero_operand" "rJ")
-			       (match_operand:SI 1 "arith_operand" "rI"))
+	(compare:CCV (minus:SI (match_operand:SI 0 "register_or_zero_operand" "rJ,rJ")
+			       (match_operand:SI 1 "arith_add_operand" "rI,O"))
 		     (unspec:SI [(match_dup 0) (match_dup 1)] UNSPEC_SUBV)))]
   ""
-  "subcc\t%r0, %1, %%g0"
+  "@
+   subcc\t%r0, %1, %%g0
+   addcc\t%r0, -%1, %%g0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccxv_minus"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (minus:DI (match_operand:DI 0 "register_or_zero_operand" "rJ")
-			        (match_operand:DI 1 "arith_operand" "rI"))
+	(compare:CCXV (minus:DI (match_operand:DI 0 "register_or_zero_operand" "rJ,rJ")
+			        (match_operand:DI 1 "arith_add_operand" "rI,O"))
 		      (unspec:DI [(match_dup 0) (match_dup 1)] UNSPEC_SUBV)))]
   "TARGET_ARCH64"
-  "subcc\t%r0, %1, %%g0"
+  "@
+   subcc\t%r0, %1, %%g0
+   addcc\t%r0, -%1, %%g0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccv_minus_set"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (minus:SI (match_operand:SI 1 "register_or_zero_operand" "rJ")
-			       (match_operand:SI 2 "arith_operand" "rI"))
+	(compare:CCV (minus:SI (match_operand:SI 1 "register_or_zero_operand" "rJ,rJ")
+			       (match_operand:SI 2 "arith_add_operand" "rI,O"))
 		     (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_SUBV)))
-   (set (match_operand:SI 0 "register_operand" "=r")
+   (set (match_operand:SI 0 "register_operand" "=r,r")
 	(minus:SI (match_dup 1) (match_dup 2)))]
   ""
-  "subcc\t%r1, %2, %0"
+  "@
+   subcc\t%r1, %2, %0
+   addcc\t%r1, -%2, %0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccxv_minus_set"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (minus:DI (match_operand:DI 1 "register_or_zero_operand" "rJ")
-			        (match_operand:DI 2 "arith_operand" "rI"))
+	(compare:CCXV (minus:DI (match_operand:DI 1 "register_or_zero_operand" "rJ,rJ")
+			        (match_operand:DI 2 "arith_add_operand" "rI,O"))
 		      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_SUBV)))
-   (set (match_operand:DI 0 "register_operand" "=r")
+   (set (match_operand:DI 0 "register_operand" "=r,r")
 	(minus:DI (match_dup 1) (match_dup 2)))]
   "TARGET_ARCH64"
-  "subcc\t%r1, %2, %0"
+  "@
+   subcc\t%r1, %2, %0
+   addcc\t%r1, -%2, %0"
   [(set_attr "type" "compare")])
 
 (define_insn "*cmp_ccv_minus_sltu_set"
@@ -5769,13 +5802,13 @@ visl")
 
 (define_insn "negsi2"
   [(set (match_operand:SI 0 "register_operand" "=r")
-        (neg:SI (match_operand:SI 1 "arith_operand" "rI")))]
+        (neg:SI (match_operand:SI 1 "register_operand" "r")))]
   ""
   "sub\t%%g0, %1, %0")
 
 (define_expand "unegvsi3"
   [(parallel [(set (reg:CCC CC_REG)
-		   (compare:CCC (not:SI (match_operand:SI 1 "arith_operand" ""))
+		   (compare:CCC (not:SI (match_operand:SI 1 "register_operand" ""))
 				(const_int -1)))
 	      (set (match_operand:SI 0 "register_operand" "")
 		   (neg:SI (match_dup 1)))])
@@ -5787,7 +5820,7 @@ visl")
 
 (define_expand "negvsi3"
   [(parallel [(set (reg:CCV CC_REG)
-		   (compare:CCV (neg:SI (match_operand:SI 1 "arith_operand" ""))
+		   (compare:CCV (neg:SI (match_operand:SI 1 "register_operand" ""))
 				(unspec:SI [(match_dup 1)] UNSPEC_NEGV)))
 	      (set (match_operand:SI 0 "register_operand" "")
 		   (neg:SI (match_dup 1)))])
@@ -5799,7 +5832,7 @@ visl")
 
 (define_insn "*cmp_ccnz_neg"
   [(set (reg:CCNZ CC_REG)
-	(compare:CCNZ (neg:SI (match_operand:SI 0 "arith_operand" "rI"))
+	(compare:CCNZ (neg:SI (match_operand:SI 0 "register_operand" "r"))
 		      (const_int 0)))]
   ""
   "subcc\t%%g0, %0, %%g0"
@@ -5807,7 +5840,7 @@ visl")
 
 (define_insn "*cmp_ccxnz_neg"
   [(set (reg:CCXNZ CC_REG)
-	(compare:CCXNZ (neg:DI (match_operand:DI 0 "arith_operand" "rI"))
+	(compare:CCXNZ (neg:DI (match_operand:DI 0 "register_operand" "r"))
 		       (const_int 0)))]
   "TARGET_ARCH64"
   "subcc\t%%g0, %0, %%g0"
@@ -5815,7 +5848,7 @@ visl")
 
 (define_insn "*cmp_ccnz_neg_set"
   [(set (reg:CCNZ CC_REG)
-	(compare:CCNZ (neg:SI (match_operand:SI 1 "arith_operand" "rI"))
+	(compare:CCNZ (neg:SI (match_operand:SI 1 "register_operand" "r"))
 		      (const_int 0)))
    (set (match_operand:SI 0 "register_operand" "=r")
 	(neg:SI (match_dup 1)))]
@@ -5825,7 +5858,7 @@ visl")
 
 (define_insn "*cmp_ccxnz_neg_set"
   [(set (reg:CCXNZ CC_REG)
-	(compare:CCXNZ (neg:DI (match_operand:DI 1 "arith_operand" "rI"))
+	(compare:CCXNZ (neg:DI (match_operand:DI 1 "register_operand" "r"))
 		       (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=r")
 	(neg:DI (match_dup 1)))]
@@ -5835,7 +5868,7 @@ visl")
 
 (define_insn "*cmp_ccc_neg_set"
   [(set (reg:CCC CC_REG)
-	(compare:CCC (not:SI (match_operand:SI 1 "arith_operand" "rI"))
+	(compare:CCC (not:SI (match_operand:SI 1 "register_operand" "r"))
 		     (const_int -1)))
    (set (match_operand:SI 0 "register_operand" "=r")
 	(neg:SI (match_dup 1)))]
@@ -5845,7 +5878,7 @@ visl")
 
 (define_insn "*cmp_ccxc_neg_set"
   [(set (reg:CCXC CC_REG)
-	(compare:CCXC (not:DI (match_operand:DI 1 "arith_operand" "rI"))
+	(compare:CCXC (not:DI (match_operand:DI 1 "register_operand" "r"))
 		      (const_int -1)))
    (set (match_operand:DI 0 "register_operand" "=r")
 	(neg:DI (match_dup 1)))]
@@ -5856,7 +5889,7 @@ visl")
 (define_insn "*cmp_ccc_neg_sltu_set"
   [(set (reg:CCC CC_REG)
 	(compare:CCC (zero_extend:DI
-		       (neg:SI (plus:SI (match_operand:SI 1 "arith_operand" "rI")
+		       (neg:SI (plus:SI (match_operand:SI 1 "register_operand" "r")
 				        (ltu:SI (reg:CCC CC_REG)
 						(const_int 0)))))
 		     (neg:DI (plus:DI (zero_extend:DI (match_dup 1))
@@ -5871,7 +5904,7 @@ visl")
 
 (define_insn "*cmp_ccv_neg"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (neg:SI (match_operand:SI 0 "arith_operand" "rI"))
+	(compare:CCV (neg:SI (match_operand:SI 0 "register_operand" "r"))
 		     (unspec:SI [(match_dup 0)] UNSPEC_NEGV)))]
   ""
   "subcc\t%%g0, %0, %%g0"
@@ -5879,7 +5912,7 @@ visl")
 
 (define_insn "*cmp_ccxv_neg"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (neg:DI (match_operand:DI 0 "arith_operand" "rI"))
+	(compare:CCXV (neg:DI (match_operand:DI 0 "register_operand" "r"))
 		      (unspec:DI [(match_dup 0)] UNSPEC_NEGV)))]
   "TARGET_ARCH64"
   "subcc\t%%g0, %0, %%g0"
@@ -5887,7 +5920,7 @@ visl")
 
 (define_insn "*cmp_ccv_neg_set"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (neg:SI (match_operand:SI 1 "arith_operand" "rI"))
+	(compare:CCV (neg:SI (match_operand:SI 1 "register_operand" "r"))
 		     (unspec:SI [(match_dup 1)] UNSPEC_NEGV)))
    (set (match_operand:SI 0 "register_operand" "=r")
 	(neg:SI (match_dup 1)))]
@@ -5897,7 +5930,7 @@ visl")
 
 (define_insn "*cmp_ccxv_neg_set"
   [(set (reg:CCXV CC_REG)
-	(compare:CCXV (neg:DI (match_operand:DI 1 "arith_operand" "rI"))
+	(compare:CCXV (neg:DI (match_operand:DI 1 "register_operand" "r"))
 		      (unspec:DI [(match_dup 1)] UNSPEC_NEGV)))
    (set (match_operand:DI 0 "register_operand" "=r")
 	(neg:DI (match_dup 1)))]
@@ -5907,7 +5940,7 @@ visl")
 
 (define_insn "*cmp_ccv_neg_sltu_set"
   [(set (reg:CCV CC_REG)
-	(compare:CCV (neg:SI (plus:SI (match_operand:SI 1 "arith_operand" "rI")
+	(compare:CCV (neg:SI (plus:SI (match_operand:SI 1 "register_operand" "r")
 				      (ltu:SI (reg:CCC CC_REG) (const_int 0))))
 		     (unspec:SI [(plus:SI (match_dup 1)
 				          (ltu:SI (reg:CCC CC_REG)
@@ -7935,7 +7968,9 @@ visl")
    (clobber (reg:P O7_REG))]
   "TARGET_TLS"
   "call\t%a1, %%tgd_call(%a2)%#"
-  [(set_attr "type" "call")])
+  [(set (attr "type") (if_then_else (eq_attr "tls_delay_slot" "true")
+                                    (const_string "call")
+                                    (const_string "call_no_delay_slot")))])
 
 (define_insn "tldm_hi22<P:mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
@@ -7966,7 +8001,9 @@ visl")
    (clobber (reg:P O7_REG))]
   "TARGET_TLS"
   "call\t%a1, %%tldm_call(%&)%#"
-  [(set_attr "type" "call")])
+  [(set (attr "type") (if_then_else (eq_attr "tls_delay_slot" "true")
+                                    (const_string "call")
+                                    (const_string "call_no_delay_slot")))])
 
 (define_insn "tldo_hix22<P:mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
diff --git a/gcc/config/tilegx/tilegx.md b/gcc/config/tilegx/tilegx.md
index dce43eca074..7e3ef50dd4e 100644
--- a/gcc/config/tilegx/tilegx.md
+++ b/gcc/config/tilegx/tilegx.md
@@ -4110,7 +4110,7 @@
   operands[1] = simplify_gen_subreg (<I124MODE:MODE>mode, operands[1],
 				     DImode,
 				     BYTES_BIG_ENDIAN
-				     ? UNITS_PER_WORD - <n> : 0);
+				     ? UNITS_PER_WORD - <I124MODE:n> : 0);
 })
 
 (define_insn "*insn_stnt<I124MODE:n>_add<I48MODE:bitsuffix>"
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index ee5612441e2..2527468d57d 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -4235,7 +4235,9 @@ hwloop_optimize (hwloop_info loop)
 
   seq = get_insns ();
 
-  if (!single_succ_p (entry_bb) || vec_safe_length (loop->incoming) > 1)
+  entry_after = BB_END (entry_bb);
+  if (!single_succ_p (entry_bb) || vec_safe_length (loop->incoming) > 1
+      || !entry_after)
     {
       basic_block new_bb;
       edge e;
@@ -4256,7 +4258,6 @@ hwloop_optimize (hwloop_info loop)
     }
   else
     {
-      entry_after = BB_END (entry_bb);
       while (DEBUG_INSN_P (entry_after)
              || (NOTE_P (entry_after)
 		 && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK))
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index 362e5ff3c1f..673ddad2eae 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -538,7 +538,7 @@
   ""
   "@
    extui\t%0, %1, 0, 16
-   l16ui\t%0, %1"
+   %v1l16ui\t%0, %1"
   [(set_attr "type"	"arith,load")
    (set_attr "mode"	"SI")
    (set_attr "length"	"3,3")])
@@ -549,7 +549,7 @@
   ""
   "@
    extui\t%0, %1, 0, 8
-   l8ui\t%0, %1"
+   %v1l8ui\t%0, %1"
   [(set_attr "type"	"arith,load")
    (set_attr "mode"	"SI")
    (set_attr "length"	"3,3")])
@@ -575,7 +575,7 @@
   ""
   "@
    sext\t%0, %1, 15
-   l16si\t%0, %1"
+   %v1l16si\t%0, %1"
   [(set_attr "type"	"arith,load")
    (set_attr "mode"	"SI")
    (set_attr "length"	"3,3")])
diff --git a/gcc/configure b/gcc/configure
index a065ba23728..4349e0f3226 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -27779,6 +27779,37 @@ if test $gcc_cv_as_s390_vector_loadstore_alignment_hints = yes; then
 
 $as_echo "#define HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS 1" >>confdefs.h
 
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for vector load/store alignment hints on z13" >&5
+$as_echo_n "checking assembler for vector load/store alignment hints on z13... " >&6; }
+if ${gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '	vl %v24,0(%r15),3 ' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -mzarch -march=z13 -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13" >&5
+$as_echo "$gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13" >&6; }
+if test $gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13 = yes; then
+
+$as_echo "#define HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS_ON_Z13 1" >>confdefs.h
+
 fi
 
 
@@ -28919,6 +28950,9 @@ case "$target:$tm_file" in
      *-*-linux*)
      emul_name="-melf64ppc"
       ;;
+     *le-*-freebsd*)
+     emul_name="-melf64lppc_fbsd"
+      ;;
      *-*-freebsd*)
      emul_name="-melf64ppc_fbsd"
       ;;
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 3a7251102ef..ec10dbeb3e9 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -4908,6 +4908,11 @@ pointers into PC-relative form.])
       [	vl %v24,0(%r15),3 ],,
       [AC_DEFINE(HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS, 1,
 	  [Define if your assembler supports vl/vst/vlm/vstm with an optional alignment hint argument.])])
+    gcc_GAS_CHECK_FEATURE([vector load/store alignment hints on z13],
+      gcc_cv_as_s390_vector_loadstore_alignment_hints_on_z13,, [-mzarch -march=z13],
+      [	vl %v24,0(%r15),3 ],,
+      [AC_DEFINE(HAVE_AS_VECTOR_LOADSTORE_ALIGNMENT_HINTS_ON_Z13, 1,
+	  [Define if your assembler supports vl/vst/vlm/vstm with an optional alignment hint argument on z13.])])
 
     ;;
 esac
@@ -5674,6 +5679,9 @@ case "$target:$tm_file" in
      *-*-linux*)
      emul_name="-melf64ppc"
       ;;
+     *le-*-freebsd*)
+     emul_name="-melf64lppc_fbsd"
+      ;;
      *-*-freebsd*)
      emul_name="-melf64ppc_fbsd"
       ;;
diff --git a/gcc/coverage.c b/gcc/coverage.c
index 1ffefd5f482..c442e2fb008 100644
--- a/gcc/coverage.c
+++ b/gcc/coverage.c
@@ -1201,6 +1201,13 @@ coverage_obj_finish (vec<constructor_elt, va_gc> *ctor)
 void
 coverage_init (const char *filename)
 {
+  const char *original_filename = filename;
+  int original_len = strlen (original_filename);
+#if HAVE_DOS_BASED_FILE_SYSTEM
+  const char *separator = "\\";
+#else
+  const char *separator = "/";
+#endif
   int len = strlen (filename);
   int prefix_len = 0;
 
@@ -1217,11 +1224,6 @@ coverage_init (const char *filename)
 	 of filename in order to prevent file path clashing.  */
       if (profile_data_prefix)
 	{
-#if HAVE_DOS_BASED_FILE_SYSTEM
-	  const char *separator = "\\";
-#else
-	  const char *separator = "/";
-#endif
 	  filename = concat (getpwd (), separator, filename, NULL);
 	  filename = mangle_path (filename);
 	  len = strlen (filename);
@@ -1240,7 +1242,7 @@ coverage_init (const char *filename)
   if (profile_data_prefix)
     {
       memcpy (da_file_name, profile_data_prefix, prefix_len);
-      da_file_name[prefix_len++] = '/';
+      da_file_name[prefix_len++] = *separator;
     }
   memcpy (da_file_name + prefix_len, filename, len);
   strcpy (da_file_name + prefix_len + len, GCOV_DATA_SUFFIX);
@@ -1255,9 +1257,9 @@ coverage_init (const char *filename)
   /* Name of bbg file.  */
   if (flag_test_coverage && !flag_compare_debug)
     {
-      bbg_file_name = XNEWVEC (char, len + strlen (GCOV_NOTE_SUFFIX) + 1);
-      memcpy (bbg_file_name, filename, len);
-      strcpy (bbg_file_name + len, GCOV_NOTE_SUFFIX);
+      bbg_file_name = XNEWVEC (char, original_len + strlen (GCOV_NOTE_SUFFIX) + 1);
+      memcpy (bbg_file_name, original_filename, original_len);
+      strcpy (bbg_file_name + original_len, GCOV_NOTE_SUFFIX);
 
       if (!gcov_open (bbg_file_name, -1))
 	{
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 6441d647a54..fe8abd7dd4a 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,305 @@
+2021-03-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-03-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/99137
+	* parser.c (cp_parser_oacc_clause_async): Reject comma expressions.
+
+2021-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/98810
+	* pt.c (tsubst_copy) [VIEW_CONVERT_EXPR]: Add const
+	to a class non-type template argument that needs it.
+
+2021-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95675
+	* call.c (build_temp): Wrap a CALL_EXPR in a TARGET_EXPR
+	if it didn't get one before.
+
+2021-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90333
+	* parser.c (cp_parser_lambda_declarator_opt): Accept GNU attributes
+	between () and ->.
+
+2021-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63707
+	* tree.c (build_vec_init_expr): Don't call build_vec_init_elt
+	if we got a CONSTRUCTOR.
+
+2020-12-16  Nathan Sidwell  <nathan@acm.org>
+
+	* parser.c (cp_parser_elaborated_type_specifier): Test
+	BOUND_TEMPLATE_TEMPLATE_PARM before checking for instantiation.
+
+2020-11-26  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-26  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* parser.c (cp_parser_omp_var_list_no_open): Assert that array
+	section's 'low_bound', 'length' are not location wrapper nodes.
+	(cp_parser_oacc_all_clauses, cp_parser_oacc_cache): Instantiate
+	'auto_suppress_location_wrappers'.
+
+2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* pt.c (tsubst_omp_clauses): Handle 'OMP_CLAUSE__CACHE_'.
+	(tsubst_expr): Handle 'OACC_CACHE'.
+
+2020-11-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95158
+	* class.c (lookup_vfn_in_binfo): New.
+	* call.c (build_over_call): Use it.
+	(build_new_method_call_1): Don't set LOOKUP_NONVIRTUAL.
+	* cp-tree.h (resolves_to_fixed_type_p): Add default argument.
+	(lookup_vfn_in_binfo): Declare.
+
+2020-11-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-07  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/88115
+	PR libstdc++/97273
+	* tree.c (cp_tree_equal) <case ALIGNOF_EXPR>: Return false if
+	ALIGNOF_EXPR_STD_P differ.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/96862
+	* constexpr.c (cxx_eval_outermost_constant_expr): Temporarily disable
+	flag_rounding_math during manifestly constant evaluation.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/95328
+	* decl.c (cp_finish_decomp): Call complete_type before checking
+	COMPLETE_TYPE_P.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94951
+	* typeck.c (cp_strict_aliasing_warning): New function.
+	(cp_build_indirect_ref_1, build_reinterpret_cast_1): Use
+	it instead of strict_aliasing_warning.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94742
+	* semantics.c (finish_call_expr): When looking if all overloads
+	are noreturn, use STRIP_TEMPLATE to look through TEMPLATE_DECLs.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94571
+	* parser.c (cp_parser_simple_declaration): Fix up a pasto in
+	diagnostics.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94325
+	* decl.c (begin_destructor_body): For CLASSTYPE_VBASECLASSES class
+	dtors, if CLASSTYPE_PRIMARY_BINFO is non-NULL, but not BINFO_VIRTUAL_P,
+	look at CLASSTYPE_PRIMARY_BINFO of its BINFO_TYPE if it is not
+	BINFO_VIRTUAL_P, and so on.
+
+2020-06-16  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95678
+	* tree.c (zero_init_expr_p): Use uses_template_parms instead of
+	dependent_type_p.
+
+2020-06-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/95344
+	* cp-gimplify.c (cp_fold) <case MODIFY_EXPR>: Don't set
+	TREE_THIS_VOLATILE here.
+	(cp_fold): Set it here along with TREE_NO_WARNING.
+
+2020-06-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/95560
+	* name-lookup.c (check_local_shadow): Check if types are
+	non-null before calling same_type_p.
+
+2020-05-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90212
+	* constexpr.c (potential_constant_expression_1): In a lambda
+	function, consider a captured variable directly.
+
+2020-05-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90479
+	* init.c (get_nsdmi): Don't push_to_top_level for a local class.
+
+2020-05-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91529
+	* decl.c (cp_finish_decl): Also clear TREE_READONLY if
+	-fmerge-all-constants.
+
+2020-05-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93822
+	* pt.c (tsubst_decl): Make sure DECL_VALUE_EXPR continues to have
+	the same type as the variable.
+
+2020-05-06  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/94946
+	* decl.c (grokdeclarator): Don't splice template attributes in
+	parm context -- they can apply to the parm.
+
+2020-04-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90750
+	PR c++/79585
+	* decl.c (grokdeclarator): Move dependent attribute to decl.
+	* decl2.c (splice_template_attributes): No longer static.
+
+2020-04-21  Martin Sebor  <msebor@redhat.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/94510
+	* decl.c (reshape_init_array_1): Avoid stripping redundant trailing
+	zero initializers...
+	* mangle.c (write_expression): ...and handle them here even for
+	pointers to members by calling zero_init_expr_p.
+	* cp-tree.h (zero_init_expr_p): Declare.
+	* tree.c (zero_init_expr_p): Define.
+	(type_initializer_zero_p): Remove.
+	* pt.c (tparm_obj_values): New hash_map.
+	(get_template_parm_object): Store to it.
+	(tparm_object_argument): New.
+
+2020-04-20  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2020-04-20  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/94505 - bogus -Wparentheses warning with fold-expression.
+	* pt.c (fold_expression): Add warning_sentinel for -Wparentheses
+	before calling build_x_binary_op.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94512
+	* parser.c (cp_parser_omp_parallel): Set OMP_PARALLEL_COMBINED
+	if cp_parser_omp_master succeeded.
+
+	Backported from mainline
+	2020-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94477
+	* pt.c (tsubst_expr) <case OMP_MASTER>: Clear
+	omp_parallel_combined_clauses.
+
+	2020-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94385
+	* semantics.c (add_stmt): Only set STMT_IS_FULL_EXPR_P on trees with
+	STATEMENT_CODE_P code.
+
+	2020-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93931
+	* parser.c (cp_parser_omp_var_list_no_open): Call process_outer_var_ref
+	on outer_automatic_var_p decls.
+	* cp-gimplify.c (cxx_omp_disregard_value_expr): Return true also for
+	capture proxy decls.
+
+	2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90995
+	* parser.c (cp_parser_enum_specifier): Use temp_override for
+	parser->colon_corrects_to_scope_p, replace goto out with return.
+	If scoped enum or enum with underlying type is not followed by
+	{ or ;, call cp_parser_commit_to_tentative_parse before calling
+	cp_parser_error and make sure to return error_mark_node instead of
+	NULL_TREE.  Formatting fixes.
+
+2020-04-05  Marek Polacek  <polacek@redhat.com>
+
+	2020-02-06  Marek Polacek  <polacek@redhat.com>
+	Backport from mainline
+
+	PR c++/93597 - ICE with lambda in operator function.
+	* name-lookup.c (maybe_save_operator_binding): Check is_overloaded_fn.
+
+2020-04-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91377
+	* mangle.c (write_expression): Skip IMPLICIT_CONV_EXPR.
+
+2020-04-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/94453
+	* constexpr.c (maybe_constant_value): Use break_out_target_exprs.
+	* expr.c (mark_use) [VIEW_CONVERT_EXPR]: Don't wrap a TARGET_EXPR in
+	NON_LVALUE_EXPR.
+
+2020-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91966
+	* pt.c (complex_pack_expansion_r): New.
+	(complex_alias_template_p): Use it.
+
+2020-03-30  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90711
+	* tree.c (cp_tree_equal) [CALL_EXPR]: Compare KOENIG_LOOKUP_P.
+	(called_fns_equal): Check DECL_CONTEXT.
+
+2020-03-27  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/84733
+	* name-lookup.c (do_pushdecl): Look through cleanp levels.
+
+2020-03-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92909
+	* pt.c (find_parameter_packs_r): [DECL_EXPR]: Walk
+	DECL_ORIGINAL_TYPE of a typedef.
+
+2020-03-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/92068
+	* pt.c (process_partial_specialization): Error rather than crash on
+	extra pack expansion.
+
+2020-03-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93248
+	* pt.c (build_deduction_guide): Clear cp_unevaluated_operand for
+	substituting DECL_ARGUMENTS.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index f365a5a7f7b..7191a4945b1 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -6836,6 +6836,14 @@ build_temp (tree expr, tree type, int flags,
       && !type_has_nontrivial_copy_init (TREE_TYPE (expr)))
     return get_target_expr_sfinae (expr, complain);
 
+  /* In decltype, we might have decided not to wrap this call in a TARGET_EXPR.
+     But it turns out to be a subexpression, so perform temporary
+     materialization now.  */
+  if (TREE_CODE (expr) == CALL_EXPR
+      && CLASS_TYPE_P (type)
+      && same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (expr)))
+    expr = build_cplus_new (type, expr, complain);
+
   savew = warningcount + werrorcount, savee = errorcount;
   args = make_tree_vector_single (expr);
   expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,
@@ -8292,6 +8300,15 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
 	  || CLASSTYPE_FINAL (TYPE_METHOD_BASETYPE (TREE_TYPE (fn))))
 	flags |= LOOKUP_NONVIRTUAL;
 
+      /* If we know the dynamic type of the object, look up the final overrider
+	 in the BINFO.  */
+      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0
+	  && resolves_to_fixed_type_p (arg))
+	{
+	  fn = lookup_vfn_in_binfo (DECL_VINDEX (fn), cand->conversion_path);
+	  flags |= LOOKUP_NONVIRTUAL;
+	}
+
       /* [class.mfct.nonstatic]: If a nonstatic member function of a class
 	 X is called for an object that is not of type X, or of a type
 	 derived from X, the behavior is undefined.
@@ -9895,17 +9912,6 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,
 
 	  if (call != error_mark_node)
 	    {
-	      /* Optimize away vtable lookup if we know that this
-		 function can't be overridden.  We need to check if
-		 the context and the type where we found fn are the same,
-		 actually FN might be defined in a different class
-		 type because of a using-declaration. In this case, we
-		 do not want to perform a non-virtual call.  */
-	      if (DECL_VINDEX (fn) && ! (flags & LOOKUP_NONVIRTUAL)
-		  && same_type_ignoring_top_level_qualifiers_p
-		  (DECL_CONTEXT (fn), BINFO_TYPE (binfo))
-		  && resolves_to_fixed_type_p (instance, 0))
-		flags |= LOOKUP_NONVIRTUAL;
               if (explicit_targs)
                 flags |= LOOKUP_EXPLICIT_TMPL_ARGS;
 	      /* Now we know what function is being called.  */
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index 6b57184e081..f7c8757c740 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -2391,6 +2391,20 @@ get_vcall_index (tree fn, tree type)
   gcc_unreachable ();
 }
 
+/* Given a DECL_VINDEX of a virtual function found in BINFO, return the final
+   overrider at that index in the vtable.  This should only be used when we
+   know that BINFO is correct for the dynamic type of the object.  */
+
+tree
+lookup_vfn_in_binfo (tree idx, tree binfo)
+{
+  int ix = tree_to_shwi (idx);
+  if (TARGET_VTABLE_USES_DESCRIPTORS)
+    ix /= MAX (TARGET_VTABLE_USES_DESCRIPTORS, 1);
+  tree virtuals = BINFO_VIRTUALS (binfo);
+  return TREE_VALUE (chain_index (ix, virtuals));
+}
+
 /* Update an entry in the vtable for BINFO, which is in the hierarchy
    dominated by T.  FN is the old function; VIRTUALS points to the
    corresponding position in the new BINFO_VIRTUALS list.  IX is the index
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index bab5935a4eb..38b852681aa 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -5352,6 +5352,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,
 			&constexpr_ctx_count, allow_non_constant, strict,
 			manifestly_const_eval || !allow_non_constant };
 
+  /* Turn off -frounding-math for manifestly constant evaluation.  */
+  warning_sentinel rm (flag_rounding_math, ctx.manifestly_const_eval);
   tree type = initialized_type (t);
   tree r = t;
   if (VOID_TYPE_P (type))
@@ -5602,7 +5604,7 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)
       r = *cached;
       if (r != t)
 	{
-	  r = unshare_expr_without_location (r);
+	  r = break_out_target_exprs (r, /*clear_loc*/true);
 	  protected_set_expr_location (r, EXPR_LOCATION (t));
 	}
       return r;
@@ -6159,12 +6161,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 		 variable with automatic storage duration defined outside that
 		 lambda-expression, where the reference would be an
 		 odr-use.  */
+
+	      if (want_rval)
+		/* Since we're doing an lvalue-rvalue conversion, this might
+		   not be an odr-use, so evaluate the variable directly. */
+		return RECUR (DECL_CAPTURED_VARIABLE (t), rval);
+
 	      if (flags & tf_error)
 		{
 		  tree cap = DECL_CAPTURED_VARIABLE (t);
 		  error ("lambda capture of %qE is not a constant expression",
 			 cap);
-		  if (!want_rval && decl_constant_var_p (cap))
+		  if (decl_constant_var_p (cap))
 		    inform (input_location, "because it is used as a glvalue");
 		}
 	      return false;
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index 4be45abca88..7525ee8d10f 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -2192,12 +2192,17 @@ cxx_omp_finish_clause (tree c, gimple_seq *)
 bool
 cxx_omp_disregard_value_expr (tree decl, bool shared)
 {
-  return !shared
-	 && VAR_P (decl)
-	 && DECL_HAS_VALUE_EXPR_P (decl)
-	 && DECL_ARTIFICIAL (decl)
-	 && DECL_LANG_SPECIFIC (decl)
-	 && DECL_OMP_PRIVATIZED_MEMBER (decl);
+  if (shared)
+    return false;
+  if (VAR_P (decl)
+      && DECL_HAS_VALUE_EXPR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && DECL_LANG_SPECIFIC (decl)
+      && DECL_OMP_PRIVATIZED_MEMBER (decl))
+    return true;
+  if (VAR_P (decl) && DECL_CONTEXT (decl) && is_capture_proxy (decl))
+    return true;
+  return false;
 }
 
 /* Fold expression X which is used as an rvalue if RVAL is true.  */
@@ -2806,6 +2811,12 @@ cp_fold (tree x)
       return org_x;
     }
 
+  if (EXPR_P (x) && TREE_CODE (x) == code)
+    {
+      TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (org_x);
+      TREE_NO_WARNING (x) = TREE_NO_WARNING (org_x);
+    }
+
   fold_cache->put (org_x, x);
   /* Prevent that we try to fold an already folded result again.  */
   if (x != org_x)
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index f7c3eea4cdf..be291e99ce6 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -6272,7 +6272,7 @@ extern tree outermost_open_class		(void);
 extern tree current_nonlambda_class_type	(void);
 extern tree finish_struct			(tree, tree);
 extern void finish_struct_1			(tree);
-extern int resolves_to_fixed_type_p		(tree, int *);
+extern int resolves_to_fixed_type_p		(tree, int * = NULL);
 extern void init_class_processing		(void);
 extern int is_empty_class			(tree);
 extern bool is_really_empty_class		(tree, bool);
@@ -6286,6 +6286,7 @@ extern void pop_lang_context			(void);
 extern tree instantiate_type			(tree, tree, tsubst_flags_t);
 extern void build_self_reference		(void);
 extern int same_signature_p			(const_tree, const_tree);
+extern tree lookup_vfn_in_binfo			(tree, tree);
 extern void maybe_add_class_template_decl_list	(tree, tree, int);
 extern void unreverse_member_declarations	(tree);
 extern void invalidate_class_lookup_cache	(void);
@@ -6492,6 +6493,7 @@ extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *,
 		       tree, bool, tree, tree);
 extern tree grokbitfield (const cp_declarator *, cp_decl_specifier_seq *,
 			  tree, tree, tree);
+extern tree splice_template_attributes		(tree *, tree);
 extern bool any_dependent_type_attributes_p	(tree);
 extern tree cp_reconstruct_complex_type		(tree, tree);
 extern bool attributes_naming_typedef_ok	(tree);
@@ -6844,6 +6846,7 @@ extern bool alias_type_or_template_p            (tree);
 extern bool alias_template_specialization_p     (const_tree);
 extern bool dependent_alias_template_spec_p     (const_tree);
 extern bool template_parm_object_p		(const_tree);
+extern tree tparm_object_argument		(tree);
 extern bool explicit_class_specialization_p     (tree);
 extern bool push_tinst_level                    (tree);
 extern bool push_tinst_level_loc                (tree, location_t);
@@ -7216,6 +7219,7 @@ extern bool type_has_nontrivial_copy_init	(const_tree);
 extern void maybe_warn_parm_abi			(tree, location_t);
 extern bool class_tmpl_impl_spec_p		(const_tree);
 extern int zero_init_p				(const_tree);
+extern bool zero_init_expr_p			(tree);
 extern bool check_abi_tag_redeclaration		(const_tree, const_tree,
 						 const_tree);
 extern bool check_abi_tag_args			(tree, tree);
@@ -7327,11 +7331,6 @@ extern tree cxx_copy_lang_qualifiers		(const_tree, const_tree);
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
-/* Analogous to initializer_zerop but also examines the type for
-   which the initializer is being used.  Unlike initializer_zerop,
-   considers empty strings to be zero initializers for arrays and
-   non-zero for pointers.  */
-extern bool type_initializer_zero_p		(tree, tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 39d55589ef3..ec18f87e47f 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -5826,9 +5826,6 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
 	max_index_cst = tree_to_uhwi (fold_convert (size_type_node, max_index));
     }
 
-  /* Set to the index of the last element with a non-zero initializer.
-     Zero initializers for elements past this one can be dropped.  */
-  unsigned HOST_WIDE_INT last_nonzero = -1;
   /* Loop until there are no more initializers.  */
   for (index = 0;
        d->cur != d->end && (!sized_array_p || index <= max_index_cst);
@@ -5847,32 +5844,11 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
       if (!TREE_CONSTANT (elt_init))
 	TREE_CONSTANT (new_init) = false;
 
-      /* Pointers initialized to strings must be treated as non-zero
-	 even if the string is empty.  */
-      tree init_type = TREE_TYPE (elt_init);
-      if (POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)
-	  || !type_initializer_zero_p (elt_type, elt_init))
-	last_nonzero = index;
-
       /* This can happen with an invalid initializer (c++/54501).  */
       if (d->cur == old_cur && !sized_array_p)
 	break;
     }
 
-  if (sized_array_p && trivial_type_p (elt_type))
-    {
-      /* Strip trailing zero-initializers from an array of a trivial
-	 type of known size.  They are redundant and get in the way
-	 of telling them apart from those with implicit zero value.  */
-      unsigned HOST_WIDE_INT nelts = CONSTRUCTOR_NELTS (new_init);
-      if (last_nonzero > nelts)
-	nelts = 0;
-      else if (last_nonzero < nelts - 1)
-	nelts = last_nonzero + 1;
-
-      vec_safe_truncate (CONSTRUCTOR_ELTS (new_init), nelts);
-    }
-
   return new_init;
 }
 
@@ -7323,7 +7299,10 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
       /* This needs to happen after the linkage is set. */
       determine_visibility (decl);
 
-      if (var_definition_p && TREE_STATIC (decl))
+      if (var_definition_p
+	  /* With -fmerge-all-constants, gimplify_init_constructor
+	     might add TREE_STATIC to the variable.  */
+	  && (TREE_STATIC (decl) || flag_merge_constants >= 2))
 	{
 	  /* If a TREE_READONLY variable needs initialization
 	     at runtime, it is no longer readonly and we need to
@@ -7885,6 +7864,8 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)
       error_at (loc, "cannot decompose lambda closure type %qT", type);
       goto error_out;
     }
+  else if (processing_template_decl && complete_type (type) == error_mark_node)
+    goto error_out;
   else if (processing_template_decl && !COMPLETE_TYPE_P (type))
     pedwarn (loc, 0, "structured binding refers to incomplete class type %qT",
 	     type);
@@ -11283,9 +11264,16 @@ grokdeclarator (const cp_declarator *declarator,
 	    attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;
 	  if (declarator->kind == cdk_array)
 	    attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;
+	  tree late_attrs = NULL_TREE;
+	  if (decl_context != PARM)
+	    /* Assume that any attributes that get applied late to
+	       templates will DTRT when applied to the declaration
+	       as a whole.  */
+	    late_attrs = splice_template_attributes (&attrs, type);
 	  returned_attrs = decl_attributes (&type,
 					    chainon (returned_attrs, attrs),
 					    attr_flags);
+	  returned_attrs = chainon (late_attrs, returned_attrs);
 	}
 
       inner_declarator = declarator->declarator;
@@ -15855,14 +15843,20 @@ begin_destructor_body (void)
 	    /* If the vptr is shared with some virtual nearly empty base,
 	       don't clear it if not in charge, the dtor of the virtual
 	       nearly empty base will do that later.  */
-	    if (CLASSTYPE_VBASECLASSES (current_class_type)
-		&& CLASSTYPE_PRIMARY_BINFO (current_class_type)
-		&& BINFO_VIRTUAL_P
-			  (CLASSTYPE_PRIMARY_BINFO (current_class_type)))
+	    if (CLASSTYPE_VBASECLASSES (current_class_type))
 	      {
-		stmt = convert_to_void (stmt, ICV_STATEMENT,
-					tf_warning_or_error);
-		stmt = build_if_in_charge (stmt);
+		tree c = current_class_type;
+		while (CLASSTYPE_PRIMARY_BINFO (c))
+		  {
+		    if (BINFO_VIRTUAL_P (CLASSTYPE_PRIMARY_BINFO (c)))
+		      {
+			stmt = convert_to_void (stmt, ICV_STATEMENT,
+						tf_warning_or_error);
+			stmt = build_if_in_charge (stmt);
+			break;
+		      }
+		    c = BINFO_TYPE (CLASSTYPE_PRIMARY_BINFO (c));
+		  }
 	      }
 	    finish_decl_cleanup (NULL_TREE, stmt);
 	  }
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index a46cbce08f4..a15bb3c45cc 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1208,7 +1208,7 @@ is_late_template_attribute (tree attr, tree decl)
    the declaration itself is dependent, so all attributes should be applied
    at instantiation time.  */
 
-static tree
+tree
 splice_template_attributes (tree *attr_p, tree decl)
 {
   tree *p = attr_p;
diff --git a/gcc/cp/expr.c b/gcc/cp/expr.c
index 9160043ed11..5a60da36025 100644
--- a/gcc/cp/expr.c
+++ b/gcc/cp/expr.c
@@ -195,11 +195,23 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
 	  tree nop = RECUR (op);
 	  if (nop == error_mark_node)
 	    return error_mark_node;
-	  TREE_OPERAND (expr, 0) = nop;
-	  /* If we're replacing a DECL with a constant, we also need to change
-	     the TREE_CODE of the location wrapper.  */
-	  if (op != nop && rvalue_p)
-	    TREE_SET_CODE (expr, NON_LVALUE_EXPR);
+	  else if (op == nop)
+	    /* No change.  */;
+	  else if (DECL_P (nop) || CONSTANT_CLASS_P (nop))
+	    {
+	      /* Reuse the location wrapper.  */
+	      TREE_OPERAND (expr, 0) = nop;
+	      /* If we're replacing a DECL with a constant, we also need to
+		 change the TREE_CODE of the location wrapper.  */
+	      if (rvalue_p)
+		TREE_SET_CODE (expr, NON_LVALUE_EXPR);
+	    }
+	  else
+	    {
+	      /* Drop the location wrapper.  */
+	      expr = nop;
+	      protected_set_expr_location (expr, loc);
+	    }
 	  return expr;
 	}
       gcc_fallthrough();
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index fcc91fc9172..c5a01c83093 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -586,16 +586,18 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 	  DECL_INSTANTIATING_NSDMI_P (member) = 1;
 
 	  bool pushed = false;
-	  if (!currently_open_class (DECL_CONTEXT (member)))
+	  tree ctx = DECL_CONTEXT (member);
+	  if (!currently_open_class (ctx)
+	      && !LOCAL_CLASS_P (ctx))
 	    {
 	      push_to_top_level ();
-	      push_nested_class (DECL_CONTEXT (member));
+	      push_nested_class (ctx);
 	      pushed = true;
 	    }
 
 	  gcc_checking_assert (!processing_template_decl);
 
-	  inject_this_parameter (DECL_CONTEXT (member), TYPE_UNQUALIFIED);
+	  inject_this_parameter (ctx, TYPE_UNQUALIFIED);
 
 	  start_lambda_scope (member);
 
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index 6f194375261..bab9fdadfb7 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -2856,6 +2856,7 @@ write_expression (tree expr)
   /* Skip NOP_EXPR and CONVERT_EXPR.  They can occur when (say) a pointer
      argument is converted (via qualification conversions) to another type.  */
   while (CONVERT_EXPR_CODE_P (code)
+	 || code == IMPLICIT_CONV_EXPR
 	 || location_wrapper_p (expr)
 	 /* Parentheses aren't mangled.  */
 	 || code == PAREN_EXPR
@@ -3156,7 +3157,8 @@ write_expression (tree expr)
 	  write_type (etype);
 	}
 
-      if (!initializer_zerop (expr) || !trivial_type_p (etype))
+      bool nontriv = !trivial_type_p (etype);
+      if (nontriv || !zero_init_expr_p (expr))
 	{
 	  /* Convert braced initializer lists to STRING_CSTs so that
 	     A<"Foo"> mangles the same as A<{'F', 'o', 'o', 0}> while
@@ -3167,19 +3169,22 @@ write_expression (tree expr)
 	  if (TREE_CODE (expr) == CONSTRUCTOR)
 	    {
 	      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);
-	      unsigned last_nonzero = -1, i;
+	      unsigned last_nonzero = UINT_MAX, i;
 	      tree val;
 
-	      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)
-		if (!initializer_zerop (val))
-		  last_nonzero = i;
+	      if (!nontriv)
+		FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)
+		  if (!zero_init_expr_p (val))
+		    last_nonzero = i;
 
-	      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)
-		{
-		  if (i > last_nonzero)
-		    break;
-		  write_expression (val);
-		}
+	      if (nontriv || last_nonzero != UINT_MAX)
+		FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)
+		  {
+		    if (i > last_nonzero)
+		      break;
+		    /* FIXME handle RANGE_EXPR */
+		    write_expression (val);
+		  }
 	    }
 	  else
 	    {
@@ -3504,7 +3509,7 @@ write_template_arg (tree node)
 
   if (template_parm_object_p (node))
     /* We want to mangle the argument, not the var we stored it in.  */
-    node = DECL_INITIAL (node);
+    node = tparm_object_argument (node);
 
   /* Strip a conversion added by convert_nontype_argument.  */
   if (TREE_CODE (node) == IMPLICIT_CONV_EXPR)
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 8999c5ad4a7..b8eb21e0f97 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -2751,7 +2751,9 @@ check_local_shadow (tree decl)
       else if (warn_shadow_local)
 	warning_code = OPT_Wshadow_local;
       else if (warn_shadow_compatible_local
-	       && (same_type_p (TREE_TYPE (old), TREE_TYPE (decl))
+	       && ((TREE_TYPE (old)
+		    && TREE_TYPE (decl)
+		    && same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))
 		   || (!dependent_type_p (TREE_TYPE (decl))
 		       && !dependent_type_p (TREE_TYPE (old))
 		       /* If the new decl uses auto, we don't yet know
@@ -2988,7 +2990,8 @@ do_pushdecl (tree decl, bool is_friend)
   /* The binding level we will be pushing into.  During local class
      pushing, we want to push to the containing scope.  */
   cp_binding_level *level = current_binding_level;
-  while (level->kind == sk_class)
+  while (level->kind == sk_class
+	 || level->kind == sk_cleanup)
     level = level->level_chain;
 
   /* An anonymous namespace has a NULL DECL_NAME, but we still want to
@@ -7626,10 +7629,10 @@ maybe_save_operator_binding (tree e)
 
   if (!fns && (fns = op_unqualified_lookup (fnname)))
     {
-      tree fn = get_first_fn (fns);
-      if (DECL_CLASS_SCOPE_P (fn))
-	/* We don't need to remember class-scope functions, normal unqualified
-	   lookup will find them again.  */
+      tree d = is_overloaded_fn (fns) ? get_first_fn (fns) : fns;
+      if (DECL_P (d) && DECL_CLASS_SCOPE_P (d))
+	/* We don't need to remember class-scope functions or declarations,
+	   normal unqualified lookup will find them again.  */
 	return;
 
       bindings = tree_cons (fnname, fns, bindings);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index e1c02d7b718..58274a3a8c3 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -10907,7 +10907,12 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)
       /* Parse optional exception specification.  */
       exception_spec = cp_parser_exception_specification_opt (parser);
 
-      std_attrs = cp_parser_std_attribute_spec_seq (parser);
+      /* GCC 8 accepted attributes here, and this is the place for standard
+	 C++11 attributes that appertain to the function type.  */
+      if (cp_next_tokens_can_be_gnu_attribute_p (parser))
+	gnu_attrs = cp_parser_gnu_attributes_opt (parser);
+      else
+	std_attrs = cp_parser_std_attribute_spec_seq (parser);
 
       /* Parse optional trailing return type.  */
       if (cp_lexer_next_token_is (parser->lexer, CPP_DEREF))
@@ -10916,8 +10921,10 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)
           return_type = cp_parser_trailing_type_id (parser);
         }
 
+      /* Also allow GNU attributes at the very end of the declaration, the
+	 usual place for GNU attributes.  */
       if (cp_next_tokens_can_be_gnu_attribute_p (parser))
-	gnu_attrs = cp_parser_gnu_attributes_opt (parser);
+	gnu_attrs = chainon (gnu_attrs, cp_parser_gnu_attributes_opt (parser));
 
       /* The function parameters must be in scope all the way until after the
          trailing-return-type in case of decltype.  */
@@ -13495,7 +13502,7 @@ cp_parser_simple_declaration (cp_parser* parser,
 	    if ((decl != error_mark_node
 		 && DECL_INITIAL (decl) != error_mark_node)
 		|| cp_parser_uncommitted_to_tentative_parse_p (parser))
-	      cp_parser_error (parser, "expected %<,%> or %<;%>");
+	      cp_parser_error (parser, "expected %<;%>");
 	    /* Skip tokens until we reach the end of the statement.  */
 	    cp_parser_skip_to_end_of_statement (parser);
 	    /* If the next token is now a `;', consume it.  */
@@ -18631,7 +18638,9 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,
       if (TREE_CODE (type) == TYPENAME_TYPE)
 	warning (OPT_Wattributes,
 		 "attributes ignored on uninstantiated type");
-      else if (tag_type != enum_type && CLASSTYPE_TEMPLATE_INSTANTIATION (type)
+      else if (tag_type != enum_type
+	       && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM
+	       && CLASSTYPE_TEMPLATE_INSTANTIATION (type)
 	       && ! processing_explicit_instantiation)
 	warning (OPT_Wattributes,
 		 "attributes ignored on template instantiation");
@@ -18705,9 +18714,7 @@ cp_parser_enum_specifier (cp_parser* parser)
   bool is_unnamed = false;
   tree underlying_type = NULL_TREE;
   cp_token *type_start_token = NULL;
-  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;
-
-  parser->colon_corrects_to_scope_p = false;
+  temp_override<bool> cleanup (parser->colon_corrects_to_scope_p, false);
 
   /* Parse tentatively so that we can back up if we don't find a
      enum-specifier.  */
@@ -18747,24 +18754,24 @@ cp_parser_enum_specifier (cp_parser* parser)
 
   push_deferring_access_checks (dk_no_check);
   nested_name_specifier
-      = cp_parser_nested_name_specifier_opt (parser,
-					     /*typename_keyword_p=*/true,
-					     /*check_dependency_p=*/false,
-					     /*type_p=*/false,
-					     /*is_declaration=*/false);
+    = cp_parser_nested_name_specifier_opt (parser,
+					   /*typename_keyword_p=*/true,
+					   /*check_dependency_p=*/false,
+					   /*type_p=*/false,
+					   /*is_declaration=*/false);
 
   if (nested_name_specifier)
     {
       tree name;
 
       identifier = cp_parser_identifier (parser);
-      name =  cp_parser_lookup_name (parser, identifier,
-				     enum_type,
-				     /*is_template=*/false,
-				     /*is_namespace=*/false,
-				     /*check_dependency=*/true,
-				     /*ambiguous_decls=*/NULL,
-				     input_location);
+      name = cp_parser_lookup_name (parser, identifier,
+				    enum_type,
+				    /*is_template=*/false,
+				    /*is_namespace=*/false,
+				    /*check_dependency=*/true,
+				    /*ambiguous_decls=*/NULL,
+				    input_location);
       if (name && name != error_mark_node)
 	{
 	  type = TREE_TYPE (name);
@@ -18844,23 +18851,21 @@ cp_parser_enum_specifier (cp_parser* parser)
     {
       if (cxx_dialect < cxx11 || (!scoped_enum_p && !underlying_type))
 	{
+	  if (has_underlying_type)
+	    cp_parser_commit_to_tentative_parse (parser);
 	  cp_parser_error (parser, "expected %<{%>");
 	  if (has_underlying_type)
-	    {
-	      type = NULL_TREE;
-	      goto out;
-	    }
+	    return error_mark_node;
 	}
       /* An opaque-enum-specifier must have a ';' here.  */
       if ((scoped_enum_p || underlying_type)
 	  && cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))
 	{
+	  if (has_underlying_type)
+	    cp_parser_commit_to_tentative_parse (parser);
 	  cp_parser_error (parser, "expected %<;%> or %<{%>");
 	  if (has_underlying_type)
-	    {
-	      type = NULL_TREE;
-	      goto out;
-	    }
+	    return error_mark_node;
 	}
     }
 
@@ -18876,9 +18881,7 @@ cp_parser_enum_specifier (cp_parser* parser)
 	  push_scope (nested_name_specifier);
 	}
       else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)
-	{
-	  push_nested_namespace (nested_name_specifier);
-	}
+	push_nested_namespace (nested_name_specifier);
     }
 
   /* Issue an error message if type-definitions are forbidden here.  */
@@ -19038,12 +19041,8 @@ cp_parser_enum_specifier (cp_parser* parser)
 	  pop_scope (nested_name_specifier);
 	}
       else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)
-	{
-	  pop_nested_namespace (nested_name_specifier);
-	}
+	pop_nested_namespace (nested_name_specifier);
     }
- out:
-  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
   return type;
 }
 
@@ -32573,6 +32572,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 					   token->location);
 	    }
 	}
+      if (outer_automatic_var_p (decl))
+	decl = process_outer_var_ref (decl, tf_warning_or_error);
       if (decl == error_mark_node)
 	;
       else if (kind != 0)
@@ -32616,7 +32617,11 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 		  parser->colon_corrects_to_scope_p = false;
 		  cp_lexer_consume_token (parser->lexer);
 		  if (!cp_lexer_next_token_is (parser->lexer, CPP_COLON))
-		    low_bound = cp_parser_expression (parser);
+		    {
+		      low_bound = cp_parser_expression (parser);
+		      /* Later handling is not prepared to see through these.  */
+		      gcc_checking_assert (!location_wrapper_p (low_bound));
+		    }
 		  if (!colon)
 		    parser->colon_corrects_to_scope_p
 		      = saved_colon_corrects_to_scope_p;
@@ -32636,7 +32641,11 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 			cp_parser_commit_to_tentative_parse (parser);
 		      if (!cp_lexer_next_token_is (parser->lexer,
 						   CPP_CLOSE_SQUARE))
-			length = cp_parser_expression (parser);
+			{
+			  length = cp_parser_expression (parser);
+			  /* Later handling is not prepared to see through these.  */
+			  gcc_checking_assert (!location_wrapper_p (length));
+			}
 		    }
 		  /* Look for the closing `]'.  */
 		  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,
@@ -35058,7 +35067,7 @@ cp_parser_oacc_clause_async (cp_parser *parser, tree list)
       matching_parens parens;
       parens.consume_open (parser);
 
-      t = cp_parser_expression (parser);
+      t = cp_parser_assignment_expression (parser);
       if (t == error_mark_node
 	  || !parens.require_close (parser))
 	cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
@@ -35087,6 +35096,9 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,
   tree clauses = NULL;
   bool first = true;
 
+  /* Don't create location wrapper nodes within OpenACC clauses.  */
+  auto_suppress_location_wrappers sentinel;
+
   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))
     {
       location_t here;
@@ -37828,9 +37840,9 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,
 	  cp_parser_end_omp_structured_block (parser, save);
 	  stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],
 				      block);
-	  OMP_PARALLEL_COMBINED (stmt) = 1;
 	  if (ret == NULL_TREE)
 	    return ret;
+	  OMP_PARALLEL_COMBINED (stmt) = 1;
 	  return stmt;
 	}
       else if (!flag_openmp)  /* flag_openmp_simd  */
@@ -38768,6 +38780,10 @@ check_clauses:
 static tree
 cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)
 {
+  /* Don't create location wrapper nodes within 'OMP_CLAUSE__CACHE_'
+     clauses.  */
+  auto_suppress_location_wrappers sentinel;
+
   tree stmt, clauses;
 
   clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE__CACHE_, NULL_TREE);
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 4787747b6ff..be3863c1522 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -3773,10 +3773,18 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)
       return NULL_TREE;
 
     case DECL_EXPR:
-      /* Ignore the declaration of a capture proxy for a parameter pack.  */
-      if (is_capture_proxy (DECL_EXPR_DECL (t)))
-	*walk_subtrees = 0;
-      return NULL_TREE;
+      {
+	tree decl = DECL_EXPR_DECL (t);
+	/* Ignore the declaration of a capture proxy for a parameter pack.  */
+	if (is_capture_proxy (decl))
+	  *walk_subtrees = 0;
+	if (is_typedef_decl (decl) && TYPE_ALIAS_P (TREE_TYPE (decl)))
+	  /* Since we stop at aliases above, we need to look through them at
+	     the point of the DECL_EXPR.  */
+	  cp_walk_tree (&DECL_ORIGINAL_TYPE (decl),
+			&find_parameter_packs_r, ppd, ppd->visited);
+	return NULL_TREE;
+      }
 
     case RECORD_TYPE:
       if (TYPE_PTRMEMFUNC_P (t))
@@ -4877,6 +4885,14 @@ process_partial_specialization (tree decl)
       return decl;
     }
 
+  else if (nargs > DECL_NTPARMS (maintmpl))
+    {
+      error ("too many arguments for partial specialization %qT", type);
+      inform (DECL_SOURCE_LOCATION (maintmpl), "primary template here");
+      /* Avoid crash below.  */
+      return decl;
+    }
+
   /* If we aren't in a dependent class, we can actually try deduction.  */
   else if (tpd.level == 1
 	   /* FIXME we should be able to handle a partial specialization of a
@@ -4903,7 +4919,6 @@ process_partial_specialization (tree decl)
 
      Also, we verify that pack expansions only occur at the
      end of the argument list.  */
-  gcc_assert (nargs == DECL_NTPARMS (maintmpl));
   tpd2.parms = 0;
   for (i = 0; i < nargs; ++i)
     {
@@ -6137,6 +6152,33 @@ uses_all_template_parms_r (tree t, void *data_)
   return 0;
 }
 
+/* for_each_template_parm any_fn callback for complex_alias_template_p.  */
+
+static int
+complex_pack_expansion_r (tree t, void *data_)
+{
+  /* An alias template with a pack expansion that expands a pack from the
+     enclosing class needs to be considered complex, to avoid confusion with
+     the same pack being used as an argument to the alias's own template
+     parameter (91966).  */
+  if (!PACK_EXPANSION_P (t))
+    return 0;
+  struct uses_all_template_parms_data &data
+    = *(struct uses_all_template_parms_data*)data_;
+  for (tree pack = PACK_EXPANSION_PARAMETER_PACKS (t); pack;
+       pack = TREE_CHAIN (pack))
+    {
+      tree parm_pack = TREE_VALUE (pack);
+      if (!TEMPLATE_PARM_P (parm_pack))
+	continue;
+      int idx, level;
+      template_parm_level_and_index (parm_pack, &level, &idx);
+      if (level < data.level)
+	return 1;
+    }
+  return 0;
+}
+
 static bool
 complex_alias_template_p (const_tree tmpl)
 {
@@ -6149,7 +6191,9 @@ complex_alias_template_p (const_tree tmpl)
   for (int i = 0; i < len; ++i)
     data.seen[i] = false;
 
-  for_each_template_parm (pat, uses_all_template_parms_r, &data, NULL, true);
+  if (for_each_template_parm (pat, uses_all_template_parms_r, &data,
+			      NULL, true, complex_pack_expansion_r))
+    return true;
   for (int i = 0; i < len; ++i)
     if (!data.seen[i])
       return true;
@@ -6709,6 +6753,11 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)
 
 }
 
+/* The template arguments corresponding to template parameter objects of types
+   that contain pointers to members.  */
+
+static GTY(()) hash_map<tree, tree> *tparm_obj_values;
+
 /* Return a VAR_DECL for the C++20 template parameter object corresponding to
    template argument EXPR.  */
 
@@ -6742,10 +6791,34 @@ get_template_parm_object (tree expr, tsubst_flags_t complain)
   SET_DECL_ASSEMBLER_NAME (decl, name);
   DECL_CONTEXT (decl) = global_namespace;
   comdat_linkage (decl);
+
+  if (!zero_init_p (type))
+    {
+      /* If EXPR contains any PTRMEM_CST, they will get clobbered by
+	 lower_var_init before we're done mangling.  So store the original
+	 value elsewhere.  */
+      tree copy = unshare_constructor (expr);
+      if (!tparm_obj_values)
+	tparm_obj_values = hash_map<tree, tree>::create_ggc (13);
+      tparm_obj_values->put (decl, copy);
+    }
+
   pushdecl_top_level_and_finish (decl, expr);
+
   return decl;
 }
 
+/* Return the actual template argument corresponding to template parameter
+   object VAR.  */
+
+tree
+tparm_object_argument (tree var)
+{
+  if (zero_init_p (TREE_TYPE (var)))
+    return DECL_INITIAL (var);
+  return *(tparm_obj_values->get (var));
+}
+
 /* Attempt to convert the non-type template parameter EXPR to the
    indicated TYPE.  If the conversion is successful, return the
    converted value.  If the conversion is unsuccessful, return
@@ -11824,6 +11897,7 @@ fold_expression (tree t, tree left, tree right, tsubst_flags_t complain)
   if (FOLD_EXPR_MODIFY_P (t))
     return build_x_modify_expr (input_location, left, code, right, complain);
 
+  warning_sentinel s(warn_parentheses);
   switch (code)
     {
     case COMPOUND_EXPR:
@@ -13882,6 +13956,11 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	    if (DECL_HAS_VALUE_EXPR_P (t))
 	      {
 		tree ve = DECL_VALUE_EXPR (t);
+		/* If the DECL_VALUE_EXPR is converted to the declared type,
+		   preserve the identity so that gimplify_type_sizes works.  */
+		bool nop = (TREE_CODE (ve) == NOP_EXPR);
+		if (nop)
+		  ve = TREE_OPERAND (ve, 0);
 		ve = tsubst_expr (ve, args, complain, in_decl,
 				  /*constant_expression_p=*/false);
 		if (REFERENCE_REF_P (ve))
@@ -13889,6 +13968,10 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 		    gcc_assert (TYPE_REF_P (type));
 		    ve = TREE_OPERAND (ve, 0);
 		  }
+		if (nop)
+		  ve = build_nop (type, ve);
+		else
+		  gcc_checking_assert (TREE_TYPE (ve) == type);
 		SET_DECL_VALUE_EXPR (r, ve);
 	      }
 	    if (CP_DECL_THREAD_LOCAL_P (r)
@@ -15828,11 +15911,26 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 		  tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 		  return build1 (code, type, op);
 		}
-	      else
+	      else if (!CP_TYPE_CONST_P (TREE_TYPE (op)))
 		{
-		  gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (op)));
-		  return op;
+		  /* The template argument is not const, presumably because
+		     it is still dependent, and so not the const template parm
+		     object.  */
+		  tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
+		  gcc_checking_assert (same_type_ignoring_top_level_qualifiers_p
+				       (type, TREE_TYPE (op)));
+		  if (TREE_CODE (op) == CONSTRUCTOR
+		      || TREE_CODE (op) == IMPLICIT_CONV_EXPR)
+		    {
+		      /* Don't add a wrapper to these.  */
+		      op = copy_node (op);
+		      TREE_TYPE (op) = type;
+		    }
+		  else
+		    /* Do add a wrapper otherwise.  */
+		    op = build1 (code, type, op);
 		}
+	      return op;
 	    }
 	  /* force_paren_expr can also create a VIEW_CONVERT_EXPR.  */
 	  else if (code == VIEW_CONVERT_EXPR && REF_PARENTHESIZED_P (t))
@@ -16372,6 +16470,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,
 	case OMP_CLAUSE_FROM:
 	case OMP_CLAUSE_TO:
 	case OMP_CLAUSE_MAP:
+	case OMP_CLAUSE__CACHE_:
 	case OMP_CLAUSE_NONTEMPORAL:
 	case OMP_CLAUSE_USE_DEVICE_PTR:
 	case OMP_CLAUSE_IS_DEVICE_PTR:
@@ -17815,6 +17914,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
       add_stmt (t);
       break;
 
+    case OACC_CACHE:
     case OACC_ENTER_DATA:
     case OACC_EXIT_DATA:
     case OACC_UPDATE:
@@ -17838,8 +17938,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
       add_stmt (t);
       break;
 
-    case OMP_SECTION:
     case OMP_MASTER:
+      omp_parallel_combined_clauses = NULL;
+      /* FALLTHRU */
+    case OMP_SECTION:
       stmt = push_stmt_list ();
       RECUR (OMP_BODY (t));
       stmt = pop_stmt_list (stmt);
@@ -27376,10 +27478,13 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)
 				     complain, ctor);
 	  if (fparms == error_mark_node)
 	    ok = false;
-	  fargs = tsubst (fargs, tsubst_args, complain, ctor);
 	  if (ci)
 	    ci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);
 
+	  /* Parms are to have DECL_CHAIN tsubsted, which would be skipped if
+	     cp_unevaluated_operand.  */
+	  cp_evaluated ev;
+	  fargs = tsubst (fargs, tsubst_args, complain, ctor);
 	  current_template_parms = save_parms;
 	}
 
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 4bfb5d15293..3c578fbfa60 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -380,7 +380,8 @@ add_stmt (tree t)
 
       /* When we expand a statement-tree, we must know whether or not the
 	 statements are full-expressions.  We record that fact here.  */
-      STMT_IS_FULL_EXPR_P (t) = stmts_are_full_exprs_p ();
+      if (STATEMENT_CODE_P (TREE_CODE (t)))
+	STMT_IS_FULL_EXPR_P (t) = stmts_are_full_exprs_p ();
     }
 
   if (code == LABEL_EXPR || code == CASE_LABEL_EXPR)
@@ -2437,7 +2438,7 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,
 	      bool abnormal = true;
 	      for (lkp_iterator iter (fn); abnormal && iter; ++iter)
 		{
-		  tree fndecl = *iter;
+		  tree fndecl = STRIP_TEMPLATE (*iter);
 		  if (TREE_CODE (fndecl) != FUNCTION_DECL
 		      || !TREE_THIS_VOLATILE (fndecl))
 		    abnormal = false;
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 3f3583c825d..896c67c850a 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -746,7 +746,15 @@ build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)
 {
   tree slot;
   bool value_init = false;
-  tree elt_init = build_vec_init_elt (type, init, complain);
+  tree elt_init;
+  if (init && TREE_CODE (init) == CONSTRUCTOR)
+    {
+      gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));
+      /* We built any needed constructor calls in digest_init.  */
+      elt_init = init;
+    }
+  else
+    elt_init = build_vec_init_elt (type, init, complain);
 
   if (init == void_type_node)
     {
@@ -2402,6 +2410,8 @@ is_overloaded_fn (tree x)
 tree
 dependent_name (tree x)
 {
+  /* FIXME a dependent name must be unqualified, but this function doesn't
+     distinguish between qualified and unqualified identifiers.  */
   if (identifier_p (x))
     return x;
   if (TREE_CODE (x) == TEMPLATE_ID_EXPR)
@@ -3506,6 +3516,15 @@ called_fns_equal (tree t1, tree t2)
       if (name1 != name2)
 	return false;
 
+      /* FIXME dependent_name currently returns an unqualified name regardless
+	 of whether the function was named with a qualified- or unqualified-id.
+	 Until that's fixed, check that we aren't looking at overload sets from
+	 different scopes.  */
+      if (is_overloaded_fn (t1) && is_overloaded_fn (t2)
+	  && (DECL_CONTEXT (get_first_fn (t1))
+	      != DECL_CONTEXT (get_first_fn (t2))))
+	return false;
+
       if (TREE_CODE (t1) == TEMPLATE_ID_EXPR)
 	targs1 = TREE_OPERAND (t1, 1);
       if (TREE_CODE (t2) == TEMPLATE_ID_EXPR)
@@ -3602,7 +3621,8 @@ cp_tree_equal (tree t1, tree t2)
       {
 	tree arg1, arg2;
 	call_expr_arg_iterator iter1, iter2;
-	if (!called_fns_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))
+	if (KOENIG_LOOKUP_P (t1) != KOENIG_LOOKUP_P (t2)
+	    || !called_fns_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))
 	  return false;
 	for (arg1 = first_call_expr_arg (t1, &iter1),
 	       arg2 = first_call_expr_arg (t2, &iter2);
@@ -3726,6 +3746,9 @@ cp_tree_equal (tree t1, tree t2)
 	    if (SIZEOF_EXPR_TYPE_P (t2))
 	      o2 = TREE_TYPE (o2);
 	  }
+	else if (ALIGNOF_EXPR_STD_P (t1) != ALIGNOF_EXPR_STD_P (t2))
+	  return false;
+
 	if (TREE_CODE (o1) != TREE_CODE (o2))
 	  return false;
 	if (TYPE_P (o1))
@@ -4364,6 +4387,33 @@ zero_init_p (const_tree t)
   return 1;
 }
 
+/* Returns true if the expression or initializer T is the result of
+   zero-initialization for its type, taking pointers to members
+   into consideration.  */
+
+bool
+zero_init_expr_p (tree t)
+{
+  tree type = TREE_TYPE (t);
+  if (!type || uses_template_parms (type))
+    return false;
+  if (zero_init_p (type))
+    return initializer_zerop (t);
+  if (TYPE_PTRMEM_P (type))
+    return null_member_pointer_value_p (t);
+  if (TREE_CODE (t) == CONSTRUCTOR
+      && CP_AGGREGATE_TYPE_P (type))
+    {
+      tree elt_init;
+      unsigned HOST_WIDE_INT i;
+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, elt_init)
+	if (!zero_init_expr_p (elt_init))
+	  return false;
+      return true;
+    }
+  return false;
+}
+
 /* Handle the C++17 [[nodiscard]] attribute, which is similar to the GNU
    warn_unused_result attribute.  */
 
@@ -5492,76 +5542,6 @@ maybe_warn_zero_as_null_pointer_constant (tree expr, location_t loc)
   return false;
 }
 
-/* Given an initializer INIT for a TYPE, return true if INIT is zero
-   so that it can be replaced by value initialization.  This function
-   distinguishes betwen empty strings as initializers for arrays and
-   for pointers (which make it return false).  */
-
-bool
-type_initializer_zero_p (tree type, tree init)
-{
-  if (type == error_mark_node || init == error_mark_node)
-    return false;
-
-  STRIP_NOPS (init);
-
-  if (POINTER_TYPE_P (type))
-    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);
-
-  if (TREE_CODE (init) != CONSTRUCTOR)
-    {
-      /* A class can only be initialized by a non-class type if it has
-	 a ctor that converts from that type.  Such classes are excluded
-	 since their semantics are unknown.  */
-      if (RECORD_OR_UNION_TYPE_P (type)
-	  && !RECORD_OR_UNION_TYPE_P (TREE_TYPE (init)))
-	return false;
-      return initializer_zerop (init);
-    }
-
-  if (TREE_CODE (type) == ARRAY_TYPE)
-    {
-      tree elt_type = TREE_TYPE (type);
-      elt_type = TYPE_MAIN_VARIANT (elt_type);
-      if (elt_type == char_type_node)
-	return initializer_zerop (init);
-
-      tree elt_init;
-      unsigned HOST_WIDE_INT i;
-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)
-	if (!type_initializer_zero_p (elt_type, elt_init))
-	  return false;
-      return true;
-    }
-
-  if (TREE_CODE (type) != RECORD_TYPE)
-    return initializer_zerop (init);
-
-  if (TYPE_NON_AGGREGATE_CLASS (type))
-    return false;
-
-  tree fld = TYPE_FIELDS (type);
-
-  tree fld_init;
-  unsigned HOST_WIDE_INT i;
-  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)
-    {
-      fld = next_initializable_field (fld);
-      if (!fld)
-	return true;
-
-      tree fldtype = TREE_TYPE (fld);
-      if (!type_initializer_zero_p (fldtype, fld_init))
-	return false;
-
-      fld = DECL_CHAIN (fld);
-      if (!fld)
-	break;
-    }
-
-  return true;
-}
-
 #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
 /* Complain that some language-specific thing hanging off a tree
    node has been accessed improperly.  */
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 2169f8c4efd..ab703a3ff07 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -3238,6 +3238,22 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,
     return rval;
 }
 
+/* Like c-family strict_aliasing_warning, but don't warn for dependent
+   types or expressions.  */
+
+static bool
+cp_strict_aliasing_warning (location_t loc, tree type, tree expr)
+{
+  if (processing_template_decl)
+    {
+      tree e = expr;
+      STRIP_NOPS (e);
+      if (dependent_type_p (type) || type_dependent_expression_p (e))
+	return false;
+    }
+  return strict_aliasing_warning (loc, type, expr);
+}
+
 /* The implementation of the above, and of indirection implied by other
    constructs.  If DO_FOLD is true, fold away INDIRECT_REF of ADDR_EXPR.  */
 
@@ -3280,10 +3296,10 @@ cp_build_indirect_ref_1 (tree ptr, ref_operator errorstring,
 	  /* If a warning is issued, mark it to avoid duplicates from
 	     the backend.  This only needs to be done at
 	     warn_strict_aliasing > 2.  */
-	  if (warn_strict_aliasing > 2)
-	    if (strict_aliasing_warning (EXPR_LOCATION (ptr),
-					 type, TREE_OPERAND (ptr, 0)))
-	      TREE_NO_WARNING (ptr) = 1;
+	  if (warn_strict_aliasing > 2
+	      && cp_strict_aliasing_warning (EXPR_LOCATION (ptr),
+					     type, TREE_OPERAND (ptr, 0)))
+	    TREE_NO_WARNING (ptr) = 1;
 	}
 
       if (VOID_TYPE_P (t))
@@ -7535,7 +7551,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,
       expr = cp_build_addr_expr (expr, complain);
 
       if (warn_strict_aliasing > 2)
-	strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
+	cp_strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
 
       if (expr != error_mark_node)
 	expr = build_reinterpret_cast_1
@@ -7648,7 +7664,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,
 
       if (warn_strict_aliasing <= 2)
 	/* strict_aliasing_warning STRIP_NOPs its expr.  */
-	strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
+	cp_strict_aliasing_warning (EXPR_LOCATION (expr), type, expr);
 
       return build_nop_reinterpret (type, expr);
     }
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index f8268e87d4d..ada783d4025 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,124 @@
+2021-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/99337
+	* dmd/dmodule.c (checkModFileAlias): Don't read past buffer in
+	  comparison.
+
+2021-02-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-02-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98921
+	* dmd/dmangle.c (Mangler::visit (TypeSArray *)): Use buf->print
+	  to format integer value.
+	(Mangler::visit (TypeIdentifier *)): Likewise.
+	(Mangler::toBuffer): Likewise.
+	(Mangler::visit (IntegerExp *)): Likewise.
+	(Mangler::visit (StringExp *)): Likewise.
+	(Mangler::visit (ArrayLiteralExp *)): Likewise.
+	(Mangler::visit (AssocArrayLiteralExp *)): Likewise.
+	(Mangler::visit (StructLiteralExp *)): Likewise.
+	* dmd/root/outbuffer.c (OutBuffer::print): New function.
+	* dmd/root/outbuffer.h (OutBuffer::print): Declare.
+
+2020-12-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-12-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98277
+	* decl.cc (DeclVisitor::visit (VarDeclaration *)): Move setting of
+	DECL_INITIAL for manifest constants to ...
+	(get_symbol_decl): ... here.
+
+2020-10-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-10-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* dmd/declaration.c (AliasDeclaration::aliasSemantic): Apply storage
+	class and protection attributes.
+
+2020-08-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-07-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96140
+	* intrinsics.cc (expand_intrinsic_vaarg): Handle ref parameters as
+	arguments to va_arg().
+	(expand_intrinsic_vastart): Handle ref parameters as arguments to
+	va_start().
+
+2020-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-06-25  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95250
+	* dmd/expressionsem.c (class ExpressionSemanticVisitor): Return early
+	if error occurred during semantic of DivExp.
+
+2020-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-06-25  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95173
+	* d-attribs.cc (uda_attribute_p): Don't search target attribute table
+	if NULL.
+
+2020-05-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backport from mainline
+	2020-03-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/92216
+	* decl.cc (make_thunk): Don't set TREE_PUBLIC on thunks if the target
+	function is external to the current compilation.
+
+2020-05-17  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backport from mainline
+	2020-05-06  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/94970
+	* d-codegen.cc (force_target_expr): Move create_temporary_var
+	implementation inline here.
+	(create_temporary_var): Remove.
+	(maybe_temporary_var): Remove.
+	(bind_expr): Remove.
+	* d-convert.cc (d_array_convert): Use build_local_temp to generate
+	temporaries, and generate its assignment.
+	* d-tree.h (create_temporary_var): Remove.
+	(maybe_temporary_var): Remove.
+	(d_array_convert): Remove vars argument.
+	* expr.cc (ExprVisitor::visit (CatExp *)): Use build_local_temp to
+	generate temporaries, don't wrap them in a BIND_EXPR.
+	(ExprVisitor::visit (NewExp *)): Likewise.
+
+2020-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95155
+	* dmd/dclass.c (ClassDeclaration::semantic): Don't prematurely
+	set done on semantic analysis.
+
+2020-04-07  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/94240
+	* typeinfo.cc (class TypeInfoVisitor): Replace type_ field with decl_.
+	(TypeInfoVisitor::TypeInfoVisitor): Set decl_.
+	(TypeInfoVisitor::result): Update.
+	(TypeInfoVisitor::internal_reference): New function.
+	(TypeInfoVisitor::layout_string): Use internal_reference.
+	(TypeInfoVisitor::visit (TypeInfoTupleDeclaration *)): Likewise.
+	(layout_typeinfo): Construct TypeInfoVisitor with typeinfo decl.
+	(layout_classinfo): Likewise.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/d/d-attribs.cc b/gcc/d/d-attribs.cc
index 59dd2eba3c2..03729a65547 100644
--- a/gcc/d/d-attribs.cc
+++ b/gcc/d/d-attribs.cc
@@ -212,10 +212,13 @@ uda_attribute_p (const char *name)
 	return true;
     }
 
-  for (const attribute_spec *p = targetm.attribute_table; p->name; p++)
+  if (targetm.attribute_table)
     {
-      if (get_identifier (p->name) == ident)
-	return true;
+      for (const attribute_spec *p = targetm.attribute_table; p->name; p++)
+	{
+	  if (get_identifier (p->name) == ident)
+	    return true;
+	}
     }
 
   return false;
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index 2abff92fc88..17f624b5a4f 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -612,7 +612,12 @@ build_target_expr (tree decl, tree exp)
 tree
 force_target_expr (tree exp)
 {
-  tree decl = create_temporary_var (TREE_TYPE (exp));
+  tree decl = build_decl (input_location, VAR_DECL, NULL_TREE,
+			  TREE_TYPE (exp));
+  DECL_CONTEXT (decl) = current_function_decl;
+  DECL_ARTIFICIAL (decl) = 1;
+  DECL_IGNORED_P (decl) = 1;
+  layout_decl (decl, 0);
 
   return build_target_expr (decl, exp);
 }
@@ -1801,66 +1806,6 @@ array_bounds_check (void)
     }
 }
 
-/* Return an undeclared local temporary of type TYPE
-   for use with BIND_EXPR.  */
-
-tree
-create_temporary_var (tree type)
-{
-  tree decl = build_decl (input_location, VAR_DECL, NULL_TREE, type);
-
-  DECL_CONTEXT (decl) = current_function_decl;
-  DECL_ARTIFICIAL (decl) = 1;
-  DECL_IGNORED_P (decl) = 1;
-  layout_decl (decl, 0);
-
-  return decl;
-}
-
-/* Return an undeclared local temporary OUT_VAR initialized
-   with result of expression EXP.  */
-
-tree
-maybe_temporary_var (tree exp, tree *out_var)
-{
-  tree t = exp;
-
-  /* Get the base component.  */
-  while (TREE_CODE (t) == COMPONENT_REF)
-    t = TREE_OPERAND (t, 0);
-
-  if (!DECL_P (t) && !REFERENCE_CLASS_P (t))
-    {
-      *out_var = create_temporary_var (TREE_TYPE (exp));
-      DECL_INITIAL (*out_var) = exp;
-      return *out_var;
-    }
-  else
-    {
-      *out_var = NULL_TREE;
-      return exp;
-    }
-}
-
-/* Builds a BIND_EXPR around BODY for the variables VAR_CHAIN.  */
-
-tree
-bind_expr (tree var_chain, tree body)
-{
-  /* Only handles one var.  */
-  gcc_assert (TREE_CHAIN (var_chain) == NULL_TREE);
-
-  if (DECL_INITIAL (var_chain))
-    {
-      tree ini = build_assign (INIT_EXPR, var_chain, DECL_INITIAL (var_chain));
-      DECL_INITIAL (var_chain) = NULL_TREE;
-      body = compound_expr (ini, body);
-    }
-
-  return d_save_expr (build3 (BIND_EXPR, TREE_TYPE (body),
-			      var_chain, body, NULL_TREE));
-}
-
 /* Returns the TypeFunction class for Type T.
    Assumes T is already ->toBasetype().  */
 
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index e9aa457d852..761ab3c5435 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -775,21 +775,23 @@ d_array_convert (Expression *exp)
 
 /* Convert EXP to a dynamic array, where ETYPE is the element type.
    Similar to above, except that EXP is allowed to be an element of an array.
-   Temporary variables that need some kind of BIND_EXPR are pushed to VARS.  */
+   Temporary variables are created inline if EXP is not an lvalue.  */
 
 tree
-d_array_convert (Type *etype, Expression *exp, vec<tree, va_gc> **vars)
+d_array_convert (Type *etype, Expression *exp)
 {
   Type *tb = exp->type->toBasetype ();
 
   if ((tb->ty != Tarray && tb->ty != Tsarray) || same_type_p (tb, etype))
     {
       /* Convert single element to an array.  */
-      tree var = NULL_TREE;
-      tree expr = maybe_temporary_var (build_expr (exp), &var);
+      tree expr = build_expr (exp);
 
-      if (var != NULL_TREE)
-	vec_safe_push (*vars, var);
+      if (!exp->isLvalue ())
+	{
+	  tree var = build_local_temp (TREE_TYPE (expr));
+	  expr = compound_expr (modify_expr (var, expr), var);
+	}
 
       return d_array_value (build_ctype (exp->type->arrayOf ()),
 			    size_int (1), build_address (expr));
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index a514bc3902f..7a54dfbc59e 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -558,8 +558,6 @@ extern tree build_array_from_val (Type *, tree);
 extern tree void_okay_p (tree);
 extern tree build_bounds_condition (const Loc &, tree, tree, bool);
 extern bool array_bounds_check (void);
-extern tree create_temporary_var (tree);
-extern tree maybe_temporary_var (tree, tree *);
 extern tree bind_expr (tree, tree);
 extern TypeFunction *get_function_type (Type *);
 extern bool call_by_alias_p (FuncDeclaration *, FuncDeclaration *);
@@ -583,7 +581,7 @@ extern tree convert_for_assignment (tree, Type *, Type *);
 extern tree convert_for_argument (tree, Parameter *);
 extern tree convert_for_condition (tree, Type *);
 extern tree d_array_convert (Expression *);
-extern tree d_array_convert (Type *, Expression *, vec<tree, va_gc> **);
+extern tree d_array_convert (Type *, Expression *);
 
 /* In d-incpath.cc.  */
 extern void add_import_paths (const char *, const char *, bool);
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index 49723649230..d24f5dcd958 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -673,31 +673,13 @@ public:
 	return;
       }
 
-    /* Do not store variables we cannot take the address of,
-       but keep the values for purposes of debugging.  */
     if (!d->canTakeAddressOf ())
       {
-	/* Don't know if there is a good way to handle instantiations.  */
-	if (d->isInstantiated ())
-	  return;
-
-	/* Cannot make an expression out of a void initializer.  */
-	if (!d->_init || d->_init->isVoidInitializer ())
-	  return;
-
-	tree decl = get_symbol_decl (d);
-	Expression *ie = initializerToExpression (d->_init);
-
-	/* CONST_DECL was initially intended for enumerals and may be used for
-	   scalars in general, but not for aggregates.  Here a non-constant
-	   value is generated anyway so as the CONST_DECL only serves as a
-	   placeholder for the value, however the DECL itself should never be
-	   referenced in any generated code, or passed to the back-end.  */
+	/* Do not store variables we cannot take the address of,
+	   but keep the values for purposes of debugging.  */
 	if (!d->type->isscalar ())
-	  DECL_INITIAL (decl) = build_expr (ie, false);
-	else
 	  {
-	    DECL_INITIAL (decl) = build_expr (ie, true);
+	    tree decl = get_symbol_decl (d);
 	    d_pushdecl (decl);
 	    rest_of_decl_compilation (decl, 1, 0);
 	  }
@@ -1135,6 +1117,25 @@ get_symbol_decl (Declaration *decl)
 
       if (vd->storage_class & STCextern)
 	DECL_EXTERNAL (decl->csym) = 1;
+
+      /* CONST_DECL was initially intended for enumerals and may be used for
+	 scalars in general, but not for aggregates.  Here a non-constant
+	 value is generated anyway so as the CONST_DECL only serves as a
+	 placeholder for the value, however the DECL itself should never be
+	 referenced in any generated code, or passed to the back-end.  */
+      if (vd->storage_class & STCmanifest)
+	{
+	  /* Cannot make an expression out of a void initializer.  */
+	  if (vd->_init && !vd->_init->isVoidInitializer ())
+	    {
+	      Expression *ie = initializerToExpression (vd->_init);
+
+	      if (!vd->type->isscalar ())
+		DECL_INITIAL (decl->csym) = build_expr (ie, false);
+	      else
+		DECL_INITIAL (decl->csym) = build_expr (ie, true);
+	    }
+	}
     }
 
   /* Set the declaration mangled identifier if static.  */
@@ -1803,8 +1804,11 @@ make_thunk (FuncDeclaration *decl, int offset)
 
   DECL_CONTEXT (thunk) = d_decl_context (decl);
 
-  /* Thunks inherit the public access of the function they are targetting.  */
-  TREE_PUBLIC (thunk) = TREE_PUBLIC (function);
+  /* Thunks inherit the public access of the function they are targetting.
+     When the function is outside the current compilation unit however, then the
+     thunk must be kept private to not conflict.  */
+  TREE_PUBLIC (thunk) = TREE_PUBLIC (function) && !DECL_EXTERNAL (function);
+
   DECL_EXTERNAL (thunk) = 0;
 
   /* Thunks are always addressable.  */
diff --git a/gcc/d/dmd/dclass.c b/gcc/d/dmd/dclass.c
index 572b3e24387..66869361dcb 100644
--- a/gcc/d/dmd/dclass.c
+++ b/gcc/d/dmd/dclass.c
@@ -395,7 +395,6 @@ void ClassDeclaration::semantic(Scope *sc)
     }
     else if (symtab && !scx)
     {
-        semanticRun = PASSsemanticdone;
         return;
     }
     semanticRun = PASSsemantic;
diff --git a/gcc/d/dmd/declaration.c b/gcc/d/dmd/declaration.c
index d0911e21858..0e5fe6259fd 100644
--- a/gcc/d/dmd/declaration.c
+++ b/gcc/d/dmd/declaration.c
@@ -340,6 +340,13 @@ void AliasDeclaration::semantic(Scope *sc)
 void AliasDeclaration::aliasSemantic(Scope *sc)
 {
     //printf("AliasDeclaration::semantic() %s\n", toChars());
+
+    // as AliasDeclaration::semantic, in case we're called first.
+    // see https://issues.dlang.org/show_bug.cgi?id=21001
+    storage_class |= sc->stc & STCdeprecated;
+    protection = sc->protection;
+    userAttribDecl = sc->userAttribDecl;
+
     if (aliassym)
     {
         FuncDeclaration *fd = aliassym->isFuncLiteralDeclaration();
diff --git a/gcc/d/dmd/dmangle.c b/gcc/d/dmd/dmangle.c
index 44f4f826b41..a6a41cb54d0 100644
--- a/gcc/d/dmd/dmangle.c
+++ b/gcc/d/dmd/dmangle.c
@@ -176,7 +176,7 @@ public:
     {
         visit((Type *)t);
         if (t->dim)
-            buf->printf("%llu", t->dim->toInteger());
+            buf->print(t->dim->toInteger());
         if (t->next)
             visitWithMask(t->next, t->mod);
     }
@@ -274,7 +274,8 @@ public:
         visit((Type *)t);
         const char *name = t->ident->toChars();
         size_t len = strlen(name);
-        buf->printf("%u%s", (unsigned)len, name);
+        buf->print(len);
+        buf->writestring(name);
     }
 
     void visit(TypeEnum *t)
@@ -396,7 +397,7 @@ public:
             s->error("excessive length %llu for symbol, possible recursive expansion?", len);
         else
         {
-            buf->printf("%llu", (ulonglong)len);
+            buf->print(len);
             buf->write(id, len);
         }
     }
@@ -614,9 +615,15 @@ public:
     void visit(IntegerExp *e)
     {
         if ((sinteger_t)e->value < 0)
-            buf->printf("N%lld", -e->value);
+        {
+            buf->writeByte('N');
+            buf->print(-e->value);
+        }
         else
-            buf->printf("i%lld",  e->value);
+        {
+            buf->writeByte('i');
+            buf->print(e->value);
+        }
     }
 
     void visit(RealExp *e)
@@ -738,7 +745,8 @@ public:
         }
         buf->reserve(1 + 11 + 2 * qlen);
         buf->writeByte(m);
-        buf->printf("%d_", (int)qlen); // nbytes <= 11
+        buf->print(qlen);
+        buf->writeByte('_');    // nbytes <= 11
 
         for (utf8_t *p = (utf8_t *)buf->data + buf->offset, *pend = p + 2 * qlen;
              p < pend; p += 2, ++q)
@@ -754,7 +762,8 @@ public:
     void visit(ArrayLiteralExp *e)
     {
         size_t dim = e->elements ? e->elements->dim : 0;
-        buf->printf("A%u", dim);
+        buf->writeByte('A');
+        buf->print(dim);
         for (size_t i = 0; i < dim; i++)
         {
             e->getElement(i)->accept(this);
@@ -764,7 +773,8 @@ public:
     void visit(AssocArrayLiteralExp *e)
     {
         size_t dim = e->keys->dim;
-        buf->printf("A%u", dim);
+        buf->writeByte('A');
+        buf->print(dim);
         for (size_t i = 0; i < dim; i++)
         {
             (*e->keys)[i]->accept(this);
@@ -775,7 +785,8 @@ public:
     void visit(StructLiteralExp *e)
     {
         size_t dim = e->elements ? e->elements->dim : 0;
-        buf->printf("S%u", dim);
+        buf->writeByte('S');
+        buf->print(dim);
         for (size_t i = 0; i < dim; i++)
         {
             Expression *ex = (*e->elements)[i];
diff --git a/gcc/d/dmd/dmodule.c b/gcc/d/dmd/dmodule.c
index 1f6fd9f10a6..2779f627b8d 100644
--- a/gcc/d/dmd/dmodule.c
+++ b/gcc/d/dmd/dmodule.c
@@ -202,7 +202,7 @@ static void checkModFileAlias(OutBuffer *buf, OutBuffer *dotmods,
         const char *m = (*ms)[j];
         const char *q = strchr(m, '=');
         assert(q);
-        if (dotmods->offset <= (size_t)(q - m) && memcmp(dotmods->peekString(), m, q - m) == 0)
+        if (dotmods->offset == (size_t)(q - m) && memcmp(dotmods->peekString(), m, q - m) == 0)
         {
             buf->reset();
             size_t qlen = strlen(q + 1);
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 19b7ccb7236..75794a03285 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -6837,6 +6837,7 @@ public:
         if (Expression *ex = binSemanticProp(exp, sc))
         {
             result = ex;
+            return;
         }
         Expression *e = exp->op_overload(sc);
         if (e)
diff --git a/gcc/d/dmd/root/outbuffer.c b/gcc/d/dmd/root/outbuffer.c
index 4f478e2306a..08562330724 100644
--- a/gcc/d/dmd/root/outbuffer.c
+++ b/gcc/d/dmd/root/outbuffer.c
@@ -325,6 +325,37 @@ void OutBuffer::printf(const char *format, ...)
     va_end(ap);
 }
 
+/**************************************
+ * Convert `u` to a string and append it to the buffer.
+ * Params:
+ *  u = integral value to append
+ */
+void OutBuffer::print(unsigned long long u)
+{
+    unsigned long long value = u;
+    char buf[20];
+    const unsigned radix = 10;
+
+    size_t i = sizeof(buf);
+    do
+    {
+        if (value < radix)
+        {
+            unsigned char x = (unsigned char)value;
+            buf[--i] = (char)(x + '0');
+            break;
+        }
+        else
+        {
+            unsigned char x = (unsigned char)(value % radix);
+            value = value / radix;
+            buf[--i] = (char)(x + '0');
+        }
+    } while (value);
+
+    write(buf + i, sizeof(buf) - i);
+}
+
 void OutBuffer::bracket(char left, char right)
 {
     reserve(2);
diff --git a/gcc/d/dmd/root/outbuffer.h b/gcc/d/dmd/root/outbuffer.h
index 7c8cc7c6793..920f4d05721 100644
--- a/gcc/d/dmd/root/outbuffer.h
+++ b/gcc/d/dmd/root/outbuffer.h
@@ -62,6 +62,7 @@ public:
     void fill0(size_t nbytes);
     void vprintf(const char *format, va_list args);
     void printf(const char *format, ...);
+    void print(unsigned long long u);
     void bracket(char left, char right);
     size_t bracket(size_t i, const char *left, size_t j, const char *right);
     void spread(size_t offset, size_t nbytes);
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 6497619e5fd..3a2823d6e46 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -691,7 +691,6 @@ public:
     else
       etype = tb2->nextOf ();
 
-    vec<tree, va_gc> *elemvars = NULL;
     tree result;
 
     if (e->e1->op == TOKcat)
@@ -711,9 +710,7 @@ public:
 
 	/* Store all concatenation args to a temporary byte[][ndims] array.  */
 	Type *targselem = Type::tint8->arrayOf ();
-	tree var = create_temporary_var (make_array_type (targselem, ndims));
-	tree init = build_constructor (TREE_TYPE (var), NULL);
-	vec_safe_push (elemvars, var);
+	tree var = build_local_temp (make_array_type (targselem, ndims));
 
 	/* Loop through each concatenation from right to left.  */
 	vec<constructor_elt, va_gc> *elms = NULL;
@@ -725,7 +722,7 @@ public:
 	      ? (oe = ce->e1)
 	      : (ce = (CatExp *)ce->e1, oe = ce->e2)))
 	  {
-	    tree arg = d_array_convert (etype, oe, &elemvars);
+	    tree arg = d_array_convert (etype, oe);
 	    tree index = size_int (dim);
 	    CONSTRUCTOR_APPEND_ELT (elms, index, d_save_expr (arg));
 
@@ -738,8 +735,8 @@ public:
 
 	/* Check there is no logic bug in constructing byte[][] of arrays.  */
 	gcc_assert (dim == 0);
-	CONSTRUCTOR_ELTS (init) = elms;
-	DECL_INITIAL (var) = init;
+	tree init = build_constructor (TREE_TYPE (var), elms);
+	var = compound_expr (modify_expr (var, init), var);
 
 	tree arrs = d_array_value (build_ctype (targselem->arrayOf ()),
 				   size_int (ndims), build_address (var));
@@ -752,13 +749,10 @@ public:
 	/* Handle single concatenation (a ~ b).  */
 	result = build_libcall (LIBCALL_ARRAYCATT, e->type, 3,
 				build_typeinfo (e->loc, e->type),
-				d_array_convert (etype, e->e1, &elemvars),
-				d_array_convert (etype, e->e2, &elemvars));
+				d_array_convert (etype, e->e1),
+				d_array_convert (etype, e->e2));
       }
 
-    for (size_t i = 0; i < vec_safe_length (elemvars); ++i)
-      result = bind_expr ((*elemvars)[i], result);
-
     this->result_ = result;
   }
 
@@ -2480,12 +2474,13 @@ public:
 	else
 	  {
 	    /* Multidimensional array allocations.  */
-	    vec<constructor_elt, va_gc> *elms = NULL;
-	    Type *telem = e->newtype->toBasetype ();
 	    tree tarray = make_array_type (Type::tsize_t, e->arguments->dim);
-	    tree var = create_temporary_var (tarray);
-	    tree init = build_constructor (TREE_TYPE (var), NULL);
+	    tree var = build_local_temp (tarray);
+	    vec<constructor_elt, va_gc> *elms = NULL;
 
+	    /* Get the base element type for the array, generating the
+	       initializer for the dims parameter along the way.  */
+	    Type *telem = e->newtype->toBasetype ();
 	    for (size_t i = 0; i < e->arguments->dim; i++)
 	      {
 		Expression *arg = (*e->arguments)[i];
@@ -2496,8 +2491,9 @@ public:
 		gcc_assert (telem);
 	      }
 
-	    CONSTRUCTOR_ELTS (init) = elms;
-	    DECL_INITIAL (var) = init;
+	    /* Initialize the temporary.  */
+	    tree init = modify_expr (var, build_constructor (tarray, elms));
+	    var = compound_expr (init, var);
 
 	    /* Generate: _d_newarraymTX(ti, dims)
 		     or: _d_newarraymiTX(ti, dims)  */
@@ -2510,7 +2506,6 @@ public:
 				       build_address (var));
 
 	    result = build_libcall (libcall, tb, 2, tinfo, dims);
-	    result = bind_expr (var, result);
 	  }
 
 	if (e->argprefix)
diff --git a/gcc/d/intrinsics.cc b/gcc/d/intrinsics.cc
index 4bd321b2db7..f8b8b90636d 100644
--- a/gcc/d/intrinsics.cc
+++ b/gcc/d/intrinsics.cc
@@ -495,8 +495,17 @@ expand_intrinsic_vaarg (tree callexp)
     {
       parmn = CALL_EXPR_ARG (callexp, 1);
       STRIP_NOPS (parmn);
-      gcc_assert (TREE_CODE (parmn) == ADDR_EXPR);
-      parmn = TREE_OPERAND (parmn, 0);
+
+      /* The `ref' argument to va_arg is either an address or reference,
+	 get the value of it.  */
+      if (TREE_CODE (parmn) == PARM_DECL && POINTER_TYPE_P (TREE_TYPE (parmn)))
+	parmn = build_deref (parmn);
+      else
+	{
+	  gcc_assert (TREE_CODE (parmn) == ADDR_EXPR);
+	  parmn = TREE_OPERAND (parmn, 0);
+	}
+
       type = TREE_TYPE (parmn);
     }
 
@@ -530,10 +539,16 @@ expand_intrinsic_vastart (tree callexp)
   /* The va_list argument should already have its address taken.  The second
      argument, however, is inout and that needs to be fixed to prevent a
      warning.  Could be casting, so need to check type too?  */
-  gcc_assert (TREE_CODE (ap) == ADDR_EXPR && TREE_CODE (parmn) == ADDR_EXPR);
+  gcc_assert (TREE_CODE (ap) == ADDR_EXPR
+	      || (TREE_CODE (ap) == PARM_DECL
+		  && POINTER_TYPE_P (TREE_TYPE (ap))));
 
   /* Assuming nobody tries to change the return type.  */
-  parmn = TREE_OPERAND (parmn, 0);
+  if (TREE_CODE (parmn) != PARM_DECL)
+    {
+      gcc_assert (TREE_CODE (parmn) == ADDR_EXPR);
+      parmn = TREE_OPERAND (parmn, 0);
+    }
 
   return call_builtin_fn (callexp, BUILT_IN_VA_START, 2, ap, parmn);
 }
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index bbd3961181d..0b19bcf7f34 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -324,9 +324,29 @@ class TypeInfoVisitor : public Visitor
 {
   using Visitor::visit;
 
-  tree type_;
+  tree decl_;
   vec<constructor_elt, va_gc> *init_;
 
+  /* Build an internal comdat symbol for the manifest constant VALUE, so that
+     its address can be taken.  */
+
+  tree internal_reference (tree value)
+  {
+    /* Use the typeinfo decl name as a prefix for the internal symbol.  */
+    const char *prefix = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (this->decl_));
+    tree decl = build_artificial_decl (TREE_TYPE (value), value, prefix);
+
+    /* The internal pointer reference should be public, but not visible outside
+       the compilation unit.  */
+    DECL_EXTERNAL (decl) = 0;
+    TREE_PUBLIC (decl) = 1;
+    DECL_VISIBILITY (decl) = VISIBILITY_INTERNAL;
+    d_comdat_linkage (decl);
+    d_pushdecl (decl);
+
+    return decl;
+  }
+
   /* Add VALUE to the constructor values list.  */
 
   void layout_field (tree value)
@@ -347,10 +367,8 @@ class TypeInfoVisitor : public Visitor
     TREE_STATIC (value) = 1;
 
     /* Taking the address, so assign the literal to a static var.  */
-    tree decl = build_artificial_decl (TREE_TYPE (value), value);
+    tree decl = this->internal_reference (value);
     TREE_READONLY (decl) = 1;
-    DECL_EXTERNAL (decl) = 0;
-    d_pushdecl (decl);
 
     value = d_array_value (build_ctype (Type::tchar->arrayOf ()),
 			   size_int (len), build_address (decl));
@@ -483,9 +501,9 @@ class TypeInfoVisitor : public Visitor
 
 
 public:
-  TypeInfoVisitor (tree type)
+  TypeInfoVisitor (tree decl)
   {
-    this->type_ = type;
+    this->decl_ = decl;
     this->init_ = NULL;
   }
 
@@ -493,7 +511,7 @@ public:
 
   tree result (void)
   {
-    return build_struct_literal (this->type_, this->init_);
+    return build_struct_literal (TREE_TYPE (this->decl_), this->init_);
   }
 
   /* Layout of TypeInfo is:
@@ -1108,19 +1126,12 @@ public:
 				build_typeinfo (d->loc, arg->type));
       }
     tree ctor = build_constructor (build_ctype (satype), elms);
-    tree decl = build_artificial_decl (TREE_TYPE (ctor), ctor);
-
-    /* The internal pointer reference should be public, but not visible outside
-       the compilation unit, as it's referencing COMDAT decls.  */
-    TREE_PUBLIC (decl) = 1;
-    DECL_VISIBILITY (decl) = VISIBILITY_INTERNAL;
-    DECL_COMDAT (decl) = 1;
+    tree decl = this->internal_reference (ctor);
 
     tree length = size_int (ti->arguments->dim);
     tree ptr = build_address (decl);
     this->layout_field (d_array_value (array_type_node, length, ptr));
 
-    d_pushdecl (decl);
     rest_of_decl_compilation (decl, 1, 0);
   }
 };
@@ -1132,8 +1143,7 @@ public:
 tree
 layout_typeinfo (TypeInfoDeclaration *d)
 {
-  tree type = TREE_TYPE (get_typeinfo_decl (d));
-  TypeInfoVisitor v = TypeInfoVisitor (type);
+  TypeInfoVisitor v = TypeInfoVisitor (get_typeinfo_decl (d));
   d->accept (&v);
   return v.result ();
 }
@@ -1145,8 +1155,7 @@ tree
 layout_classinfo (ClassDeclaration *cd)
 {
   TypeInfoClassDeclaration *d = TypeInfoClassDeclaration::create (cd->type);
-  tree type = TREE_TYPE (get_classinfo_decl (cd));
-  TypeInfoVisitor v = TypeInfoVisitor (type);
+  TypeInfoVisitor v = TypeInfoVisitor (get_classinfo_decl (cd));
   d->accept (&v);
   return v.result ();
 }
diff --git a/gcc/df-core.c b/gcc/df-core.c
index b19ba289d16..2f5d0f02d17 100644
--- a/gcc/df-core.c
+++ b/gcc/df-core.c
@@ -1063,7 +1063,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,
 	     " n_basic_blocks %d n_edges %d"
 	     " count %d (%5.2g)\n",
 	     n_basic_blocks_for_fn (cfun), n_edges_for_fn (cfun),
-	     dcount, dcount / (float)n_basic_blocks_for_fn (cfun));
+	     dcount, dcount / (double)n_basic_blocks_for_fn (cfun));
 }
 
 /* Worklist-based dataflow solver. It uses sbitmap as a worklist,
diff --git a/gcc/dfp.c b/gcc/dfp.c
index 65d5fcb0845..25a79c4df8a 100644
--- a/gcc/dfp.c
+++ b/gcc/dfp.c
@@ -342,9 +342,13 @@ decimal_to_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from,
 		   const real_format *fmt)
 {
   char string[256];
-  const decimal128 *const d128 = (const decimal128 *) from->sig;
-
-  decimal128ToString (d128, string);
+  if (from->cl == rvc_normal)
+    {
+      const decimal128 *const d128 = (const decimal128 *) from->sig;
+      decimal128ToString (d128, string);
+    }
+  else
+    real_to_decimal (string, from, sizeof (string), 0, 1);
   real_from_string3 (to, string, fmt);
 }
 
@@ -736,4 +740,6 @@ decimal_real_maxval (REAL_VALUE_TYPE *r, int sign, machine_mode mode)
   decimal_real_from_string (r, max);
   if (sign)
     decimal128SetSign ((decimal128 *) r->sig, 1);
+
+  r->sign = sign;
 }
diff --git a/gcc/doc/cpp.texi b/gcc/doc/cpp.texi
index e271f5180d8..520b61fb5bc 100644
--- a/gcc/doc/cpp.texi
+++ b/gcc/doc/cpp.texi
@@ -1632,7 +1632,7 @@ a function can.  The syntax for defining the macro is similar to that of
 a function.  Here is an example:
 
 @smallexample
-#define eprintf(@dots{}) fprintf (stderr, __VA_ARGS__)
+#define eprintf(...) fprintf (stderr, __VA_ARGS__)
 @end smallexample
 
 This kind of macro is called @dfn{variadic}.  When the macro is invoked,
@@ -1656,11 +1656,11 @@ below for an important special case for @samp{##}.)
 If your macro is complicated, you may want a more descriptive name for
 the variable argument than @code{@w{__VA_ARGS__}}.  CPP permits
 this, as an extension.  You may write an argument name immediately
-before the @samp{@dots{}}; that name is used for the variable argument.
+before the @samp{...}; that name is used for the variable argument.
 The @code{eprintf} macro above could be written
 
 @smallexample
-#define eprintf(args@dots{}) fprintf (stderr, args)
+#define eprintf(args...) fprintf (stderr, args)
 @end smallexample
 
 @noindent
@@ -1671,7 +1671,7 @@ You can have named arguments as well as variable arguments in a variadic
 macro.  We could define @code{eprintf} like this, instead:
 
 @smallexample
-#define eprintf(format, @dots{}) fprintf (stderr, format, __VA_ARGS__)
+#define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)
 @end smallexample
 
 @noindent
@@ -1710,7 +1710,7 @@ invocation expands to its argument; but if the variable argument does
 not have any tokens, the @code{@w{__VA_OPT__}} expands to nothing:
 
 @smallexample
-#define eprintf(format, @dots{}) \
+#define eprintf(format, ...) \
   fprintf (stderr, format __VA_OPT__(,) __VA_ARGS__)
 @end smallexample
 
@@ -1723,7 +1723,7 @@ the introduction of @code{@w{__VA_OPT__}}, this extension remains
 supported in GNU CPP, for backward compatibility.  If you write
 
 @smallexample
-#define eprintf(format, @dots{}) fprintf (stderr, format, ##__VA_ARGS__)
+#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)
 @end smallexample
 
 @noindent
@@ -1759,7 +1759,7 @@ replacement list of a variadic macro.
 Variadic macros became a standard part of the C language with C99.  
 GNU CPP previously supported them
 with a named variable argument
-(@samp{args@dots{}}, not @samp{@dots{}} and @code{@w{__VA_ARGS__}}), which
+(@samp{args...}, not @samp{...} and @code{@w{__VA_ARGS__}}), which
 is still supported for backward compatibility.
 
 @node Predefined Macros
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index f5becf988d2..3ab83a1cf94 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -2760,7 +2760,7 @@ the same type as the target function.  As a result of the @code{copy}
 attribute the alias also shares the same attributes as the target.
 
 @smallexample
-#define StrongAlias(TagetFunc, AliasDecl)   \
+#define StrongAlias(TargetFunc, AliasDecl)  \
   extern __typeof__ (TargetFunc) AliasDecl  \
     __attribute__ ((alias (#TargetFunc), copy (TargetFunc)));
 
@@ -3957,6 +3957,12 @@ Select the function scope on which branch protection will be applied.  The
 behavior and permissible arguments are the same as for the command-line option
 @option{-mbranch-protection=}.  The default value is @code{none}.
 
+@item outline-atomics
+@cindex @code{outline-atomics} function attribute, AArch64
+Enable or disable calls to out-of-line helpers to implement atomic operations.
+This corresponds to the behavior of the command line options
+@option{-moutline-atomics} and @option{-mno-outline-atomics}.
+
 @end table
 
 The above target attributes can be specified as follows:
@@ -10914,18 +10920,31 @@ The @var{level} argument must be a constant integer.
 
 On some machines it may be impossible to determine the return address of
 any function other than the current one; in such cases, or when the top
-of the stack has been reached, this function returns @code{0} or a
-random value.  In addition, @code{__builtin_frame_address} may be used
+of the stack has been reached, this function returns an unspecified
+value.  In addition, @code{__builtin_frame_address} may be used
 to determine if the top of the stack has been reached.
 
 Additional post-processing of the returned value may be needed, see
 @code{__builtin_extract_return_addr}.
 
+The stored representation of the return address in memory may be different
+from the address returned by @code{__builtin_return_address}.  For example,
+on AArch64 the stored address may be mangled with return address signing
+whereas the address returned by @code{__builtin_return_address} is not.
+
 Calling this function with a nonzero argument can have unpredictable
 effects, including crashing the calling program.  As a result, calls
 that are considered unsafe are diagnosed when the @option{-Wframe-address}
 option is in effect.  Such calls should only be made in debugging
 situations.
+
+On targets where code addresses are representable as @code{void *},
+@smallexample
+void *addr = __builtin_extract_return_addr (__builtin_return_address (0));
+@end smallexample
+gives the code address where the current function would return.  For example,
+such an address may be used with @code{dladdr} or other interfaces that work
+with code addresses.
 @end deftypefn
 
 @deftypefn {Built-in Function} {void *} __builtin_extract_return_addr (void *@var{addr})
@@ -14402,12 +14421,12 @@ long long __builtin_arm_wzero ()
 
 GCC implements extensions for C as described in the ARM C Language
 Extensions (ACLE) specification, which can be found at
-@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf}.
+@uref{https://developer.arm.com/documentation/ihi0053/latest/}.
 
 As a part of ACLE, GCC implements extensions for Advanced SIMD as described in
 the ARM C Language Extensions Specification.  The complete list of Advanced SIMD
 intrinsics can be found at
-@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf}.
+@uref{https://developer.arm.com/documentation/ihi0073/latest/}.
 The built-in intrinsics for the Advanced SIMD extension are available when
 NEON is enabled.
 
@@ -14438,7 +14457,7 @@ void __builtin_arm_set_fpscr (unsigned int)
 GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M
 Security Extensions: Requirements on Development Tools Engineering
 Specification, which can be found at
-@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}.
+@uref{https://developer.arm.com/documentation/ecm0359818/latest/}.
 
 As part of the Security Extensions GCC implements two new function attributes:
 @code{cmse_nonsecure_entry} and @code{cmse_nonsecure_call}.
@@ -19722,6 +19741,13 @@ bool scalar_test_data_class (__ieee128 source, const int condition);
 bool scalar_test_neg (float source);
 bool scalar_test_neg (double source);
 bool scalar_test_neg (__ieee128 source);
+
+vector _uint128_t vec_msum (vector unsigned long long,
+			    vector unsigned long long,
+			    vector _uint128_t);
+vector _int128_t vec_msum (vector signed long long,
+			   vector signed long long,
+			   vector _int128_t);
 @end smallexample
 
 The @code{scalar_extract_exp} and @code{scalar_extract_sig}
@@ -19741,6 +19767,9 @@ Note that the sign of the significand is not represented in the result
 returned from the @code{scalar_extract_sig} function.  Use the
 @code{scalar_test_neg} function to test the sign of its @code{double}
 argument.
+The @code{vec_msum} functions perform a vector multiply-sum, returning
+the result of arg1*arg2+arg3.  ISA 3.0 adds support for vec_msum returning
+a vector int128 result.
 
 The @code{scalar_insert_exp}
 functions require a 64-bit environment supporting ISA 3.0 or later.
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 0d08696c207..03cea999259 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -1294,7 +1294,7 @@ Specify which cpu variant the compiler should generate code for by default.
 This option is only supported on some targets, including ARC, ARM, i386, M68k,
 PowerPC, and SPARC@.  It is mandatory for ARC@.  The @option{--with-cpu-32} and
 @option{--with-cpu-64} options specify separate default CPUs for
-32-bit and 64-bit modes; these options are only supported for i386,
+32-bit and 64-bit modes; these options are only supported for aarch64, i386,
 x86-64, PowerPC, and SPARC@.
 
 @item --with-schedule=@var{cpu}
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 0ab6c9c6449..c39efa0e33e 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -634,10 +634,12 @@ Objective-C and Objective-C++ Dialects}.
 -mpc-relative-literal-loads @gol
 -msign-return-address=@var{scope} @gol
 -mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}]|@var{bti} @gol
+-mharden-sls=@var{opts} @gol
 -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  @gol
 -moverride=@var{string}  -mverbose-cost-dump @gol
 -mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{sysreg} @gol
--mstack-protector-guard-offset=@var{offset} -mtrack-speculation }
+-mstack-protector-guard-offset=@var{offset} -mtrack-speculation @gol
+-moutline-atomics }
 
 @emph{Adapteva Epiphany Options}
 @gccoptlist{-mhalf-reg-file  -mprefer-short-insn-regs @gol
@@ -4313,6 +4315,11 @@ are being produced.  This allows the use of new @option{-Wno-} options
 with old compilers, but if something goes wrong, the compiler
 warns that an unrecognized option is present.
 
+The effectiveness of some warnings depends on optimizations also being
+enabled. For example @option{-Wsuggest-final-types} is more effective
+with link-time optimization and @option{-Wmaybe-uninitialized} will not
+warn at all unless optimization is enabled.
+
 @table @gcctabopt
 @item -Wpedantic
 @itemx -pedantic
@@ -10266,6 +10273,12 @@ conflicting translation units.  Specifically
 precedence; and for example @option{-ffp-contract=off} takes precedence
 over @option{-ffp-contract=fast}.  You can override them at link time.
 
+When you need to pass options to the assembler via @option{-Wa} or
+@option{-Xassembler} make sure to either compile such translation
+units with @option{-fno-lto} or consistently use the same assembler
+options on all translation units.  You can alternatively also
+specify assembler options at LTO link time.
+
 If LTO encounters objects with C linkage declared with incompatible
 types in separate translation units to be linked together (undefined
 behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be
@@ -11792,6 +11805,11 @@ speed
 (@option{sra-max-scalarization-size-Ospeed}) or size
 (@option{sra-max-scalarization-size-Osize}) respectively.
 
+@item sra-max-propagations
+The maximum number of artificial accesses that Scalar Replacement of
+Aggregates (SRA) will track, per one local variable, in order to
+facilitate copy propagation.
+
 @item tm-max-aggregate-size
 When making copies of thread-local variables in a transaction, this
 parameter specifies the size in bytes after which variables are
@@ -15777,6 +15795,19 @@ be used by the compiler when expanding calls to
 @code{__builtin_speculation_safe_copy} to permit a more efficient code
 sequence to be generated.
 
+@item -moutline-atomics
+@itemx -mno-outline-atomics
+Enable or disable calls to out-of-line helpers to implement atomic operations.
+These helpers will, at runtime, determine if the LSE instructions from
+ARMv8.1-A can be used; if not, they will use the load/store-exclusive
+instructions that are present in the base ARMv8.0 ISA.
+
+This option is only applicable when compiling for the base ARMv8.0
+instruction set.  If using a later revision, e.g. @option{-march=armv8.1-a}
+or @option{-march=armv8-a+lse}, the ARMv8.1-Atomics instructions will be
+used directly.  The same applies when using @option{-mcpu=} when the
+selected cpu supports the @samp{lse} feature.
+
 @item -march=@var{name}
 @opindex march
 Specify the name of the target architecture and, optionally, one or
@@ -15826,11 +15857,13 @@ performance of the code.  Permissible values for this option are:
 @samp{generic}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55},
 @samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
 @samp{cortex-a76}, @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
-@samp{neoverse-e1},@samp{neoverse-n1},@samp{qdf24xx}, @samp{saphira},
-@samp{phecda}, @samp{xgene1}, @samp{vulcan}, @samp{octeontx},
-@samp{octeontx81},  @samp{octeontx83}, @samp{thunderx}, @samp{thunderxt88},
+@samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1},
+@samp{qdf24xx}, @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
+@samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
+@samp{a64fx},
+@samp{thunderx}, @samp{thunderxt88},
 @samp{thunderxt88p1}, @samp{thunderxt81}, @samp{tsv110},
-@samp{thunderxt83}, @samp{thunderx2t99},
+@samp{thunderxt83}, @samp{thunderx2t99}, @samp{zeus},
 @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55}
@@ -15916,6 +15949,17 @@ argument @samp{leaf} can be used to extend the signing to include leaf
 functions.
 @samp{bti} turns on branch target identification mechanism.
 
+@item -mharden-sls=@var{opts}
+@opindex mharden-sls
+Enable compiler hardening against straight line speculation (SLS).
+@var{opts} is a comma-separated list of the following options:
+@table @samp
+@item retbr
+@item blr
+@end table
+In addition, @samp{-mharden-sls=all} enables all SLS hardening while
+@samp{-mharden-sls=none} disables all SLS hardening.
+
 @item -msve-vector-bits=@var{bits}
 @opindex msve-vector-bits
 Specify the number of bits in an SVE vector register.  This option only has
@@ -17532,9 +17576,9 @@ Permissible names are: @samp{arm7tdmi}, @samp{arm7tdmi-s}, @samp{arm710t},
 @samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m23}, @samp{cortex-m33},
 @samp{cortex-m1.small-multiply}, @samp{cortex-m0.small-multiply},
 @samp{cortex-m0plus.small-multiply}, @samp{exynos-m1}, @samp{marvell-pj4},
-@samp{neoverse-n1}, @samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2},
-@samp{ep9312}, @samp{fa526}, @samp{fa626}, @samp{fa606te}, @samp{fa626te},
-@samp{fmp626}, @samp{fa726te}, @samp{xgene1}.
+@samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1}, @samp{xscale},
+@samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}, @samp{fa526}, @samp{fa626},
+@samp{fa606te}, @samp{fa626te}, @samp{fmp626}, @samp{fa726te}, @samp{xgene1}.
 
 Additionally, this option can specify that GCC should tune the performance
 of the code for a big.LITTLE system.  Permissible names are:
@@ -17926,7 +17970,7 @@ is only available when generating non-pic code for M-profile targets.
 @opindex mcmse
 Generate secure code as per the "ARMv8-M Security Extensions: Requirements on
 Development Tools Engineering Specification", which can be found on
-@url{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}.
+@url{https://developer.arm.com/documentation/ecm0359818/latest/}.
 @end table
 
 @node AVR Options
@@ -27257,14 +27301,14 @@ BMI, BMI2 and F16C instruction set support.
 
 @item broadwell
 Intel Broadwell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
-SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA,
-BMI, BMI2, F16C, RDSEED, ADCX and PREFETCHW instruction set support.
+SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2,
+F16C, RDSEED ADCX and PREFETCHW instruction set support.
 
 @item skylake
 Intel Skylake CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
 SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA,
-BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC and
-XSAVES instruction set support.
+BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC and XSAVES
+instruction set support.
 
 @item bonnell
 Intel Bonnell CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3 and SSSE3
@@ -27272,34 +27316,36 @@ instruction set support.
 
 @item silvermont
 Intel Silvermont CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
-SSE4.1, SSE4.2, POPCNT, AES, PCLMUL and RDRND instruction set support.
+SSE4.1, SSE4.2, POPCNT, AES, PREFETCHW, PCLMUL and RDRND instruction set support.
 
 @item goldmont
 Intel Goldmont CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
-SSE4.1, SSE4.2, POPCNT, AES, PCLMUL, RDRND, XSAVE, XSAVEOPT and FSGSBASE
-instruction set support.
+SSE4.1, SSE4.2, POPCNT, AES, PREFETCHW, PCLMUL, RDRND, XSAVE, XSAVEC, XSAVES,
+XSAVEOPT and FSGSBASE instruction set support.
 
 @item goldmont-plus
 Intel Goldmont Plus CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3,
-SSSE3, SSE4.1, SSE4.2, POPCNT, AES, PCLMUL, RDRND, XSAVE, XSAVEOPT, FSGSBASE,
-PTWRITE, RDPID, SGX and UMIP instruction set support.
+SSSE3, SSE4.1, SSE4.2, POPCNT, AES, PREFETCHW, PCLMUL, RDRND, XSAVE, XSAVEC,
+XSAVES, XSAVEOPT, FSGSBASE, PTWRITE, RDPID, SGX and UMIP instruction set support.
 
 @item tremont
 Intel Tremont CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
-SSE4.1, SSE4.2, POPCNT, AES, PCLMUL, RDRND, XSAVE, XSAVEOPT, FSGSBASE, PTWRITE,
-RDPID, SGX, UMIP, GFNI-SSE, CLWB and ENCLV instruction set support.
+SSE4.1, SSE4.2, POPCNT, AES, PREFETCHW, PCLMUL, RDRND, XSAVE, XSAVEC, XSAVES,
+XSAVEOPT, FSGSBASE, PTWRITE, RDPID, SGX, UMIP, GFNI-SSE, CLWB, MOVDIRI,
+MOVDIR64B, CLDEMOTE and WAITPKG instruction set support.
 
 @item knl
 Intel Knight's Landing CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3,
 SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA,
-BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, AVX512F, AVX512PF, AVX512ER and
-AVX512CD instruction set support.
+BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, PREFETCHWT1, AVX512F, AVX512PF,
+AVX512ER and AVX512CD instruction set support.
 
 @item knm
 Intel Knights Mill CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3,
 SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA,
-BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, AVX512F, AVX512PF, AVX512ER, AVX512CD,
-AVX5124VNNIW, AVX5124FMAPS and AVX512VPOPCNTDQ instruction set support.
+BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, PREFETCHWT1, AVX512F, AVX512PF,
+AVX512ER, AVX512CD, AVX5124VNNIW, AVX5124FMAPS and AVX512VPOPCNTDQ instruction
+set support.
 
 @item skylake-avx512
 Intel Skylake Server CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3,
@@ -28711,9 +28757,9 @@ Note that @option{-mcmodel=large} is incompatible with
 @option{-mindirect-branch=thunk-extern} since the thunk function may
 not be reachable in the large code model.
 
-Note that @option{-mindirect-branch=thunk-extern} is incompatible with
-@option{-fcf-protection=branch} since the external thunk cannot be modified
-to disable control-flow check.
+Note that @option{-mindirect-branch=thunk-extern} is compatible with
+@option{-fcf-protection=branch} since the external thunk can be made
+to enable control-flow check.
 
 @item -mfunction-return=@var{choice}
 @opindex mfunction-return
@@ -28726,6 +28772,10 @@ object file.  You can control this behavior for a specific function by
 using the function attribute @code{function_return}.
 @xref{Function Attributes}.
 
+Note that @option{-mindirect-return=thunk-extern} is compatible with
+@option{-fcf-protection=branch} since the external thunk can be made
+to enable control-flow check.
+
 Note that @option{-mcmodel=large} is incompatible with
 @option{-mfunction-return=thunk} and
 @option{-mfunction-return=thunk-extern} since the thunk function may
diff --git a/gcc/doc/sourcebuild.texi b/gcc/doc/sourcebuild.texi
index 546af7f7261..6bed48907c8 100644
--- a/gcc/doc/sourcebuild.texi
+++ b/gcc/doc/sourcebuild.texi
@@ -1244,6 +1244,18 @@ This DejaGnu directive compares @var{regexp} to the combined output
 that the test executable writes to @file{stdout} and @file{stderr}.
 @end table
 
+@subsubsection Specify environment variables for a test
+
+@table @code
+@item @{ dg-set-compiler-env-var @var{var_name} "@var{var_value}" @}
+Specify that the environment variable @var{var_name} needs to be set
+to @var{var_value} before invoking the compiler on the test file.
+
+@item @{ dg-set-target-env-var @var{var_name} "@var{var_value}" @}
+Specify that the environment variable @var{var_name} needs to be set
+to @var{var_value} before execution of the program created by the test.
+@end table
+
 @subsubsection Specify additional files for a test
 
 @table @code
@@ -1915,6 +1927,9 @@ AArch64 target which generates instruction sequences for big endian.
 Binutils installed on test system supports relocation types required by -fpic
 for AArch64 small memory model.
 
+@item aarch64_fjcvtzs_hw
+AArch64 target that is able to generate and execute armv8.3-a FJCVTZS
+instruction.
 @end table
 
 @subsubsection MIPS-specific attributes
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index 8c8978bb13a..7f5c370d97a 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -8330,11 +8330,11 @@ as the number of bits.
 @end defmac
 
 @defmac ASM_OUTPUT_ALIGNED_DECL_LOCAL (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
-Like @code{ASM_OUTPUT_ALIGNED_DECL} except that @var{decl} of the
+Like @code{ASM_OUTPUT_ALIGNED_LOCAL} except that @var{decl} of the
 variable to be output, if there is one, or @code{NULL_TREE} if there
 is no corresponding variable.  If you define this macro, GCC will use it
-in place of both @code{ASM_OUTPUT_DECL} and
-@code{ASM_OUTPUT_ALIGNED_DECL}.  Define this macro when you need to see
+in place of both @code{ASM_OUTPUT_LOCAL} and
+@code{ASM_OUTPUT_ALIGNED_LOCAL}.  Define this macro when you need to see
 the variable's decl in order to chose what to output.
 @end defmac
 
diff --git a/gcc/doc/tm.texi.in b/gcc/doc/tm.texi.in
index fe1194ef91a..44a15dda240 100644
--- a/gcc/doc/tm.texi.in
+++ b/gcc/doc/tm.texi.in
@@ -5403,11 +5403,11 @@ as the number of bits.
 @end defmac
 
 @defmac ASM_OUTPUT_ALIGNED_DECL_LOCAL (@var{stream}, @var{decl}, @var{name}, @var{size}, @var{alignment})
-Like @code{ASM_OUTPUT_ALIGNED_DECL} except that @var{decl} of the
+Like @code{ASM_OUTPUT_ALIGNED_LOCAL} except that @var{decl} of the
 variable to be output, if there is one, or @code{NULL_TREE} if there
 is no corresponding variable.  If you define this macro, GCC will use it
-in place of both @code{ASM_OUTPUT_DECL} and
-@code{ASM_OUTPUT_ALIGNED_DECL}.  Define this macro when you need to see
+in place of both @code{ASM_OUTPUT_LOCAL} and
+@code{ASM_OUTPUT_ALIGNED_LOCAL}.  Define this macro when you need to see
 the variable's decl in order to chose what to output.
 @end defmac
 
diff --git a/gcc/dumpfile.c b/gcc/dumpfile.c
index 14b6dfea75e..abab401b3e7 100644
--- a/gcc/dumpfile.c
+++ b/gcc/dumpfile.c
@@ -2055,7 +2055,7 @@ temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo,
 				      bool forcibly_enable_dumping,
 				      dump_flags_t test_pp_flags)
 : m_context (),
-  m_saved (&dump_context ().get ())
+  m_saved (&dump_context::get ())
 {
   dump_context::s_current = &m_context;
   if (forcibly_enable_optinfo)
diff --git a/gcc/dwarf2cfi.c b/gcc/dwarf2cfi.c
index d6aed358484..3831979e26d 100644
--- a/gcc/dwarf2cfi.c
+++ b/gcc/dwarf2cfi.c
@@ -71,6 +71,9 @@ struct GTY(()) dw_cfi_row
 
   /* True if the register window is saved.  */
   bool window_save;
+
+  /* True if the return address is in a mangled state.  */
+  bool ra_mangled;
 };
 
 /* The caller's ORIG_REG is saved in SAVED_IN_REG.  */
@@ -772,6 +775,9 @@ cfi_row_equal_p (dw_cfi_row *a, dw_cfi_row *b)
   if (a->window_save != b->window_save)
     return false;
 
+  if (a->ra_mangled != b->ra_mangled)
+    return false;
+
   return true;
 }
 
@@ -1370,20 +1376,33 @@ dwarf2out_frame_debug_cfa_restore (rtx reg)
 }
 
 /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_WINDOW_SAVE.
-   FAKE is true if this is not really a window save but something else.
 
    ??? Perhaps we should note in the CIE where windows are saved (instead
    of assuming 0(cfa)) and what registers are in the window.  */
 
 static void
-dwarf2out_frame_debug_cfa_window_save (bool fake)
+dwarf2out_frame_debug_cfa_window_save (void)
 {
   dw_cfi_ref cfi = new_cfi ();
 
   cfi->dw_cfi_opc = DW_CFA_GNU_window_save;
   add_cfi (cfi);
-  if (!fake)
-    cur_row->window_save = true;
+  cur_row->window_save = true;
+}
+
+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_TOGGLE_RA_MANGLE.
+   Note: DW_CFA_GNU_window_save dwarf opcode is reused for toggling RA mangle
+   state, this is a target specific operation on AArch64 and can only be used
+   on other targets if they don't use the window save operation otherwise.  */
+
+static void
+dwarf2out_frame_debug_cfa_toggle_ra_mangle (void)
+{
+  dw_cfi_ref cfi = new_cfi ();
+
+  cfi->dw_cfi_opc = DW_CFA_GNU_window_save;
+  add_cfi (cfi);
+  cur_row->ra_mangled = !cur_row->ra_mangled;
 }
 
 /* Record call frame debugging information for an expression EXPR,
@@ -2143,13 +2162,12 @@ dwarf2out_frame_debug (rtx_insn *insn)
 	break;
 
       case REG_CFA_TOGGLE_RA_MANGLE:
-	/* This uses the same DWARF opcode as the next operation.  */
-	dwarf2out_frame_debug_cfa_window_save (true);
+	dwarf2out_frame_debug_cfa_toggle_ra_mangle ();
 	handled_one = true;
 	break;
 
       case REG_CFA_WINDOW_SAVE:
-	dwarf2out_frame_debug_cfa_window_save (false);
+	dwarf2out_frame_debug_cfa_window_save ();
 	handled_one = true;
 	break;
 
@@ -2218,6 +2236,17 @@ change_cfi_row (dw_cfi_row *old_row, dw_cfi_row *new_row)
     {
       dw_cfi_ref cfi = new_cfi ();
 
+      gcc_assert (!old_row->ra_mangled && !new_row->ra_mangled);
+      cfi->dw_cfi_opc = DW_CFA_GNU_window_save;
+      add_cfi (cfi);
+    }
+
+  if (old_row->ra_mangled != new_row->ra_mangled)
+    {
+      dw_cfi_ref cfi = new_cfi ();
+
+      gcc_assert (!old_row->window_save && !new_row->window_save);
+      /* DW_CFA_GNU_window_save is reused for toggling RA mangle state.  */
       cfi->dw_cfi_opc = DW_CFA_GNU_window_save;
       add_cfi (cfi);
     }
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 30c4c7007ee..c18a325d760 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -23011,11 +23011,22 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)
 		  != (unsigned) s.column))
 	    add_AT_unsigned (subr_die, DW_AT_decl_column, s.column);
 
-	  /* If the prototype had an 'auto' or 'decltype(auto)' return type,
-	     emit the real type on the definition die.  */
+	  /* If the prototype had an 'auto' or 'decltype(auto)' in
+	     the return type, emit the real type on the definition die.  */
 	  if (is_cxx () && debug_info_level > DINFO_LEVEL_TERSE)
 	    {
 	      dw_die_ref die = get_AT_ref (old_die, DW_AT_type);
+	      while (die
+		     && (die->die_tag == DW_TAG_reference_type
+			 || die->die_tag == DW_TAG_rvalue_reference_type
+			 || die->die_tag == DW_TAG_pointer_type
+			 || die->die_tag == DW_TAG_const_type
+			 || die->die_tag == DW_TAG_volatile_type
+			 || die->die_tag == DW_TAG_restrict_type
+			 || die->die_tag == DW_TAG_array_type
+			 || die->die_tag == DW_TAG_ptr_to_member_type
+			 || die->die_tag == DW_TAG_subroutine_type))
+		die = get_AT_ref (die, DW_AT_type);
 	      if (die == auto_die || die == decltype_auto_die)
 		add_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),
 				    TYPE_UNQUALIFIED, false, context_die);
@@ -27251,7 +27262,7 @@ static bool maybe_at_text_label_p = true;
 /* One above highest N where .LVLN label might be equal to .Ltext0 label.  */
 static unsigned int first_loclabel_num_not_at_text_label;
 
-/* Look ahead for a real insn, or for a begin stmt marker.  */
+/* Look ahead for a real insn.  */
 
 static rtx_insn *
 dwarf2out_next_real_insn (rtx_insn *loc_note)
@@ -27276,7 +27287,7 @@ dwarf2out_var_location (rtx_insn *loc_note)
 {
   char loclabel[MAX_ARTIFICIAL_LABEL_BYTES + 2];
   struct var_loc_node *newloc;
-  rtx_insn *next_real, *next_note;
+  rtx_insn *next_real;
   rtx_insn *call_insn = NULL;
   static const char *last_label;
   static const char *last_postcall_label;
@@ -27301,7 +27312,6 @@ dwarf2out_var_location (rtx_insn *loc_note)
 	      var_loc_p = false;
 
 	      next_real = dwarf2out_next_real_insn (call_insn);
-	      next_note = NULL;
 	      cached_next_real_insn = NULL;
 	      goto create_label;
 	    }
@@ -27329,7 +27339,6 @@ dwarf2out_var_location (rtx_insn *loc_note)
 		  var_loc_p = false;
 
 		  next_real = dwarf2out_next_real_insn (call_insn);
-		  next_note = NULL;
 		  cached_next_real_insn = NULL;
 		  goto create_label;
 		}
@@ -27358,22 +27367,28 @@ dwarf2out_var_location (rtx_insn *loc_note)
 	next_real = NULL;
     }
 
-  next_note = NEXT_INSN (loc_note);
-  if (! next_note
-      || next_note->deleted ()
-      || ! NOTE_P (next_note)
-      || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION
-	  && NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT
-	  && NOTE_KIND (next_note) != NOTE_INSN_INLINE_ENTRY))
-    next_note = NULL;
-
   if (! next_real)
     next_real = dwarf2out_next_real_insn (loc_note);
 
-  if (next_note)
+  if (next_real)
     {
-      expected_next_loc_note = next_note;
-      cached_next_real_insn = next_real;
+      rtx_insn *next_note = NEXT_INSN (loc_note);
+      while (next_note != next_real)
+	{
+	  if (! next_note->deleted ()
+	      && NOTE_P (next_note)
+	      && NOTE_KIND (next_note) == NOTE_INSN_VAR_LOCATION)
+	    break;
+	  next_note = NEXT_INSN (next_note);
+	}
+
+      if (next_note == next_real)
+	cached_next_real_insn = NULL;
+      else
+	{
+	  expected_next_loc_note = next_note;
+	  cached_next_real_insn = next_real;
+	}
     }
   else
     cached_next_real_insn = NULL;
@@ -32132,13 +32147,13 @@ dwarf2out_early_finish (const char *filename)
      emit full debugging info for them.  */
   retry_incomplete_types ();
 
+  gen_scheduled_generic_parms_dies ();
+  gen_remaining_tmpl_value_param_die_attribute ();
+
   /* The point here is to flush out the limbo list so that it is empty
      and we don't need to stream it for LTO.  */
   flush_limbo_die_list ();
 
-  gen_scheduled_generic_parms_dies ();
-  gen_remaining_tmpl_value_param_die_attribute ();
-
   /* Add DW_AT_linkage_name for all deferred DIEs.  */
   for (limbo_die_node *node = deferred_asm_name; node; node = node->next)
     {
diff --git a/gcc/early-remat.c b/gcc/early-remat.c
index 122891c1edb..712e39033f4 100644
--- a/gcc/early-remat.c
+++ b/gcc/early-remat.c
@@ -1995,7 +1995,7 @@ early_remat::process_block (basic_block bb)
 	}
 
       /* Now process definitions.  */
-      if (next_def && insn == next_def->insn)
+      while (next_def && insn == next_def->insn)
 	{
 	  unsigned int gen = canon_candidate (next_candidate);
 
diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
index 7b1cecd3c44..b8a07d21d37 100644
--- a/gcc/emit-rtl.h
+++ b/gcc/emit-rtl.h
@@ -266,6 +266,9 @@ struct GTY(()) rtl_data {
      pass_stack_ptr_mod has run.  */
   bool sp_is_unchanging;
 
+  /* True if the stack pointer is clobbered by asm statement.  */
+  bool sp_is_clobbered_by_asm;
+
   /* Nonzero if function being compiled doesn't contain any calls
      (ignoring the prologue and epilogue).  This is set prior to
      register allocation in IRA and is valid for the remaining
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index c717f24501e..613553e1a05 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -5423,8 +5423,22 @@ fold_cond_expr_with_comparison (location_t loc, tree type,
       case LT_EXPR:
 	if (TYPE_UNSIGNED (TREE_TYPE (arg1)))
 	  break;
-	tem = fold_build1_loc (loc, ABS_EXPR, TREE_TYPE (arg1), arg1);
-	return negate_expr (fold_convert_loc (loc, type, tem));
+	if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg1))
+	    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))
+	  {
+	    /* A <= 0 ? A : -A for A INT_MIN is valid, but -abs(INT_MIN)
+	       is not, invokes UB both in abs and in the negation of it.
+	       So, use ABSU_EXPR instead.  */
+	    tree utype = unsigned_type_for (TREE_TYPE (arg1));
+	    tem = fold_build1_loc (loc, ABSU_EXPR, utype, arg1);
+	    tem = negate_expr (tem);
+	    return fold_convert_loc (loc, type, tem);
+	  }
+	else
+	  {
+	    tem = fold_build1_loc (loc, ABS_EXPR, TREE_TYPE (arg1), arg1);
+	    return negate_expr (fold_convert_loc (loc, type, tem));
+	  }
       default:
 	gcc_assert (TREE_CODE_CLASS (comp_code) == tcc_comparison);
 	break;
@@ -5570,6 +5584,13 @@ fold_range_test (location_t loc, enum tree_code code, tree type,
     return 0;
 
   lhs = make_range (op0, &in0_p, &low0, &high0, &strict_overflow_p);
+  /* If op0 is known true or false and this is a short-circuiting
+     operation we must not merge with op1 since that makes side-effects
+     unconditional.  So special-case this.  */
+  if (!lhs
+      && ((code == TRUTH_ORIF_EXPR && in0_p)
+	  || (code == TRUTH_ANDIF_EXPR && !in0_p)))
+    return op0;
   rhs = make_range (op1, &in1_p, &low1, &high1, &strict_overflow_p);
 
   /* If this is an OR operation, invert both sides; we will invert
@@ -10376,11 +10397,11 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,
 
       /* Convert -A / -B to A / B when the type is signed and overflow is
 	 undefined.  */
-      if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))
+      if ((!ANY_INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))
 	  && TREE_CODE (op0) == NEGATE_EXPR
 	  && negate_expr_p (op1))
 	{
-	  if (INTEGRAL_TYPE_P (type))
+	  if (ANY_INTEGRAL_TYPE_P (type))
 	    fold_overflow_warning (("assuming signed overflow does not occur "
 				    "when distributing negation across "
 				    "division"),
@@ -10390,11 +10411,11 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,
 						    TREE_OPERAND (arg0, 0)),
 				  negate_expr (op1));
 	}
-      if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))
+      if ((!ANY_INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))
 	  && TREE_CODE (arg1) == NEGATE_EXPR
 	  && negate_expr_p (op0))
 	{
-	  if (INTEGRAL_TYPE_P (type))
+	  if (ANY_INTEGRAL_TYPE_P (type))
 	    fold_overflow_warning (("assuming signed overflow does not occur "
 				    "when distributing negation across "
 				    "division"),
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 8fefea2b63d..0230bb9bb7b 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,802 @@
+2021-04-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-01  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99840
+	* simplify.c (gfc_simplify_transpose): Properly initialize
+	resulting shape.
+
+2021-03-24  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-03-22  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/99688
+	* match.c (select_type_set_tmp, gfc_match_select_type) Fix 'name'
+	buffersize to avoid out of bounds.
+	* resolve.c (resolve_select_type): Likewise.
+
+2021-03-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-27  Harald Anlauf  <anlauf@gmx.de>
+
+	* resolve.c (gfc_impure_variable): A dummy argument with the VALUE
+	attribute may be redefined without making a procedure impure.
+
+2021-03-15  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-15  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99545
+	* trans-stmt.c (gfc_trans_allocate): Mark the initialization
+	assignment by setting init_flag.
+
+2021-02-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-14  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.h (gfc_resolve_substring): Add prototype.
+	* primary.c (match_string_constant): Simplify substrings with
+	constant starting and ending points.
+	* resolve.c: Rename resolve_substring to gfc_resolve_substring.
+	(gfc_resolve_ref): Use renamed function gfc_resolve_substring.
+
+2021-02-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99124
+	* resolve.c (resolve_fl_procedure): Include class results in
+	the test for F2018, C15100.
+	* trans-array.c (get_class_info_from_ss): Do not use the saved
+	descriptor to obtain the class expression for variables. Use
+	gfc_get_class_from_expr instead.
+
+2021-02-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-02-21  Harald Anlauf  <anlauf@gmx.de>
+
+	* trans-expr.c (gfc_conv_procedure_call): Do not add clobber to
+	allocatable intent(out) argument.
+
+2021-02-11  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-02-11  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99060
+	* primary.c (gfc_match_varspec): Test for non-null 'previous'
+	before using its name in the error message.
+
+2021-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/86470
+	* trans.c (gfc_call_malloc): Allocate area of size 1 if passed
+	size is NULL (as documented).
+
+2021-01-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-25  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/98517
+	* resolve.c (resolve_charlen): Check that length expression is
+	present before testing for scalar/integer..
+
+2021-01-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93833
+	* trans-array.c (get_array_ctor_var_strlen): If the character
+	length backend_decl cannot be found, convert the expression and
+	use the string length. Clear up some minor white space issues
+	in the rest of the file.
+
+2021-01-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98022
+	* data.c (gfc_assign_data_value): Throw an error for inquiry
+	references. Follow with corrected code that would provide the
+	expected result and provides clean error recovery.
+
+2021-01-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98022
+	* data.c (gfc_assign_data_value): Handle inquiry references in
+	the data statement object list.
+
+2021-01-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-01-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91640
+	* trans-expr.c (gfc_conv_procedure_call): Avoid copy-out for nonvariable
+	arguments to contiguous dummy args.  Avoid re-checking whether fsym is
+	NULL.
+
+2021-01-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-06  Harald Anlauf  <anlauf@gmx.de>
+
+	* resolve.c (resolve_component): Add check for valid CLASS
+	reference before trying to access CLASS data.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-02  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96325
+	* primary.c (gfc_match_varspec): In the case that a component
+	reference is added to an intrinsic type component, emit the
+	error message in this function.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Make
+	sure that class expressions are captured for dummy arguments by
+	use of gfc_get_class_from_gfc_expr otherwise the wrong vptr is
+	used.
+	* trans-expr.c (gfc_get_class_from_gfc_expr): New function.
+	(gfc_get_class_from_expr): If a constant expression is
+	encountered, return NULL_TREE;
+	(gfc_trans_assignment_1): Deallocate rhs allocatable components
+	after passing derived type function results to class lhs.
+	* trans.h : Add prototype for gfc_get_class_from_gfc_expr.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	PR fortran/96012
+	* resolve.c (resolve_ordinary_assign): Generate a vtable if
+	necessary for scalar non-polymorphic rhs's to unlimited lhs's.
+	* trans-array.c (get_class_info_from_ss): New function.
+	(gfc_trans_allocate_array_storage): Defer obtaining class
+	element type until all sources of class exprs are tried. Use
+	class API rather than TREE_OPERAND. Look for class expressions
+	in ss->info by calling get_class_info_from_ss. After, obtain
+	the element size for class descriptors. Where the element type
+	is unknown, cast the data as character(len=size) to overcome
+	unlimited polymorphic problems.
+	(gfc_conv_ss_descriptor): Do not fix class variable refs.
+	(build_class_array_ref, structure_alloc_comps): Replace code
+	replicating the new function gfc_resize_class_size_with_len.
+	(gfc_alloc_allocatable_for_assignment): Obtain element size
+	for lhs in cases of deferred characters and class enitities.
+	Move code for the element size of rhs to start of block. Clean
+	up extraction of class parameters throughout this function.
+	After the shape check test whether or not the lhs and rhs
+	element sizes are the same. Use earlier evaluation of
+	'cond_null'. Reallocation of lhs only to happen if size changes
+	or element size changes.
+	* trans-expr.c (gfc_resize_class_size_with_len): New function.
+	(gfc_get_class_from_expr): If a constant expression is
+	encountered, return NULL_TREE;
+	(trans_scalar_class_assign): New function.
+	(gfc_conv_procedure_call): Ensure the vtable is present for
+	passing a non-class actual to an unlimited formal.
+	(trans_class_vptr_len_assignment): For expressions of type
+	BT_CLASS, extract the class expression if necessary. Use a
+	statement block outside the loop body. Ensure that 'rhs' is
+	of the correct type. Obtain rhs vptr in all circumstances.
+	(gfc_trans_scalar_assign): Call trans_scalar_class_assign to
+	make maximum use of the vptr copy in place of assignment.
+	(trans_class_assignment): Actually do reallocation if needed.
+	(gfc_trans_assignment_1): Simplify some of the logic with
+	'realloc_flag'. Set 'vptr_copy' for all array assignments to
+	unlimited polymorphic lhs.
+	* trans.c (gfc_build_array_ref): Call gfc_resize_class_size_
+	with_len to correct span for unlimited polymorphic decls.
+	* trans.h : Add prototype for gfc_resize_class_size_with_len.
+
+2021-01-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-04-14  Tobias Burnus  <tobias@codesourcery.com>
+
+	* module.c (gfc_match_use): Fix name-conflict check for use-associating
+	the same symbol again in a submodule.
+
+2021-01-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-01  Harald Anlauf  <anlauf@gmx.de>
+
+	* class.c (gfc_find_vtab): Add check on attribute is_class.
+
+2021-01-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-12-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92587
+	* match.c (gfc_match_assignment): Move gfc_find_vtab call from here ...
+	* resolve.c (gfc_resolve_code): ... to here.
+
+2021-01-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96320
+	* interface.c (gfc_check_dummy_characteristics): If a module
+	procedure arrives with assumed shape in the interface and
+	deferred shape in the procedure itself, update the latter and
+	copy the lower bounds.
+
+2021-01-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/94246
+	* expr.c (scalarize_intrinsic_call): Remove the error checking.
+	Make a copy of the expression to be simplified and only replace
+	the original if the simplification succeeds.
+
+2020-12-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-25  Harald Anlauf  <anlauf@gmx.de>
+
+	* data.c (gfc_assign_data_value): Restrict use of
+	create_character_initializer to constant initializers.
+	* trans-expr.c (gfc_conv_initializer): Ensure that character
+	initializer is constant, otherwise fall through to get the same
+	error handling as for non-character cases.
+
+2020-12-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96100
+	PR fortran/96101
+	* trans-array.c (get_array_charlen): Tidy up the evaluation of
+	the string length for array constructors. Avoid trailing array
+	references. Ensure string lengths of deferred length components
+	are set. For parentheses operator apply string  length to both
+	the primary expression and the enclosed expression.
+
+2020-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98307
+	* trans-stmt.c (check_forall_dependencies): Extend dependency
+	check to allocatable components of derived types.
+
+2020-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-11-29  Harald Anlauf  <anlauf@gmx.de>
+
+	* expr.c (simplify_parameter_variable): Fix up character length
+	after copying an array-valued expression.
+
+2020-12-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95342
+	* decl.c (gfc_match_function_decl): Avoid NULL pointer dereference.
+	(gfc_match_subroutine): Likewise.
+
+2020-11-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-10  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/95847
+	* trans-decl.c (gfc_get_symbol_decl): Do not (re)set the location
+	of an external procedure.
+	(build_entry_thunks, generate_coarray_init, create_main_function,
+	gfc_generate_function_code): Use fndecl's location in BIND_EXPR.
+
+2020-11-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/97652
+	* module.c (mio_symbol): Fix symbol name for pdt_type.
+
+2020-10-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/97272
+	* trans-intrinsic.c (strip_kind_from_actual): Helper function for
+	removal of KIND argument.
+	(gfc_conv_intrinsic_minmaxloc): Ignore KIND argument here, as it
+	is treated elsewhere.
+
+2020-09-28  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Revert:
+	2020-09-27  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95614
+	* decl.c (gfc_get_common): Use gfc_match_common_name instead
+	of match_common_name.
+	* decl.c (gfc_bind_idents): Use gfc_match_common_name instead
+	of match_common_name.
+	* match.c : Rename match_common_name to gfc_match_common_name.
+	* match.c (gfc_match_common): Use gfc_match_common_name instead
+	of match_common_name.
+	* match.h : Rename match_common_name to gfc_match_common_name.
+	* resolve.c (resolve_common_vars): Check each symbol in a
+	common block has a global symbol.  If there is a global symbol
+	issue an error if the symbol type is known as is not a common
+	block name.
+
+2020-09-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-09-27  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95614
+	* decl.c (gfc_get_common): Use gfc_match_common_name instead
+	of match_common_name.
+	* decl.c (gfc_bind_idents): Use gfc_match_common_name instead
+	of match_common_name.
+	* match.c : Rename match_common_name to gfc_match_common_name.
+	* match.c (gfc_match_common): Use gfc_match_common_name instead
+	of match_common_name.
+	* match.h : Rename match_common_name to gfc_match_common_name.
+	* resolve.c (resolve_common_vars): Check each symbol in a
+	common block has a global symbol.  If there is a global symbol
+	issue an error if the symbol type is known as is not a common
+	block name.
+
+2020-09-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-09-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/96041
+	PR fortran/93423
+	* decl.c (gfc_match_submod_proc): Avoid later double-free
+	in the error case.
+
+2020-09-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-02  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/93423
+	* resolve.c (resolve_symbol): Avoid NULL pointer dereference.
+
+2020-09-08  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2020-09-08  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	* intrinsic.texi: Fix description of FINDLOC result.
+
+2020-08-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95882
+	* decl.c (char_len_param_value): Check gfc_seen_div0 and
+	if it is set return MATCH_ERROR.
+
+2020-07-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95612
+	* expr.c (gfc_check_pointer_assigb): Output an error if
+	rvalue is a zero sized array or output an error if rvalue
+	doesn't have a symbol tree.
+
+2020-07-26  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95585
+	* check.c (gfc_check_reshape): Add check for a value when
+	the symbol has an attribute flavor FL_PARAMETER.
+
+2020-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/89574
+	* trans-decl.c (gfc_get_extern_function_decl): Check whether a
+	symbol belongs to a different module.
+
+2020-07-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/96018
+	* frontend-passes.c (gfc_check_externals): Adjust formatting.
+	(implicit_pure_call): New function.
+	(implicit_pure_expr): New function.
+	(gfc_fix_implicit_pure): New function.
+	* gfortran.h (gfc_fix_implicit_pure): New prototype.
+	* parse.c (translate_all_program_units): Call gfc_fix_implicit_pure.
+
+2020-07-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/96220
+	* dump-parse-tree.c (get_c_type_name): Always use the entries from
+	c_interop_kinds_table to find the correct C type.
+
+2020-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-06  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95709
+	* resolve.c (gfc_resolve_code): Check for valid arguments to
+	assigned GOTO.
+
+2020-07-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-02  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/93337
+	* class.c (gfc_find_derived_vtab): Punt if name is not set.
+
+2020-07-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-30  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/88379
+	* resolve.c (resolve_assoc_var): Avoid NULL pointer dereference.
+
+2020-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-29  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71706
+	* trans-stmt.c (gfc_trans_sync): Do proper kind conversion in
+	bounds-checking code.
+
+2020-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95880
+	* symbol.c (gfc_add_type): If sym->ns->proc_name is set, use it,
+	otherwise fall back to sym->name.
+
+2020-07-01  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95829
+	* decl.c (gfc_match_decl_type_spec): Compare with "* ) " instead
+	of "*)".
+
+2020-06-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-29  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/95743
+	* trans-decl.c (gfc_generate_function_code): Do not generate
+	recursion check for compiler-generated procedures.
+
+2020-06-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95881
+	* resolve.c (resolve_symbol): Avoid NULL pointer dereference.
+
+2020-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95689
+	* interface.c (check_sym_interfaces): Enlarge temporary buffer,
+	and add check on length on mangled name to prevent overflow.
+
+2020-06-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95689
+	* interface.c (check_sym_interfaces): Enlarge temporary buffer,
+	and add check on length on mangled name to prevent overflow.
+
+2020-06-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95587
+	* match.c (gfc_match_equivalence): Check constraints on
+	EQUIVALENCE objects also for CLASS variables.
+
+2020-06-23  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95708
+	* intrinsic.c (add_functions): Replace CLASS_INQUIRY with
+	CLASS_TRANSFORMATIONAL for intrinsic num_images.
+	(make_generic): Replace ACTUAL_NO with ACTUAL_YES for
+	intrinsic team_number.
+	* resolve.c (resolve_fl_procedure): Check pointer ts.u.derived
+	exists before using it.
+
+2020-06-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95503
+	* expr.c (gfc_check_pointer_assign): Skip contiguity check of rhs
+	of pointer assignment if lhs cannot be simply contiguous.
+
+2020-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/94109
+	* class.c (finalize_component): Return early if finalization has
+	already happened for expression and component within namespace.
+	* gfortran.h (gfc_was_finalized): New type.
+	(gfc_namespace): Add member was_finalzed.
+	(gfc_expr): Remove finalized.
+	* symbol.c (gfc_free_namespace): Free was_finalized.
+
+2020-06-11  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl   <kargl@gcc.gnu.org>
+
+	PR fortran/95611
+	* decl.c (access_attr_decl): Use correct symbol in error message.
+
+2020-06-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95091
+	* class.c (gfc_hash_value): Add cast.
+
+2020-06-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95091
+	* class.c (get_unique_type_string, gfc_hash_value): Enlarge
+	buffers, and check whether the strings returned by
+	get_unique_type_string() fit.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95373
+	* primary.c (is_inquiry_ref): Move validity check of inquiry
+	references against selected Fortran standard from here...
+	(gfc_match_varspec) ...to here.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95373
+	* primary.c (is_inquiry_ref): Check validity of inquiry
+	references against selected Fortran standard.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95106
+	* trans-common.c (gfc_sym_mangled_common_id): Enlarge temporaries
+	for name-mangling.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95530
+	PR fortran/95537
+	* decl.c (gfc_match_decl_type_spec): Enlarge buffer, and enhance
+	string copy to detect buffer overflow.
+	* gfortran.h (gfc_common_head): Enlarge buffer.
+	* trans-common.c (finish_equivalences): Enhance string copy to
+	detect buffer overflow.
+
+2020-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+	    Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95500
+	* trans-expr.c (gfc_conv_expr_reference): Do not dereference NULL
+	pointer.
+
+2020-06-01  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/94361
+	* class.c (finalize_component): Use expr->finalized instead of
+	comp->finalized.
+	* gfortran.h (gfc_component): Remove finalized member.
+	(gfc_expr): Add it here instead.
+
+2020-05-28  Steven G. Kargl  <kargl@gcc.gnu.org>
+	    Mark Eggleston  <markeggleston@gcc.gnu.org>
+	    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/94397
+	* match.c (gfc_match_type_spec): New variable ok initialised
+	to true. Set ok with the return value of gfc_reduce_init_expr
+	called only if the expression is not EXPR_CONSTANT and is not
+	EXPR_VARIABLE. Add !ok to the check for type not being integer
+	or the rank being greater than zero.
+
+2020-05-28  Tobias Burnus  <tobias@codesourcery.com>
+	    Mark Eggleston  <markeggleston@gnu.gcc.org>
+
+	PR fortran/50392
+	* trans-decl.c (gfc_get_symbol_decl): Remove unnecessary block
+	delimiters.  Add auxiliary variables if a label is assigned to
+	a return variable. (gfc_gat_fake_result): If the symbol has an
+	assign attribute set declaration from the symbol's backend
+	declaration.
+
+2020-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/95191
+	* libgfortran.h (libgfortran_error_codes): Add
+	LIBERROR_BAD_WAIT_ID.
+
+2020-05-20  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/39695
+	* resolve.c (resolve_fl_procedure): Set name depending on
+	whether the result attribute is set.  For PROCEDURE/RESULT
+	conflict use the name in sym->ns->proc_name->name.
+	* symbol.c (gfc_add_type): Add check for function and result
+	attributes use sym->ns->proc_name->name if both are set.
+	Where the symbol cannot have a type use the name in
+	sym->ns->proc_name->name.
+
+2020-05-13  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master
+	2020-05-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/93497
+	* decl.c (char_len_param_value): Check whether character
+	length expression is of type EXPR_OP and if so simplify it.
+	* resolve.c (resolve_charlen): Reject length if it has a
+	rank.
+
+2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from mainline
+	2020-05-11  Janus Weil  <janus@gcc.gnu.org>
+		    Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	PR fortran/59107
+	* gfortran.h: Rename field resolved as resolve_symbol_called
+	and assign two 2 bits instead of 1.
+	* interface.c (gfc_find_typebound_dtio_proc): Use new field name.
+	* resolve.c (gfc_resolve_intrinsic): Replace check of the formal
+	field with resolve_symbol_called is at least 2, if it is not
+	set the field to 2.  (resolve_typebound_procedure): Use new field
+	name.  (resolve_symbol): Use new field name and check whether it
+	is at least 1, if it is not set the field to 1.
+
+2020-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline.
+	2020-03-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93581
+	* resolve.c (gfc_resolve_ref): Modify array refs to be elements
+	if the ref chain ends in INQUIRY_LEN.
+	* trans-array.c (gfc_get_dataptr_offset): Provide the offsets
+	for INQUIRY_RE and INQUIRY_IM.
+
+2020-04-27  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/93956
+	PR fortran/94788
+	* expr.c (gfc_check_pointer_assign): Revert patch for PR 93956.
+	* interface.c: Likewise.
+
+2020-04-24  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/93956
+	* expr.c (gfc_check_pointer_assign): Also set subref_array_pointer
+	when a function returns a pointer.
+	* interface.c (gfc_set_subref_array_pointer_arg): New function.
+	(gfc_procedure_use): Call it.
+
+2020-04-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline.
+	PR fortran/93364
+	* array.c (gfc_set_array_spec): Check for sum of rank and corank
+	not exceeding GFC_MAX_DIMENSIONS.
+
+2020-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/94270
+	* trans-decl.c (generate_local_decl): Do not warn if the
+	symbol is artifical.
+
+2020-04-06  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backport from master
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/93686
+	* decl.c (gfc_match_data): Handle data matching for derived type
+	pointers.
+
+2020-04-02  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/93498
+	* check.c (gfc_check_findloc):  If the kinds of the arguments
+	differ goto label "incompat".
+
+2020-04-02  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	2020-04-02  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/94030
+	* resolve.c (resolve_equivalence): Correct formatting
+	around the label "identical_types".  Instead of using
+	gfc_resolve_array_spec use is_non_constants_shape_array
+	to determine whether the array can be used in a in an
+	equivalence statement.
+
+2020-03-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2020-03-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/94348
+	* decl.c (gfc_match_submod_proc): Add result var to the
+	proc's namespace.
+
+2020-03-25  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	2020-03-25  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	PR fortran/93484
+	* match.c (gfc_match_type_spec): Replace gfc_match_init_expr with
+	gfc_match_expr. Return m if m is MATCH_NO or MATCH_ERROR.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 4a7f44f3e8b..017334839ed 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -835,6 +835,10 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
       return false;
     }
 
+  /* Check F2018:C822.  */
+  if (sym->as->rank + sym->as->corank > GFC_MAX_DIMENSIONS)
+    goto too_many;
+
   if (as->corank)
     {
       sym->as->cotype = as->cotype;
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 6d37bbb8fd2..16cc5d4c368 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -3384,6 +3384,10 @@ gfc_check_findloc (gfc_actual_arglist *ap)
   v1 = v->ts.type == BT_CHARACTER;
   if ((a1 && !v1) || (!a1 && v1))
     goto incompat;
+
+  /* Check the kind of the characters argument match.  */
+  if (a1 && v1 && a->ts.kind != v->ts.kind)
+    goto incompat;
 	 
   d = ap->next->next->expr;
   m = ap->next->next->next->expr;
@@ -4150,7 +4154,8 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,
 	   && shape->ref->u.ar.as->lower[0]->ts.type == BT_INTEGER
 	   && shape->ref->u.ar.as->upper[0]->expr_type == EXPR_CONSTANT
 	   && shape->ref->u.ar.as->upper[0]->ts.type == BT_INTEGER
-	   && shape->symtree->n.sym->attr.flavor == FL_PARAMETER)
+	   && shape->symtree->n.sym->attr.flavor == FL_PARAMETER
+	   && shape->symtree->n.sym->value)
     {
       int i, extent;
       gfc_expr *e, *v;
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 9117121e5fe..1a5bcfae3c0 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -501,8 +501,11 @@ get_unique_type_string (char *string, gfc_symbol *derived)
 static void
 get_unique_hashed_string (char *string, gfc_symbol *derived)
 {
-  char tmp[2*GFC_MAX_SYMBOL_LEN+2];
+  /* Provide sufficient space to hold "symbol.symbol_symbol".  */
+  char tmp[3*GFC_MAX_SYMBOL_LEN+3];
   get_unique_type_string (&tmp[0], derived);
+  size_t len = strnlen (tmp, sizeof (tmp));
+  gcc_assert (len < sizeof (tmp));
   /* If string is too long, use hash value in hex representation (allow for
      extra decoration, cf. gfc_build_class_symbol & gfc_find_derived_vtab).
      We need space to for 15 characters "__class_" + symbol name + "_%d_%da",
@@ -523,11 +526,13 @@ unsigned int
 gfc_hash_value (gfc_symbol *sym)
 {
   unsigned int hash = 0;
-  char c[2*(GFC_MAX_SYMBOL_LEN+1)];
+  /* Provide sufficient space to hold "symbol.symbol_symbol".  */
+  char c[3*GFC_MAX_SYMBOL_LEN+3];
   int i, len;
 
   get_unique_type_string (&c[0], sym);
-  len = strlen (c);
+  len = strnlen (c, sizeof (c));
+  gcc_assert ((size_t) len < sizeof (c));
 
   for (i = 0; i < len; i++)
     hash = (hash << 6) + (hash << 16) - hash + c[i];
@@ -907,12 +912,18 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
 {
   gfc_expr *e;
   gfc_ref *ref;
+  gfc_was_finalized *f;
 
   if (!comp_is_finalizable (comp))
     return;
 
-  if (comp->finalized)
-    return;
+  /* If this expression with this component has been finalized
+     already in this namespace, there is nothing to do.  */
+  for (f = sub_ns->was_finalized; f; f = f->next)
+    {
+      if (f->e == expr && f->c == comp)
+	return;
+    }
 
   e = gfc_copy_expr (expr);
   if (!e->ref)
@@ -1002,6 +1013,7 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
 	}
       else
 	(*code) = cond;
+
     }
   else if (comp->ts.type == BT_DERIVED
 	    && comp->ts.u.derived->f2k_derived
@@ -1041,7 +1053,13 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
 			    sub_ns);
       gfc_free_expr (e);
     }
-  comp->finalized = true;
+
+  /* Record that this was finalized already in this namespace.  */
+  f = sub_ns->was_finalized;
+  sub_ns->was_finalized = XCNEW (gfc_was_finalized);
+  sub_ns->was_finalized->e = expr;
+  sub_ns->was_finalized->c = comp;
+  sub_ns->was_finalized->next = f;
 }
 
 
@@ -2244,6 +2262,9 @@ gfc_find_derived_vtab (gfc_symbol *derived)
   if (!derived)
     return NULL;
 
+  if (!derived->name)
+    return NULL;
+
   /* Find the gsymbol for the module of use associated derived types.  */
   if ((derived->attr.use_assoc || derived->attr.used_in_submodule)
        && !derived->attr.vtype && !derived->attr.is_class)
@@ -2864,7 +2885,9 @@ gfc_find_vtab (gfc_typespec *ts)
     case BT_DERIVED:
       return gfc_find_derived_vtab (ts->u.derived);
     case BT_CLASS:
-      if (ts->u.derived->components && ts->u.derived->components->ts.u.derived)
+      if (ts->u.derived->attr.is_class
+	  && ts->u.derived->components
+	  && ts->u.derived->components->ts.u.derived)
 	return gfc_find_derived_vtab (ts->u.derived->components->ts.u.derived);
       else
 	return NULL;
diff --git a/gcc/fortran/data.c b/gcc/fortran/data.c
index 9c200d28e1a..0ca41c3dad8 100644
--- a/gcc/fortran/data.c
+++ b/gcc/fortran/data.c
@@ -20,14 +20,14 @@ along with GCC; see the file COPYING3.  If not see
 
 
 /* Notes for DATA statement implementation:
-									       
+
    We first assign initial value to each symbol by gfc_assign_data_value
    during resolving DATA statement. Refer to check_data_variable and
    traverse_data_list in resolve.c.
-									       
+
    The complexity exists in the handling of array section, implied do
    and array of struct appeared in DATA statement.
-									       
+
    We call gfc_conv_structure, gfc_con_array_array_initializer,
    etc., to convert the initial value. Refer to trans-expr.c and
    trans-array.c.  */
@@ -221,11 +221,14 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
   gfc_ref *ref;
   gfc_expr *init;
   gfc_expr *expr = NULL;
+  gfc_expr *rexpr;
   gfc_constructor *con;
   gfc_constructor *last_con;
   gfc_symbol *symbol;
   gfc_typespec *last_ts;
   mpz_t offset;
+  const char *msg = "F18(R841): data-implied-do object at %L is neither an "
+		    "array-element nor a scalar-structure-component";
 
   symbol = lvalue->symtree->n.sym;
   init = symbol->value;
@@ -464,6 +467,74 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
 	    }
 	  break;
 
+	case REF_INQUIRY:
+
+	  /* After some discussion on clf it was determined that the following
+	     violates F18(R841). If the error is removed, the expected result
+	     is obtained. Leaving the code in place ensures a clean error
+	     recovery.  */
+	  gfc_error (msg, &lvalue->where);
+
+	  /* This breaks with the other reference types in that the output
+	     constructor has to be of type COMPLEX, whereas the lvalue is
+	     of type REAL.  The rvalue is copied to the real or imaginary
+	     part as appropriate.  In addition, for all except scalar
+	     complex variables, a complex expression has to provided, where
+	     the constructor does not have it, and the expression modified
+	     with a new value for the real or imaginary part.  */
+	  gcc_assert (ref->next == NULL && last_ts->type == BT_COMPLEX);
+	  rexpr = gfc_copy_expr (rvalue);
+	  if (!gfc_compare_types (&lvalue->ts, &rexpr->ts))
+	    gfc_convert_type (rexpr, &lvalue->ts, 0);
+
+	  /* This is the scalar, complex case, where an initializer exists.  */
+	  if (init && ref == lvalue->ref)
+	    expr = symbol->value;
+	  /* Then all cases, where a complex expression does not exist.  */
+	  else if (!last_con || !last_con->expr)
+	    {
+	      expr = gfc_get_constant_expr (BT_COMPLEX, lvalue->ts.kind,
+					    &lvalue->where);
+	      if (last_con)
+		last_con->expr = expr;
+	    }
+	  else
+	    /* Finally, and existing constructor expression to be modified.  */
+	    expr = last_con->expr;
+
+	  /* Rejection of LEN and KIND inquiry references is handled
+	     elsewhere. The error here is added as backup. The assertion
+	     of F2008 for RE and IM is also done elsewhere.  */
+	  switch (ref->u.i)
+	    {
+	    case INQUIRY_LEN:
+	    case INQUIRY_KIND:
+	      gfc_error ("LEN or KIND inquiry ref in DATA statement at %L",
+			 &lvalue->where);
+	      goto abort;
+	    case INQUIRY_RE:
+	      mpfr_set (mpc_realref (expr->value.complex),
+			rexpr->value.real,
+			GFC_RND_MODE);
+	      break;
+	    case INQUIRY_IM:
+	      mpfr_set (mpc_imagref (expr->value.complex),
+			rexpr->value.real,
+			GFC_RND_MODE);
+	      break;
+	    }
+
+	  /* Only the scalar, complex expression needs to be saved as the
+	     symbol value since the last constructor expression is already
+	     provided as the initializer in the code after the reference
+	     cases.  */
+	  if (ref == lvalue->ref)
+	    symbol->value = expr;
+
+	  gfc_free_expr (rexpr);
+	  mpz_clear (offset);
+	  return true;
+
 	default:
 	  gcc_unreachable ();
 	}
@@ -498,12 +569,11 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
 	return false;
     }
 
-  if (ref || last_ts->type == BT_CHARACTER)
+  if (ref || (last_ts->type == BT_CHARACTER
+	      && rvalue->expr_type == EXPR_CONSTANT))
     {
       /* An initializer has to be constant.  */
-      if (rvalue->expr_type != EXPR_CONSTANT
-	  || (lvalue->ts.u.cl->length == NULL
-	      && !(ref && ref->u.ss.length != NULL)))
+      if (lvalue->ts.u.cl->length == NULL && !(ref && ref->u.ss.length != NULL))
 	return false;
       expr = create_character_initializer (init, last_ts, ref, rvalue);
     }
@@ -513,7 +583,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
 	  && gfc_has_default_initializer (lvalue->ts.u.derived))
 	{
 	  gfc_error ("Nonpointer object %qs with default initialization "
-		     "shall not appear in a DATA statement at %L", 
+		     "shall not appear in a DATA statement at %L",
 		     symbol->name, &lvalue->where);
 	  return false;
 	}
@@ -540,13 +610,13 @@ abort:
 
 /* Modify the index of array section and re-calculate the array offset.  */
 
-void 
+void
 gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,
 		     mpz_t *offset_ret)
 {
   int i;
   mpz_t delta;
-  mpz_t tmp; 
+  mpz_t tmp;
   bool forwards;
   int cmp;
   gfc_expr *start, *end, *stride;
@@ -567,21 +637,21 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,
 	    forwards = true;
 	  else
 	    forwards = false;
-	  gfc_free_expr(stride);	
+	  gfc_free_expr(stride);
 	}
       else
 	{
 	  mpz_add_ui (section_index[i], section_index[i], 1);
 	  forwards = true;
 	}
-      
+
       if (ar->end[i])
         {
 	  end = gfc_copy_expr(ar->end[i]);
 	  if(!gfc_simplify_expr(end, 1))
 	    gfc_internal_error("Simplification error");
 	  cmp = mpz_cmp (section_index[i], end->value.integer);
-	  gfc_free_expr(end);	
+	  gfc_free_expr(end);
 	}
       else
 	cmp = mpz_cmp (section_index[i], ar->as->upper[i]->value.integer);
@@ -595,7 +665,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,
 	      if(!gfc_simplify_expr(start, 1))
 	        gfc_internal_error("Simplification error");
 	      mpz_set (section_index[i], start->value.integer);
-	      gfc_free_expr(start); 
+	      gfc_free_expr(start);
 	    }
 	  else
 	    mpz_set (section_index[i], ar->as->lower[i]->value.integer);
@@ -613,7 +683,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,
       mpz_mul (tmp, tmp, delta);
       mpz_add (*offset_ret, tmp, *offset_ret);
 
-      mpz_sub (tmp, ar->as->upper[i]->value.integer, 
+      mpz_sub (tmp, ar->as->upper[i]->value.integer,
 	       ar->as->lower[i]->value.integer);
       mpz_add_ui (tmp, tmp, 1);
       mpz_mul (delta, tmp, delta);
@@ -699,7 +769,7 @@ gfc_formalize_init_value (gfc_symbol *sym)
 
 /* Get the integer value into RET_AS and SECTION from AS and AR, and return
    offset.  */
- 
+
 void
 gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)
 {
@@ -741,7 +811,7 @@ gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)
 	  gcc_unreachable ();
 	}
 
-      mpz_sub (tmp, ar->as->upper[i]->value.integer, 
+      mpz_sub (tmp, ar->as->upper[i]->value.integer,
 	       ar->as->lower[i]->value.integer);
       mpz_add_ui (tmp, tmp, 1);
       mpz_mul (delta, tmp, delta);
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index abff4af9f67..00321da827e 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -668,6 +668,10 @@ gfc_match_data (void)
 	  /* F2008:C567 (R536) A data-i-do-object or a variable that appears
 	     as a data-stmt-object shall not be an object designator in which
 	     a pointer appears other than as the entire rightmost part-ref.  */
+	  if (!e->ref && e->ts.type == BT_DERIVED
+	      && e->symtree->n.sym->attr.pointer)
+	    goto partref;
+
 	  ref = e->ref;
 	  if (e->symtree->n.sym->ts.type == BT_DERIVED
 	      && e->symtree->n.sym->attr.pointer
@@ -1029,6 +1033,11 @@ char_len_param_value (gfc_expr **expr, bool *deferred)
   if (!gfc_expr_check_typed (*expr, gfc_current_ns, false))
     return MATCH_ERROR;
 
+  /* If gfortran gets an EXPR_OP, try to simplifiy it.  This catches things
+     like CHARACTER(([1])).   */
+  if ((*expr)->expr_type == EXPR_OP)
+    gfc_simplify_expr (*expr, 1);
+
   if ((*expr)->expr_type == EXPR_FUNCTION)
     {
       if ((*expr)->ts.type == BT_INTEGER
@@ -1093,6 +1102,9 @@ char_len_param_value (gfc_expr **expr, bool *deferred)
       gfc_free_expr (e);
     }
 
+  if (gfc_seen_div0)
+    m = MATCH_ERROR;
+
   return m;
 
 syntax:
@@ -3980,7 +3992,8 @@ error_return:
 match
 gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 {
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  /* Provide sufficient space to hold "pdtsymbol".  */
+  char name[GFC_MAX_SYMBOL_LEN + 1 + 3];
   gfc_symbol *sym, *dt_sym;
   match m;
   char c;
@@ -4025,7 +4038,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       gfc_gobble_whitespace ();
       if (gfc_peek_ascii_char () == '*')
 	{
-	  if ((m = gfc_match ("*)")) != MATCH_YES)
+	  if ((m = gfc_match ("* ) ")) != MATCH_YES)
 	    return m;
 	  if (gfc_comp_struct (gfc_current_state ()))
 	    {
@@ -4182,7 +4195,11 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	    return m;
 	  gcc_assert (!sym->attr.pdt_template && sym->attr.pdt_type);
 	  ts->u.derived = sym;
-	  strcpy (name, gfc_dt_lower_string (sym->name));
+	  const char* lower = gfc_dt_lower_string (sym->name);
+	  size_t len = strnlen (lower, sizeof (name));
+	  gcc_assert (len < sizeof (name));
+	  memcpy (name, lower, len);
+	  name[len] = '\0';
 	}
 
       if (sym && sym->attr.flavor == FL_STRUCT)
@@ -5339,15 +5356,19 @@ match_attr_spec (void)
       if (d == DECL_STATIC && seen[DECL_SAVE])
 	continue;
 
-      if (gfc_current_state () == COMP_DERIVED
+      if (gfc_comp_struct (gfc_current_state ())
 	  && d != DECL_DIMENSION && d != DECL_CODIMENSION
 	  && d != DECL_POINTER   && d != DECL_PRIVATE
 	  && d != DECL_PUBLIC && d != DECL_CONTIGUOUS && d != DECL_NONE)
 	{
+	  bool is_derived = gfc_current_state () == COMP_DERIVED;
 	  if (d == DECL_ALLOCATABLE)
 	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "ALLOCATABLE "
-				   "attribute at %C in a TYPE definition"))
+	      if (!gfc_notify_std (GFC_STD_F2003, is_derived
+				   ? G_("ALLOCATABLE attribute at %C in a "
+					"TYPE definition")
+				   : G_("ALLOCATABLE attribute at %C in a "
+					"STRUCTURE definition")))
 		{
 		  m = MATCH_ERROR;
 		  goto cleanup;
@@ -5355,8 +5376,11 @@ match_attr_spec (void)
 	    }
 	  else if (d == DECL_KIND)
 	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "KIND "
-				   "attribute at %C in a TYPE definition"))
+	      if (!gfc_notify_std (GFC_STD_F2003, is_derived
+				   ? G_("KIND attribute at %C in a "
+					"TYPE definition")
+				   : G_("KIND attribute at %C in a "
+					"STRUCTURE definition")))
 		{
 		  m = MATCH_ERROR;
 		  goto cleanup;
@@ -5379,8 +5403,11 @@ match_attr_spec (void)
 	    }
 	  else if (d == DECL_LEN)
 	    {
-	      if (!gfc_notify_std (GFC_STD_F2003, "LEN "
-				   "attribute at %C in a TYPE definition"))
+	      if (!gfc_notify_std (GFC_STD_F2003, is_derived
+				   ? G_("LEN attribute at %C in a "
+					"TYPE definition")
+				   : G_("LEN attribute at %C in a "
+					"STRUCTURE definition")))
 		{
 		  m = MATCH_ERROR;
 		  goto cleanup;
@@ -5403,8 +5430,10 @@ match_attr_spec (void)
 	    }
 	  else
 	    {
-	      gfc_error ("Attribute at %L is not allowed in a TYPE definition",
-			 &seen_at[d]);
+	      gfc_error (is_derived ? G_("Attribute at %L is not allowed in a "
+					 "TYPE definition")
+				    : G_("Attribute at %L is not allowed in a "
+					 "STRUCTURE definition"), &seen_at[d]);
 	      m = MATCH_ERROR;
 	      goto cleanup;
 	    }
@@ -7281,6 +7310,7 @@ gfc_match_function_decl (void)
      procedure interface body.  */
     if (sym->attr.is_bind_c && sym->attr.module_procedure && sym->old_symbol
   	&& strcmp (sym->name, sym->old_symbol->name) == 0
+	&& sym->binding_label && sym->old_symbol->binding_label
 	&& strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
       {
 	  const char *null = "NULL", *s1, *s2;
@@ -7796,6 +7826,7 @@ gfc_match_subroutine (void)
 	 procedure interface body.  */
       if (sym->attr.module_procedure && sym->old_symbol
   	  && strcmp (sym->name, sym->old_symbol->name) == 0
+	  && sym->binding_label && sym->old_symbol->binding_label
 	  && strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
 	{
 	  const char *null = "NULL", *s1, *s2;
@@ -8962,7 +8993,7 @@ access_attr_decl (gfc_statement st)
 	  else
 	    {
 	      gfc_error ("Access specification of the .%s. operator at %C "
-			 "has already been specified", sym->name);
+			 "has already been specified", uop->name);
 	      goto done;
 	    }
 
@@ -9602,13 +9633,20 @@ gfc_match_submod_proc (void)
   if (get_proc_name (name, &sym, false))
     return MATCH_ERROR;
 
-  /* Make sure that the result field is appropriately filled, even though
-     the result symbol will be replaced later on.  */
+  /* Make sure that the result field is appropriately filled.  */
   if (sym->tlink && sym->tlink->attr.function)
     {
-      if (sym->tlink->result
-	  && sym->tlink->result != sym->tlink)
-	sym->result= sym->tlink->result;
+      if (sym->tlink->result && sym->tlink->result != sym->tlink)
+	{
+	  sym->result = sym->tlink->result;
+	  if (!sym->result->attr.use_assoc)
+	    {
+	      gfc_symtree *st = gfc_new_symtree (&gfc_current_ns->sym_root,
+						 sym->result->name);
+	      st->n.sym = sym->result;
+	      sym->result->refs++;
+	    }
+	}
       else
 	sym->result = sym;
     }
@@ -9657,6 +9695,15 @@ gfc_match_submod_proc (void)
 
   if (gfc_match_eos () != MATCH_YES)
     {
+      /* Unset st->n.sym. Note: in reject_statement (), the symbol changes are
+	 undone, such that the st->n.sym->formal points to the original symbol;
+	 if now this namespace is finalized, the formal namespace is freed,
+	 but it might be still needed in the parent namespace.  */
+      gfc_symtree *st = gfc_find_symtree (gfc_current_ns->sym_root, sym->name);
+      st->n.sym = NULL;
+      gfc_free_symbol (sym->tlink);
+      sym->tlink = NULL;
+      sym->refs--;
       gfc_syntax_error (ST_MODULE_PROC);
       return MATCH_ERROR;
     }
diff --git a/gcc/fortran/dump-parse-tree.c b/gcc/fortran/dump-parse-tree.c
index ebd73110e2d..f4a7d9adb51 100644
--- a/gcc/fortran/dump-parse-tree.c
+++ b/gcc/fortran/dump-parse-tree.c
@@ -3136,45 +3136,28 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,
   if (ts->type == BT_REAL || ts->type == BT_INTEGER || ts->type == BT_COMPLEX)
     {
       if (ts->is_c_interop && ts->interop_kind)
-	{
-	  *type_name = ts->interop_kind->name + 2;
-	  if (strcmp (*type_name, "signed_char") == 0)
-	    *type_name = "signed char";
-	  else if (strcmp (*type_name, "size_t") == 0)
-	    *type_name = "ssize_t";
-	  else if (strcmp (*type_name, "float_complex") == 0)
-	    *type_name = "__GFORTRAN_FLOAT_COMPLEX";
-	  else if (strcmp (*type_name, "double_complex") == 0)
-	    *type_name = "__GFORTRAN_DOUBLE_COMPLEX";
-	  else if (strcmp (*type_name, "long_double_complex") == 0)
-	    *type_name = "__GFORTRAN_LONG_DOUBLE_COMPLEX";
-
-	  ret = T_OK;
-	}
+	ret = T_OK;
       else
+	ret = T_WARN;
+
+      for (int i = 0; i < ISOCBINDING_NUMBER; i++)
 	{
-	  /* The user did not specify a C interop type.  Let's look through
-	     the available table and use the first one, but warn.  */
-	  for (int i = 0; i < ISOCBINDING_NUMBER; i++)
+	  if (c_interop_kinds_table[i].f90_type == ts->type
+	      && c_interop_kinds_table[i].value == ts->kind)
 	    {
-	      if (c_interop_kinds_table[i].f90_type == ts->type
-		  && c_interop_kinds_table[i].value == ts->kind)
-		{
-		  *type_name = c_interop_kinds_table[i].name + 2;
-		  if (strcmp (*type_name, "signed_char") == 0)
-		    *type_name = "signed char";
-		  else if (strcmp (*type_name, "size_t") == 0)
-		    *type_name = "ssize_t";
-		  else if (strcmp (*type_name, "float_complex") == 0)
-		    *type_name = "__GFORTRAN_FLOAT_COMPLEX";
-		  else if (strcmp (*type_name, "double_complex") == 0)
-		    *type_name = "__GFORTRAN_DOUBLE_COMPLEX";
-		  else if (strcmp (*type_name, "long_double_complex") == 0)
-		    *type_name = "__GFORTRAN_LONG_DOUBLE_COMPLEX";
-
-		  ret = T_WARN;
-		  break;
-		}
+	      *type_name = c_interop_kinds_table[i].name + 2;
+	      if (strcmp (*type_name, "signed_char") == 0)
+		*type_name = "signed char";
+	      else if (strcmp (*type_name, "size_t") == 0)
+		*type_name = "ssize_t";
+	      else if (strcmp (*type_name, "float_complex") == 0)
+		*type_name = "__GFORTRAN_FLOAT_COMPLEX";
+	      else if (strcmp (*type_name, "double_complex") == 0)
+		*type_name = "__GFORTRAN_DOUBLE_COMPLEX";
+	      else if (strcmp (*type_name, "long_double_complex") == 0)
+		*type_name = "__GFORTRAN_LONG_DOUBLE_COMPLEX";
+
+	      break;
 	    }
 	}
     }
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 94f9eb00f71..019245a3ab8 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -2063,6 +2063,9 @@ simplify_parameter_variable (gfc_expr *p, int type)
 
   e->rank = p->rank;
 
+  if (e->ts.type == BT_CHARACTER && p->ts.u.cl)
+    e->ts = p->ts;
+
   /* Do not copy subobject refs for constant.  */
   if (e->expr_type != EXPR_CONSTANT && p->ref != NULL)
     e->ref = gfc_copy_ref (p->ref);
@@ -2278,7 +2281,7 @@ scalarize_intrinsic_call (gfc_expr *e, bool init_flag)
   gfc_constructor *ci, *new_ctor;
   gfc_expr *expr, *old;
   int n, i, rank[5], array_arg;
-  int errors = 0;
+  gfc_expr *p;
 
   if (e == NULL)
     return false;
@@ -2346,8 +2349,6 @@ scalarize_intrinsic_call (gfc_expr *e, bool init_flag)
       n++;
     }
 
-  gfc_get_errors (NULL, &errors);
-
   /* Using the array argument as the master, step through the array
      calling the function for each element and advancing the array
      constructors together.  */
@@ -2381,8 +2382,12 @@ scalarize_intrinsic_call (gfc_expr *e, bool init_flag)
       /* Simplify the function calls.  If the simplification fails, the
 	 error will be flagged up down-stream or the library will deal
 	 with it.  */
-      if (errors == 0)
-	gfc_simplify_expr (new_ctor->expr, 0);
+      p = gfc_copy_expr (new_ctor->expr);
+
+      if (!gfc_simplify_expr (p, init_flag))
+	gfc_free_expr (p);
+      else
+	gfc_replace_expr (new_ctor->expr, p);
 
       for (i = 0; i < n; i++)
 	if (args[i])
@@ -4225,7 +4230,20 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,
       gfc_symbol *sym;
       bool target;
 
-      gcc_assert (rvalue->symtree);
+      if (gfc_is_size_zero_array (rvalue))
+	{
+	  gfc_error ("Zero-sized array detected at %L where an entity with "
+		     "the TARGET attribute is expected", &rvalue->where);
+	  return false;
+	}
+      else if (!rvalue->symtree)
+	{
+	  gfc_error ("Pointer assignment target in initialization expression "
+		     "does not have the TARGET attribute at %L",
+		     &rvalue->where);
+	  return false;
+	}
+
       sym = rvalue->symtree->n.sym;
 
       if (sym->ts.type == BT_CLASS && sym->attr.class_ok)
@@ -4300,7 +4318,9 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue,
      contiguous.  Be lenient in the definition of what counts as
      contiguous.  */
 
-  if (lhs_attr.contiguous && !gfc_is_simply_contiguous (rvalue, false, true))
+  if (lhs_attr.contiguous
+      && lhs_attr.dimension > 0
+      && !gfc_is_simply_contiguous (rvalue, false, true))
     gfc_warning (OPT_Wextra, "Assignment to contiguous pointer from "
 		 "non-contiguous target at %L", &rvalue->where);
 
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index a6e710beb33..ff71b44b409 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -5388,3 +5388,77 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
     }
   return 0;
 }
+
+/* Callback function. If there is a call to a subroutine which is
+   neither pure nor implicit_pure, unset the implicit_pure flag for
+   the caller and return -1.  */
+
+static int
+implicit_pure_call (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
+		    void *sym_data)
+{
+  gfc_code *co = *c;
+  gfc_symbol *caller_sym;
+  symbol_attribute *a;
+
+  if (co->op != EXEC_CALL || co->resolved_sym == NULL)
+    return 0;
+
+  a = &co->resolved_sym->attr;
+  if (a->intrinsic || a->pure || a->implicit_pure)
+    return 0;
+
+  caller_sym = (gfc_symbol *) sym_data;
+  gfc_unset_implicit_pure (caller_sym);
+  return 1;
+}
+
+/* Callback function. If there is a call to a function which is
+   neither pure nor implicit_pure, unset the implicit_pure flag for
+   the caller and return 1.  */
+
+static int
+implicit_pure_expr (gfc_expr **e, int *walk ATTRIBUTE_UNUSED, void *sym_data)
+{
+  gfc_expr *expr = *e;
+  gfc_symbol *caller_sym;
+  gfc_symbol *sym;
+  symbol_attribute *a;
+
+  if (expr->expr_type != EXPR_FUNCTION || expr->value.function.isym)
+    return 0;
+
+  sym = expr->symtree->n.sym;
+  a = &sym->attr;
+  if (a->pure || a->implicit_pure)
+    return 0;
+
+  caller_sym = (gfc_symbol *) sym_data;
+  gfc_unset_implicit_pure (caller_sym);
+  return 1;
+}
+
+/* Go through all procedures in the namespace and unset the
+   implicit_pure attribute for any procedure that calls something not
+   pure or implicit pure.  */
+
+bool
+gfc_fix_implicit_pure (gfc_namespace *ns)
+{
+  bool changed = false;
+  gfc_symbol *proc = ns->proc_name;
+
+  if (proc && proc->attr.flavor == FL_PROCEDURE && proc->attr.implicit_pure
+      && ns->code
+      && gfc_code_walker (&ns->code, implicit_pure_call, implicit_pure_expr,
+			  (void *) ns->proc_name))
+    changed = true;
+
+  for (ns = ns->contained; ns; ns = ns->sibling)
+    {
+      if (gfc_fix_implicit_pure (ns))
+	changed = true;
+    }
+
+  return changed;
+}
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index d7071ae5fcf..ad689e6a509 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -1094,7 +1094,6 @@ typedef struct gfc_component
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
-  bool finalized;
 }
 gfc_component;
 
@@ -1602,7 +1601,10 @@ typedef struct gfc_symbol
   /* Set if the symbol is used in a function result specification .  */
   unsigned fn_result_spec:1;
   /* Used to avoid multiple resolutions of a single symbol.  */
-  unsigned resolved:1;
+  /* = 2 if this has already been resolved as an intrinsic,
+       in gfc_resolve_intrinsic,
+     = 1 if it has been resolved in resolve_symbol.  */
+  unsigned resolve_symbol_called:2;
   /* Set if this is a module function or subroutine with the
      abreviated declaration in a submodule.  */
   unsigned abr_modproc_decl:1;
@@ -1650,7 +1652,8 @@ typedef struct gfc_common_head
   char use_assoc, saved, threadprivate;
   unsigned char omp_declare_target : 1;
   unsigned char omp_declare_target_link : 1;
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  /* Provide sufficient space to hold "symbol.eq.1234567890".  */
+  char name[GFC_MAX_SYMBOL_LEN + 1 + 14];
   struct gfc_symbol *head;
   const char* binding_label;
   int is_bind_c;
@@ -1746,6 +1749,16 @@ gfc_oacc_routine_name;
 
 #define gfc_get_oacc_routine_name() XCNEW (gfc_oacc_routine_name)
 
+/* Node in linked list to see what has already been finalized
+   earlier.  */
+
+typedef struct gfc_was_finalized {
+  gfc_expr *e;
+  gfc_component *c;
+  struct gfc_was_finalized *next;
+}
+gfc_was_finalized;
+
 /* A namespace describes the contents of procedure, module, interface block
    or BLOCK construct.  */
 /* ??? Anything else use these?  */
@@ -1838,6 +1851,11 @@ typedef struct gfc_namespace
   /* Linked list of !$omp declare simd constructs.  */
   struct gfc_omp_declare_simd *omp_declare_simd;
 
+  /* A hash set for the the gfc expressions that have already
+     been finalized in this namespace.  */
+
+  gfc_was_finalized *was_finalized;
+
   /* Set to 1 if namespace is a BLOCK DATA program unit.  */
   unsigned is_block_data:1;
 
@@ -2187,6 +2205,7 @@ typedef struct gfc_expr
   /* Set this if no warning should be given somewhere in a lower level.  */
 
   unsigned int do_not_warn : 1;
+
   /* If an expression comes from a Hollerith constant or compile-time
      evaluation of a transfer statement, it may have a prescribed target-
      memory representation, and these cannot always be backformed from
@@ -3340,6 +3359,7 @@ bool find_forall_index (gfc_expr *, gfc_symbol *, int);
 bool gfc_resolve_index (gfc_expr *, int);
 bool gfc_resolve_dim_arg (gfc_expr *);
 bool gfc_is_formal_arg (void);
+bool gfc_resolve_substring (gfc_ref *, bool *);
 void gfc_resolve_substring_charlen (gfc_expr *);
 match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);
 gfc_expr *gfc_expr_to_initialize (gfc_expr *);
@@ -3545,6 +3565,7 @@ typedef int (*walk_expr_fn_t) (gfc_expr **, int *, void *);
 int gfc_dummy_code_callback (gfc_code **, int *, void *);
 int gfc_expr_walker (gfc_expr **, walk_expr_fn_t, void *);
 int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);
+bool gfc_fix_implicit_pure (gfc_namespace *);
 
 /* simplify.c */
 
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index b5701b1a59a..d88fa77573d 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -1464,6 +1464,19 @@ gfc_check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,
       int i, compval;
       gfc_expr *shape1, *shape2;
 
+      /* Sometimes the ambiguity between deferred shape and assumed shape
+	 does not get resolved in module procedures, where the only explicit
+	 declaration of the dummy is in the interface.  */
+      if (s1->ns->proc_name && s1->ns->proc_name->attr.module_procedure
+	  && s1->as->type == AS_ASSUMED_SHAPE
+	  && s2->as->type == AS_DEFERRED)
+	{
+	  s2->as->type = AS_ASSUMED_SHAPE;
+	  for (i = 0; i < s2->as->rank; i++)
+	    if (s1->as->lower[i] != NULL)
+	      s2->as->lower[i] = gfc_copy_expr (s1->as->lower[i]);
+	}
+
       if (s1->as->type != s2->as->type)
 	{
 	  snprintf (errmsg, err_len, "Shape mismatch in argument '%s'",
@@ -2424,7 +2437,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
 	       && formal->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
 	      || formal->attr.lock_comp))
 
-    	{
+	{
 	  if (where)
 	    gfc_error ("Actual argument to non-INTENT(INOUT) dummy %qs at %L, "
 		       "which is LOCK_TYPE or has a LOCK_TYPE component",
@@ -2439,7 +2452,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,
 	       && formal->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)
 	      || formal->attr.event_comp))
 
-    	{
+	{
 	  if (where)
 	    gfc_error ("Actual argument to non-INTENT(INOUT) dummy %qs at %L, "
 		       "which is EVENT_TYPE or has a EVENT_TYPE component",
@@ -3798,7 +3811,7 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
   if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,
 			      sym->attr.proc == PROC_ST_FUNCTION, where))
     return false;
- 
+
   if (!check_intents (dummy_args, *ap))
     return false;
 
@@ -4979,7 +4992,8 @@ gfc_find_typebound_dtio_proc (gfc_symbol *derived, bool write, bool formatted)
   gfc_symtree *tb_io_st = NULL;
   bool t = false;
 
-  if (!derived || !derived->resolved || derived->attr.flavor != FL_DERIVED)
+  if (!derived || !derived->resolve_symbol_called
+      || derived->attr.flavor != FL_DERIVED)
     return NULL;
 
   /* Try to find a typebound DTIO binding.  */
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 357a35052eb..d1da044f8f1 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -2700,8 +2700,8 @@ add_functions (void)
 
   make_generic ("null", GFC_ISYM_NULL, GFC_STD_F95);
 
-  add_sym_2 ("num_images", GFC_ISYM_NUM_IMAGES, CLASS_INQUIRY, ACTUAL_NO,
-	     BT_INTEGER, di, GFC_STD_F2008,
+  add_sym_2 ("num_images", GFC_ISYM_NUM_IMAGES, CLASS_TRANSFORMATIONAL,
+	     ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008,
 	     gfc_check_num_images, gfc_simplify_num_images, NULL,
 	     dist, BT_INTEGER, di, OPTIONAL,
 	     failed, BT_LOGICAL, dl, OPTIONAL);
@@ -3133,7 +3133,7 @@ add_functions (void)
   make_generic ("tanh", GFC_ISYM_TANH, GFC_STD_F77);
 
   add_sym_1 ("team_number", GFC_ISYM_TEAM_NUMBER, CLASS_TRANSFORMATIONAL,
-	     ACTUAL_YES, BT_INTEGER, di, GFC_STD_F2018,
+	     ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2018,
 	     gfc_check_team_number, NULL, gfc_resolve_team_number,
 	     team, BT_DERIVED, di, OPTIONAL);
 
diff --git a/gcc/fortran/intrinsic.texi b/gcc/fortran/intrinsic.texi
index b39c576a8f6..05632e19c4d 100644
--- a/gcc/fortran/intrinsic.texi
+++ b/gcc/fortran/intrinsic.texi
@@ -6041,7 +6041,8 @@ END PROGRAM
 @item @emph{Description}:
 Determines the location of the element in the array with the value
 given in the @var{VALUE} argument, or, if the @var{DIM} argument is
-supplied, determines the locations of the maximum element along each
+supplied, determines the locations of the elements equal to the
+@var{VALUE} argument element along each
 row of the array in the @var{DIM} direction.  If @var{MASK} is
 present, only the elements for which @var{MASK} is @code{.TRUE.} are
 considered.  If more than one element in the array has the value
diff --git a/gcc/fortran/libgfortran.h b/gcc/fortran/libgfortran.h
index 581b2f529db..02250fab4be 100644
--- a/gcc/fortran/libgfortran.h
+++ b/gcc/fortran/libgfortran.h
@@ -122,6 +122,7 @@ typedef enum
   LIBERROR_SHORT_RECORD,
   LIBERROR_CORRUPT_FILE,
   LIBERROR_INQUIRE_INTERNAL_UNIT, /* Must be different from STAT_STOPPED_IMAGE.  */
+  LIBERROR_BAD_WAIT_ID,
   LIBERROR_LAST			/* Not a real error, the last error # + 1.  */
 }
 libgfortran_error_codes;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 088b69f8ec9..f61eac0b955 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -1374,9 +1374,6 @@ gfc_match_assignment (void)
 
   gfc_check_do_variable (lvalue->symtree);
 
-  if (lvalue->ts.type == BT_CLASS)
-    gfc_find_vtab (&rvalue->ts);
-
   return MATCH_YES;
 }
 
@@ -2200,9 +2197,9 @@ gfc_match_type_spec (gfc_typespec *ts)
 
 found:
 
-      m = gfc_match_init_expr (&e);
+      m = gfc_match_expr (&e);
       if (m == MATCH_NO || m == MATCH_ERROR)
-	return MATCH_NO;
+	return m;
 
       /* If a comma appears, it is an intrinsic subprogram. */
       gfc_gobble_whitespace ();
@@ -2217,7 +2214,10 @@ found:
 	 a scalar integer initialization-expr and valid kind parameter. */
       if (c == ')')
 	{
-	  if (e->ts.type != BT_INTEGER || e->rank > 0)
+	  bool ok = true;
+	  if (e->expr_type != EXPR_CONSTANT && e->expr_type != EXPR_VARIABLE)
+	    ok = gfc_reduce_init_expr (e);
+	  if (!ok || e->ts.type != BT_INTEGER || e->rank > 0)
 	    {
 	      gfc_free_expr (e);
 	      return MATCH_NO;
@@ -5575,6 +5575,11 @@ gfc_match_equivalence (void)
 
 	  if (!gfc_add_in_equivalence (&sym->attr, sym->name, NULL))
 	    goto cleanup;
+	  if (sym->ts.type == BT_CLASS
+	      && CLASS_DATA (sym)
+	      && !gfc_add_in_equivalence (&CLASS_DATA (sym)->attr,
+					  sym->name, NULL))
+	    goto cleanup;
 
 	  if (sym->attr.in_common)
 	    {
@@ -6163,7 +6168,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)
 static void
 select_type_set_tmp (gfc_typespec *ts)
 {
-  char name[GFC_MAX_SYMBOL_LEN];
+  char name[GFC_MAX_SYMBOL_LEN + 12 + 1];
   gfc_symtree *tmp = NULL;
   gfc_symbol *selector = select_type_stack->selector;
 
@@ -6237,7 +6242,7 @@ gfc_match_select_type (void)
 {
   gfc_expr *expr1, *expr2 = NULL;
   match m;
-  char name[GFC_MAX_SYMBOL_LEN];
+  char name[GFC_MAX_SYMBOL_LEN + 1];
   bool class_array;
   gfc_symbol *sym;
   gfc_namespace *ns = gfc_current_ns;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index dccce4fe0a4..849a1d0fa00 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -646,18 +646,6 @@ gfc_match_use (void)
 	  if (type == INTERFACE_USER_OP)
 	    new_use->op = INTRINSIC_USER;
 
-	  st = gfc_find_symtree (gfc_current_ns->sym_root, name);
-	  if (st && type != INTERFACE_USER_OP)
-	    {
-	      if (m == MATCH_YES)
-		gfc_error ("Symbol %qs at %L conflicts with the rename symbol "
-			   "at %L", name, &st->n.sym->declared_at, &loc);
-	      else
-		gfc_error ("Symbol %qs at %L conflicts with the symbol "
-			   "at %L", name, &st->n.sym->declared_at, &loc);
-	      goto cleanup;
-	    }
-
 	  if (use_list->only_flag)
 	    {
 	      if (m != MATCH_YES)
@@ -689,6 +677,20 @@ gfc_match_use (void)
 		goto cleanup;
 	    }
 
+	  st = gfc_find_symtree (gfc_current_ns->sym_root, name);
+	  if (st && type != INTERFACE_USER_OP
+	      && (st->n.sym->module != use_list->module_name
+		  || strcmp (st->n.sym->name, new_use->use_name) != 0))
+	    {
+	      if (m == MATCH_YES)
+		gfc_error ("Symbol %qs at %L conflicts with the rename symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      else
+		gfc_error ("Symbol %qs at %L conflicts with the symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      goto cleanup;
+	    }
+
 	  if (strcmp (new_use->use_name, use_list->module_name) == 0
 	      || strcmp (new_use->local_name, use_list->module_name) == 0)
 	    {
@@ -4393,6 +4395,9 @@ mio_symbol (gfc_symbol *sym)
 
   mio_symbol_attribute (&sym->attr);
 
+  if (sym->attr.pdt_type)
+    sym->name = gfc_dt_upper_string (sym->name);
+
   /* Note that components are always saved, even if they are supposed
      to be private.  Component access is checked during searching.  */
   mio_component_list (&sym->components, sym->attr.vtype);
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 9e662a66126..8426f3b2839 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -6310,6 +6310,11 @@ loop:
 
   gfc_resolve (gfc_current_ns);
 
+  /* Fix the implicit_pure attribute for those procedures who should
+     not have it.  */
+  while (gfc_fix_implicit_pure (gfc_current_ns))
+    ;
+
   /* Dump the parse tree if requested.  */
   if (flag_dump_fortran_original)
     gfc_dump_parse_tree (gfc_current_ns, stdout);
@@ -6355,6 +6360,24 @@ done:
   /* Do the resolution.  */
   resolve_all_program_units (gfc_global_ns_list);
 
+  /* Go through all top-level namespaces and unset the implicit_pure
+     attribute for any procedures that call something not pure or
+     implicit_pure.  Because the a procedure marked as not implicit_pure
+     in one sweep may be called by another routine, we repeat this
+     process until there are no more changes.  */
+  bool changed;
+  do
+    {
+      changed = false;
+      for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;
+	   gfc_current_ns = gfc_current_ns->sibling)
+	{
+	  if (gfc_fix_implicit_pure (gfc_current_ns))
+	    changed = true;
+	}
+    }
+  while (changed);
+
   /* Do the parse tree dump.  */
   gfc_current_ns = flag_dump_fortran_original ? gfc_global_ns_list : NULL;
 
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index ff93698f478..cbd84bb0abc 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -1151,6 +1151,61 @@ got_delim:
   if (match_substring (NULL, 0, &e->ref, false) != MATCH_NO)
     e->expr_type = EXPR_SUBSTRING;
 
+  /* Substrings with constant starting and ending points are eligible as
+     designators (F2018, section 9.1).  Simplify substrings to make them usable
+     e.g. in data statements.  */
+  if (e->expr_type == EXPR_SUBSTRING
+      && e->ref && e->ref->type == REF_SUBSTRING
+      && e->ref->u.ss.start->expr_type == EXPR_CONSTANT
+      && (e->ref->u.ss.end == NULL
+	  || e->ref->u.ss.end->expr_type == EXPR_CONSTANT))
+    {
+      gfc_expr *res;
+      ptrdiff_t istart, iend;
+      size_t length;
+      bool equal_length = false;
+
+      /* Basic checks on substring starting and ending indices.  */
+      if (!gfc_resolve_substring (e->ref, &equal_length))
+	return MATCH_ERROR;
+
+      length = e->value.character.length;
+      istart = gfc_mpz_get_hwi (e->ref->u.ss.start->value.integer);
+      if (e->ref->u.ss.end == NULL)
+	iend = length;
+      else
+	iend = gfc_mpz_get_hwi (e->ref->u.ss.end->value.integer);
+
+      if (istart <= iend)
+	{
+	  if (istart < 1)
+	    {
+	      gfc_error ("Substring start index (%ld) at %L below 1",
+			 (long) istart, &e->ref->u.ss.start->where);
+	      return MATCH_ERROR;
+	    }
+	  if (iend > (ssize_t) length)
+	    {
+	      gfc_error ("Substring end index (%ld) at %L exceeds string "
+			 "length", (long) iend, &e->ref->u.ss.end->where);
+	      return MATCH_ERROR;
+	    }
+	  length = iend - istart + 1;
+	}
+      else
+	length = 0;
+
+      res = gfc_get_constant_expr (BT_CHARACTER, e->ts.kind, &e->where);
+      res->value.character.string = gfc_get_wide_string (length + 1);
+      res->value.character.length = length;
+      if (length > 0)
+	memcpy (res->value.character.string,
+		&e->value.character.string[istart - 1],
+		length * sizeof (gfc_char_t));
+      res->value.character.string[length] = '\0';
+      e = res;
+    }
+
   *result = e;
 
   return MATCH_YES;
@@ -1984,7 +2039,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
   gfc_ref *substring, *tail, *tmp;
-  gfc_component *component;
+  gfc_component *component = NULL;
+  gfc_component *previous = NULL;
   gfc_symbol *sym = primary->symtree->n.sym;
   gfc_expr *tgt_expr = NULL;
   match m;
@@ -2206,6 +2262,27 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	    {
 	      if (tmp)
 		{
+		  switch (tmp->u.i)
+		    {
+		    case INQUIRY_RE:
+		    case INQUIRY_IM:
+		      if (!gfc_notify_std (GFC_STD_F2008,
+					   "RE or IM part_ref at %C"))
+			return MATCH_ERROR;
+		      break;
+
+		    case INQUIRY_KIND:
+		      if (!gfc_notify_std (GFC_STD_F2003,
+					   "KIND part_ref at %C"))
+			return MATCH_ERROR;
+		      break;
+
+		    case INQUIRY_LEN:
+		      if (!gfc_notify_std (GFC_STD_F2003, "LEN part_ref at %C"))
+			return MATCH_ERROR;
+		      break;
+		    }
+
 		  if ((tmp->u.i == INQUIRY_RE || tmp->u.i == INQUIRY_IM)
 		      && primary->ts.type != BT_COMPLEX)
 		    {
@@ -2283,15 +2360,23 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	  break;
 	}
 
+      previous = component;
+
       if (!inquiry && !intrinsic)
 	component = gfc_find_component (sym, name, false, false, &tmp);
       else
 	component = NULL;
 
-      /* In some cases, returning MATCH_NO gives a better error message. Most
-	 cases return "Unclassifiable statement at..."  */
       if (intrinsic && !inquiry)
-	return MATCH_NO;
+	{
+	  if (previous)
+	    gfc_error ("%qs at %C is not an inquiry reference to an intrinsic "
+			"type component %qs", name, previous->name);
+	  else
+	    gfc_error ("%qs at %C is not an inquiry reference to an intrinsic "
+			"type component", name);
+	  return MATCH_ERROR;
+	}
       else if (component == NULL && !inquiry)
 	return MATCH_ERROR;
 
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index a4ad26efffc..1c72e0db9ea 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1754,9 +1754,11 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)
   gfc_intrinsic_sym* isym = NULL;
   const char* symstd;
 
-  if (sym->formal)
+  if (sym->resolve_symbol_called >= 2)
     return true;
 
+  sym->resolve_symbol_called = 2;
+
   /* Already resolved.  */
   if (sym->from_intmod && sym->ts.type != BT_UNKNOWN)
     return true;
@@ -4908,8 +4910,8 @@ resolve_array_ref (gfc_array_ref *ar)
 }
 
 
-static bool
-resolve_substring (gfc_ref *ref, bool *equal_length)
+bool
+gfc_resolve_substring (gfc_ref *ref, bool *equal_length)
 {
   int k = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);
 
@@ -5094,8 +5096,8 @@ gfc_resolve_substring_charlen (gfc_expr *e)
 static bool
 resolve_ref (gfc_expr *expr)
 {
-  int current_part_dimension, n_components, seen_part_dimension;
-  gfc_ref *ref, **prev;
+  int current_part_dimension, n_components, seen_part_dimension, dim;
+  gfc_ref *ref, **prev, *array_ref;
   bool equal_length;
 
   for (ref = expr->ref; ref; ref = ref->next)
@@ -5120,7 +5122,7 @@ resolve_ref (gfc_expr *expr)
 
       case REF_SUBSTRING:
 	equal_length = false;
-	if (!resolve_substring (*prev, &equal_length))
+	if (!gfc_resolve_substring (*prev, &equal_length))
 	  return false;
 
 	if (expr->expr_type != EXPR_SUBSTRING && equal_length)
@@ -5141,12 +5143,14 @@ resolve_ref (gfc_expr *expr)
   current_part_dimension = 0;
   seen_part_dimension = 0;
   n_components = 0;
+  array_ref = NULL;
 
   for (ref = expr->ref; ref; ref = ref->next)
     {
       switch (ref->type)
 	{
 	case REF_ARRAY:
+	  array_ref = ref;
 	  switch (ref->u.ar.type)
 	    {
 	    case AR_FULL:
@@ -5162,6 +5166,7 @@ resolve_ref (gfc_expr *expr)
 	      break;
 
 	    case AR_ELEMENT:
+	      array_ref = NULL;
 	      current_part_dimension = 0;
 	      break;
 
@@ -5201,7 +5206,33 @@ resolve_ref (gfc_expr *expr)
 	  break;
 
 	case REF_SUBSTRING:
+	  break;
+
 	case REF_INQUIRY:
+	  /* Implement requirement in note 9.7 of F2018 that the result of the
+	     LEN inquiry be a scalar.  */
+	  if (ref->u.i == INQUIRY_LEN && array_ref)
+	    {
+	      array_ref->u.ar.type = AR_ELEMENT;
+	      expr->rank = 0;
+	      /* INQUIRY_LEN is not evaluated from the the rest of the expr
+		 but directly from the string length. This means that setting
+		 the array indices to one does not matter but might trigger
+		 a runtime bounds error. Suppress the check.  */
+	      expr->no_bounds_check = 1;
+	      for (dim = 0; dim < array_ref->u.ar.dimen; dim++)
+		{
+		  array_ref->u.ar.dimen_type[dim] = DIMEN_ELEMENT;
+		  if (array_ref->u.ar.start[dim])
+		    gfc_free_expr (array_ref->u.ar.start[dim]);
+		  array_ref->u.ar.start[dim]
+			= gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);
+		  if (array_ref->u.ar.end[dim])
+		    gfc_free_expr (array_ref->u.ar.end[dim]);
+		  if (array_ref->u.ar.stride[dim])
+		    gfc_free_expr (array_ref->u.ar.stride[dim]);
+		}
+	    }
 	  break;
 	}
 
@@ -8870,7 +8901,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)
 	  as = NULL;
 	  sym->ts = *ts;
 	  sym->ts.type = BT_CLASS;
-	  attr = CLASS_DATA (sym)->attr;
+	  attr = CLASS_DATA (sym) ? CLASS_DATA (sym)->attr : sym->attr;
 	  attr.class_ok = 0;
 	  attr.associate_var = 1;
 	  attr.dimension = attr.codimension = 0;
@@ -9009,7 +9040,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)
   gfc_code *class_is = NULL, *default_case = NULL;
   gfc_case *c;
   gfc_symtree *st;
-  char name[GFC_MAX_SYMBOL_LEN];
+  char name[GFC_MAX_SYMBOL_LEN + 12 + 1];
   gfc_namespace *ns;
   int error = 0;
   int rank = 0;
@@ -10648,7 +10679,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)
 
   /* Make sure there is a vtable and, in particular, a _copy for the
      rhs type.  */
-  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)
+  if (lhs->ts.type == BT_CLASS && rhs->ts.type != BT_CLASS)
     gfc_find_vtab (&rhs->ts);
 
   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB
@@ -11449,10 +11480,18 @@ start:
 	case EXEC_GOTO:
 	  if (code->expr1 != NULL)
 	    {
-	      if (code->expr1->ts.type != BT_INTEGER)
-		gfc_error ("ASSIGNED GOTO statement at %L requires an "
-			   "INTEGER variable", &code->expr1->where);
-	      else if (code->expr1->symtree->n.sym->attr.assign != 1)
+	      if (code->expr1->expr_type != EXPR_VARIABLE
+		  || code->expr1->ts.type != BT_INTEGER
+		  || (code->expr1->ref
+		      && code->expr1->ref->type == REF_ARRAY)
+		  || code->expr1->symtree == NULL
+		  || (code->expr1->symtree->n.sym
+		      && (code->expr1->symtree->n.sym->attr.flavor
+			  == FL_PARAMETER)))
+		gfc_error ("ASSIGNED GOTO statement at %L requires a "
+			   "scalar INTEGER variable", &code->expr1->where);
+	      else if (code->expr1->symtree->n.sym
+		       && code->expr1->symtree->n.sym->attr.assign != 1)
 		gfc_error ("Variable %qs has not been assigned a target "
 			   "label at %L", code->expr1->symtree->n.sym->name,
 			   &code->expr1->where);
@@ -11476,6 +11515,9 @@ start:
 	  if (!t)
 	    break;
 
+	  if (code->expr1->ts.type == BT_CLASS)
+	   gfc_find_vtab (&code->expr2->ts);
+
 	  /* Remove a GFC_ISYM_CAF_GET inserted for a coindexed variable on
 	     the LHS.  */
 	  if (code->expr1->expr_type == EXPR_FUNCTION
@@ -12000,7 +12042,8 @@ resolve_charlen (gfc_charlen *cl)
 	}
 
       /* cl->length has been resolved.  It should have an integer type.  */
-      if (cl->length->ts.type != BT_INTEGER)
+      if (cl->length
+	  && (cl->length->ts.type != BT_INTEGER || cl->length->rank != 0))
 	{
 	  gfc_error ("Scalar INTEGER expression expected at %L",
 		     &cl->length->where);
@@ -12593,6 +12636,7 @@ static bool
 resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 {
   gfc_formal_arglist *arg;
+  bool allocatable_or_pointer;
 
   if (sym->attr.function
       && !resolve_fl_var_and_proc (sym, mp_flag))
@@ -12629,6 +12673,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 	{
 	  if (arg->sym
 	      && arg->sym->ts.type == BT_DERIVED
+	      && arg->sym->ts.u.derived
 	      && !arg->sym->ts.u.derived->attr.use_assoc
 	      && !gfc_check_symbol_access (arg->sym->ts.u.derived)
 	      && !gfc_notify_std (GFC_STD_F2003, "%qs is of a PRIVATE type "
@@ -12755,8 +12800,10 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
     {
       if (sym->attr.proc_pointer)
 	{
+	  const char* name = (sym->attr.result ? sym->ns->proc_name->name
+					       : sym->name);
 	  gfc_error ("Procedure pointer %qs at %L shall not be elemental",
-		     sym->name, &sym->declared_at);
+		     name, &sym->declared_at);
 	  return false;
 	}
       if (sym->attr.dummy)
@@ -12770,8 +12817,16 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
   /* F2018, C15100: "The result of an elemental function shall be scalar,
      and shall not have the POINTER or ALLOCATABLE attribute."  The scalar
      pointer is tested and caught elsewhere.  */
+  if (sym->result)
+    allocatable_or_pointer = sym->result->ts.type == BT_CLASS
+			     && CLASS_DATA (sym->result) ?
+			     (CLASS_DATA (sym->result)->attr.allocatable
+			      || CLASS_DATA (sym->result)->attr.pointer) :
+			     (sym->result->attr.allocatable
+			      || sym->result->attr.pointer);
+
   if (sym->attr.elemental && sym->result
-      && (sym->result->attr.allocatable || sym->result->attr.pointer))
+      && allocatable_or_pointer)
     {
       gfc_error ("Function result variable %qs at %L of elemental "
 		 "function %qs shall not have an ALLOCATABLE or POINTER "
@@ -12843,7 +12898,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
       if (sym->attr.subroutine && sym->attr.result)
 	{
 	  gfc_error ("PROCEDURE attribute conflicts with RESULT attribute "
-		     "in %qs at %L", sym->name, &sym->declared_at);
+		     "in %qs at %L", sym->ns->proc_name->name, &sym->declared_at);
 	  return false;
 	}
       if (sym->attr.external && sym->attr.function && !sym->attr.module_procedure
@@ -13541,7 +13596,7 @@ resolve_typebound_procedure (gfc_symtree* stree)
     {
       /* If proc has not been resolved at this point, proc->name may
 	 actually be a USE associated entity. See PR fortran/89647. */
-      if (!proc->resolved
+      if (!proc->resolve_symbol_called
 	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
 	{
 	  gfc_symbol *tmp;
@@ -13929,7 +13984,7 @@ resolve_component (gfc_component *c, gfc_symbol *sym)
   /* F2008, C448.  */
   if (c->ts.type == BT_CLASS)
     {
-      if (CLASS_DATA (c))
+      if (c->attr.class_ok && CLASS_DATA (c))
 	{
 	  attr = &(CLASS_DATA (c)->attr);
 
@@ -14791,9 +14846,9 @@ resolve_symbol (gfc_symbol *sym)
   gfc_array_spec *as;
   bool saved_specification_expr;
 
-  if (sym->resolved)
+  if (sym->resolve_symbol_called >= 1)
     return;
-  sym->resolved = 1;
+  sym->resolve_symbol_called = 1;
 
   /* No symbol will ever have union type; only components can be unions.
      Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION
@@ -14805,6 +14860,7 @@ resolve_symbol (gfc_symbol *sym)
   if (flag_coarray == GFC_FCOARRAY_LIB && sym->ts.type == BT_CLASS
       && sym->ts.u.derived && CLASS_DATA (sym)
       && CLASS_DATA (sym)->attr.codimension
+      && CLASS_DATA (sym)->ts.u.derived
       && (CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp
 	  || CLASS_DATA (sym)->ts.u.derived->attr.pointer_comp))
     {
@@ -15534,7 +15590,7 @@ resolve_symbol (gfc_symbol *sym)
       if (formal)
 	{
 	  sym->formal_ns = formal->sym->ns;
-          if (sym->ns != formal->sym->ns)
+	  if (sym->formal_ns && sym->ns != formal->sym->ns)
 	    sym->formal_ns->refs++;
 	}
     }
@@ -16042,6 +16098,7 @@ gfc_impure_variable (gfc_symbol *sym)
 
   proc = sym->ns->proc_name;
   if (sym->attr.dummy
+      && !sym->attr.value
       && ((proc->attr.subroutine && sym->attr.intent == INTENT_IN)
 	  || proc->attr.function))
     return 1;
@@ -16510,7 +16567,8 @@ resolve_equivalence (gfc_equiv *eq)
 	  && !gfc_notify_std (GFC_STD_GNU, msg, sym->name, &e->where))
 		continue;
 
-  identical_types:
+identical_types:
+
       last_ts =&sym->ts;
       last_where = &e->where;
 
@@ -16518,8 +16576,7 @@ resolve_equivalence (gfc_equiv *eq)
 	continue;
 
       /* Shall not be an automatic array.  */
-      if (e->ref->type == REF_ARRAY
-	  && !gfc_resolve_array_spec (e->ref->u.ar.as, 1))
+      if (e->ref->type == REF_ARRAY && is_non_constant_shape_array (sym))
 	{
 	  gfc_error ("Array %qs at %L with non-constant bounds cannot be "
 		     "an EQUIVALENCE object", sym->name, &e->where);
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 2b4581e1236..2004895fbe3 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -8008,8 +8008,8 @@ gfc_simplify_transpose (gfc_expr *matrix)
 			       &matrix->where);
   result->rank = 2;
   result->shape = gfc_get_shape (result->rank);
-  mpz_set (result->shape[0], matrix->shape[1]);
-  mpz_set (result->shape[1], matrix->shape[0]);
+  mpz_init_set (result->shape[0], matrix->shape[1]);
+  mpz_init_set (result->shape[1], matrix->shape[0]);
 
   if (matrix->ts.type == BT_CHARACTER)
     result->ts.u.cl = matrix->ts.u.cl;
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index faaeebf2c09..1c45330dca2 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -2004,9 +2004,12 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)
 	gfc_error ("Symbol %qs at %L conflicts with symbol from module %qs, "
 		   "use-associated at %L", sym->name, where, sym->module,
 		   &sym->declared_at);
+      else if (sym->attr.function && sym->attr.result)
+	gfc_error ("Symbol %qs at %L already has basic type of %s",
+		   sym->ns->proc_name->name, where, gfc_basic_typename (type));
       else
 	gfc_error ("Symbol %qs at %L already has basic type of %s", sym->name,
-		 where, gfc_basic_typename (type));
+		   where, gfc_basic_typename (type));
       return false;
     }
 
@@ -2024,7 +2027,9 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)
       || (flavor == FL_PROCEDURE && sym->attr.subroutine)
       || flavor == FL_DERIVED || flavor == FL_NAMELIST)
     {
-      gfc_error ("Symbol %qs at %L cannot have a type", sym->name, where);
+      gfc_error ("Symbol %qs at %L cannot have a type",
+		 sym->ns->proc_name ? sym->ns->proc_name->name : sym->name,
+		 where);
       return false;
     }
 
@@ -4030,6 +4035,7 @@ gfc_free_namespace (gfc_namespace *ns)
 {
   gfc_namespace *p, *q;
   int i;
+  gfc_was_finalized *f;
 
   if (ns == NULL)
     return;
@@ -4062,6 +4068,17 @@ gfc_free_namespace (gfc_namespace *ns)
     gfc_free_interface (ns->op[i]);
 
   gfc_free_data (ns->data);
+
+  /* Free all the expr + component combinations that have been
+     finalized.  */
+  f = ns->was_finalized;
+  while (f)
+    {
+      gfc_was_finalized* current = f;
+      f = f->next;
+      free (current);
+    }
+
   p = ns->contained;
   free (ns);
 
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 2e5eb4f468f..c6efe95e236 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -1099,7 +1099,6 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,
 	      gcc_assert (TREE_CODE (tmp) == POINTER_TYPE);
 	      tmp = TREE_TYPE (tmp); /* The descriptor itself.  */
 	      tmp = gfc_get_element_type (tmp);
-	      gcc_assert (tmp == gfc_get_element_type (TREE_TYPE (desc)));
 	      packed = gfc_create_var (build_pointer_type (tmp), "data");
 
 	      tmp = build_call_expr_loc (input_location,
@@ -1208,6 +1207,126 @@ get_array_ref_dim_for_loop_dim (gfc_ss *ss, int loop_dim)
 }
 
 
+/* Use the information in the ss to obtain the required information about
+   the type and size of an array temporary, when the lhs in an assignment
+   is a class expression.  */
+
+static tree
+get_class_info_from_ss (stmtblock_t * pre, gfc_ss *ss, tree *eltype)
+{
+  gfc_ss *lhs_ss;
+  gfc_ss *rhs_ss;
+  tree tmp;
+  tree tmp2;
+  tree vptr;
+  tree rhs_class_expr = NULL_TREE;
+  tree lhs_class_expr = NULL_TREE;
+  bool unlimited_rhs = false;
+  bool unlimited_lhs = false;
+  bool rhs_function = false;
+  gfc_symbol *vtab;
+
+  /* The second element in the loop chain contains the source for the
+     temporary; ie. the rhs of the assignment.  */
+  rhs_ss = ss->loop->ss->loop_chain;
+
+  if (rhs_ss != gfc_ss_terminator
+      && rhs_ss->info
+      && rhs_ss->info->expr
+      && rhs_ss->info->expr->ts.type == BT_CLASS
+      && rhs_ss->info->data.array.descriptor)
+    {
+      if (rhs_ss->info->expr->expr_type != EXPR_VARIABLE)
+	rhs_class_expr
+	  = gfc_get_class_from_expr (rhs_ss->info->data.array.descriptor);
+      else
+	rhs_class_expr = gfc_get_class_from_gfc_expr (rhs_ss->info->expr);
+      unlimited_rhs = UNLIMITED_POLY (rhs_ss->info->expr);
+      if (rhs_ss->info->expr->expr_type == EXPR_FUNCTION)
+	rhs_function = true;
+    }
+
+  /* For an assignment the lhs is the next element in the loop chain.
+     If we have a class rhs, this had better be a class variable
+     expression!  */
+  lhs_ss = rhs_ss->loop_chain;
+  if (lhs_ss != gfc_ss_terminator
+      && lhs_ss->info
+      && lhs_ss->info->expr
+      && lhs_ss->info->expr->expr_type ==EXPR_VARIABLE
+      && lhs_ss->info->expr->ts.type == BT_CLASS)
+    {
+      tmp = lhs_ss->info->data.array.descriptor;
+      unlimited_lhs = UNLIMITED_POLY (rhs_ss->info->expr);
+    }
+  else
+    tmp = NULL_TREE;
+
+  /* Get the lhs class expression.  */
+  if (tmp != NULL_TREE && lhs_ss->loop_chain == gfc_ss_terminator)
+    lhs_class_expr = gfc_get_class_from_expr (tmp);
+  else
+    return rhs_class_expr;
+
+  gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (lhs_class_expr)));
+
+  /* Set the lhs vptr and, if necessary, the _len field.  */
+  if (rhs_class_expr)
+    {
+      /* Both lhs and rhs are class expressions.  */
+      tmp = gfc_class_vptr_get (lhs_class_expr);
+      gfc_add_modify (pre, tmp,
+		      fold_convert (TREE_TYPE (tmp),
+				    gfc_class_vptr_get (rhs_class_expr)));
+      if (unlimited_lhs)
+	{
+	  tmp = gfc_class_len_get (lhs_class_expr);
+	  if (unlimited_rhs)
+	    tmp2 = gfc_class_len_get (rhs_class_expr);
+	  else
+	    tmp2 = build_int_cst (TREE_TYPE (tmp), 0);
+	  gfc_add_modify (pre, tmp, tmp2);
+	}
+
+      if (rhs_function)
+	{
+	  tmp = gfc_class_data_get (rhs_class_expr);
+	  gfc_conv_descriptor_offset_set (pre, tmp, gfc_index_zero_node);
+	}
+    }
+  else
+   {
+      /* lhs is class and rhs is intrinsic or derived type.  */
+      *eltype = TREE_TYPE (rhs_ss->info->data.array.descriptor);
+      *eltype = gfc_get_element_type (*eltype);
+      vtab = gfc_find_vtab (&rhs_ss->info->expr->ts);
+      vptr = vtab->backend_decl;
+      if (vptr == NULL_TREE)
+	vptr = gfc_get_symbol_decl (vtab);
+      vptr = gfc_build_addr_expr (NULL_TREE, vptr);
+      tmp = gfc_class_vptr_get (lhs_class_expr);
+      gfc_add_modify (pre, tmp,
+		      fold_convert (TREE_TYPE (tmp), vptr));
+
+      if (unlimited_lhs)
+	{
+	  tmp = gfc_class_len_get (lhs_class_expr);
+	  if (rhs_ss->info
+	      && rhs_ss->info->expr
+	      && rhs_ss->info->expr->ts.type == BT_CHARACTER)
+	    tmp2 = build_int_cst (TREE_TYPE (tmp),
+				  rhs_ss->info->expr->ts.kind);
+	  else
+	    tmp2 = build_int_cst (TREE_TYPE (tmp), 0);
+	  gfc_add_modify (pre, tmp, tmp2);
+	}
+    }
+
+  return rhs_class_expr;
+}
+
+
+
 /* Generate code to create and initialize the descriptor for a temporary
    array.  This is used for both temporaries needed by the scalarizer, and
    functions returning arrays.  Adjusts the loop variables to be
@@ -1253,13 +1372,46 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,
     {
       gcc_assert (POINTER_TYPE_P (TREE_TYPE (initial)));
       class_expr = build_fold_indirect_ref_loc (input_location, initial);
-      eltype = TREE_TYPE (class_expr);
-      eltype = gfc_get_element_type (eltype);
       /* Obtain the structure (class) expression.  */
-      class_expr = TREE_OPERAND (class_expr, 0);
+      class_expr = gfc_get_class_from_expr (class_expr);
       gcc_assert (class_expr);
     }
 
+  /* Otherwise, some expressions, such as class functions, arising from
+     dependency checking in assignments come here with class element type.
+     The descriptor can be obtained from the ss->info and then converted
+     to the class object.  */
+  if (class_expr == NULL_TREE && GFC_CLASS_TYPE_P (eltype))
+    class_expr = get_class_info_from_ss (pre, ss, &eltype);
+
+  /* If the dynamic type is not available, use the declared type.  */
+  if (eltype && GFC_CLASS_TYPE_P (eltype))
+    eltype = gfc_get_element_type (TREE_TYPE (TYPE_FIELDS (eltype)));
+
+  if (class_expr == NULL_TREE)
+    elemsize = fold_convert (gfc_array_index_type,
+			     TYPE_SIZE_UNIT (eltype));
+  else
+    {
+      /* Unlimited polymorphic entities are initialised with NULL vptr. They
+	 can be tested for by checking if the len field is present. If so
+	 test the vptr before using the vtable size.  */
+      tmp = gfc_class_vptr_get (class_expr);
+      tmp = fold_build2_loc (input_location, NE_EXPR,
+			     logical_type_node,
+			     tmp, build_int_cst (TREE_TYPE (tmp), 0));
+      elemsize = fold_build3_loc (input_location, COND_EXPR,
+				  gfc_array_index_type,
+				  tmp,
+				  gfc_class_vtab_size_get (class_expr),
+				  gfc_index_zero_node);
+      elemsize = gfc_evaluate_now (elemsize, pre);
+      elemsize = gfc_resize_class_size_with_len (pre, class_expr, elemsize);
+      /* Casting the data as a character of the dynamic length ensures that
+	 assignment of elements works when needed.  */
+      eltype = gfc_get_character_type_len (1, elemsize);
+    }
+
   memset (from, 0, sizeof (from));
   memset (to, 0, sizeof (to));
 
@@ -1408,12 +1560,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,
 	}
     }
 
-  if (class_expr == NULL_TREE)
-    elemsize = fold_convert (gfc_array_index_type,
-			     TYPE_SIZE_UNIT (gfc_get_element_type (type)));
-  else
-    elemsize = gfc_class_vtab_size_get (class_expr);
-
   /* Get the size of the array.  */
   if (size && !callee_alloc)
     {
@@ -2125,6 +2271,7 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)
   gfc_ref *ref;
   gfc_typespec *ts;
   mpz_t char_len;
+  gfc_se se;
 
   /* Don't bother if we already know the length is a constant.  */
   if (*len && INTEGER_CST_P (*len))
@@ -2170,6 +2317,19 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)
 	}
     }
 
+  /* A last ditch attempt that is sometimes needed for deferred characters.  */
+  if (!ts->u.cl->backend_decl)
+    {
+      gfc_init_se (&se, NULL);
+      if (expr->rank)
+	gfc_conv_expr_descriptor (&se, expr);
+      else
+	gfc_conv_expr (&se, expr);
+      gcc_assert (se.string_length != NULL_TREE);
+      gfc_add_block_to_block (block, &se.pre);
+      ts->u.cl->backend_decl = se.string_length;
+    }
+
   *len = ts->u.cl->backend_decl;
 }
 
@@ -2979,13 +3139,16 @@ gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)
 	}
       /* Also the data pointer.  */
       tmp = gfc_conv_array_data (se.expr);
-      /* If this is a variable or address of a variable we use it directly.
+      /* If this is a variable or address or a class array, use it directly.
          Otherwise we must evaluate it now to avoid breaking dependency
 	 analysis by pulling the expressions for elemental array indices
 	 inside the loop.  */
       if (!(DECL_P (tmp)
 	    || (TREE_CODE (tmp) == ADDR_EXPR
-		&& DECL_P (TREE_OPERAND (tmp, 0)))))
+		&& DECL_P (TREE_OPERAND (tmp, 0)))
+	    || (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr))
+		&& TREE_CODE (se.expr) == COMPONENT_REF
+		&& GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (se.expr, 0))))))
 	tmp = gfc_evaluate_now (tmp, block);
       info->data = tmp;
 
@@ -3442,18 +3605,10 @@ build_class_array_ref (gfc_se *se, tree base, tree index)
   size = gfc_class_vtab_size_get (decl);
 
   /* For unlimited polymorphic entities then _len component needs to be
-     multiplied with the size.  If no _len component is present, then
-     gfc_class_len_or_zero_get () return a zero_node.  */
-  tmp = gfc_class_len_or_zero_get (decl);
-  if (!integer_zerop (tmp))
-    size = fold_build2 (MULT_EXPR, TREE_TYPE (index),
-			fold_convert (TREE_TYPE (index), size),
-			fold_build2 (MAX_EXPR, TREE_TYPE (index),
-				     fold_convert (TREE_TYPE (index), tmp),
-				     fold_convert (TREE_TYPE (index),
-						   integer_one_node)));
-  else
-    size = fold_convert (TREE_TYPE (index), size);
+     multiplied with the size.  */
+  size = gfc_resize_class_size_with_len (&se->pre, decl, size);
+
+  size = fold_convert (TREE_TYPE (index), size);
 
   /* Build the address of the element.  */
   type = TREE_TYPE (TREE_TYPE (base));
@@ -6945,6 +7100,24 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,
 	      tmp = gfc_build_array_ref (tmp, index, NULL);
 	      break;
 
+	    case REF_INQUIRY:
+	      switch (ref->u.i)
+		{
+		case INQUIRY_RE:
+		  tmp = fold_build1_loc (input_location, REALPART_EXPR,
+					 TREE_TYPE (TREE_TYPE (tmp)), tmp);
+		  break;
+
+		case INQUIRY_IM:
+		  tmp = fold_build1_loc (input_location, IMAGPART_EXPR,
+					 TREE_TYPE (TREE_TYPE (tmp)), tmp);
+		  break;
+
+		default:
+		  break;
+		}
+	      break;
+
 	    default:
 	      gcc_unreachable ();
 	      break;
@@ -6991,7 +7164,12 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)
       e = gfc_constructor_first (expr->value.constructor)->expr;
 
       gfc_init_se (&tse, NULL);
+
+      /* Avoid evaluating trailing array references since all we need is
+	 the string length.  */
       if (e->rank)
+	tse.descriptor_only = 1;
+      if (e->rank && e->expr_type != EXPR_VARIABLE)
 	gfc_conv_expr_descriptor (&tse, e);
       else
 	gfc_conv_expr (&tse, e);
@@ -7009,14 +7187,26 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)
       gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,
 		      tse.string_length);
 
+      /* Make sure that deferred length components point to the hidden
+	 string_length component.  */
+      if (TREE_CODE (tse.expr) == COMPONENT_REF
+	  && TREE_CODE (tse.string_length) == COMPONENT_REF
+	  && TREE_OPERAND (tse.expr, 0) == TREE_OPERAND (tse.string_length, 0))
+	e->ts.u.cl->backend_decl = expr->ts.u.cl->backend_decl;
+
       return;
 
     case EXPR_OP:
       get_array_charlen (expr->value.op.op1, se);
 
-      /* For parentheses the expression ts.u.cl is identical.  */
+      /* For parentheses the expression ts.u.cl should be identical.  */
       if (expr->value.op.op == INTRINSIC_PARENTHESES)
-	return;
+	{
+	  if (expr->value.op.op1->ts.u.cl != expr->ts.u.cl)
+	    expr->ts.u.cl->backend_decl
+			= expr->value.op.op1->ts.u.cl->backend_decl;
+	  return;
+	}
 
       expr->ts.u.cl->backend_decl =
 		gfc_create_var (gfc_charlen_type_node, "sln");
@@ -9137,21 +9327,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,
 		 for the malloc call.  */
 	      if (UNLIMITED_POLY (c))
 		{
-		  tree ctmp;
 		  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),
 				  gfc_class_len_get (comp));
-
-		  size = gfc_evaluate_now (size, &tmpblock);
-		  tmp = gfc_class_len_get (comp);
-		  ctmp = fold_build2_loc (input_location, MULT_EXPR,
-					  size_type_node, size,
-					  fold_convert (size_type_node, tmp));
-		  tmp = fold_build2_loc (input_location, GT_EXPR,
-					 logical_type_node, tmp,
-					 build_zero_cst (TREE_TYPE (tmp)));
-		  size = fold_build3_loc (input_location, COND_EXPR,
-					  size_type_node, tmp, ctmp, size);
-		  size = gfc_evaluate_now (size, &tmpblock);
+		  size = gfc_resize_class_size_with_len (&tmpblock, comp, size);
 		}
 
 	      /* Coarray component have to have the same allocation status and
@@ -9890,6 +10068,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   tree alloc_expr;
   tree size1;
   tree size2;
+  tree elemsize1;
+  tree elemsize2;
   tree array1;
   tree cond_null;
   tree cond;
@@ -9905,6 +10085,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   tree jump_label2;
   tree neq_size;
   tree lbd;
+  tree class_expr2 = NULL_TREE;
   int n;
   int dim;
   gfc_array_spec * as;
@@ -9969,6 +10150,114 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));
   array1 = gfc_conv_descriptor_data_get (desc);
 
+  if (expr2)
+    desc2 = rss->info->data.array.descriptor;
+  else
+    desc2 = NULL_TREE;
+
+  /* Get the old lhs element size for deferred character and class expr1.  */
+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
+    {
+      if (expr1->ts.u.cl->backend_decl
+	  && VAR_P (expr1->ts.u.cl->backend_decl))
+	elemsize1 = expr1->ts.u.cl->backend_decl;
+      else
+	elemsize1 = lss->info->string_length;
+    }
+  else if (expr1->ts.type == BT_CLASS)
+    {
+      tmp = expr1->rank ? gfc_get_class_from_expr (desc) : NULL_TREE;
+      if (tmp == NULL_TREE)
+	tmp = gfc_get_class_from_gfc_expr (expr1);
+
+      if (tmp != NULL_TREE)
+	{
+	  tmp2 = gfc_class_vptr_get (tmp);
+	  cond = fold_build2_loc (input_location, NE_EXPR,
+				  logical_type_node, tmp2,
+				  build_int_cst (TREE_TYPE (tmp2), 0));
+	  elemsize1 = gfc_class_vtab_size_get (tmp);
+	  elemsize1 = fold_build3_loc (input_location, COND_EXPR,
+				      gfc_array_index_type, cond,
+				      elemsize1, gfc_index_zero_node);
+	}
+      else
+	elemsize1 = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&CLASS_DATA (expr1)->ts));
+    }
+  else
+    elemsize1 = NULL_TREE;
+  if (elemsize1 != NULL_TREE)
+    elemsize1 = gfc_evaluate_now (elemsize1, &fblock);
+
+  /* Get the new lhs size in bytes.  */
+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
+    {
+      if (expr2->ts.deferred)
+	{
+	  if (expr2->ts.u.cl->backend_decl
+	      && VAR_P (expr2->ts.u.cl->backend_decl))
+	    tmp = expr2->ts.u.cl->backend_decl;
+	  else
+	    tmp = rss->info->string_length;
+	}
+      else
+	{
+	  tmp = expr2->ts.u.cl->backend_decl;
+	  if (!tmp && expr2->expr_type == EXPR_OP
+	      && expr2->value.op.op == INTRINSIC_CONCAT)
+	    {
+	      tmp = concat_str_length (expr2);
+	      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);
+	    }
+	  else if (!tmp && expr2->ts.u.cl->length)
+	    {
+	      gfc_se tmpse;
+	      gfc_init_se (&tmpse, NULL);
+	      gfc_conv_expr_type (&tmpse, expr2->ts.u.cl->length,
+				  gfc_charlen_type_node);
+	      tmp = tmpse.expr;
+	      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);
+	    }
+	  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);
+	}
+
+      if (expr1->ts.u.cl->backend_decl
+	  && VAR_P (expr1->ts.u.cl->backend_decl))
+	gfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);
+      else
+	gfc_add_modify (&fblock, lss->info->string_length, tmp);
+
+      if (expr1->ts.kind > 1)
+	tmp = fold_build2_loc (input_location, MULT_EXPR,
+			       TREE_TYPE (tmp),
+			       tmp, build_int_cst (TREE_TYPE (tmp),
+						   expr1->ts.kind));
+    }
+  else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)
+    {
+      tmp = TYPE_SIZE_UNIT (TREE_TYPE (gfc_typenode_for_spec (&expr1->ts)));
+      tmp = fold_build2_loc (input_location, MULT_EXPR,
+			     gfc_array_index_type, tmp,
+			     expr1->ts.u.cl->backend_decl);
+    }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
+  else if (expr1->ts.type == BT_CLASS && expr2->ts.type == BT_CLASS)
+    {
+      tmp = expr2->rank ? gfc_get_class_from_expr (desc2) : NULL_TREE;
+      if (tmp == NULL_TREE && expr2->expr_type == EXPR_VARIABLE)
+	tmp = class_expr2 = gfc_get_class_from_gfc_expr (expr2);
+
+      if (tmp != NULL_TREE)
+	tmp = gfc_class_vtab_size_get (tmp);
+      else
+	tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&CLASS_DATA (expr2)->ts));
+    }
+  else
+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
+  elemsize2 = fold_convert (gfc_array_index_type, tmp);
+  elemsize2 = gfc_evaluate_now (elemsize2, &fblock);
+
   /* 7.4.1.3 "If variable is an allocated allocatable variable, it is
      deallocated if expr is an array of different shape or any of the
      corresponding length type parameter values of variable and expr
@@ -9988,6 +10277,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 			     rss->info->string_length);
       cond_null = fold_build2_loc (input_location, TRUTH_OR_EXPR,
 				   logical_type_node, tmp, cond_null);
+      cond_null= gfc_evaluate_now (cond_null, &fblock);
     }
   else
     cond_null= gfc_evaluate_now (cond_null, &fblock);
@@ -10036,6 +10326,19 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
       gfc_add_expr_to_block (&fblock, tmp);
     }
 
+  /* ...else if the element lengths are not the same also go to
+     setting the bounds and doing the reallocation.... */
+  if (elemsize1 != NULL_TREE)
+    {
+      cond = fold_build2_loc (input_location, NE_EXPR,
+			      logical_type_node,
+			      elemsize1, elemsize2);
+      tmp = build3_v (COND_EXPR, cond,
+		      build1_v (GOTO_EXPR, jump_label1),
+		      build_empty_stmt (input_location));
+      gfc_add_expr_to_block (&fblock, tmp);
+    }
+
   /* ....else jump past the (re)alloc code.  */
   tmp = build1_v (GOTO_EXPR, jump_label2);
   gfc_add_expr_to_block (&fblock, tmp);
@@ -10058,11 +10361,6 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   gfc_add_expr_to_block (&fblock, tmp);
 
   /* Get the rhs size and fix it.  */
-  if (expr2)
-    desc2 = rss->info->data.array.descriptor;
-  else
-    desc2 = NULL_TREE;
-
   size2 = gfc_index_one_node;
   for (n = 0; n < expr2->rank; n++)
     {
@@ -10177,69 +10475,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 	gfc_add_modify (&fblock, linfo->delta[dim], tmp);
     }
 
-  /* Get the new lhs size in bytes.  */
-  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
-    {
-      if (expr2->ts.deferred)
-	{
-	  if (expr2->ts.u.cl->backend_decl
-	      && VAR_P (expr2->ts.u.cl->backend_decl))
-	    tmp = expr2->ts.u.cl->backend_decl;
-	  else
-	    tmp = rss->info->string_length;
-	}
-      else
-	{
-	  tmp = expr2->ts.u.cl->backend_decl;
-	  if (!tmp && expr2->expr_type == EXPR_OP
-	      && expr2->value.op.op == INTRINSIC_CONCAT)
-	    {
-	      tmp = concat_str_length (expr2);
-	      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);
-	    }
-	  else if (!tmp && expr2->ts.u.cl->length)
-	    {
-	      gfc_se tmpse;
-	      gfc_init_se (&tmpse, NULL);
-	      gfc_conv_expr_type (&tmpse, expr2->ts.u.cl->length,
-				  gfc_charlen_type_node);
-	      tmp = tmpse.expr;
-	      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);
-	    }
-	  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);
-	}
-
-      if (expr1->ts.u.cl->backend_decl
-	  && VAR_P (expr1->ts.u.cl->backend_decl))
-	gfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);
-      else
-	gfc_add_modify (&fblock, lss->info->string_length, tmp);
-
-      if (expr1->ts.kind > 1)
-	tmp = fold_build2_loc (input_location, MULT_EXPR,
-			       TREE_TYPE (tmp),
-			       tmp, build_int_cst (TREE_TYPE (tmp),
-						   expr1->ts.kind));
-    }
-  else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)
-    {
-      tmp = TYPE_SIZE_UNIT (TREE_TYPE (gfc_typenode_for_spec (&expr1->ts)));
-      tmp = fold_build2_loc (input_location, MULT_EXPR,
-			     gfc_array_index_type, tmp,
-			     expr1->ts.u.cl->backend_decl);
-    }
-  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
-    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
-  else
-    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));
-  tmp = fold_convert (gfc_array_index_type, tmp);
-
   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))
-    gfc_conv_descriptor_span_set (&fblock, desc, tmp);
+    gfc_conv_descriptor_span_set (&fblock, desc, elemsize2);
 
   size2 = fold_build2_loc (input_location, MULT_EXPR,
 			   gfc_array_index_type,
-			   tmp, size2);
+			   elemsize2, size2);
   size2 = fold_convert (size_type_node, size2);
   size2 = fold_build2_loc (input_location, MAX_EXPR, size_type_node,
 			   size2, size_one_node);
@@ -10260,27 +10501,47 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
       gfc_add_modify (&fblock, tmp,
 		      gfc_get_dtype_rank_type (expr1->rank,type));
     }
-  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+  else if (expr1->ts.type == BT_CLASS)
     {
       tree type;
       tmp = gfc_conv_descriptor_dtype (desc);
-      type = gfc_typenode_for_spec (&expr2->ts);
+
+      if (expr2->ts.type != BT_CLASS)
+	type = gfc_typenode_for_spec (&expr2->ts);
+      else
+	type = gfc_get_character_type_len (1, elemsize2);
+
       gfc_add_modify (&fblock, tmp,
 		      gfc_get_dtype_rank_type (expr2->rank,type));
       /* Set the _len field as well...  */
-      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));
-      if (expr2->ts.type == BT_CHARACTER)
-	gfc_add_modify (&fblock, tmp,
-			fold_convert (TREE_TYPE (tmp),
-				      TYPE_SIZE_UNIT (type)));
-      else
-	gfc_add_modify (&fblock, tmp,
-			build_int_cst (TREE_TYPE (tmp), 0));
+      if (UNLIMITED_POLY (expr1))
+	{
+	  tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));
+	  if (expr2->ts.type == BT_CHARACTER)
+	    gfc_add_modify (&fblock, tmp,
+			    fold_convert (TREE_TYPE (tmp),
+					  TYPE_SIZE_UNIT (type)));
+	  else
+	    gfc_add_modify (&fblock, tmp,
+			    build_int_cst (TREE_TYPE (tmp), 0));
+	}
       /* ...and the vptr.  */
       tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));
-      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));
-      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);
-      gfc_add_modify (&fblock, tmp, tmp2);
+      if (expr2->ts.type == BT_CLASS && !VAR_P (desc2)
+	  && TREE_CODE (desc2) == COMPONENT_REF)
+	{
+	  tmp2 = gfc_get_class_from_expr (desc2);
+	  tmp2 = gfc_class_vptr_get (tmp2);
+	}
+      else if (expr2->ts.type == BT_CLASS && class_expr2 != NULL_TREE)
+	tmp2 = gfc_class_vptr_get (class_expr2);
+      else
+	{
+	  tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));
+	  tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);
+	}
+
+      gfc_add_modify (&fblock, tmp, fold_convert (TREE_TYPE (tmp), tmp2));
     }
   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))
     {
@@ -10356,11 +10617,19 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   gfc_add_block_to_block (&realloc_block, &caf_se.post);
   realloc_expr = gfc_finish_block (&realloc_block);
 
-  /* Only reallocate if sizes are different.  */
+  /* Reallocate if sizes or dynamic types are different.  */
+  if (elemsize1)
+    {
+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,
+			     elemsize1, elemsize2);
+      tmp = gfc_evaluate_now (tmp, &fblock);
+      neq_size = fold_build2_loc (input_location, TRUTH_OR_EXPR,
+				  logical_type_node, neq_size, tmp);
+    }
   tmp = build3_v (COND_EXPR, neq_size, realloc_expr,
 		  build_empty_stmt (input_location));
-  realloc_expr = tmp;
 
+  realloc_expr = tmp;
 
   /* Malloc expression.  */
   gfc_init_block (&alloc_block);
@@ -10407,11 +10676,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   alloc_expr = gfc_finish_block (&alloc_block);
 
   /* Malloc if not allocated; realloc otherwise.  */
-  tmp = build_int_cst (TREE_TYPE (array1), 0);
-  cond = fold_build2_loc (input_location, EQ_EXPR,
-			  logical_type_node,
-			  array1, tmp);
-  tmp = build3_v (COND_EXPR, cond, alloc_expr, realloc_expr);
+  tmp = build3_v (COND_EXPR, cond_null, alloc_expr, realloc_expr);
   gfc_add_expr_to_block (&fblock, tmp);
 
   /* Make sure that the scalarizer data pointer is updated.  */
@@ -10421,7 +10686,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
       gfc_add_modify (&fblock, linfo->data, tmp);
     }
 
-  /* Add the exit label.  */
+  /* Add the label for same shape lhs and rhs.  */
   tmp = build1_v (LABEL_EXPR, jump_label2);
   gfc_add_expr_to_block (&fblock, tmp);
 
diff --git a/gcc/fortran/trans-common.c b/gcc/fortran/trans-common.c
index debdbd98ac0..38302f35ef4 100644
--- a/gcc/fortran/trans-common.c
+++ b/gcc/fortran/trans-common.c
@@ -242,8 +242,9 @@ static tree
 gfc_sym_mangled_common_id (gfc_common_head *com)
 {
   int has_underscore;
-  char mangled_name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  /* Provide sufficient space to hold "symbol.eq.1234567890__".  */
+  char mangled_name[GFC_MAX_MANGLED_SYMBOL_LEN + 1 + 16];
+  char name[GFC_MAX_SYMBOL_LEN + 1 + 16];
 
   /* Get the name out of the common block pointer.  */
   strcpy (name, com->name);
@@ -1252,7 +1253,11 @@ finish_equivalences (gfc_namespace *ns)
 	      c->where = ns->proc_name->declared_at;
 	    else if (ns->is_block_data)
 	      c->where = ns->sym_root->n.sym->declared_at;
-	    strcpy (c->name, z->module);
+
+	    size_t len = strlen (z->module);
+	    gcc_assert (len < sizeof (c->name));
+	    memcpy (c->name, z->module, len);
+	    c->name[len] = '\0';
 	  }
 	else
 	  c = NULL;
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 71f751de76f..fb957d187d3 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1658,9 +1658,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 
       TREE_USED (sym->backend_decl) = 1;
       if (sym->attr.assign && GFC_DECL_ASSIGN (sym->backend_decl) == 0)
-	{
-	  gfc_add_assign_aux_vars (sym);
-	}
+	gfc_add_assign_aux_vars (sym);
 
       if (sym->ts.type == BT_CLASS && sym->backend_decl)
 	GFC_DECL_CLASS(sym->backend_decl) = 1;
@@ -1668,6 +1666,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)
      return sym->backend_decl;
     }
 
+  if (sym->result == sym && sym->attr.assign
+      && GFC_DECL_ASSIGN (sym->backend_decl) == 0)
+    gfc_add_assign_aux_vars (sym);
+
   if (sym->backend_decl)
     return sym->backend_decl;
 
@@ -1702,7 +1704,6 @@ gfc_get_symbol_decl (gfc_symbol * sym)
 	  || sym->attr.if_source != IFSRC_DECL)
 	{
 	  decl = gfc_get_extern_function_decl (sym);
-	  gfc_set_decl_location (decl, &sym->declared_at);
 	}
       else
 	{
@@ -2062,12 +2063,17 @@ gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
       if (gsym && !gsym->bind_c)
 	gsym = NULL;
     }
-  else
+  else if (sym->module == NULL)
     {
       gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
       if (gsym && gsym->bind_c)
 	gsym = NULL;
     }
+  else
+    {
+      /* Procedure from a different module.  */
+      gsym = NULL;
+    }
 
   if (gsym && !gsym->defined)
     gsym = NULL;
@@ -2939,8 +2945,9 @@ build_entry_thunks (gfc_namespace * ns, bool global)
       poplevel (1, 1);
       BLOCK_SUPERCONTEXT (DECL_INITIAL (thunk_fndecl)) = thunk_fndecl;
       DECL_SAVED_TREE (thunk_fndecl)
-	= build3_v (BIND_EXPR, tmp, DECL_SAVED_TREE (thunk_fndecl),
-		    DECL_INITIAL (thunk_fndecl));
+	= fold_build3_loc (DECL_SOURCE_LOCATION (thunk_fndecl), BIND_EXPR,
+			   void_type_node, tmp, DECL_SAVED_TREE (thunk_fndecl),
+			   DECL_INITIAL (thunk_fndecl));
 
       /* Output the GENERIC tree.  */
       dump_function (TDI_original, thunk_fndecl);
@@ -3142,6 +3149,9 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)
   else
     current_fake_result_decl = build_tree_list (NULL, decl);
 
+  if (sym->attr.assign)
+    DECL_LANG_SPECIFIC (decl) = DECL_LANG_SPECIFIC (sym->backend_decl);
+
   return decl;
 }
 
@@ -5683,8 +5693,8 @@ generate_coarray_init (gfc_namespace * ns __attribute((unused)))
   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;
 
   DECL_SAVED_TREE (fndecl)
-    = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (fndecl),
-                DECL_INITIAL (fndecl));
+    = fold_build3_loc (DECL_SOURCE_LOCATION (fndecl), BIND_EXPR, void_type_node,
+		       decl, DECL_SAVED_TREE (fndecl), DECL_INITIAL (fndecl));
   dump_function (TDI_original, fndecl);
 
   cfun->function_end_locus = input_location;
@@ -6011,7 +6021,7 @@ generate_local_decl (gfc_symbol * sym)
       /* Unused procedure passed as dummy argument.  */
       if (sym->attr.flavor == FL_PROCEDURE)
 	{
-	  if (!sym->attr.referenced)
+	  if (!sym->attr.referenced && !sym->attr.artificial)
 	    {
 	      if (warn_unused_dummy_argument)
 		gfc_warning (OPT_Wunused_dummy_argument,
@@ -6409,8 +6419,9 @@ create_main_function (tree fndecl)
   BLOCK_SUPERCONTEXT (DECL_INITIAL (ftn_main)) = ftn_main;
 
   DECL_SAVED_TREE (ftn_main)
-    = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (ftn_main),
-		DECL_INITIAL (ftn_main));
+    = fold_build3_loc (DECL_SOURCE_LOCATION (ftn_main), BIND_EXPR,
+		       void_type_node, decl, DECL_SAVED_TREE (ftn_main),
+		       DECL_INITIAL (ftn_main));
 
   /* Output the GENERIC tree.  */
   dump_function (TDI_original, ftn_main);
@@ -6723,7 +6734,7 @@ gfc_generate_function_code (gfc_namespace * ns)
 		 || (sym->attr.entry_master
 		     && sym->ns->entries->sym->attr.recursive);
   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)
-      && !is_recursive && !flag_recursive)
+      && !is_recursive && !flag_recursive && !sym->attr.artificial)
     {
       char * msg;
 
@@ -6901,8 +6912,8 @@ gfc_generate_function_code (gfc_namespace * ns)
   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;
 
   DECL_SAVED_TREE (fndecl)
-    = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (fndecl),
-		DECL_INITIAL (fndecl));
+    = fold_build3_loc (DECL_SOURCE_LOCATION (fndecl), BIND_EXPR, void_type_node,
+		       decl, DECL_SAVED_TREE (fndecl), DECL_INITIAL (fndecl));
 
   /* Output the GENERIC tree.  */
   dump_function (TDI_original, fndecl);
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index fe10d52dd16..e903b438007 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -257,6 +257,42 @@ gfc_class_len_or_zero_get (tree decl)
 }
 
 
+tree
+gfc_resize_class_size_with_len (stmtblock_t * block, tree class_expr, tree size)
+{
+  tree tmp;
+  tree tmp2;
+  tree type;
+
+  tmp = gfc_class_len_or_zero_get (class_expr);
+
+  /* Include the len value in the element size if present.  */
+  if (!integer_zerop (tmp))
+    {
+      type = TREE_TYPE (size);
+      if (block)
+	{
+	  size = gfc_evaluate_now (size, block);
+	  tmp = gfc_evaluate_now (fold_convert (type , tmp), block);
+	}
+      tmp2 = fold_build2_loc (input_location, MULT_EXPR,
+			      type, size, tmp);
+      tmp = fold_build2_loc (input_location, GT_EXPR,
+			     logical_type_node, tmp,
+			     build_zero_cst (type));
+      size = fold_build3_loc (input_location, COND_EXPR,
+			      type, tmp, tmp2, size);
+    }
+  else
+    return size;
+
+  if (block)
+    size = gfc_evaluate_now (size, block);
+
+  return size;
+}
+
+
 /* Get the specified FIELD from the VPTR.  */
 
 static tree
@@ -472,9 +508,63 @@ gfc_reset_len (stmtblock_t *block, gfc_expr *expr)
 }
 
 
-/* Obtain the vptr of the last class reference in an expression.
+/* Obtain the last class reference in a gfc_expr. Return NULL_TREE if no class
+   reference is found. Note that it is up to the caller to avoid using this
+   for expressions other than variables.  */
+
+tree
+gfc_get_class_from_gfc_expr (gfc_expr *e)
+{
+  gfc_expr *class_expr;
+  gfc_se cse;
+  class_expr = gfc_find_and_cut_at_last_class_ref (e);
+  if (class_expr == NULL)
+    return NULL_TREE;
+  gfc_init_se (&cse, NULL);
+  gfc_conv_expr (&cse, class_expr);
+  gfc_free_expr (class_expr);
+  return cse.expr;
+}
+
+
+/* Obtain the last class reference in an expression.
    Return NULL_TREE if no class reference is found.  */
 
+tree
+gfc_get_class_from_expr (tree expr)
+{
+  tree tmp;
+  tree type;
+
+  for (tmp = expr; tmp; tmp = TREE_OPERAND (tmp, 0))
+    {
+      if (CONSTANT_CLASS_P (tmp))
+	return NULL_TREE;
+
+      type = TREE_TYPE (tmp);
+      while (type)
+	{
+	  if (GFC_CLASS_TYPE_P (type))
+	    return tmp;
+	  if (type != TYPE_CANONICAL (type))
+	    type = TYPE_CANONICAL (type);
+	  else
+	    type = NULL_TREE;
+	}
+      if (VAR_P (tmp) || TREE_CODE (tmp) == PARM_DECL)
+	break;
+    }
+
+  if (POINTER_TYPE_P (TREE_TYPE (tmp)))
+    tmp = build_fold_indirect_ref_loc (input_location, tmp);
+
+  if (GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+    return tmp;
+
+  return NULL_TREE;
+}
+
+
 tree
 gfc_get_vptr_from_expr (tree expr)
 {
@@ -483,6 +573,9 @@ gfc_get_vptr_from_expr (tree expr)
 
   for (tmp = expr; tmp; tmp = TREE_OPERAND (tmp, 0))
     {
+      if (CONSTANT_CLASS_P (tmp))
+	return NULL_TREE;
+
       type = TREE_TYPE (tmp);
       while (type)
 	{
@@ -1577,6 +1670,111 @@ gfc_trans_class_init_assign (gfc_code *code)
 }
 
 
+/* Class valued elemental function calls or class array elements arriving
+   in gfc_trans_scalar_assign come here.  Wherever possible the vptr copy
+   is used to ensure that the rhs dynamic type is assigned to the lhs.  */
+
+static bool
+trans_scalar_class_assign (stmtblock_t *block, gfc_se *lse, gfc_se *rse)
+{
+  tree fcn;
+  tree rse_expr;
+  tree class_data;
+  tree tmp;
+  tree zero;
+  tree cond;
+  tree final_cond;
+  stmtblock_t inner_block;
+  bool is_descriptor;
+  bool not_call_expr = TREE_CODE (rse->expr) != CALL_EXPR;
+  bool not_lhs_array_type;
+
+  /* Temporaries arising from depencies in assignment get cast as a
+     character type of the dynamic size of the rhs. Use the vptr copy
+     for this case.  */
+  tmp = TREE_TYPE (lse->expr);
+  not_lhs_array_type = !(tmp && TREE_CODE (tmp) == ARRAY_TYPE
+			 && TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)) != NULL_TREE);
+
+  /* Use ordinary assignment if the rhs is not a call expression or
+     the lhs is not a class entity or an array(ie. character) type.  */
+  if ((not_call_expr && gfc_get_class_from_expr (lse->expr) == NULL_TREE)
+      && not_lhs_array_type)
+    return false;
+
+  /* Ordinary assignment can be used if both sides are class expressions
+     since the dynamic type is preserved by copying the vptr.  This
+     should only occur, where temporaries are involved.  */
+  if (GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
+      && GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))
+    return false;
+
+  /* Fix the class expression and the class data of the rhs.  */
+  if (!GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr))
+      || not_call_expr)
+    {
+      tmp = gfc_get_class_from_expr (rse->expr);
+      if (tmp == NULL_TREE)
+	return false;
+      rse_expr = gfc_evaluate_now (tmp, block);
+    }
+  else
+    rse_expr = gfc_evaluate_now (rse->expr, block);
+
+  class_data = gfc_class_data_get (rse_expr);
+
+  /* Check that the rhs data is not null.  */
+  is_descriptor = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (class_data));
+  if (is_descriptor)
+    class_data = gfc_conv_descriptor_data_get (class_data);
+  class_data = gfc_evaluate_now (class_data, block);
+
+  zero = build_int_cst (TREE_TYPE (class_data), 0);
+  cond = fold_build2_loc (input_location, NE_EXPR,
+			  logical_type_node,
+			  class_data, zero);
+
+  /* Copy the rhs to the lhs.  */
+  fcn = gfc_vptr_copy_get (gfc_class_vptr_get (rse_expr));
+  fcn = build_fold_indirect_ref_loc (input_location, fcn);
+  tmp = gfc_evaluate_now (gfc_build_addr_expr (NULL, rse->expr), block);
+  tmp = is_descriptor ? tmp : class_data;
+  tmp = build_call_expr_loc (input_location, fcn, 2, tmp,
+			     gfc_build_addr_expr (NULL, lse->expr));
+  gfc_add_expr_to_block (block, tmp);
+
+  /* Only elemental function results need to be finalised and freed.  */
+  if (not_call_expr)
+    return true;
+
+  /* Finalize the class data if needed.  */
+  gfc_init_block (&inner_block);
+  fcn = gfc_vptr_final_get (gfc_class_vptr_get (rse_expr));
+  zero = build_int_cst (TREE_TYPE (fcn), 0);
+  final_cond = fold_build2_loc (input_location, NE_EXPR,
+				logical_type_node, fcn, zero);
+  fcn = build_fold_indirect_ref_loc (input_location, fcn);
+  tmp = build_call_expr_loc (input_location, fcn, 1, class_data);
+  tmp = build3_v (COND_EXPR, final_cond,
+		  tmp, build_empty_stmt (input_location));
+  gfc_add_expr_to_block (&inner_block, tmp);
+
+  /* Free the class data.  */
+  tmp = gfc_call_free (class_data);
+  tmp = build3_v (COND_EXPR, cond, tmp,
+		  build_empty_stmt (input_location));
+  gfc_add_expr_to_block (&inner_block, tmp);
+
+  /* Finish the inner block and subject it to the condition on the
+     class data being non-zero.  */
+  tmp = gfc_finish_block (&inner_block);
+  tmp = build3_v (COND_EXPR, cond, tmp,
+		  build_empty_stmt (input_location));
+  gfc_add_expr_to_block (block, tmp);
+
+  return true;
+}
+
 /* End of prototype trans-class.c  */
 
 
@@ -5372,8 +5570,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	{
 	  /* The intrinsic type needs to be converted to a temporary
 	     CLASS object for the unlimited polymorphic formal.  */
+	  gfc_find_vtab (&e->ts);
 	  gfc_init_se (&parmse, se);
 	  gfc_conv_intrinsic_to_class (&parmse, e, fsym->ts);
+
 	}
       else if (se->ss && se->ss->info->useflags)
 	{
@@ -5668,6 +5868,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 			&& !fsym->attr.allocatable && !fsym->attr.pointer
 			&& !e->symtree->n.sym->attr.dimension
 			&& !e->symtree->n.sym->attr.pointer
+			&& !e->symtree->n.sym->attr.allocatable
 			/* See PR 41453.  */
 			&& !e->symtree->n.sym->attr.dummy
 			/* FIXME - PR 87395 and PR 41453  */
@@ -5958,7 +6159,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				fsym && fsym->attr.pointer);
 
 	      else if (gfc_is_class_array_ref (e, NULL)
-			 && fsym && fsym->ts.type == BT_DERIVED)
+		       && fsym && fsym->ts.type == BT_DERIVED)
 		/* The actual argument is a component reference to an
 		   array of derived types.  In this case, the argument
 		   is converted to a temporary, which is passed and then
@@ -5967,26 +6168,26 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		   the same as the declared type, copy-in/copy-out does
 		   not occur.  */
 		gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
-				fsym ? fsym->attr.intent : INTENT_INOUT,
-				fsym && fsym->attr.pointer);
+					   fsym->attr.intent,
+					   fsym->attr.pointer);
 
 	      else if (gfc_is_class_array_function (e)
-			 && fsym && fsym->ts.type == BT_DERIVED)
+		       && fsym && fsym->ts.type == BT_DERIVED)
 		/* See previous comment.  For function actual argument,
 		   the write out is not needed so the intent is set as
 		   intent in.  */
 		{
 		  e->must_finalize = 1;
 		  gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
-					     INTENT_IN,
-					     fsym && fsym->attr.pointer);
+					     INTENT_IN, fsym->attr.pointer);
 		}
 	      else if (fsym && fsym->attr.contiguous
-		       && !gfc_is_simply_contiguous (e, false, true))
+		       && !gfc_is_simply_contiguous (e, false, true)
+		       && gfc_expr_is_variable (e))
 		{
 		  gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,
-				fsym ? fsym->attr.intent : INTENT_INOUT,
-				fsym && fsym->attr.pointer);
+					     fsym->attr.intent,
+					     fsym->attr.pointer);
 		}
 	      else
 		gfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,
@@ -7462,12 +7663,14 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,
 	  return se.expr;
 
 	case BT_CHARACTER:
-	  {
-	    tree ctor = gfc_conv_string_init (ts->u.cl->backend_decl,expr);
-	    TREE_STATIC (ctor) = 1;
-	    return ctor;
-	  }
+	  if (expr->expr_type == EXPR_CONSTANT)
+	    {
+	      tree ctor = gfc_conv_string_init (ts->u.cl->backend_decl, expr);
+	      TREE_STATIC (ctor) = 1;
+	      return ctor;
+	    }
 
+	  /* Fallthrough.  */
 	default:
 	  gfc_init_se (&se, NULL);
 	  gfc_conv_constant (&se, expr);
@@ -8558,6 +8761,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
 
   if (expr->expr_type == EXPR_FUNCTION
       && ((expr->value.function.esym
+	   && expr->value.function.esym->result
 	   && expr->value.function.esym->result->attr.pointer
 	   && !expr->value.function.esym->result->attr.dimension)
 	  || (!expr->value.function.esym && !expr->ref
@@ -8645,14 +8849,32 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,
   tree tmp, to_len = NULL_TREE, from_len = NULL_TREE, lhs_vptr;
   bool set_vptr = false, temp_rhs = false;
   stmtblock_t *pre = block;
+  tree class_expr = NULL_TREE;
 
   /* Create a temporary for complicated expressions.  */
   if (re->expr_type != EXPR_VARIABLE && re->expr_type != EXPR_NULL
       && rse->expr != NULL_TREE && !DECL_P (rse->expr))
     {
-      tmp = gfc_create_var (TREE_TYPE (rse->expr), "rhs");
-      pre = &rse->pre;
-      gfc_add_modify (&rse->pre, tmp, rse->expr);
+      if (re->ts.type == BT_CLASS && !GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))
+	class_expr = gfc_get_class_from_expr (rse->expr);
+
+      if (rse->loop)
+	pre = &rse->loop->pre;
+      else
+	pre = &rse->pre;
+
+      if (class_expr != NULL_TREE && UNLIMITED_POLY (re))
+	{
+	  tmp = TREE_OPERAND (rse->expr, 0);
+	  tmp = gfc_create_var (TREE_TYPE (tmp), "rhs");
+	  gfc_add_modify (&rse->pre, tmp, TREE_OPERAND (rse->expr, 0));
+	}
+      else
+	{
+	  tmp = gfc_create_var (TREE_TYPE (rse->expr), "rhs");
+	  gfc_add_modify (&rse->pre, tmp, rse->expr);
+	}
+
       rse->expr = tmp;
       temp_rhs = true;
     }
@@ -8720,9 +8942,17 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,
 	  else if (temp_rhs && re->ts.type == BT_CLASS)
 	    {
 	      vptr_expr = NULL;
-	      se.expr = gfc_class_vptr_get (rse->expr);
+	      if (class_expr)
+		tmp = class_expr;
+	      else if (!GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr)))
+		tmp = gfc_get_class_from_expr (rse->expr);
+	      else
+		tmp = rse->expr;
+
+	      se.expr = gfc_class_vptr_get (tmp);
 	      if (UNLIMITED_POLY (re))
-		from_len = gfc_class_len_get (rse->expr);
+		from_len = gfc_class_len_get (tmp);
+
 	    }
 	  else if (re->expr_type != EXPR_NULL)
 	    /* Only when rhs is non-NULL use its declared type for vptr
@@ -9461,7 +9691,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type))
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -9469,7 +9699,20 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
 			     TREE_TYPE (lse->expr), rse->expr);
       gfc_add_modify (&block, lse->expr, tmp);
     }
-  else
+  /* If possible use the rhs vptr copy with trans_scalar_class_assign....  */
+  else if (ts.type == BT_CLASS
+	   && !trans_scalar_class_assign (&block, lse, rse))
+    {
+      gfc_add_block_to_block (&block, &lse->pre);
+      gfc_add_block_to_block (&block, &rse->pre);
+      /* ...otherwise assignment suffices. Note the use of VIEW_CONVERT_EXPR
+	 for the lhs which ensures that class data rhs cast as a string assigns
+	 correctly.  */
+      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,
+			     TREE_TYPE (rse->expr), lse->expr);
+      gfc_add_modify (&block, tmp, rse->expr);
+    }
+  else if (ts.type != BT_CLASS)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -10366,23 +10609,53 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
 			gfc_se *lse, gfc_se *rse, bool use_vptr_copy,
 			bool class_realloc)
 {
-  tree tmp, fcn, stdcopy, to_len, from_len, vptr;
+  tree tmp, fcn, stdcopy, to_len, from_len, vptr, old_vptr;
   vec<tree, va_gc> *args = NULL;
 
+  /* Store the old vptr so that dynamic types can be compared for
+     reallocation to occur or not.  */
+  if (class_realloc)
+    {
+      tmp = lse->expr;
+      if (!GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+	tmp = gfc_get_class_from_expr (tmp);
+    }
+
   vptr = trans_class_vptr_len_assignment (block, lhs, rhs, rse, &to_len,
 					 &from_len);
 
-  /* Generate allocation of the lhs.  */
+  /* Generate (re)allocation of the lhs.  */
   if (class_realloc)
     {
-      stmtblock_t alloc;
-      tree class_han;
+      stmtblock_t alloc, re_alloc;
+      tree class_han, re, size;
+
+      if (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+	old_vptr = gfc_evaluate_now (gfc_class_vptr_get (tmp), block);
+      else
+	old_vptr = build_int_cst (TREE_TYPE (vptr), 0);
 
-      tmp = gfc_vptr_size_get (vptr);
+      size = gfc_vptr_size_get (vptr);
       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
 	  ? gfc_class_data_get (lse->expr) : lse->expr;
+
+      /* Allocate block.  */
       gfc_init_block (&alloc);
-      gfc_allocate_using_malloc (&alloc, class_han, tmp, NULL_TREE);
+      gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);
+
+      /* Reallocate if dynamic types are different. */
+      gfc_init_block (&re_alloc);
+      re = build_call_expr_loc (input_location,
+				builtin_decl_explicit (BUILT_IN_REALLOC), 2,
+				fold_convert (pvoid_type_node, class_han),
+				size);
+      tmp = fold_build2_loc (input_location, NE_EXPR,
+			     logical_type_node, vptr, old_vptr);
+      re = fold_build3_loc (input_location, COND_EXPR, void_type_node,
+			    tmp, re, build_empty_stmt (input_location));
+      gfc_add_expr_to_block (&re_alloc, re);
+
+      /* Allocate if _data is NULL, reallocate otherwise.  */
       tmp = fold_build2_loc (input_location, EQ_EXPR,
 			     logical_type_node, class_han,
 			     build_int_cst (prvoid_type_node, 0));
@@ -10390,7 +10663,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
 			     gfc_unlikely (tmp,
 					   PRED_FORTRAN_FAIL_ALLOC),
 			     gfc_finish_block (&alloc),
-			     build_empty_stmt (input_location));
+			     gfc_finish_block (&re_alloc));
       gfc_add_expr_to_block (&lse->pre, tmp);
     }
 
@@ -10493,6 +10766,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
   bool maybe_workshare = false, lhs_refs_comp = false, rhs_refs_comp = false;
   symbol_attribute lhs_caf_attr, rhs_caf_attr, lhs_attr;
   bool is_poly_assign;
+  bool realloc_flag;
 
   /* Assignment of the form lhs = rhs.  */
   gfc_start_block (&block);
@@ -10533,6 +10807,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 		       || gfc_is_class_array_ref (expr2, NULL)
 		       || gfc_is_class_scalar_expr (expr2));
 
+  realloc_flag = flag_realloc_lhs
+		 && gfc_is_reallocatable_lhs (expr1)
+		 && expr2->rank
+		 && !is_runtime_conformable (expr1, expr2);
 
   /* Only analyze the expressions for coarray properties, when in coarray-lib
      mode.  */
@@ -10776,10 +11054,24 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
   tmp = NULL_TREE;
 
   if (is_poly_assign)
-    tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,
-				  use_vptr_copy || (lhs_attr.allocatable
-						    && !lhs_attr.dimension),
-				  flag_realloc_lhs && !lhs_attr.pointer);
+    {
+      tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,
+				    use_vptr_copy || (lhs_attr.allocatable
+						      && !lhs_attr.dimension),
+				    !realloc_flag && flag_realloc_lhs
+				    && !lhs_attr.pointer);
+      if (expr2->expr_type == EXPR_FUNCTION
+	  && expr2->ts.type == BT_DERIVED
+	  && expr2->ts.u.derived->attr.alloc_comp)
+	{
+	  tree tmp2 = gfc_deallocate_alloc_comp (expr2->ts.u.derived,
+						 rse.expr, expr2->rank);
+	  if (lss == gfc_ss_terminator)
+	    gfc_add_expr_to_block (&rse.post, tmp2);
+	  else
+	    gfc_add_expr_to_block (&loop.post, tmp2);
+	}
+    }
   else if (flag_coarray == GFC_FCOARRAY_LIB
 	   && lhs_caf_attr.codimension && rhs_caf_attr.codimension
 	   && ((lhs_caf_attr.allocatable && lhs_refs_comp)
@@ -10809,7 +11101,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
     {
       /* This case comes about when the scalarizer provides array element
 	 references. Use the vptr copy function, since this does a deep
-	 copy of allocatable components, without which the finalizer call */
+	 copy of allocatable components, without which the finalizer call
+	 will deallocate the components.  */
       tmp = gfc_get_vptr_from_expr (rse.expr);
       if (tmp != NULL_TREE)
 	{
@@ -10884,10 +11177,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	}
 
       /* F2003: Allocate or reallocate lhs of allocatable array.  */
-      if (flag_realloc_lhs
-	  && gfc_is_reallocatable_lhs (expr1)
-	  && expr2->rank
-	  && !is_runtime_conformable (expr1, expr2))
+      if (realloc_flag)
 	{
 	  realloc_lhs_warning (expr1->ts.type, true, &expr1->where);
 	  ompws_flags &= ~OMPWS_SCALARIZER_WS;
@@ -10996,8 +11286,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	return tmp;
     }
 
-  if (UNLIMITED_POLY (expr1) && expr1->rank
-      && expr2->ts.type != BT_CLASS)
+  if (UNLIMITED_POLY (expr1) && expr1->rank)
     use_vptr_copy = true;
 
   /* Fallback to the scalarizer to generate explicit loops.  */
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 3018711afc1..1b51e870f04 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -4861,6 +4861,24 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)
 }
 
 
+/* Remove unneeded kind= argument from actual argument list when the
+   result conversion is dealt with in a different place.  */
+
+static void
+strip_kind_from_actual (gfc_actual_arglist * actual)
+{
+  for (gfc_actual_arglist *a = actual; a; a = a->next)
+    {
+      gfc_actual_arglist *b = a->next;
+      if (b && b->name && strcmp (b->name, "kind") == 0)
+	{
+	  a->next = b->next;
+	  b->next = NULL;
+	  gfc_free_actual_arglist (b);
+	}
+    }
+}
+
 /* Emit code for minloc or maxloc intrinsic.  There are many different cases
    we need to handle.  For performance reasons we sometimes create two
    loops instead of one, where the second one is much simpler.
@@ -4996,6 +5014,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)
     {
       gfc_actual_arglist *a, *b;
       a = actual;
+      strip_kind_from_actual (a);
       while (a->next)
 	{
 	  b = a->next;
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index b839d6c73e1..d5aec5286fc 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1228,6 +1228,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)
   if (code->expr1 && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)
       && code->expr1->rank == 0)
     {
+      tree images2 = fold_convert (integer_type_node, images);
       tree cond;
       if (flag_coarray != GFC_FCOARRAY_LIB)
 	cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,
@@ -1239,7 +1240,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)
 				     2, integer_zero_node,
 				     build_int_cst (integer_type_node, -1));
 	  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,
-				  images, tmp);
+				  images2, tmp);
 	  cond2 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,
 				   images,
 				   build_int_cst (TREE_TYPE (images), 1));
@@ -1248,8 +1249,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)
 	}
       gfc_trans_runtime_check (true, false, cond, &se.pre,
 			       &code->expr1->where, "Invalid image number "
-			       "%d in SYNC IMAGES",
-			       fold_convert (integer_type_node, images));
+			       "%d in SYNC IMAGES", images2);
     }
 
   /* Per F2008, 8.5.1, a SYNC MEMORY is implied by calling the
@@ -3576,9 +3576,10 @@ check_forall_dependencies (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)
      point to the copy instead.  Note that the shallow copy of
      the variable will not suffice for derived types with
      pointer components.  We therefore leave these to their
-     own devices.  */
+     own devices.  Likewise for allocatable components.  */
   if (lsym->ts.type == BT_DERIVED
-	&& lsym->ts.u.derived->attr.pointer_comp)
+      && (lsym->ts.u.derived->attr.pointer_comp
+	  || lsym->ts.u.derived->attr.alloc_comp))
     return need_temp;
 
   new_symtree = NULL;
@@ -6627,7 +6628,7 @@ gfc_trans_allocate (gfc_code * code)
 	  gfc_expr *init_expr = gfc_expr_to_initialize (expr);
 	  gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);
 	  flag_realloc_lhs = 0;
-	  tmp = gfc_trans_assignment (init_expr, rhs, false, false, true,
+	  tmp = gfc_trans_assignment (init_expr, rhs, true, false, true,
 				      false);
 	  flag_realloc_lhs = realloc_lhs;
 	  /* Free the expression allocated for init_expr.  */
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index 167fcb2158c..598c4d5694f 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -417,7 +417,14 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)
   /* If decl or vptr are non-null, pointer arithmetic for the array reference
      is likely. Generate the 'span' for the array reference.  */
   if (vptr)
-    span = gfc_vptr_size_get (vptr);
+    {
+      span = gfc_vptr_size_get (vptr);
+
+      /* Check if this is an unlimited polymorphic object carrying a character
+	 payload. In this case, the 'len' field is non-zero.  */
+      if (decl && GFC_CLASS_TYPE_P (TREE_TYPE (decl)))
+	span = gfc_resize_class_size_with_len (NULL, decl, span);
+    }
   else if (decl)
     span = get_array_span (type, decl);
 
@@ -609,6 +616,9 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)
   /* Call malloc.  */
   gfc_start_block (&block2);
 
+  if (size == NULL_TREE)
+    size = build_int_cst (size_type_node, 1);
+
   size = fold_convert (size_type_node, size);
   size = fold_build2_loc (input_location, MAX_EXPR, size_type_node, size,
 			  build_int_cst (size_type_node, 1));
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index f6af09fedf7..066975790a6 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -415,6 +415,7 @@ tree gfc_class_data_get (tree);
 tree gfc_class_vptr_get (tree);
 tree gfc_class_len_get (tree);
 tree gfc_class_len_or_zero_get (tree);
+tree gfc_resize_class_size_with_len (stmtblock_t *, tree, tree);
 gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);
 /* Get an accessor to the class' vtab's * field, when a class handle is
    available.  */
@@ -434,6 +435,8 @@ tree gfc_vptr_final_get (tree);
 tree gfc_vptr_deallocate_get (tree);
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 void gfc_reset_len (stmtblock_t *, gfc_expr *);
+tree gfc_get_class_from_gfc_expr (gfc_expr *);
+tree gfc_get_class_from_expr (tree);
 tree gfc_get_vptr_from_expr (tree);
 tree gfc_get_class_array_ref (tree, tree, tree, bool);
 tree gfc_copy_class_to_class (tree, tree, tree, bool);
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 4f57765b012..410ba67a4b0 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -5240,6 +5240,34 @@ do_specs_vec (vec<char_p> vec)
     }
 }
 
+/* Add options passed via -Xassembler or -Wa to COLLECT_AS_OPTIONS.  */
+
+static void
+putenv_COLLECT_AS_OPTIONS (vec<char_p> vec)
+{
+  if (vec.is_empty ())
+     return;
+
+  obstack_init (&collect_obstack);
+  obstack_grow (&collect_obstack, "COLLECT_AS_OPTIONS=",
+		strlen ("COLLECT_AS_OPTIONS="));
+
+  char *opt;
+  unsigned ix;
+
+  FOR_EACH_VEC_ELT (vec, ix, opt)
+    {
+      obstack_1grow (&collect_obstack, '\'');
+      obstack_grow (&collect_obstack, opt, strlen (opt));
+      obstack_1grow (&collect_obstack, '\'');
+      if (ix < vec.length () - 1)
+	obstack_1grow(&collect_obstack, ' ');
+    }
+
+  obstack_1grow (&collect_obstack, '\0');
+  xputenv (XOBFINISH (&collect_obstack, char *));
+}
+
 /* Process the sub-spec SPEC as a portion of a larger spec.
    This is like processing a whole spec except that we do
    not initialize at the beginning and we do not supply a
@@ -7355,6 +7383,7 @@ driver::main (int argc, char **argv)
   global_initializations ();
   build_multilib_strings ();
   set_up_specs ();
+  putenv_COLLECT_AS_OPTIONS (assembler_options);
   putenv_COLLECT_GCC (argv[0]);
   maybe_putenv_COLLECT_LTO_WRAPPER ();
   maybe_putenv_OFFLOAD_TARGETS ();
diff --git a/gcc/gcov-io.c b/gcc/gcov-io.c
index 1f8ac375931..a906830f3c9 100644
--- a/gcc/gcov-io.c
+++ b/gcc/gcov-io.c
@@ -48,6 +48,7 @@ struct gcov_var
   unsigned overread;		/* Number of words overread.  */
   int error;			/* < 0 overflow, > 0 disk error.  */
   int mode;	                /* < 0 writing, > 0 reading */
+  int endian;			/* Swap endianness.  */
 #if IN_LIBGCOV
   /* Holds one block plus 4 bytes, thus all coverage reads & writes
      fit within this buffer and we always can transfer GCOV_BLOCK_SIZE
@@ -55,7 +56,6 @@ struct gcov_var
      or 8 byte objects.  */
   gcov_unsigned_t buffer[GCOV_BLOCK_SIZE + 1];
 #else
-  int endian;			/* Swap endianness.  */
   /* Holds a variable length block, as the compiler can write
      strings and needs to backtrack.  */
   size_t alloc;
@@ -100,7 +100,7 @@ gcov_rewrite (void)
 
 static inline gcov_unsigned_t from_file (gcov_unsigned_t value)
 {
-#if !IN_LIBGCOV
+#if !IN_LIBGCOV || defined (IN_GCOV_TOOL)
   if (gcov_var.endian)
     {
       value = (value >> 16) | (value << 16);
@@ -222,7 +222,7 @@ gcov_close (void)
   return gcov_var.error;
 }
 
-#if !IN_LIBGCOV
+#if !IN_LIBGCOV || defined (IN_GCOV_TOOL)
 /* Check if MAGIC is EXPECTED. Use it to determine endianness of the
    file. Returns +1 for same endian, -1 for other endian and zero for
    not EXPECTED.  */
diff --git a/gcc/gcov-io.h b/gcc/gcov-io.h
index 9edb2923982..f650673d2de 100644
--- a/gcc/gcov-io.h
+++ b/gcc/gcov-io.h
@@ -326,6 +326,9 @@ struct gcov_summary
 
 #if !IN_LIBGCOV
 GCOV_LINKAGE int gcov_open (const char */*name*/, int /*direction*/);
+#endif
+
+#if !IN_LIBGCOV || defined (IN_GCOV_TOOL)
 GCOV_LINKAGE int gcov_magic (gcov_unsigned_t, gcov_unsigned_t);
 #endif
 
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index d00f1e2b035..408b93b2200 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -1242,12 +1242,18 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)
 
   length = tree_to_uhwi (len);
   if (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (etype)) != length
+      || (GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (etype))
+	  != GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (etype)))
       || get_pointer_alignment (dest) / BITS_PER_UNIT < length)
     return NULL_TREE;
 
   if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)
     return NULL_TREE;
 
+  if (!type_has_mode_precision_p (etype))
+    etype = lang_hooks.types.type_for_mode (SCALAR_INT_TYPE_MODE (etype),
+					    TYPE_UNSIGNED (etype));
+
   if (integer_zerop (c))
     cval = 0;
   else
diff --git a/gcc/gimple-ssa-split-paths.c b/gcc/gimple-ssa-split-paths.c
index 33bbb66674b..0bfe67a02ba 100644
--- a/gcc/gimple-ssa-split-paths.c
+++ b/gcc/gimple-ssa-split-paths.c
@@ -68,8 +68,14 @@ find_block_to_duplicate_for_splitting_paths (basic_block latch)
 	 region.  Verify that it is.
 
 	 First, verify that BB has two predecessors (each arm of the
-	 IF-THEN-ELSE) and two successors (the latch and exit).  */
-      if (EDGE_COUNT (bb->preds) == 2 && EDGE_COUNT (bb->succs) == 2)
+	 IF-THEN-ELSE) and two successors (the latch and exit) and that
+	 all edges are normal.  */
+      if (EDGE_COUNT (bb->preds) == 2
+	  && !(EDGE_PRED (bb, 0)->flags & EDGE_COMPLEX)
+	  && !(EDGE_PRED (bb, 1)->flags & EDGE_COMPLEX)
+	  && EDGE_COUNT (bb->succs) == 2
+	  && !(EDGE_SUCC (bb, 0)->flags & EDGE_COMPLEX)
+	  && !(EDGE_SUCC (bb, 1)->flags & EDGE_COMPLEX))
 	{
 	  /* Now verify that BB's immediate dominator ends in a
 	     conditional as well.  */
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index 550f782813b..c1081da9c0e 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -2081,7 +2081,8 @@ struct imm_store_chain_info
       }
   }
   bool terminate_and_process_chain ();
-  bool try_coalesce_bswap (merged_store_group *, unsigned int, unsigned int);
+  bool try_coalesce_bswap (merged_store_group *, unsigned int, unsigned int,
+			   unsigned int);
   bool coalesce_immediate_stores ();
   bool output_merged_store (merged_store_group *);
   bool output_merged_stores ();
@@ -2402,14 +2403,39 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)
    into the group.  That way it will be its own store group and will
    not be touched.  If ALL_INTEGER_CST_P and there are overlapping
    INTEGER_CST stores, those are mergeable using merge_overlapping,
-   so don't return false for those.  */
+   so don't return false for those.
+
+   Similarly, check stores from FIRST_EARLIER (inclusive) to END_EARLIER
+   (exclusive), whether they don't overlap the bitrange START to END
+   and have order in between FIRST_ORDER and LAST_ORDER.  This is to
+   prevent merging in cases like:
+     MEM <char[12]> [&b + 8B] = {};
+     MEM[(short *) &b] = 5;
+     _5 = *x_4(D);
+     MEM <long long unsigned int> [&b + 2B] = _5;
+     MEM[(char *)&b + 16B] = 88;
+     MEM[(int *)&b + 20B] = 1;
+   The = {} store comes in sort_by_bitpos before the = 88 store, and can't
+   be merged with it, because the = _5 store overlaps these and is in between
+   them in sort_by_order ordering.  If it was merged, the merged store would
+   go after the = _5 store and thus change behavior.  */
 
 static bool
 check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,
-		  bool all_integer_cst_p, unsigned int last_order,
-		  unsigned HOST_WIDE_INT end)
+		  bool all_integer_cst_p, unsigned int first_order,
+		  unsigned int last_order, unsigned HOST_WIDE_INT start,
+		  unsigned HOST_WIDE_INT end, unsigned int first_earlier,
+		  unsigned end_earlier)
 {
   unsigned int len = m_store_info.length ();
+  for (unsigned int j = first_earlier; j < end_earlier; j++)
+    {
+      store_immediate_info *info = m_store_info[j];
+      if (info->order > first_order
+	  && info->order < last_order
+	  && info->bitpos + info->bitsize > start)
+	return false;
+    }
   for (++i; i < len; ++i)
     {
       store_immediate_info *info = m_store_info[i];
@@ -2430,7 +2456,8 @@ check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,
 bool
 imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,
 					  unsigned int first,
-					  unsigned int try_size)
+					  unsigned int try_size,
+					  unsigned int first_earlier)
 {
   unsigned int len = m_store_info.length (), last = first;
   unsigned HOST_WIDE_INT width = m_store_info[first]->bitsize;
@@ -2569,7 +2596,8 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,
   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))
     return false;
 
-  if (!check_no_overlap (m_store_info, last, false, last_order, end))
+  if (!check_no_overlap (m_store_info, last, false, first_order, last_order,
+			 merged_store->start, end, first_earlier, first))
     return false;
 
   /* Don't handle memory copy this way if normal non-bswap processing
@@ -2661,6 +2689,8 @@ imm_store_chain_info::coalesce_immediate_stores ()
 
   store_immediate_info *info;
   unsigned int i, ignore = 0;
+  unsigned int first_earlier = 0;
+  unsigned int end_earlier = 0;
 
   /* Order the stores by the bitposition they write to.  */
   m_store_info.qsort (sort_by_bitpos);
@@ -2675,6 +2705,12 @@ imm_store_chain_info::coalesce_immediate_stores ()
       if (i <= ignore)
 	goto done;
 
+      while (first_earlier < end_earlier
+	     && (m_store_info[first_earlier]->bitpos
+		 + m_store_info[first_earlier]->bitsize
+		 <= merged_store->start))
+	first_earlier++;
+
       /* First try to handle group of stores like:
 	 p[0] = data >> 24;
 	 p[1] = data >> 16;
@@ -2688,7 +2724,8 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	{
 	  unsigned int try_size;
 	  for (try_size = 64; try_size >= 16; try_size >>= 1)
-	    if (try_coalesce_bswap (merged_store, i - 1, try_size))
+	    if (try_coalesce_bswap (merged_store, i - 1, try_size,
+				    first_earlier))
 	      break;
 
 	  if (try_size >= 16)
@@ -2696,7 +2733,10 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	      ignore = i + merged_store->stores.length () - 1;
 	      m_merged_store_groups.safe_push (merged_store);
 	      if (ignore < m_store_info.length ())
-		merged_store = new merged_store_group (m_store_info[ignore]);
+		{
+		  merged_store = new merged_store_group (m_store_info[ignore]);
+		  end_earlier = ignore;
+		}
 	      else
 		merged_store = NULL;
 	      goto done;
@@ -2722,12 +2762,16 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	  /* Only allow overlapping stores of constants.  */
 	  if (info->rhs_code == INTEGER_CST && merged_store->only_constants)
 	    {
+	      unsigned int first_order
+		= MIN (merged_store->first_order, info->order);
 	      unsigned int last_order
 		= MAX (merged_store->last_order, info->order);
 	      unsigned HOST_WIDE_INT end
 		= MAX (merged_store->start + merged_store->width,
 		       info->bitpos + info->bitsize);
-	      if (check_no_overlap (m_store_info, i, true, last_order, end))
+	      if (check_no_overlap (m_store_info, i, true, first_order,
+				    last_order, merged_store->start, end,
+				    first_earlier, end_earlier))
 		{
 		  /* check_no_overlap call above made sure there are no
 		     overlapping stores with non-INTEGER_CST rhs_code
@@ -2756,6 +2800,7 @@ imm_store_chain_info::coalesce_immediate_stores ()
 		  do
 		    {
 		      unsigned int max_order = 0;
+		      unsigned int min_order = first_order;
 		      unsigned first_nonmergeable_int_order = ~0U;
 		      unsigned HOST_WIDE_INT this_end = end;
 		      k = i;
@@ -2781,6 +2826,7 @@ imm_store_chain_info::coalesce_immediate_stores ()
 				  break;
 				}
 			      k = j;
+			      min_order = MIN (min_order, info2->order);
 			      this_end = MAX (this_end,
 					      info2->bitpos + info2->bitsize);
 			    }
@@ -2796,6 +2842,12 @@ imm_store_chain_info::coalesce_immediate_stores ()
 			    first_nonmergeable_order
 			      = MIN (first_nonmergeable_order, info2->order);
 			}
+		      if (k > i
+			  && !check_no_overlap (m_store_info, len - 1, true,
+						min_order, try_order,
+						merged_store->start, this_end,
+						first_earlier, end_earlier))
+			k = 0;
 		      if (k == 0)
 			{
 			  if (last_order == try_order)
@@ -2881,9 +2933,12 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	      info->ops_swapped_p = true;
 	    }
 	  if (check_no_overlap (m_store_info, i, false,
+				MIN (merged_store->first_order, info->order),
 				MAX (merged_store->last_order, info->order),
+				merged_store->start,
 				MAX (merged_store->start + merged_store->width,
-				     info->bitpos + info->bitsize)))
+				     info->bitpos + info->bitsize),
+				first_earlier, end_earlier))
 	    {
 	      /* Turn MEM_REF into BIT_INSERT_EXPR for bit-field stores.  */
 	      if (info->rhs_code == MEM_REF && infof->rhs_code != MEM_REF)
@@ -2928,6 +2983,7 @@ imm_store_chain_info::coalesce_immediate_stores ()
 	delete merged_store;
 
       merged_store = new merged_store_group (info);
+      end_earlier = i;
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fputs ("New store group\n", dump_file);
 
diff --git a/gcc/gimple.c b/gcc/gimple.c
index 8fae60fb848..0c3321ff625 100644
--- a/gcc/gimple.c
+++ b/gcc/gimple.c
@@ -2860,8 +2860,8 @@ check_loadstore (gimple *, tree op, tree, void *data)
 bool
 infer_nonnull_range (gimple *stmt, tree op)
 {
-  return infer_nonnull_range_by_dereference (stmt, op)
-    || infer_nonnull_range_by_attribute (stmt, op);
+  return (infer_nonnull_range_by_dereference (stmt, op)
+	  || infer_nonnull_range_by_attribute (stmt, op));
 }
 
 /* Return true if OP can be inferred to be non-NULL after STMT
@@ -2873,7 +2873,8 @@ infer_nonnull_range_by_dereference (gimple *stmt, tree op)
      non-NULL if -fdelete-null-pointer-checks is enabled.  */
   if (!flag_delete_null_pointer_checks
       || !POINTER_TYPE_P (TREE_TYPE (op))
-      || gimple_code (stmt) == GIMPLE_ASM)
+      || gimple_code (stmt) == GIMPLE_ASM
+      || gimple_clobber_p (stmt))
     return false;
 
   if (walk_stmt_load_store_ops (stmt, (void *)op,
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index bd8bd6d7e06..e103e76b466 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -6086,7 +6086,9 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 
       /* For various reasons, the gimplification of the expression
 	 may have made a new INDIRECT_REF.  */
-      if (TREE_CODE (op0) == INDIRECT_REF)
+      if (TREE_CODE (op0) == INDIRECT_REF
+	  || (TREE_CODE (op0) == MEM_REF
+	      && integer_zerop (TREE_OPERAND (op0, 1))))
 	goto do_indirect_ref;
 
       mark_addressable (TREE_OPERAND (expr, 0));
diff --git a/gcc/graphite-isl-ast-to-gimple.c b/gcc/graphite-isl-ast-to-gimple.c
index 40d1e8de6ae..556264dc0d3 100644
--- a/gcc/graphite-isl-ast-to-gimple.c
+++ b/gcc/graphite-isl-ast-to-gimple.c
@@ -266,6 +266,9 @@ gcc_expression_from_isl_ast_expr_id (tree type,
   tree t = res->second;
   if (useless_type_conversion_p (type, TREE_TYPE (t)))
     return t;
+  if (POINTER_TYPE_P (TREE_TYPE (t))
+      && !POINTER_TYPE_P (type) && !ptrofftype_p (type))
+    t = fold_convert (sizetype, t);
   return fold_convert (type, t);
 }
 
diff --git a/gcc/graphite-scop-detection.c b/gcc/graphite-scop-detection.c
index 4534d43721f..d6e804b2ddf 100644
--- a/gcc/graphite-scop-detection.c
+++ b/gcc/graphite-scop-detection.c
@@ -1103,7 +1103,6 @@ static void
 assign_parameter_index_in_region (tree name, sese_info_p region)
 {
   gcc_assert (TREE_CODE (name) == SSA_NAME
-	      && INTEGRAL_TYPE_P (TREE_TYPE (name))
 	      && ! defined_in_sese_p (name, region->region));
 
   int i;
diff --git a/gcc/hsa-gen.c b/gcc/hsa-gen.c
index edcec10f49f..5d4bc1979c7 100644
--- a/gcc/hsa-gen.c
+++ b/gcc/hsa-gen.c
@@ -5298,10 +5298,6 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)
   if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
     {
       tree function_decl = gimple_call_fndecl (stmt);
-      /* Prefetch pass can create type-mismatching prefetch builtin calls which
-	 fail the gimple_call_builtin_p test above.  Handle them here.  */
-      if (fndecl_built_in_p (function_decl, BUILT_IN_PREFETCH))
-	return;
 
       if (function_decl == NULL_TREE)
 	{
@@ -5310,6 +5306,11 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)
 	  return;
 	}
 
+      /* Prefetch pass can create type-mismatching prefetch builtin calls which
+	 fail the gimple_call_builtin_p test above.  Handle them here.  */
+      if (fndecl_built_in_p (function_decl, BUILT_IN_PREFETCH))
+	return;
+
       if (hsa_callable_function_p (function_decl))
 	gen_hsa_insns_for_direct_call (stmt, hbb);
       else if (!gen_hsa_insns_for_known_library_call (stmt, hbb))
diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
index 3e040e27305..356641b51a5 100644
--- a/gcc/ipa-devirt.c
+++ b/gcc/ipa-devirt.c
@@ -2003,10 +2003,11 @@ add_type_duplicate (odr_type val, tree type)
   return build_bases;
 }
 
-/* REF is OBJ_TYPE_REF, return the class the ref corresponds to.  */
+/* REF is OBJ_TYPE_REF, return the class the ref corresponds to.
+   FOR_DUMP_P is true when being called from the dump routines.  */
 
 tree
-obj_type_ref_class (const_tree ref)
+obj_type_ref_class (const_tree ref, bool for_dump_p)
 {
   gcc_checking_assert (TREE_CODE (ref) == OBJ_TYPE_REF);
   ref = TREE_TYPE (ref);
@@ -2022,8 +2023,10 @@ obj_type_ref_class (const_tree ref)
   tree ret = TREE_TYPE (ref);
   if (!in_lto_p && !TYPE_STRUCTURAL_EQUALITY_P (ret))
     ret = TYPE_CANONICAL (ret);
+  else if (odr_type ot = get_odr_type (ret, !for_dump_p))
+    ret = ot->type;
   else
-    ret = get_odr_type (ret)->type;
+    gcc_assert (for_dump_p);
   return ret;
 }
 
diff --git a/gcc/ipa-icf-gimple.c b/gcc/ipa-icf-gimple.c
index 25284936bc3..38e0ac12f7e 100644
--- a/gcc/ipa-icf-gimple.c
+++ b/gcc/ipa-icf-gimple.c
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "ipa-utils.h"
 #include "tree-eh.h"
 #include "builtins.h"
+#include "attribs.h"
 
 #include "ipa-icf-gimple.h"
 
@@ -768,6 +769,9 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)
       || (fntype1 && !types_compatible_p (fntype1, fntype2)))
     return return_false_with_msg ("call function types are not compatible");
 
+  if (fntype1 && fntype2 && comp_type_attributes (fntype1, fntype2) != 1)
+    return return_false_with_msg ("different fntype attributes");
+
   tree chain1 = gimple_call_chain (s1);
   tree chain2 = gimple_call_chain (s2);
   if ((chain1 && !chain2)
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index 40edee7951c..7c8aee20a88 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -122,7 +122,8 @@ struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range_base *>
   static bool
   equal (const value_range_base *a, const value_range_base *b)
     {
-      return a->equal_p (*b);
+      return (a->equal_p (*b)
+	      && types_compatible_p (a->type (), b->type ()));
     }
   static void
   mark_empty (value_range_base *&p)
diff --git a/gcc/lto-opts.c b/gcc/lto-opts.c
index 5e59e9327e7..bb0cdfae029 100644
--- a/gcc/lto-opts.c
+++ b/gcc/lto-opts.c
@@ -159,6 +159,12 @@ lto_write_options (void)
 	append_to_collect_gcc_options (&temporary_obstack, &first_p,
 				       option->canonical_option[j]);
     }
+
+  const char *collect_as_options = getenv ("COLLECT_AS_OPTIONS");
+  if (collect_as_options)
+    prepend_xassembler_to_collect_as_options (collect_as_options,
+					      &temporary_obstack);
+
   obstack_grow (&temporary_obstack, "\0", 1);
   args = XOBFINISH (&temporary_obstack, char *);
   lto_write_data (args, strlen (args) + 1);
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index 10bd7c9becb..d12135ade1f 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -73,6 +73,7 @@ static char *offload_objects_file_name;
 static char *makefile;
 static unsigned int num_deb_objs;
 static const char **early_debug_object_names;
+static bool xassembler_options_error = false;
 
 const char tool_name[] = "lto-wrapper";
 
@@ -137,41 +138,14 @@ get_options_from_collect_gcc_options (const char *collect_gcc,
 				      unsigned int *decoded_options_count)
 {
   struct obstack argv_obstack;
-  char *argv_storage;
   const char **argv;
-  int j, k, argc;
+  int argc;
 
-  argv_storage = xstrdup (collect_gcc_options);
   obstack_init (&argv_obstack);
   obstack_ptr_grow (&argv_obstack, collect_gcc);
 
-  for (j = 0, k = 0; argv_storage[j] != '\0'; ++j)
-    {
-      if (argv_storage[j] == '\'')
-	{
-	  obstack_ptr_grow (&argv_obstack, &argv_storage[k]);
-	  ++j;
-	  do
-	    {
-	      if (argv_storage[j] == '\0')
-		fatal_error (input_location, "malformed COLLECT_GCC_OPTIONS");
-	      else if (strncmp (&argv_storage[j], "'\\''", 4) == 0)
-		{
-		  argv_storage[k++] = '\'';
-		  j += 4;
-		}
-	      else if (argv_storage[j] == '\'')
-		break;
-	      else
-		argv_storage[k++] = argv_storage[j++];
-	    }
-	  while (1);
-	  argv_storage[k++] = '\0';
-	}
-    }
-
-  obstack_ptr_grow (&argv_obstack, NULL);
-  argc = obstack_object_size (&argv_obstack) / sizeof (void *) - 1;
+  parse_options_from_collect_gcc_options (collect_gcc_options,
+					  &argv_obstack, &argc);
   argv = XOBFINISH (&argv_obstack, const char **);
 
   decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,
@@ -509,6 +483,45 @@ merge_and_complain (struct cl_decoded_option **decoded_options,
       }
    else
      j++;
+
+  if (!xassembler_options_error)
+    for (i = j = 0; ; i++, j++)
+      {
+	for (; i < *decoded_options_count; i++)
+	  if ((*decoded_options)[i].opt_index == OPT_Xassembler)
+	    break;
+
+	for (; j < fdecoded_options_count; j++)
+	  if (fdecoded_options[j].opt_index == OPT_Xassembler)
+	    break;
+
+	if (i == *decoded_options_count && j == fdecoded_options_count)
+	  break;
+	else if (i < *decoded_options_count && j == fdecoded_options_count)
+	  {
+	    warning (0, "Extra option to -Xassembler: %s,"
+		     " dropping all -Xassembler and -Wa options.",
+		     (*decoded_options)[i].arg);
+	    xassembler_options_error = true;
+	    break;
+	  }
+	else if (i == *decoded_options_count && j < fdecoded_options_count)
+	  {
+	    warning (0, "Extra option to -Xassembler: %s,"
+		     " dropping all -Xassembler and -Wa options.",
+		     fdecoded_options[j].arg);
+	    xassembler_options_error = true;
+	    break;
+	  }
+	else if (strcmp ((*decoded_options)[i].arg, fdecoded_options[j].arg))
+	  {
+	    warning (0, "Options to Xassembler do not match: %s, %s,"
+		     " dropping all -Xassembler and -Wa options.",
+		     (*decoded_options)[i].arg, fdecoded_options[j].arg);
+	    xassembler_options_error = true;
+	    break;
+	  }
+      }
 }
 
 /* Auxiliary function that frees elements of PTR and PTR itself.
@@ -622,6 +635,13 @@ append_compiler_options (obstack *argv_obstack, struct cl_decoded_option *opts,
 	case OPT_Os:
 	  break;
 
+	case OPT_Xassembler:
+	  /* When we detected a mismatch in assembler options between
+	     the input TU's fall back to previous behavior of ignoring them.  */
+	  if (xassembler_options_error)
+	    continue;
+	  break;
+
 	default:
 	  if (!(cl_options[option->opt_index].flags & CL_TARGET))
 	    continue;
@@ -1117,7 +1137,8 @@ run_gcc (unsigned argc, char *argv[])
   const char **argv_ptr;
   char *list_option_full = NULL;
   const char *linker_output = NULL;
-  const char *collect_gcc, *collect_gcc_options;
+  const char *collect_gcc;
+  char *collect_gcc_options;
   int parallel = 0;
   int jobserver = 0;
   bool no_partition = false;
@@ -1146,6 +1167,25 @@ run_gcc (unsigned argc, char *argv[])
   if (!collect_gcc_options)
     fatal_error (input_location,
 		 "environment variable COLLECT_GCC_OPTIONS must be set");
+
+  char *collect_as_options = getenv ("COLLECT_AS_OPTIONS");
+
+  /* Prepend -Xassembler to each option, and append the string
+     to collect_gcc_options.  */
+  if (collect_as_options)
+    {
+      obstack temporary_obstack;
+      obstack_init (&temporary_obstack);
+
+      prepend_xassembler_to_collect_as_options (collect_as_options,
+						&temporary_obstack);
+      obstack_1grow (&temporary_obstack, '\0');
+
+      char *xassembler_opts_string
+	= XOBFINISH (&temporary_obstack, char *);
+      strcat (collect_gcc_options, xassembler_opts_string);
+    }
+
   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,
 					&decoded_options,
 					&decoded_options_count);
diff --git a/gcc/modulo-sched.c b/gcc/modulo-sched.c
index 059b5440123..b312903a36d 100644
--- a/gcc/modulo-sched.c
+++ b/gcc/modulo-sched.c
@@ -211,8 +211,6 @@ static int sms_order_nodes (ddg_ptr, int, int *, int *);
 static void set_node_sched_params (ddg_ptr);
 static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);
 static void permute_partial_schedule (partial_schedule_ptr, rtx_insn *);
-static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,
-                                    rtx, rtx);
 static int calculate_stage_count (partial_schedule_ptr, int);
 static void calculate_must_precede_follow (ddg_node_ptr, int, int,
 					   int, int, sbitmap, sbitmap, sbitmap);
@@ -392,30 +390,40 @@ doloop_register_get (rtx_insn *head, rtx_insn *tail)
    this constant.  Otherwise return 0.  */
 static rtx_insn *
 const_iteration_count (rtx count_reg, basic_block pre_header,
-		       int64_t * count)
+		       int64_t *count, bool* adjust_inplace)
 {
   rtx_insn *insn;
   rtx_insn *head, *tail;
 
+  *adjust_inplace = false;
+  bool read_after = false;
+
   if (! pre_header)
     return NULL;
 
   get_ebb_head_tail (pre_header, pre_header, &head, &tail);
 
   for (insn = tail; insn != PREV_INSN (head); insn = PREV_INSN (insn))
-    if (NONDEBUG_INSN_P (insn) && single_set (insn) &&
-	rtx_equal_p (count_reg, SET_DEST (single_set (insn))))
+    if (single_set (insn) && rtx_equal_p (count_reg,
+					  SET_DEST (single_set (insn))))
       {
 	rtx pat = single_set (insn);
 
 	if (CONST_INT_P (SET_SRC (pat)))
 	  {
 	    *count = INTVAL (SET_SRC (pat));
+	    *adjust_inplace = !read_after;
 	    return insn;
 	  }
 
 	return NULL;
       }
+    else if (NONDEBUG_INSN_P (insn) && reg_mentioned_p (count_reg, insn))
+      {
+	read_after = true;
+	if (reg_set_p (count_reg, insn))
+	   break;
+      }
 
   return NULL;
 }
@@ -1125,7 +1133,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,
 /* Generate the instructions (including reg_moves) for prolog & epilog.  */
 static void
 generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,
-                        rtx count_reg, rtx count_init)
+			rtx count_reg, bool adjust_init)
 {
   int i;
   int last_stage = PS_STAGE_COUNT (ps) - 1;
@@ -1134,12 +1142,12 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,
   /* Generate the prolog, inserting its insns on the loop-entry edge.  */
   start_sequence ();
 
-  if (!count_init)
+  if (adjust_init)
     {
       /* Generate instructions at the beginning of the prolog to
-         adjust the loop count by STAGE_COUNT.  If loop count is constant
-         (count_init), this constant is adjusted by STAGE_COUNT in
-         generate_prolog_epilog function.  */
+	 adjust the loop count by STAGE_COUNT.  If loop count is constant
+	 and it not used anywhere in prologue, this constant is adjusted by
+	 STAGE_COUNT outside of generate_prolog_epilog function.  */
       rtx sub_reg = NULL_RTX;
 
       sub_reg = expand_simple_binop (GET_MODE (count_reg), MINUS, count_reg,
@@ -1530,7 +1538,8 @@ sms_schedule (void)
       rtx_insn *count_init;
       int mii, rec_mii, stage_count, min_cycle;
       int64_t loop_count = 0;
-      bool opt_sc_p;
+      bool opt_sc_p, adjust_inplace = false;
+      basic_block pre_header;
 
       if (! (g = g_arr[loop->num]))
         continue;
@@ -1571,19 +1580,13 @@ sms_schedule (void)
 	}
 
 
-      /* In case of th loop have doloop register it gets special
-	 handling.  */
-      count_init = NULL;
-      if ((count_reg = doloop_register_get (head, tail)))
-	{
-	  basic_block pre_header;
-
-	  pre_header = loop_preheader_edge (loop)->src;
-	  count_init = const_iteration_count (count_reg, pre_header,
-					      &loop_count);
-	}
+      count_reg = doloop_register_get (head, tail);
       gcc_assert (count_reg);
 
+      pre_header = loop_preheader_edge (loop)->src;
+      count_init = const_iteration_count (count_reg, pre_header, &loop_count,
+					  &adjust_inplace);
+
       if (dump_file && count_init)
         {
           fprintf (dump_file, "SMS const-doloop ");
@@ -1703,9 +1706,20 @@ sms_schedule (void)
 	      print_partial_schedule (ps, dump_file);
 	    }
  
-          /* case the BCT count is not known , Do loop-versioning */
-	  if (count_reg && ! count_init)
+	  if (count_init)
+	    {
+	       if (adjust_inplace)
+		{
+		  /* When possible, set new iteration count of loop kernel in
+		     place.  Otherwise, generate_prolog_epilog creates an insn
+		     to adjust.  */
+		  SET_SRC (single_set (count_init)) = GEN_INT (loop_count
+							    - stage_count + 1);
+		}
+	    }
+	  else
             {
+	      /* case the BCT count is not known , Do loop-versioning */
 	      rtx comp_rtx = gen_rtx_GT (VOIDmode, count_reg,
 					 gen_int_mode (stage_count,
 						       GET_MODE (count_reg)));
@@ -1715,12 +1729,7 @@ sms_schedule (void)
 	      loop_version (loop, comp_rtx, &condition_bb,
 	  		    prob, prob.invert (),
 			    prob, prob.invert (), true);
-	     }
-
-	  /* Set new iteration count of loop kernel.  */
-          if (count_reg && count_init)
-	    SET_SRC (single_set (count_init)) = GEN_INT (loop_count
-						     - stage_count + 1);
+	    }
 
 	  /* Now apply the scheduled kernel to the RTL of the loop.  */
 	  permute_partial_schedule (ps, g->closing_branch->first_note);
@@ -1737,7 +1746,7 @@ sms_schedule (void)
 	  if (dump_file)
 	    print_node_sched_params (dump_file, g->num_nodes, ps);
 	  /* Generate prolog and epilog.  */
-          generate_prolog_epilog (ps, loop, count_reg, count_init);
+	  generate_prolog_epilog (ps, loop, count_reg, !adjust_inplace);
 	  break;
 	}
 
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 813cefd69b9..9708e2de7fb 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -9050,7 +9050,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
     }
   lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx, NULL);
   lower_omp (&par_body, ctx);
-  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL)
+  if (gimple_code (stmt) != GIMPLE_OMP_TASK)
     lower_reduction_clauses (clauses, &par_rlist, ctx);
 
   /* Declare all the variables created by mapping and the variables
diff --git a/gcc/omp-simd-clone.c b/gcc/omp-simd-clone.c
index e865828f569..f403c0a2b9c 100644
--- a/gcc/omp-simd-clone.c
+++ b/gcc/omp-simd-clone.c
@@ -812,6 +812,7 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,
 struct modify_stmt_info {
   ipa_parm_adjustment_vec adjustments;
   gimple *stmt;
+  gimple *after_stmt;
   /* True if the parent statement was modified by
      ipa_simd_modify_stmt_ops.  */
   bool modified;
@@ -892,7 +893,10 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)
       gimple_stmt_iterator gsi;
       if (gimple_code (info->stmt) == GIMPLE_PHI)
 	{
-	  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	  if (info->after_stmt)
+	    gsi = gsi_for_stmt (info->after_stmt);
+	  else
+	    gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
 	  /* Cache SSA_NAME for next time.  */
 	  if (cand
 	      && TREE_CODE (*orig_tp) == ADDR_EXPR
@@ -901,7 +905,12 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)
 	}
       else
 	gsi = gsi_for_stmt (info->stmt);
-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
+      if (info->after_stmt)
+	gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);
+      else
+	gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
+      if (gimple_code (info->stmt) == GIMPLE_PHI)
+	info->after_stmt = stmt;
       *orig_tp = repl;
     }
   else if (!useless_type_conversion_p (TREE_TYPE (*tp), TREE_TYPE (repl)))
@@ -1006,6 +1015,7 @@ ipa_simd_modify_function_body (struct cgraph_node *node,
 	  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));
 	  int i, n = gimple_phi_num_args (phi);
 	  info.stmt = phi;
+	  info.after_stmt = NULL;
 	  struct walk_stmt_info wi;
 	  memset (&wi, 0, sizeof (wi));
 	  info.modified = false;
@@ -1031,6 +1041,7 @@ ipa_simd_modify_function_body (struct cgraph_node *node,
 	{
 	  gimple *stmt = gsi_stmt (gsi);
 	  info.stmt = stmt;
+	  info.after_stmt = NULL;
 	  struct walk_stmt_info wi;
 
 	  memset (&wi, 0, sizeof (wi));
diff --git a/gcc/optabs.c b/gcc/optabs.c
index 7d7efe0a4a2..0ae429cad8e 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -1395,6 +1395,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,
       if (target == 0
 	  || target == op0
 	  || target == op1
+	  || reg_overlap_mentioned_p (target, op0)
+	  || reg_overlap_mentioned_p (target, op1)
 	  || !valid_multiword_target_p (target))
 	target = gen_reg_rtx (int_mode);
 
@@ -1475,6 +1477,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,
 	  if (target == 0
 	      || target == op0
 	      || target == op1
+	      || reg_overlap_mentioned_p (target, op0)
+	      || reg_overlap_mentioned_p (target, op1)
 	      || !valid_multiword_target_p (target))
 	    target = gen_reg_rtx (int_mode);
 
@@ -1533,6 +1537,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,
 	  || target == op0
 	  || target == op1
 	  || !REG_P (target)
+	  || reg_overlap_mentioned_p (target, op0)
+	  || reg_overlap_mentioned_p (target, op1)
 	  || !valid_multiword_target_p (target))
 	target = gen_reg_rtx (int_mode);
 
@@ -2670,6 +2676,7 @@ expand_absneg_bit (enum rtx_code code, scalar_float_mode mode,
 
   if (target == 0
       || target == op0
+      || reg_overlap_mentioned_p (target, op0)
       || (nwords > 1 && !valid_multiword_target_p (target)))
     target = gen_reg_rtx (mode);
 
@@ -2948,7 +2955,10 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,
       int i;
       rtx_insn *insns;
 
-      if (target == 0 || target == op0 || !valid_multiword_target_p (target))
+      if (target == 0
+	  || target == op0
+	  || reg_overlap_mentioned_p (target, op0)
+	  || !valid_multiword_target_p (target))
 	target = gen_reg_rtx (int_mode);
 
       start_sequence ();
@@ -3458,6 +3468,8 @@ expand_copysign_bit (scalar_float_mode mode, rtx op0, rtx op1, rtx target,
   if (target == 0
       || target == op0
       || target == op1
+      || reg_overlap_mentioned_p (target, op0)
+      || reg_overlap_mentioned_p (target, op1)
       || (nwords > 1 && !valid_multiword_target_p (target)))
     target = gen_reg_rtx (mode);
 
@@ -5559,6 +5571,8 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,
       if (shift_amt)
 	{
 	  struct expand_operand ops[3];
+	  if (shift_amt == const0_rtx)
+	    return v0;
 	  if (shift_code != CODE_FOR_nothing)
 	    {
 	      create_output_operand (&ops[0], target, mode);
diff --git a/gcc/opts-common.c b/gcc/opts-common.c
index d0b943bc819..fb48005b665 100644
--- a/gcc/opts-common.c
+++ b/gcc/opts-common.c
@@ -1711,3 +1711,69 @@ control_warning_option (unsigned int opt_index, int kind, const char *arg,
 	}
     }
 }
+
+/* Parse options in COLLECT_GCC_OPTIONS and push them on ARGV_OBSTACK.
+   Store number of arguments into ARGC_P.  */
+
+void
+parse_options_from_collect_gcc_options (const char *collect_gcc_options,
+					obstack *argv_obstack,
+					int *argc_p)
+{
+  char *argv_storage = xstrdup (collect_gcc_options);
+  int j, k;
+
+  for (j = 0, k = 0; argv_storage[j] != '\0'; ++j)
+    {
+      if (argv_storage[j] == '\'')
+	{
+	  obstack_ptr_grow (argv_obstack, &argv_storage[k]);
+	  ++j;
+	  do
+	    {
+	      if (argv_storage[j] == '\0')
+		fatal_error (input_location,
+			     "malformed %<COLLECT_GCC_OPTIONS%>");
+	      else if (strncmp (&argv_storage[j], "'\\''", 4) == 0)
+		{
+		  argv_storage[k++] = '\'';
+		  j += 4;
+		}
+	      else if (argv_storage[j] == '\'')
+		break;
+	      else
+		argv_storage[k++] = argv_storage[j++];
+	    }
+	  while (1);
+	  argv_storage[k++] = '\0';
+	}
+    }
+
+  obstack_ptr_grow (argv_obstack, NULL);
+  *argc_p = obstack_object_size (argv_obstack) / sizeof (void *) - 1;
+}
+
+/* Prepend -Xassembler for each option in COLLECT_AS_OPTIONS,
+   and push on O.  */
+
+void prepend_xassembler_to_collect_as_options (const char *collect_as_options,
+					       obstack *o)
+{
+  obstack opts_obstack;
+  int opts_count;
+
+  obstack_init (&opts_obstack);
+  parse_options_from_collect_gcc_options (collect_as_options,
+					  &opts_obstack, &opts_count);
+  const char **assembler_opts = XOBFINISH (&opts_obstack, const char **);
+
+  for (int i = 0; i < opts_count; i++)
+    {
+      obstack_grow (o, " '-Xassembler' ",
+		    strlen (" '-Xassembler' "));
+      const char *opt = assembler_opts[i];
+      obstack_1grow (o, '\'');
+      obstack_grow (o, opt, strlen (opt));
+      obstack_1grow (o, '\'');
+    }
+}
diff --git a/gcc/opts.h b/gcc/opts.h
index f14d9bcb896..c517458ddef 100644
--- a/gcc/opts.h
+++ b/gcc/opts.h
@@ -456,4 +456,9 @@ extern bool parse_and_check_align_values (const char *flag,
 					  bool report_error,
 					  location_t loc);
 
+extern void parse_options_from_collect_gcc_options (const char *, obstack *,
+						    int *);
+
+extern void prepend_xassembler_to_collect_as_options (const char *, obstack *);
+
 #endif
diff --git a/gcc/params.def b/gcc/params.def
index 8e4887e50a2..e23a4530bfa 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -1081,6 +1081,13 @@ DEFPARAM (PARAM_SRA_MAX_SCALARIZATION_SIZE_SIZE,
 	  "considered for scalarization when compiling for size.",
 	  0, 0, 0)
 
+DEFPARAM (PARAM_SRA_MAX_PROPAGATIONS,
+	  "sra-max-propagations",
+	  "Maximum number of artificial accesses to enable forward propagation "
+	  "that Scalar Replacement of Aggregates will keep for one local "
+	  "variable.",
+	  32, 0, 0)
+
 DEFPARAM (PARAM_IPA_CP_VALUE_LIST_SIZE,
 	  "ipa-cp-value-list-size",
 	  "Maximum size of a list of values associated with each parameter for "
diff --git a/gcc/print-rtl.c b/gcc/print-rtl.c
index fbb108568b3..819b8473d9d 100644
--- a/gcc/print-rtl.c
+++ b/gcc/print-rtl.c
@@ -1678,7 +1678,9 @@ print_value (pretty_printer *pp, const_rtx x, int verbose)
       pp_string (pp, tmp);
       break;
     case CONST_STRING:
-      pp_printf (pp, "\"%s\"", XSTR (x, 0));
+      pp_string (pp, "\"");
+      pretty_print_string (pp, XSTR (x, 0), strlen (XSTR (x, 0)));
+      pp_string (pp, "\"");
       break;
     case SYMBOL_REF:
       pp_printf (pp, "`%s'", XSTR (x, 0));
diff --git a/gcc/profile-count.c b/gcc/profile-count.c
index 8c58f8666f0..8d3340041fc 100644
--- a/gcc/profile-count.c
+++ b/gcc/profile-count.c
@@ -262,8 +262,8 @@ profile_count::to_frequency (struct function *fun) const
     return BB_FREQ_MAX;
   if (*this == profile_count::zero ())
     return 0;
-  gcc_assert (REG_BR_PROB_BASE == BB_FREQ_MAX
-	      && fun->cfg->count_max.initialized_p ());
+  STATIC_ASSERT (REG_BR_PROB_BASE == BB_FREQ_MAX);
+  gcc_assert (fun->cfg->count_max.initialized_p ());
   profile_probability prob = probability_in (fun->cfg->count_max);
   if (!prob.initialized_p ())
     return REG_BR_PROB_BASE;
diff --git a/gcc/profile.c b/gcc/profile.c
index a1dba1ac8fb..9ac3a7e93fe 100644
--- a/gcc/profile.c
+++ b/gcc/profile.c
@@ -1293,7 +1293,7 @@ branch_prob (bool thunk)
 	      seen_locations.add (loc);
 	      expanded_location curr_location = expand_location (loc);
 	      output_location (&streamed_locations, curr_location.file,
-			       curr_location.line, &offset, bb);
+			       MAX (1, curr_location.line), &offset, bb);
 	    }
 
 	  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
@@ -1304,7 +1304,7 @@ branch_prob (bool thunk)
 		{
 		  seen_locations.add (loc);
 		  output_location (&streamed_locations, gimple_filename (stmt),
-				   gimple_lineno (stmt), &offset, bb);
+				   MAX (1, gimple_lineno (stmt)), &offset, bb);
 		}
 	    }
 
@@ -1319,7 +1319,7 @@ branch_prob (bool thunk)
 	    {
 	      expanded_location curr_location = expand_location (loc);
 	      output_location (&streamed_locations, curr_location.file,
-			       curr_location.line, &offset, bb);
+			       MAX (1, curr_location.line), &offset, bb);
 	    }
 
 	  if (offset)
diff --git a/gcc/regs.h b/gcc/regs.h
index 48b2e708160..2a19940281b 100644
--- a/gcc/regs.h
+++ b/gcc/regs.h
@@ -128,7 +128,8 @@ extern size_t reg_info_p_size;
    or profile driven feedback is available and the function is never executed,
    frequency is always equivalent.  Otherwise rescale the basic block
    frequency.  */
-#define REG_FREQ_FROM_BB(bb) (optimize_function_for_size_p (cfun)	      \
+#define REG_FREQ_FROM_BB(bb) ((optimize_function_for_size_p (cfun)	      \
+			       || !cfun->cfg->count_max.initialized_p ())     \
 			      ? REG_FREQ_MAX				      \
 			      : ((bb)->count.to_frequency (cfun)	      \
 				* REG_FREQ_MAX / BB_FREQ_MAX)		      \
diff --git a/gcc/reorg.c b/gcc/reorg.c
index 81349382b81..a93cf90e0ab 100644
--- a/gcc/reorg.c
+++ b/gcc/reorg.c
@@ -577,8 +577,9 @@ add_to_delay_list (rtx_insn *insn, vec<rtx_insn *> *delay_list)
 {
   /* If INSN has its block number recorded, clear it since we may
      be moving the insn to a new block.  */
-      clear_hashed_info_for_insn (insn);
-      delay_list->safe_push (insn);
+  clear_hashed_info_for_insn (insn);
+
+  delay_list->safe_push (insn);
 }
 
 /* Delete INSN from the delay slot of the insn that it is in, which may
@@ -3221,7 +3222,14 @@ relax_delay_slots (rtx_insn *first)
 
 	      if (invert_jump (jump_insn, label, 1))
 		{
-		  delete_related_insns (next);
+		  rtx_insn *from = delete_related_insns (next);
+
+		  /* We have just removed a BARRIER, which means that the block
+		     number of the next insns has effectively been changed (see
+		     find_basic_block in resource.c), so clear it.  */
+		  if (from)
+		    clear_hashed_info_until_next_barrier (from);
+
 		  next = jump_insn;
 		}
 
@@ -3494,18 +3502,22 @@ relax_delay_slots (rtx_insn *first)
 
 	      if (invert_jump (delay_jump_insn, label, 1))
 		{
-		  int i;
-
 		  /* Must update the INSN_FROM_TARGET_P bits now that
 		     the branch is reversed, so that mark_target_live_regs
 		     will handle the delay slot insn correctly.  */
-		  for (i = 1; i < XVECLEN (PATTERN (insn), 0); i++)
+		  for (int i = 1; i < XVECLEN (PATTERN (insn), 0); i++)
 		    {
 		      rtx slot = XVECEXP (PATTERN (insn), 0, i);
 		      INSN_FROM_TARGET_P (slot) = ! INSN_FROM_TARGET_P (slot);
 		    }
 
-		  delete_related_insns (next);
+		  /* We have just removed a BARRIER, which means that the block
+		     number of the next insns has effectively been changed (see
+		     find_basic_block in resource.c), so clear it.  */
+		  rtx_insn *from = delete_related_insns (next);
+		  if (from)
+		    clear_hashed_info_until_next_barrier (from);
+
 		  next = insn;
 		}
 
diff --git a/gcc/resource.c b/gcc/resource.c
index c4bcfd7dc71..164b55e561b 100644
--- a/gcc/resource.c
+++ b/gcc/resource.c
@@ -1311,7 +1311,26 @@ clear_hashed_info_for_insn (rtx_insn *insn)
 	tinfo->block = -1;
     }
 }
-
+
+/* Clear any hashed information that we have stored for instructions
+   between INSN and the next BARRIER that follow a JUMP or a LABEL.  */
+
+void
+clear_hashed_info_until_next_barrier (rtx_insn *insn)
+{
+  while (insn && !BARRIER_P (insn))
+    {
+      if (JUMP_P (insn) || LABEL_P (insn))
+	{
+	  rtx_insn *next = next_active_insn (insn);
+	  if (next)
+	    clear_hashed_info_for_insn (next);
+	}
+
+      insn = next_nonnote_insn (insn);
+    }
+}
+
 /* Increment the tick count for the basic block that contains INSN.  */
 
 void
diff --git a/gcc/resource.h b/gcc/resource.h
index 7916344c584..3e969e52176 100644
--- a/gcc/resource.h
+++ b/gcc/resource.h
@@ -46,6 +46,7 @@ extern void mark_set_resources (rtx, struct resources *, int,
 				enum mark_resource_type);
 extern void mark_referenced_resources (rtx, struct resources *, bool);
 extern void clear_hashed_info_for_insn (rtx_insn *);
+extern void clear_hashed_info_until_next_barrier (rtx_insn *);
 extern void incr_ticks_for_insn (rtx_insn *);
 extern void mark_end_of_function_resources (rtx, bool);
 extern void init_resource_info (rtx_insn *);
diff --git a/gcc/sbitmap.c b/gcc/sbitmap.c
index 5e3d6b83afa..fc9d554cf0b 100644
--- a/gcc/sbitmap.c
+++ b/gcc/sbitmap.c
@@ -139,7 +139,8 @@ sbitmap_realloc (sbitmap src, unsigned int n_elms)
 sbitmap *
 sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)
 {
-  unsigned int i, bytes, offset, elm_bytes, size, amt, vector_bytes;
+  unsigned int i, size;
+  size_t amt, bytes, vector_bytes, elm_bytes, offset;
   sbitmap *bitmap_vector;
 
   size = SBITMAP_SET_SIZE (n_elms);
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index 5d6f2e0166c..125fc66b5ce 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -1315,7 +1315,8 @@ place_field (record_layout_info rli, tree field)
 	 Bump the cumulative size to multiple of field alignment.  */
 
       if (!targetm.ms_bitfield_layout_p (rli->t)
-          && DECL_SOURCE_LOCATION (field) != BUILTINS_LOCATION)
+	  && DECL_SOURCE_LOCATION (field) != BUILTINS_LOCATION
+	  && !TYPE_ARTIFICIAL (rli->t))
 	warning (OPT_Wpadded, "padding struct to align %q+D", field);
 
       /* If the alignment is still within offset_align, just align
@@ -1749,7 +1750,8 @@ finalize_record_size (record_layout_info rli)
 
   if (TREE_CONSTANT (unpadded_size)
       && simple_cst_equal (unpadded_size, TYPE_SIZE (rli->t)) == 0
-      && input_location != BUILTINS_LOCATION)
+      && input_location != BUILTINS_LOCATION
+      && !TYPE_ARTIFICIAL (rli->t))
     warning (OPT_Wpadded, "padding struct size to alignment boundary");
 
   if (warn_packed && TREE_CODE (rli->t) == RECORD_TYPE
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index e132f2657ef..50a94e87c04 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,2327 @@
+2021-04-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2021-04-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/97009
+	* gcc.dg/tree-ssa/pr97009.c: New test.
+
+2021-04-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-04-01  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99840
+	* gfortran.dg/transpose_5.f90: New test.
+
+2021-04-01  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-04-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/99856
+	* gcc.dg/vect/pr99856.c: New testcase.
+
+2021-03-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-03-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR ipa/99466
+	* gcc.dg/tls/pr99466-1.c: New test.
+	* gcc.dg/tls/pr99466-2.c: New test.
+
+2021-03-22  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backported from master:
+	2021-03-22  Kito Cheng  <kito.cheng@sifive.com>
+
+	PR target/99702
+	* gcc.target/riscv/pr99702.c: New.
+
+2021-03-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-27  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/value_8.f90: New test.
+
+2021-03-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2021-03-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/acle/rng_2.c: New test.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-03-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98758
+	* gcc.dg/torture/pr98758.c: New testcase.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98282
+	* g++.dg/opt/pr98282.C: New testcase.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/98117
+	* gcc.dg/torture/pr98117.c: New testcase.
+
+2021-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-03-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/93964
+	* gcc.dg/graphite/pr93964.c: New testcase.
+
+2021-03-15  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-03-15  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99545
+	* gfortran.dg/pr99545.f90: New test.
+
+2021-03-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/99218
+	* gfortran.dg/matmul_21.f90: New test.
+
+2021-03-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2021-03-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR c/99137
+	* c-c++-common/goacc/asyncwait-1.c: Update dg-error; add
+	additional test.
+
+2021-03-05  Marek Polacek  <polacek@redhat.com>
+
+	* g++.dg/cpp2a/nontype-class-defarg1.C: Use target c++2a.
+
+2021-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/98810
+	* g++.dg/cpp2a/nontype-class-defarg1.C: New test.
+
+2021-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95675
+	* g++.dg/cpp0x/decltype-call5.C: New test.
+	* g++.dg/cpp0x/decltype-call6.C: New test.
+
+2021-03-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/eh/seh-xmm-unwind.C: New test.
+
+2021-02-28  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/ext/attr-lambda3.C: Add missing ;
+
+2021-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90333
+	* g++.dg/ext/attr-lambda3.C: New test.
+
+2021-02-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-14  Harald Anlauf  <anlauf@gmx.de>
+
+	* substr_10.f90: New test.
+	* substr_9.f90: New test.
+
+2021-02-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99124
+	* gfortran.dg/class_defined_operator_2.f03 : New test.
+	* gfortran.dg/elemental_result_2.f90 : New test.
+	* gfortran.dg/class_assign_4.f90: Correct the non-conforming
+	elemental function with an allocatable result with an operator
+	interface with array dummies and result.
+
+2021-02-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-02-21  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/intent_optimize_3.f90: New test.
+
+2021-02-11  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-02-11  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/99060
+	* gfortran.dg/pr99060.f90: New test.
+
+2021-02-05  Matthias Klose  <doko@ubuntu.com>
+
+	Backported from master:
+	2020-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97236
+	* gcc.dg/vect/pr97236.c: New testcase.
+
+2021-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97528
+	* gcc.target/arm/pr97528.c: New test.
+
+2021-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63707
+	* g++.dg/cpp0x/initlist-array13.C: New test.
+
+2021-01-29  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-01-29  Bin Cheng  <bin.cheng@linux.alibaba.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97627
+	* g++.dg/pr97627.C: New testcase.
+
+2021-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/86470
+	* gfortran.dg/gomp/pr86470.f90: New test.
+
+2021-01-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/thunk2.adb, gnat.dg/thunk2.ads: New test.
+	* gnat.dg/thunk2_pkg.ads: New helper.
+
+2021-01-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2021-01-25  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/98517
+	* gfortran.dg/charlen_18.f90 : New test.
+
+2021-01-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93833
+	* gfortran.dg/deferred_character_36.f90 : New test.
+
+2021-01-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98022
+	* gfortran.dg/data_inquiry_ref.f90: Change to dg-compile and
+	add errors for inquiry references.
+
+2021-01-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/98022
+	* gfortran.dg/data_inquiry_ref.f90: New test.
+
+2021-01-21  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backported from master:
+	2019-10-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/98618
+	* gcc.target/aarch64/symbol-range.c: Improve testcase.
+	* gcc.target/aarch64/symbol-range-tiny.c: Likewise.
+
+2021-01-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-01-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91640
+	* gfortran.dg/contiguous_10.f90: New.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96325
+	* gfortran.dg/pr96325.f90: Change from run to compile.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-02  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96325
+	* gfortran.dg/pr96325.f90: New test.
+	* gfortran.dg/pr91589.f90: Update error message.
+
+2021-01-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	PR fortran/96012
+	* gfortran.dg/dependency_60.f90: New test.
+	* gfortran.dg/class_allocate_25.f90: New test.
+	* gfortran.dg/class_assign_4.f90: New test.
+	* gfortran.dg/unlimited_polymorphic_32.f03: New test.
+
+2021-01-06  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-04-14  Tobias Burnus  <tobias@codesourcery.com>
+
+	* gfortran.dg/use_rename_10.f90: New.
+	* gfortran.dg/use_rename_11.f90: New.
+
+2021-01-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-12-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92587
+	* gfortran.dg/finalize_37.f90: New test.
+
+2021-01-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96320
+	* gfortran.dg/module_procedure_4.f90 : New test.
+
+2021-01-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/94246
+	* gfortran.dg/bessel_5_redux.f90 : New test.
+
+2020-12-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-25  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/pr93685_1.f90: New test.
+	* gfortran.dg/pr93685_2.f90: New test.
+
+2020-12-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* gcc.target/i386/pr96793-2.c: New test.
+
+2020-12-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/96100
+	PR fortran/96101
+	* gfortran.dg/char_length_23.f90: New test.
+
+2020-12-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* gcc.target/i386/pr96793-1.c: New test.
+
+2020-12-24  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backported from master:
+	2020-12-05  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/97421
+	* gcc.c-torture/execute/pr97421-1.c: New test.
+	* gcc.c-torture/execute/pr97421-2.c: New test.
+	* gcc.c-torture/execute/pr97421-3.c: New test.
+
+2020-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/98307
+	* gfortran.dg/forall_19.f90: New test.
+
+2020-12-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/96793
+	* gcc.target/i386/pr96793.c: New test.
+
+2020-12-16  Nathan Sidwell  <nathan@acm.org>
+
+	* g++.dg/template/pr98297.C: New.
+
+2020-12-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-12-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98277
+	* gdc.dg/pr98277.d: New test.
+
+2020-12-14  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* lib/target-supports.exp (check_effective_target_tune_cortex_a76): New
+	effective target test.
+	* gcc.target/aarch64/with-tune-config.c: New test.
+	* gcc.target/aarch64/with-tune-march.c: Likewise.
+	* gcc.target/aarch64/with-tune-mcpu.c: Likewise.
+	* gcc.target/aarch64/with-tune-mtune.c: Likewise.
+
+2020-12-11  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-11-29  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/pr98017.f90: New test.
+
+2020-12-10  Ed Schonberg  <schonberg@adacore.com>
+
+	* gnat.dg/modular6.adb: New test.
+
+2020-12-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-12-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95342
+	* gfortran.dg/pr95342.f90: New test.
+
+2020-12-04  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-12-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96075
+	* gcc.dg/vect/slp-46.c: Add XFAIL for load-lanes.
+
+2020-12-03  Uroš Bizjak  <ubizjak@gmail.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/98086
+	* gcc.target/i386/pr98086.c: New test.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96075
+	* gcc.dg/vect/slp-46.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/96369
+	* c-c++-common/pr96369.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97812
+	* gcc.dg/torture/pr97812.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-10-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97255
+	* g++.dg/vect/pr97255.cc: New testcase.
+
+2020-12-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/97081
+	* gcc.dg/vect/pr97081-2.c: New test.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-09-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/97081
+	* gcc.dg/vect/pr97081.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96579
+	* gcc.dg/pr96579.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-07-30  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96370
+	* gcc.dg/pr96370.c: New testcase.
+
+2020-12-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-08-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/96514
+	* gcc.dg/pr96514.c: New testcase.
+
+2020-12-01  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/98002
+	* gcc.dg/strncmp-2.c: Call mprotect again before free.
+
+2020-11-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* gcc.target/arm/pr91816.c: New test.
+
+2020-11-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/overflow-6.c: New test.
+
+2020-11-26  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-26  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* c-c++-common/goacc/cache-3-1.c: New.
+	* c-c++-common/goacc/cache-3-2.c: Likewise.
+	* c-c++-common/goacc/data-clause-1.c: Likewise.
+	* c-c++-common/goacc/data-clause-2.c: Likewise.
+	* c-c++-common/gomp/map-1.c: Adjust.
+	* c-c++-common/gomp/map-2.c: Likewise.
+	* g++.dg/goacc/cache-3-1.C: New.
+	* g++.dg/goacc/cache-3-2.C: Likewise.
+	* g++.dg/goacc/data-clause-1.C: Likewise.
+	* g++.dg/goacc/data-clause-2.C: Likewise.
+	* g++.dg/gomp/map-1.C: Adjust.
+	* g++.dg/gomp/map-2.C: Likewise.
+
+2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* g++.dg/gomp/map-1.C: New.
+	* g++.dg/gomp/map-2.C: Likewise.
+	* c-c++-common/gomp/map-1.c: Adjust.
+	* c-c++-common/gomp/map-2.c: Likewise.
+
+2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* c-c++-common/goacc/cache-1.c: Update.
+	* c-c++-common/goacc/cache-2.c: Likewise.
+	* g++.dg/goacc/cache-1.C: New.
+	* g++.dg/goacc/cache-2.C: Likewise.
+
+2020-11-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/97918
+	* g++.dg/debug/localclass2.C: New test.
+
+2020-11-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/95158
+	* g++.dg/template/virtual5.C: New test.
+
+2020-11-24  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-24  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* lib/gcc-dg.exp (dg-optimized, dg-missed): Use 'saved-dg-warning'
+	instead of 'saved-dg-error'.
+
+2020-11-24  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-24  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* lib/gcc-dg.exp (dg-optimized, dg-missed): Fix 'process-message'
+	call.
+	* gcc.dg/vect/nodump-vect-opt-info-1.c: Demonstrate.
+	* gcc.dg/vect/nodump-vect-opt-info-2.c: Likewise.
+
+2020-11-17  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-10-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/97535
+	* gcc.target/aarch64/pr97535.c: Exclude ILP32.
+
+2020-11-17  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-10-27  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/97535
+	* gcc.target/aarch64/pr97535.c: New test.
+
+2020-11-17  Monk Chiang  <monk.chiang@sifive.com>
+
+	Backported from master:
+	2020-11-14  Monk Chiang  <monk.chiang@sifive.com>
+
+	PR target/97682
+	* g++.target/riscv/pr97682.C: New test.
+	* gcc.target/riscv/interrupt-3.c: Check register for t0.
+	* gcc.target/riscv/interrupt-4.c: Likewise.
+
+2020-11-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-10-07  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/88115
+	PR libstdc++/97273
+	* g++.dg/template/alignof3.C: New test.
+
+2020-11-12  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2020-11-10  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/95847
+	* gfortran.dg/coverage.f90: New test.
+
+2020-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/bias2.adb: New test.
+
+2020-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt89.adb: New test.
+
+2020-11-06  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2020-11-06  Peter Bergner  <bergner@linux.ibm.com>
+
+	* gcc.target/powerpc/pr64505.c: Run everywhere.  Use correct minimized
+	test case.
+
+2020-11-05  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/97392
+	* g++.dg/asan/asan_test.C: Disable -Wstringop-overflow.
+	* gcc.dg/asan/pr80166.c: Likewise.
+
+2020-11-03  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-11-03  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/97688
+	* gcc.dg/vect/tree-vect.h (check_vect): Fix the x86 cpuid
+	check to always specify subleaf zero.
+
+2020-10-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-18  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/matmul_20.f90: New test.
+
+2020-10-22  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backported from master:
+	2020-10-22  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.dg/dfp/pr97439.c: New test.
+
+2020-10-16  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-10-16  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/97404
+	* gcc.c-torture/execute/pr97404.c: New test.
+
+2020-10-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/97349
+	* gcc.target/aarch64/simd/pr97349.c: New test.
+
+2020-10-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-10-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* gdc.test/fail_compilation/fail21001.d: New test.
+	* gdc.test/fail_compilation/imports/fail21001b.d: New test.
+	* gdc.test/fail_compilation/imports/issue21295ast_node.d: New test.
+	* gdc.test/fail_compilation/imports/issue21295astcodegen.d: New test.
+	* gdc.test/fail_compilation/imports/issue21295dtemplate.d: New test.
+	* gdc.test/fail_compilation/imports/issue21295visitor.d: New test.
+	* gdc.test/fail_compilation/issue21295.d: New test.
+
+2020-10-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/97272
+	* gfortran.dg/pr97272.f90: New test.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/acle/rintnzx_1.c: New test.
+	* gcc.target/aarch64/simd/vrndnzx_1.c: Likewise.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/97150
+	* gcc.target/aarch64/pr97150.c: New test.
+
+2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-10-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/96313
+	* gcc.target/aarch64/pr96313.c: New test.
+	* gcc.target/aarch64/scalar_intrinsics.c (test_vqmovunh_s16):
+	Adjust return type.
+	(test_vqmovuns_s32): Likewise.
+	(test_vqmovund_s64): Likewise.
+
+2020-10-02  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2020-09-23  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/97069
+	* g++.dg/gcov/pr97069.C: New test.
+
+2020-09-30  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2020-09-30  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/97184
+	* gcc.target/i386/movdir64b.c: New test.
+	* gcc.target/i386/movdiri32.c: Likewise.
+	* gcc.target/i386/movdiri64.c: Likewise.
+	* lib/target-supports.exp (check_effective_target_movdir): New.
+
+2020-09-28  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backported from master:
+	2020-09-25  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/71233
+	* gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c: Remove
+	declarations of vector, vector2, vector_res for float64x2 type.
+	* gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c: Likewise.
+	* gcc.target/aarch64/advsimd-intrinsics/vzip_half.c: Likewise.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
+	(clean_results): Add float64x2_t cleanup.
+	(DECL_VARIABLE_128BITS_VARIANTS): Add float64x2_t variable.
+	* gcc.target/aarch64/advsimd-intrinsics/vreinterpret_p128.c: Add
+	testing of vreinterpretq_f64_p128, vreinterpretq_p128_f64.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vrndns_f32_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/trn_zip_p64_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vldrq_p128_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vstrq_p128_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vcls_unsigned_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vceq_poly_1.c: New test.
+
+2020-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-09-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/simd/vadd_poly_1.c: New test.
+
+2020-09-28  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Revert:
+	2020-09-28  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95614
+	* gfortran.dg/pr95614_1.f90: New test.
+	* gfortran.dg/pr95614_2.f90: New test.
+
+2020-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/97073
+	* gcc.c-torture/execute/pr97073.c: New test.
+
+2020-09-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-09-27  Steven G. Kargl  <kargl@gcc.gnu.org>
+		    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95614
+	* gfortran.dg/pr95614_1.f90: New test.
+	* gfortran.dg/pr95614_2.f90: New test.
+
+2020-09-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/acle/rng_1.c: New test.
+
+2020-09-24  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2020-09-16  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/97032
+	* gcc.target/i386/pr97032.c: New test.
+
+2020-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2020-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+		    Andrea Corallo   <andrea.corallo@arm.com>
+
+	PR target/71233
+	* gcc.target/aarch64/acle/jcvt_1.c: New test.
+	* gcc.target/aarch64/acle/jcvt_2.c: New testcase.
+	* lib/target-supports.exp
+	(check_effective_target_aarch64_fjcvtzs_hw): Add new check for
+	FJCVTZS hw.
+
+2020-09-19  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-02  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/93423
+	* gfortran.dg/pr93423.f90: New file.
+
+2020-09-18  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/97053
+	* gcc.dg/store_merging_31.c: New test.
+	* gcc.dg/store_merging_32.c: New test.
+
+2020-09-17  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/xsave-avx-1.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/96862
+	* g++.dg/cpp1z/constexpr-96862.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/96722
+	* g++.dg/opt/pr96722.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/96571
+	* gcc.dg/Wunused-var-4.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/96545
+	* c-c++-common/pr96545.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/96426
+	* gcc.c-torture/compile/pr96426.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-07-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/96174
+	* gcc.target/i386/avx512f-vcmppd-3.c: New test.
+	* gcc.target/i386/avx512f-vcmpps-3.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/95857
+	* gcc.dg/pr95857.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-06-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95903
+	* c-c++-common/pr95903.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-06-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95810
+	* gcc.dg/ubsan/pr95810.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/95328
+	* g++.dg/cpp1z/decomp53.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/95108
+	* gcc.dg/gomp/pr95108.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/95080
+	* g++.dg/opt/pr95080.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94951
+	* g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94873
+	* gcc.dg/pr94873.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94842
+	* gcc.dg/pr94842.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94809
+	* gcc.c-torture/execute/pr94809.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94780
+	* gcc.dg/pr94780.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94755
+	* c-c++-common/pr94755.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94742
+	* g++.dg/warn/Wreturn-type-12.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94705
+	* gcc.dg/pr94705.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94641
+	* c-c++-common/ubsan/pr94641.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94618
+	* g++.dg/opt/pr94618.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94621
+	* gcc.c-torture/compile/pr94621.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94571
+	* g++.dg/cpp1z/decomp51.C: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94524
+	* gcc.c-torture/execute/pr94524-1.c: New test.
+	* gcc.c-torture/execute/pr94524-2.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94438
+	* gcc.target/i386/avx512bw-pr94438.c: New test.
+	* gcc.target/i386/avx512vlbw-pr94438.c: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-04-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94325
+	* g++.dg/ubsan/vptr-15.C: New test.
+
+2020-09-16  Sylvia Taylor  <sylvia.taylor@arm.com>
+
+	Backported from master:
+	2019-08-22  Sylvia Taylor  <sylvia.taylor@arm.com>
+
+	* gcc.target/aarch64/advsimd-intrinsics/vld1x4.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vst1x4.c: New test.
+
+2020-09-15  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/pr96139-a.c: New test.
+	* gcc.target/powerpc/pr96139-b.c: New test.
+	* gcc.target/powerpc/pr96139-c.c: New test.
+
+2020-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/97028
+	* gcc.target/i386/avx512f-pr97028.c: Untested fix.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/94947
+	* gcc.dg/torture/pr94947-1.c: New testcase.
+	* gcc.dg/torture/pr94947-2.c: Likewise.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95049
+	* gcc.dg/torture/pr95049.c: New testcase.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-05-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95133
+	* gcc.dg/pr95133.c: New testcase.
+
+2020-09-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2020-06-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/95717
+	* g++.dg/torture/pr95717.C: New testcase.
+
+2020-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/discr7.ads: New test.
+
+2020-09-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr59.adb: New test.
+	* gnat.dg/discr59_pkg1.ads: New helper.
+	* gnat.dg/discr59_pkg2.ads: Likewise.
+
+2020-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-09-03  Harald Anlauf  <anlauf@gmx.de>
+
+	* gfortran.dg/iall_masked.f90: New test.
+
+2020-09-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	* gcc.target/powerpc/fold-vec-logical-ands-longlong.c: Adjust.
+	* gcc.target/powerpc/fold-vec-logical-ors-longlong.c: Likewise.
+
+	Backported from master:
+	2019-12-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/92923
+	* gcc.target/powerpc/pr92923-1.c: New test.
+	* gcc.target/powerpc/pr92923-2.c: Likewise.
+
+	2020-02-08  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/93136
+	* gcc.dg/vmx/ops.c: Add -flax-vector-conversions to dg-options.
+	* gcc.target/powerpc/vsx-vector-6.h: Split tests into smaller functions.
+	* gcc.target/powerpc/vsx-vector-6.p7.c: Adjust scan-assembler-times
+	regex directives.  Adjust expected instruction counts.
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Likewise.
+	* gcc.target/powerpc/vsx-vector-6.p9.c: Likewise.
+
+2020-08-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/95882
+	* gfortran.dg/pr95882_1.f90: New test.
+	* gfortran.dg/pr95882_2.f90: New test.
+	* gfortran.dg/pr95882_3.f90: New test.
+	* gfortran.dg/pr95882_4.f90: New test.
+	* gfortran.dg/pr95882_5.f90: New test.
+
+2020-08-27  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backported from master:
+	2020-08-24  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/94538
+	* gcc.target/arm/pure-code/pr94538-1.c: New test.
+	* gcc.target/arm/pure-code/pr94538-2.c: New test.
+
+2020-08-24  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-24  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/96486
+	* gfortran.dg/pr96486.f90: New test.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* gcc.target/aarch64/cpunative/aarch64-cpunative.exp: New file.
+	* gcc.target/aarch64/cpunative/info_0: New test.
+	* gcc.target/aarch64/cpunative/info_1: New test.
+	* gcc.target/aarch64/cpunative/info_10: New test.
+	* gcc.target/aarch64/cpunative/info_11: New test.
+	* gcc.target/aarch64/cpunative/info_12: New test.
+	* gcc.target/aarch64/cpunative/info_13: New test.
+	* gcc.target/aarch64/cpunative/info_14: New test.
+	* gcc.target/aarch64/cpunative/info_15: New test.
+	* gcc.target/aarch64/cpunative/info_2: New test.
+	* gcc.target/aarch64/cpunative/info_3: New test.
+	* gcc.target/aarch64/cpunative/info_4: New test.
+	* gcc.target/aarch64/cpunative/info_5: New test.
+	* gcc.target/aarch64/cpunative/info_6: New test.
+	* gcc.target/aarch64/cpunative/info_7: New test.
+	* gcc.target/aarch64/cpunative/info_8: New test.
+	* gcc.target/aarch64/cpunative/info_9: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_0.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_1.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_10.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_13.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_14.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_2.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_3.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_4.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_5.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_6.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_7.c: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_8.c: New test.
+
+2020-08-21  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2020-07-17  Tamar Christina  <tamar.christina@arm.com>
+
+	* lib/gcc-dg.exp (dg-set-compiler-env-var, dg-set-target-env-var): Add
+	verbose output.
+
+2020-08-12  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/94077
+	* gcc.dg/gomp/pr82374.c: Add option -fno-common.
+
+2020-08-12  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backported from master:
+	2020-08-12  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/stack-protector-1.c: Adapt code to Cortex-M
+	restrictions.
+
+2020-08-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/96402
+	* gcc.target/aarch64/pr96402.c: New test.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-08-06  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/arm/stack-protector-1.c: New test.
+	* gcc.target/arm/stack-protector-2.c: Likewise.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-08-05  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/96191
+	* gcc.target/aarch64/stack-protector-1.c: New test.
+	* gcc.target/aarch64/stack-protector-2.c: Likewise.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-04-16  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR rtl-optimization/94605
+	* gcc.target/aarch64/sve/pr94605.c: New test.
+
+2020-08-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2020-07-13  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/95114
+	* g++.target/aarch64/pr95114.C: New test.
+
+2020-08-04  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	* gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c: New test.
+	* gcc.target/aarch64/sls-mitigation/sls-miti-blr.c: New test.
+
+2020-08-04  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	* gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c: New test.
+	* gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c:
+	New test.
+	* gcc.target/aarch64/sls-mitigation/sls-mitigation.exp: New file.
+	* lib/target-supports.exp (check_effective_target_aarch64_asm_sb_ok):
+	New proc.
+
+2020-08-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-07-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/96140
+	* gdc.dg/pr96140.d: New test.
+
+2020-07-27  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/95612
+	* gfortran.dg/pr95612.f90: New test.
+
+2020-07-26  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/95585
+	* gfortran.dg/pr95585.f90: New test.
+
+2020-07-25  Dominique d'Humieres  <dhumieres.dominique@free.fr>
+
+	Backported from master:
+	2020-07-24  Dominique d'Humieres  <dhumieres.dominique@free.fr>
+
+	PR fortran/93592
+	* gfortran.dg/fmt_en.f90: Adjust test.
+	* gfortran.dg/fmt_en_rd.f90: New test.
+	* gfortran.dg/fmt_en_rn.f90: New test.
+	* gfortran.dg/fmt_en_ru.f90: New test.
+	* gfortran.dg/fmt_en_rz.f90: New test.
+
+2020-07-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/89574
+	* gfortran.dg/pr89574.f90: New file.
+
+2020-07-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/96018
+	* gfortran.dg/implicit_pure_5.c: New file.
+	* gfortran.dg/implicit_pure_5.f90: New file.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94891
+	* gcc.target/aarch64/return_address_sign_1.c: Update test.
+
+2020-07-16  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2020-06-16  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/vector/align-1.c: Change target architecture
+	to z13.
+	* gcc.target/s390/vector/align-2.c: Change target architecture
+	to z13.
+
+2020-07-10  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/builtins-msum-runnable.c: New test.
+	* gcc.target/powerpc/vsx-builtin-msum.c: New test.
+	Modified from ...
+	(cherry picked from commit c1a57681a64150d2fc336ba8e055c5f82e3737e8)
+
+2020-07-10  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2020-07-09  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/95804
+	* gcc.dg/tree-ssa/pr95804.c: New test.
+
+2020-07-10  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backported from master:
+	2020-06-20  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/95638
+	* g++.dg/tree-ssa/pr95638.C: New test.
+
+2020-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-06  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95709
+	* gfortran.dg/pr95709.f90: New file.
+
+2020-07-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-07-02  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/93337
+	* gfortran.dg/pr93337.f90: New file.
+
+2020-07-06  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/94954
+	* gcc.target/powerpc/builtins-1-p9-runnable.c: Update.
+
+2020-07-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-30  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/88379
+	* gfortran.dg/pr88379.f90: New file.
+
+2020-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-29  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71706
+	* gfortran.dg/pr71706.f90: New file.
+
+2020-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95880
+	* gfortran.dg/pr95880.f90: New file.
+
+2020-07-01  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/95829
+	* gfortran.dg/pr95829.f90: New test.
+
+2020-06-30  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2020-05-18  Alex Coplan  <alex.coplan@arm.com>
+
+	* gcc.c-torture/compile/packed-aligned-1.c: New test.
+	* gcc.c-torture/execute/packed-aligned.c: New test.
+
+2020-06-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-29  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/95743
+	* gfortran.dg/recursive_check_16.f90: New file.
+
+2020-06-27  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95881
+	* gfortran.dg/pr95881.f90: New file.
+
+2020-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-06-25  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95250
+	* gdc.dg/pr95250.d: New test.
+
+2020-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2020-06-25  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95173
+	* gdc.dg/pr95173.d: New test.
+
+2020-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95689
+	* gfortran.dg/pr95689.f90: New test.
+	(reverts the cherry-pick from commit 62c0c0ea7bfb6f8f6b8d767b05120cafb6823da6)
+
+2020-06-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95689
+	* gfortran.dg/pr95689.f90: New file.
+
+2020-06-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-06-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95587
+	* gfortran.dg/pr95587.f90: New file.
+
+2020-06-23  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-06-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/95708
+	* gfortran.dg/pr95708.f90: New test.
+
+2020-06-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-06-17  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* c-c++-common/gomp/hsa-indirect-call-1.c: New file.
+
+2020-06-16  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/95678
+	* g++.dg/cpp0x/dependent3.C: New test.
+
+2020-06-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95503
+	* gfortran.dg/pr95503.f90: New test.
+
+2020-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/94109
+	* gfortran.dg/finalize_34.f90: Adjust free counts.
+	* gfortran.dg/finalize_36.f90: New test.
+
+2020-06-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/95344
+	* c-c++-common/Wparentheses-2.c: New test.
+
+2020-06-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/95560
+	* g++.dg/warn/Wshadow-compatible-local-3.C: New test.
+
+2020-06-11  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl   <kargl@gcc.gnu.org>
+
+	PR fortran/95611
+	* gfortran.dg/pr95611.f90: New file.
+
+2020-06-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95091
+	* gfortran.dg/pr95091.f90: New file.
+
+2020-06-06  Carl Love  <cel@us.ibm.com>
+
+	PR target/94833
+	* gcc.target/powerpc/builtins-8-p9-runnable.c (main): Add
+	additional test cases with zero vector elements.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95373
+	* gfortran.dg/pr95373_1.f90: Adjust error messages.
+	* gfortran.dg/pr95373_2.f90: Adjust error message.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95373
+	* gfortran.dg/pr95373_1.f90: New test.
+	* gfortran.dg/pr95373_2.f90: New test.
+
+2020-06-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95106
+	* gfortran.dg/equiv_11.f90: New test.
+
+2020-06-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+	    Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95500
+	* gfortran.dg/pr95500.f90: New test.
+
+2020-06-01  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/94361
+	* gfortran.dg/finalize_28.f90: Adjusted free counts.
+	* gfortran.dg/finalize_33.f90: Likewise.
+	* gfortran.dg/finalize_34.f90: Likewise.
+	* gfortran.dg/finalize_35.f90: New test.
+
+2020-05-29  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/94591
+	* gcc.c-torture/execute/pr94591.c: New test.
+
+2020-05-28  Steven G. Kargl  <kargl@gcc.gnu.org>
+	    Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/94397
+	* gfortran.dg/pr94397.F90: New test.
+
+2020-05-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/50392
+	* gfortran.dg/pr50392.f: New test.
+
+2020-05-27  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl   <kargl@gcc.gnu.org>
+
+	PR libfortran/95104
+	* gfortran.dg/pr95104.f90: New test.
+
+2020-05-26  Alexandre Oliva  <oliva@adacore.com>
+
+	PR target/94812
+	* gcc.target/powerpc/test_mffsl.c: Call mffsl only once.
+	Reinterpret the doubles as long longs for compares.  Mask out
+	mffs bits that are not expected from mffsl.
+
+2020-05-22  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backport from master
+	PR tree-optimization/95110
+	2020-05-13  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/tree-ssa/pr94969.c: Swap scan-tree-dump-not arguments.
+
+2020-05-22  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backport from master
+	PR tree-optimization/94969
+	2020-05-13  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	* gcc.dg/tree-ssa/pr94969.c: New test.
+
+2020-05-21  Martin Liska  <mliska@suse.cz>
+
+	* gcc.target/aarch64/target_attr_20.c: New test.
+	* gcc.target/aarch64/target_attr_21.c: New test.
+
+2020-05-20  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/39695
+	* gfortran.dg/pr39695_1.f90: New test.
+	* gfortran.dg/pr39695_2.f90: New test.
+	* gfortran.dg/pr39695_3.f90: New test.
+	* gfortran.dg/pr39695_4.f90: New test.
+
+2020-05-18  Doug Rupp  <rupp@adacore.com>
+
+	* gcc.target/powerpc/pr71763.c: Require powerpc_vsx_ok.
+
+
+2020-05-18  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backport from mainline
+	2020-03-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/92216
+	* gdc.dg/imports/pr92216.d: New.
+	* gdc.dg/pr92216.d: New test.
+
+2020-05-17  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backport from mainline
+	2020-05-06  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/94970
+	* gdc.dg/pr94970.d: New test.
+
+2020-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/95155
+	* gdc.test/compilable/imports/pr9471a.d: New test.
+	* gdc.test/compilable/imports/pr9471b.d: New test.
+	* gdc.test/compilable/imports/pr9471c.d: New test.
+	* gdc.test/compilable/imports/pr9471d.d: New test.
+	* gdc.test/compilable/pr9471.d: New test.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-30  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94748
+	* gcc.target/aarch64/pr94748.c: New test.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-27  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94515
+	* g++.target/aarch64/pr94515-1.C: New test.
+	* g++.target/aarch64/pr94515-2.C: New test.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-23  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94514
+	* g++.target/aarch64/pr94514.C: Require lp64.
+	* gcc.target/aarch64/pr94514.c: Likewise.
+
+	Backport from mainline.
+	2020-04-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94514
+	* g++.target/aarch64/pr94514.C: New test.
+	* gcc.target/aarch64/pr94514.c: New test.
+
+2020-05-13  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master
+	2020-05-13  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/93497
+	* gfortran.dg/pr88025.f90: Change in wording of error.
+	* gfortran.dg/pr93497.f90: New test.
+	* gfortran.dg/pr93714_1.f90: Change in wording of errors.
+	* gfortran.dg/pr93714_2.f90: Change in wording of errors.
+
+2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+    
+	Backported from mainline
+	2020-05-11  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/59107
+	* gfortran.dg/pr59107.f90: New test.
+
+2020-05-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94946
+	* g++.dg/ext/attr-parm-1.C: Enable the test also for lp64 x86, use
+	sysv_abi and ms_abi attributes in that case instead of fastcall and
+	no attribute.  Remove dg-options.
+
+2020-05-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-30  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec_load_len_r.c: New test.
+	* gcc.target/s390/zvector/vec_store_len_r.c: New test.
+
+2020-05-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline.
+	2020-03-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/93581
+	* gfortran.dg/inquiry_type_ref_6.f90 : New test.
+
+2020-05-04  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* g++.dg/pr94666.C: New test.
+
+2020-05-04  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2020-04-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/94613
+	* gcc.target/s390/zvector/pr94613.c: New test.
+	* gcc.target/s390/zvector/vec_sel-1.c: New test.
+
+2020-05-04  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/93674
+	Backport from master
+	2020-04-09  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	* g++.dg/pr93674.C: New test.
+
+2020-05-01  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/93956
+	PR fortran/94788
+	* gfortran.dg/pointer_assign_13.f90: Remove.
+
+2020-04-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-04-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93654
+	* gcc.target/i386/pr93654.c: New test.
+
+2020-04-24  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/93956
+	* gfortran.dg/pointer_assign_13.f90: New test.
+
+2020-04-23 Iain Sandoe <iain@sandoe.co.uk>
+
+	* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: Adjust for
+	changed inline namespace.
+	* g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C: Likewise.
+	* g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C: Likewise
+	* g++.dg/coroutines/coro.h: Likewise
+
+2020-04-21  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/94510
+	* g++.dg/init/array58.C: New test.
+	* g++.dg/init/array59.C: New test.
+	* g++.dg/cpp2a/nontype-class34.C: New test.
+	* g++.dg/cpp2a/nontype-class35.C: New test.
+
+2020-04-21  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from master
+	2020-04-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/94482
+	* gcc.dg/torture/pr94482.c: New test.
+	* gcc.dg/tree-ssa/pr94482-2.c: Likewise.
+
+2020-04-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline.
+	PR fortran/93364
+	* gfortran.dg/pr93364.f90: New test.
+
+2020-04-20  Andrea Corallo  <andrea.corallo@arm.com>
+
+	Backport from mainline.
+	2020-04-09  Andrea Corallo  <andrea.corallo@arm.com
+
+	PR target/94530
+	* gcc.target/aarch64/pr94530.c: New test.
+
+2020-04-20  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from mainline.
+	2020-04-03  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/94396
+	* gcc.target/aarch64/options_set_11.c: New test.
+	* gcc.target/aarch64/options_set_12.c: New test.
+	* gcc.target/aarch64/options_set_13.c: New test.
+	* gcc.target/aarch64/options_set_14.c: New test.
+	* gcc.target/aarch64/options_set_15.c: New test.
+	* gcc.target/aarch64/options_set_16.c: New test.
+	* gcc.target/aarch64/options_set_17.c: New test.
+	* gcc.target/aarch64/options_set_18.c: New test.
+	* gcc.target/aarch64/options_set_19.c: New test.
+	* gcc.target/aarch64/options_set_20.c: New test.
+	* gcc.target/aarch64/options_set_21.c: New test.
+	* gcc.target/aarch64/options_set_22.c: New test.
+	* gcc.target/aarch64/options_set_23.c: New test.
+	* gcc.target/aarch64/options_set_24.c: New test.
+	* gcc.target/aarch64/options_set_25.c: New test.
+	* gcc.target/aarch64/options_set_26.c: New test.
+
+2020-04-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-04-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/94417
+	* gcc.target/i386/pr94417-1.c: New test.
+	* gcc.target/i386/pr94417-2.c: Likewise.
+	* gcc.target/i386/pr94417-3.c: Likewise.
+
+2020-04-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2020-04-03  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR tree-optimization/94443
+	* gcc.dg/vect/pr94443.c: New test.
+
+2020-04-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2020-04-01  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR tree-optimization/94043
+	* gfortran.dg/graphite/vect-pr94043.f90: New test.
+
+2020-04-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-04-07  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/94479
+	* gcc.dg/torture/pr94479.c: New testcase.
+
+2020-04-15  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline.
+	2020-04-13  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR target/94584
+	* gcc.target/xtensa/pr94584.c: New test.
+
+2020-04-15  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline.
+	2019-09-26  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* gcc.target/xtensa/pr91880.c: New test case.
+	* gcc.target/xtensa/xtensa.exp: New test suite.
+
+2020-04-15  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/94603
+	* gcc.target/i386/pr94603.c: New test.
+
+2020-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/94270
+	* gfortran.dg/warn_unused_dummy_argument_6.f90: New test.
+
+2020-04-11  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/94494
+	* gcc.target/i386/pr94494.c: New test.
+
+2020-04-07  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from mainline.
+	2020-03-23  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	    * gcc.target/powerpc/pragma_power6.c: New.
+	    * gcc.target/powerpc/pragma_power7.c: New.
+	    * gcc.target/powerpc/pragma_power8.c: New.
+	    * gcc.target/powerpc/pragma_power9.c: New.
+	    * gcc.target/powerpc/pragma_misc9.c: New.
+	    * gcc.target/powerpc/vsu/pragma_misc9.c: New.
+	    * gcc.target/powerpc/vsu/vec-all-nez-7.c: Update.
+	    * gcc.target/powerpc/vsu/vec-any-eqz-7.c: Update.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94509
+	* gcc.target/i386/avx512bw-pr94509-1.c: New test.
+	* gcc.target/i386/avx512bw-pr94509-2.c: New test.
+
+	PR c++/94512
+	* g++.dg/gomp/pr94512.C: New test.
+
+	PR target/94488
+	* gcc.c-torture/compile/pr94488.c: New test.
+
+	Backported from mainline
+	2020-04-04  Hannes Domani  <ssbssa@yahoo.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94459
+	* g++.dg/debug/pr94459.C: New test.
+
+	2020-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94477
+	* g++.dg/gomp/pr94477.C: New test.
+
+	2020-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94460
+	* gcc.target/i386/avx2-pr94460.c: New test.
+
+	2020-04-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94423
+	* gcc.dg/ubsan/pr94423.c: New test.
+
+	2020-03-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94412
+	* gcc.c-torture/execute/pr94412.c: New test.
+
+	2020-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94385
+	* c-c++-common/pr94385.c: New test.
+
+	PR target/93069
+	* gcc.target/i386/avx512vl-pr93069.c: New test.
+	* gcc.dg/vect/pr93069.c: New test.
+
+	2020-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94329
+	* gfortran.dg/pr94329.f90: New test.
+
+	2020-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94303
+	* g++.dg/torture/pr94303.C: New test.
+
+	PR debug/94283
+	* gcc.dg/pr94283.c: New test.
+
+	2020-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94283
+	* gcc.target/i386/pr94283.c: New test.
+
+	PR debug/94277
+	* gcc.dg/pr94277.c: New test.
+
+	2020-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR gcov-profile/94029
+	* gcc.misc-tests/gcov-pr94029.c: New test.
+
+	PR tree-optimization/94211
+	* gcc.dg/pr94211.c: New test.
+
+	2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/94172
+	* gcc.dg/pr94172-1.c: New test.
+	* gcc.dg/pr94172-2.c: New test.
+
+	PR c++/90995
+	* g++.dg/cpp0x/enum40.C: New test.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94500
+	* gcc.target/i386/avx512bw-pr94500.c: New test.
+
+2020-04-06  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backport from master.
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/93686
+	* gfortran.dg/pr93686_1.f90: New test.
+	* gfortran.dg/pr93686_2.f90: Likewise.
+	* gfortran.dg/pr93686_3.f90: Likewise.
+	* gfortran.dg/pr93686_4.f90: Likewise.
+
+2020-04-05  Marek Polacek  <polacek@redhat.com>
+
+	2020-02-06  Marek Polacek  <polacek@redhat.com>
+	Backport from mainline
+
+	PR c++/93597 - ICE with lambda in operator function.
+	* g++.dg/cpp0x/lambda/lambda-93597.C: New test.
+
+2020-04-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/93435
+	* gcc.dg/tree-ssa/pr93435.c: New test.
+
+2020-04-02  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backport from master.
+	2020-04-02  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/85982
+	* gfortran.dg/dec_structure_28.f90: New test.
+
+2020-04-02  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2020-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/94103
+	* gcc.target/i386/pr94103.c: New testcase.
+
+	2020-03-18  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/94206
+	* gcc.dg/torture/pr94206.c: New testcase.
+
+2020-04-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94435
+	* gcc.target/aarch64/pr94435.c: New test.
+
+2020-04-02  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	Mark Eggleston  <mark.eggleston@codethink.com>
+
+	PR fortran/93498
+	* gfortran.dg/pr93498_1.f90:  New test.
+	* gfortran.dg/pr93498_2.f90:  New test.
+
+2020-04-02  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	2020-04-02  Mark Eggleston <markeggleston@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/94030
+	* gfortran.dg/pr94030_1.f90: New test.
+	* gfortran.dg/pr94030_2.f90: New test.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2020-03-31  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/pr94368.c: New test.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* gcc.target/aarch64/atomic-op-acq_rel.c: Use -mno-outline-atomics.
+	* gcc.target/aarch64/atomic-comp-swap-release-acquire.c: Likewise.
+	* gcc.target/aarch64/atomic-op-acquire.c: Likewise.
+	* gcc.target/aarch64/atomic-op-char.c: Likewise.
+	* gcc.target/aarch64/atomic-op-consume.c: Likewise.
+	* gcc.target/aarch64/atomic-op-imm.c: Likewise.
+	* gcc.target/aarch64/atomic-op-int.c: Likewise.
+	* gcc.target/aarch64/atomic-op-long.c: Likewise.
+	* gcc.target/aarch64/atomic-op-relaxed.c: Likewise.
+	* gcc.target/aarch64/atomic-op-release.c: Likewise.
+	* gcc.target/aarch64/atomic-op-seq_cst.c: Likewise.
+	* gcc.target/aarch64/atomic-op-short.c: Likewise.
+	* gcc.target/aarch64/atomic_cmp_exchange_zero_reg_1.c: Likewise.
+	* gcc.target/aarch64/atomic_cmp_exchange_zero_strong_1.c: Likewise.
+	* gcc.target/aarch64/sync-comp-swap.c: Likewise.
+	* gcc.target/aarch64/sync-op-acquire.c: Likewise.
+	* gcc.target/aarch64/sync-op-full.c: Likewise.
+
+2020-03-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2020-03-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/94348
+	* gfortran.dg/module_procedure_3.f90: New.
+
+2020-03-25  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	Backport from master
+	2020-03-25  Mark Eggleston <markeggleston@gcc.gnu.org>
+
+	PR fortran/93484
+	* gfortran.dg/pr93484_1.f90: New test.
+	* gfortran.dg/pr93484_2.f90: New test.
+
+2020-03-25  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from master
+	2020-03-13  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR testsuite/93935
+	* gcc.dg/vect/bb-slp-over-widen-2.c: Expect basic block vectorized
+	messages only on vect_hw_misalign targets.
+
+2020-03-24  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/94052
+	* g++.target/aarch64/pr94052.C: New test.
+
+2020-03-24  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	Backport from mainline
+	2020-03-16  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/94125
+	* gcc.dg/tree-ssa/pr94125.c: New test.
+
+2020-03-23  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from mainline
+	2020-03-10  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/90763
+	* gcc.target/powerpc/pr90763.c: New.
+
+2020-03-19  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/93709
+	* gcc.target/powerpc/p9-minmax-3.c: New test.
+
+2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/94189
+	* gcc.dg/pr94189.c: New test.
+
+	Backported from mainline
+	2020-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/94167
+	* gcc.dg/pr94167.c: New test.
+
+	2020-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/94130
+	* gcc.c-torture/execute/pr94130.c: New test.
+
+	2020-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/94134
+	* gcc.c-torture/execute/pr94134.c: New test.
+
+	PR target/94121
+	* gcc.dg/pr94121.c: New test.
+
+	PR middle-end/94111
+	* gcc.dg/dfp/pr94111.c: New test.
+
+	PR tree-optimization/94114
+	* gcc.dg/pr94114.c: New test.
+
+	2020-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93399
+	* gcc.dg/pr93399.c: New test.
+
+	2020-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/93888
+	* g++.dg/guality/pr93888.C: New test.
+
+	PR tree-optimization/94001
+	* gcc.dg/pr94001.c: New test.
+
+2020-03-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from master
+	2020-03-09  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR testsuite/94019
+	* gcc.dg/vect/vect-over-widen-17.c: Don't expect vector char if it's
+	without misaligned vector access support.
+
+2020-03-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from master
+	2020-03-09  Kewen Lin  <linkw@gcc.gnu.org>
+
+	PR testsuite/94023
+	* gcc.dg/vect/slp-perm-12.c: Expect loop vectorized messages only on
+	vect_hw_misalign targets.
+
+2020-03-12  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from master
+	2020-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91913
+	* gfortran.dg/pr91913.f90: New test.
+
+2020-03-12  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-03-09  Martin Liska  <mliska@suse.cz>
+
+	PR target/93800
+	* gcc.target/powerpc/pr93800.c: New test.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/Wparentheses-2.c b/gcc/testsuite/c-c++-common/Wparentheses-2.c
new file mode 100644
index 00000000000..1aa5d314ae7
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wparentheses-2.c
@@ -0,0 +1,18 @@
+// PR c++/95344 - bogus -Wparentheses warning.
+// { dg-do compile }
+// { dg-options "-Wparentheses" }
+
+#ifndef __cplusplus
+# define bool _Bool
+# define true 1
+# define false 0
+#endif
+
+void
+f (int i)
+{
+  bool b = false;
+  if (i == 99 ? (b = true) : false) // { dg-bogus "suggest parentheses" }
+    {
+    }
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/asyncwait-1.c b/gcc/testsuite/c-c++-common/goacc/asyncwait-1.c
index 2f5d4762b49..1857d65a0b2 100644
--- a/gcc/testsuite/c-c++-common/goacc/asyncwait-1.c
+++ b/gcc/testsuite/c-c++-common/goacc/asyncwait-1.c
@@ -9,7 +9,7 @@ f (int N, float *a, float *b)
             b[ii] = a[ii];
     }
 
-#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,) /* { dg-error "expected '\\)' before ',' token" } */
     {
         for (ii = 0; ii < N; ii++)
             b[ii] = a[ii];
@@ -21,19 +21,19 @@ f (int N, float *a, float *b)
             b[ii] = a[ii];
     }
 
-#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,) /* { dg-error "expected '\\)' before ',' token" } */
     {
         for (ii = 0; ii < N; ii++)
             b[ii] = a[ii];
     }
 
-#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2 3) /* { dg-error "expected '\\)' before numeric constant" } */
+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2 3) /* { dg-error "expected '\\)' before ',' token" } */
     {
         for (ii = 0; ii < N; ii++)
             b[ii] = a[ii];
     }
 
-#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,,) /* { dg-error "expected '\\)' before ',' token" } */
     {
         for (ii = 0; ii < N; ii++)
             b[ii] = a[ii];
@@ -193,15 +193,15 @@ f (int N, float *a, float *b)
 
 #pragma acc wait async (1 2) /* { dg-error "expected '\\)' before numeric constant" } */
 
-#pragma acc wait async (1,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc wait async (1,) /* { dg-error "expected '\\)' before ',' token" } */
 
 #pragma acc wait async (,1) /* { dg-error "expected (primary-|)expression before" } */
 
-#pragma acc wait async (1,2,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc wait async (1,2,) /* { dg-error "expected '\\)' before ',' token" } */
 
-#pragma acc wait async (1,2 3) /* { dg-error "expected '\\)' before numeric constant" } */
+#pragma acc wait async (1,2 3) /* { dg-error "expected '\\)' before ',' token" } */
 
-#pragma acc wait async (1,2,,) /* { dg-error "expected (primary-|)expression before" } */
+#pragma acc wait async (1,2,,) /* { dg-error "expected '\\)' before ',' token" } */
 
 #pragma acc wait async (1 /* { dg-error "expected '\\)' before end of line" } */
 
@@ -215,3 +215,10 @@ f (int N, float *a, float *b)
    /* { dg-error "expected integer expression before" "" { target c } .-1 } */
    /* { dg-error "expression must be integral" "" { target c++ } .-2 } */
 }
+
+/* PR c/99137 */
+void f2 ()
+{
+  #pragma acc parallel async(1,2)  /* { dg-error "expected '\\)' before ',' token" } */
+  ;
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/cache-1.c b/gcc/testsuite/c-c++-common/goacc/cache-1.c
index 1d4759e738c..242f3c612fd 100644
--- a/gcc/testsuite/c-c++-common/goacc/cache-1.c
+++ b/gcc/testsuite/c-c++-common/goacc/cache-1.c
@@ -1,9 +1,15 @@
-/* OpenACC cache directive: valid usage.  */
-/* For execution testing, this file is "#include"d from
-   libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c.  */
+/* OpenACC 'cache' directive: valid usage.  */
 
-int
-main (int argc, char **argv)
+/* See also corresponding C++ variant: '../../g++.dg/goacc/cache-1.C'.  */
+
+/* For execution testing, this file is '#include'd from
+   '../../../../libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c'.  */
+
+#ifdef TEMPLATIZE
+template <int N>
+#endif
+static void
+test ()
 {
 #define N   2
     int a[N], b[N];
@@ -61,6 +67,4 @@ main (int argc, char **argv)
         if (a[i] != b[i])
             __builtin_abort ();
     }
-
-    return 0;
 }
diff --git a/gcc/testsuite/c-c++-common/goacc/cache-2.c b/gcc/testsuite/c-c++-common/goacc/cache-2.c
index d1181d1b6e7..80b925e5112 100644
--- a/gcc/testsuite/c-c++-common/goacc/cache-2.c
+++ b/gcc/testsuite/c-c++-common/goacc/cache-2.c
@@ -1,7 +1,9 @@
-/* OpenACC cache directive: invalid usage.  */
+/* OpenACC 'cache' directive: invalid usage.  */
 
-int
-main (int argc, char **argv)
+/* See also corresponding C++ variant: '../../g++.dg/goacc/cache-2.C'.  */
+
+static void
+test ()
 {
 #define N   2
     int a[N], b[N];
@@ -52,6 +54,4 @@ main (int argc, char **argv)
         if (a[i] != b[i])
             __builtin_abort ();
     }
-
-    return 0;
 }
diff --git a/gcc/testsuite/c-c++-common/goacc/cache-3-1.c b/gcc/testsuite/c-c++-common/goacc/cache-3-1.c
new file mode 100644
index 00000000000..155de689dfa
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/cache-3-1.c
@@ -0,0 +1,116 @@
+/* Test 'cache' directive diagnostics.  */
+
+/* See also corresponding C++ variant: '../../g++.dg/goacc/cache-3-1.C'.  */
+
+/* See also corresponding C/C++ data clause variant: 'data-clause-1.c'.  */
+
+/* { dg-additional-options "-fopenmp" } for '#pragma omp threadprivate'.  */
+
+/* The current implementation doesn't restrict where a 'cache' directive may
+   appear, so we don't make any special arrangements.  */
+
+extern int a[][10], a2[][10];
+int b[10], c[10][2], d[10], e[10], f[10];
+int b2[10], c2[10][2], d2[10], e2[10], f2[10];
+int k[10], l[10], m[10], n[10], o;
+int *p;
+int **q;
+int r[4][4][4][4][4];
+extern struct s s1;
+extern struct s s2[1]; /* { dg-error "array type has incomplete element type" "" { target c } } */
+int t[10];
+#pragma omp threadprivate (t)
+#pragma acc routine
+void bar (int *);
+
+void
+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],
+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])
+{
+  #pragma acc cache(bar[2:5]) /* { dg-error "is not a variable" } */
+    ;
+  #pragma acc cache(t[2:5]) /* { dg-error "is threadprivate variable" } */
+    ;
+  #pragma acc cache(k[0.5:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(l[:7.5f]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(m[p:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(n[:p]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(o[2:5]) /* { dg-error "does not have pointer or array type" } */
+    ;
+  #pragma acc cache(s1) /* { dg-error "expected '\\\['" } */
+    ;
+  #pragma acc cache(s2) /* { dg-error "expected '\\\['" } */
+    ;
+  #pragma acc cache(a[:][:]) /* { dg-error "array type length expression must be specified" } */
+    bar (&a[0][0]); /* { dg-bogus "referenced in target region does not have a mappable type" } */
+  #pragma acc cache(b[-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (b);
+  #pragma acc cache(c[:-3][:]) /* { dg-error "negative length in array section" } */
+    bar (&c[0][0]);
+  #pragma acc cache(d[11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (d);
+  #pragma acc cache(e[:11]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (e);
+  #pragma acc cache(f[1:10]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (f);
+  #pragma acc cache(g[:][0:10]) /* { dg-error "for pointer type length expression must be specified" } */
+    bar (&g[0][0]);
+  #pragma acc cache(h[2:1][-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (&h[0][0]);
+  #pragma acc cache(h[:1][:-3]) /* { dg-error "negative length in array section" } */
+    bar (&h[0][0]);
+  #pragma acc cache(i[:1][11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (&i[0][0]);
+  #pragma acc cache(j[3:1][:10]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc cache(j[30:1][5:5]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc cache(a2[:1][2:4])
+    bar (&a2[0][0]);
+  #pragma acc cache(a2[3:5][:])
+    bar (&a2[0][0]);
+  #pragma acc cache(a2[3:5][:10])
+    bar (&a2[0][0]);
+  #pragma acc cache(b2[0:])
+    bar (b2);
+  #pragma acc cache(c2[:3][:])
+    bar (&c2[0][0]);
+  #pragma acc cache(d2[9:])
+    bar (d2);
+  #pragma acc cache(e2[:10])
+    bar (e2);
+  #pragma acc cache(f2[1:9])
+    bar (f2);
+  #pragma acc cache(g2[:1][2:4])
+    bar (&g2[0][0]);
+  #pragma acc cache(h2[2:2][0:])
+    bar (&h2[0][0]);
+  #pragma acc cache(h2[:1][:3])
+    bar (&h2[0][0]);
+  #pragma acc cache(i2[:1][9:])
+    bar (&i2[0][0]);
+  #pragma acc cache(j2[3:4][:9])
+    bar (&j2[0][0]);
+  #pragma acc cache(j2[30:1][5:4])
+    bar (&j2[0][0]);
+  #pragma acc cache(q[1:2])
+    ;
+  #pragma acc cache(q[3:5][:10]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2])
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][0:4])
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][1:][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:3][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][1:]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][:3]) /* { dg-error "array section is not contiguous" } */
+    ;
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/cache-3-2.c b/gcc/testsuite/c-c++-common/goacc/cache-3-2.c
new file mode 100644
index 00000000000..ea5222e7d0c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/cache-3-2.c
@@ -0,0 +1,50 @@
+/* Test 'cache' directive diagnostics.  */
+
+/* See also corresponding C++ variant: '../../g++.dg/goacc/cache-3-2.C'.  */
+
+/* See also corresponding C/C++ data clause variant: 'data-clause-2.c'.  */
+
+/* The current implementation doesn't restrict where a 'cache' directive may
+   appear, so we don't make any special arrangements.  */
+
+void
+foo (int *p, int (*q)[10], int r[10], int s[10][10])
+{
+  int a[10], b[10][10];
+  #pragma acc cache (p[-1:2])
+  ;
+  #pragma acc cache (q[-1:2][0:10])
+  ;
+  #pragma acc cache (q[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (r[-1:2])
+  ;
+  #pragma acc cache (s[-1:2][:])
+  ;
+  #pragma acc cache (s[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (a[-1:2])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (b[-1:2][0:])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (b[1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (p[2:-3])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (q[2:-3][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (q[2:3][0:-1])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (r[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (s[2:-5][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (s[2:5][0:-4])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (a[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (b[2:-5][0:10]) /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (b[2:5][0:-4]) /* { dg-error "negative length in array section in" } */
+  ;
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/data-clause-1.c b/gcc/testsuite/c-c++-common/goacc/data-clause-1.c
new file mode 100644
index 00000000000..20f822cbb99
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/data-clause-1.c
@@ -0,0 +1,115 @@
+/* Test data clause diagnostics.  */
+
+/* See also corresponding OpenACC C++ variant: '../../g++.dg/goacc/data-clause-1.C'.  */
+
+/* See also corresponding OpenACC 'cache' directive variant: 'cache-3-1.c'.  */
+
+/* See also corresponding OpenMP variant: '../gomp/map-1.c'.  */
+
+/* { dg-additional-options "-fopenmp" } for '#pragma omp threadprivate'.  */
+
+extern int a[][10], a2[][10];
+int b[10], c[10][2], d[10], e[10], f[10];
+int b2[10], c2[10][2], d2[10], e2[10], f2[10];
+int k[10], l[10], m[10], n[10], o;
+int *p;
+int **q;
+int r[4][4][4][4][4];
+extern struct s s1;
+extern struct s s2[1]; /* { dg-error "array type has incomplete element type" "" { target c } } */
+int t[10];
+#pragma omp threadprivate (t)
+#pragma acc routine
+void bar (int *);
+
+void
+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],
+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])
+{
+  #pragma acc parallel copyin(bar[2:5]) /* { dg-error "is not a variable" } */
+    ;
+  #pragma acc parallel copyout(t[2:5]) /* { dg-error "is threadprivate variable" } */
+    ;
+  #pragma acc parallel copy(k[0.5:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyout(l[:7.5f]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyin(m[p:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copy(n[:p]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyin(o[2:5]) /* { dg-error "does not have pointer or array type" } */
+    ;
+  #pragma acc parallel create(s1) /* { dg-error "'s1' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma acc parallel create(s2) /* { dg-error "'s2' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma acc parallel copyin(a[:][:]) /* { dg-error "array type length expression must be specified" } */
+    bar (&a[0][0]); /* { dg-error "referenced in target region does not have a mappable type" } */
+  #pragma acc parallel copy(b[-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (b);
+  #pragma acc parallel copy(c[:-3][:]) /* { dg-error "negative length in array section" } */
+    bar (&c[0][0]);
+  #pragma acc parallel copyout(d[11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (d);
+  #pragma acc parallel copyin(e[:11]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (e);
+  #pragma acc parallel copyin(f[1:10]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (f);
+  #pragma acc parallel copyout(g[:][0:10]) /* { dg-error "for pointer type length expression must be specified" } */
+    bar (&g[0][0]);
+  #pragma acc parallel copyout(h[2:1][-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (&h[0][0]);
+  #pragma acc parallel copy(h[:1][:-3]) /* { dg-error "negative length in array section" } */
+    bar (&h[0][0]);
+  #pragma acc parallel copy(i[:1][11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (&i[0][0]);
+  #pragma acc parallel copyout(j[3:1][:10]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc parallel copyin(j[30:1][5:5]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc parallel copyin(a2[:1][2:4])
+    bar (&a2[0][0]);
+  #pragma acc parallel copy(a2[3:5][:])
+    bar (&a2[0][0]);
+  #pragma acc parallel copyin(a2[3:5][:10])
+    bar (&a2[0][0]);
+  #pragma acc parallel copy(b2[0:])
+    bar (b2);
+  #pragma acc parallel copy(c2[:3][:])
+    bar (&c2[0][0]);
+  #pragma acc parallel copyout(d2[9:])
+    bar (d2);
+  #pragma acc parallel copyin(e2[:10])
+    bar (e2);
+  #pragma acc parallel copyin(f2[1:9])
+    bar (f2);
+  #pragma acc parallel copy(g2[:1][2:4])
+    bar (&g2[0][0]);
+  #pragma acc parallel copyout(h2[2:2][0:])
+    bar (&h2[0][0]);
+  #pragma acc parallel copy(h2[:1][:3])
+    bar (&h2[0][0]);
+  #pragma acc parallel copyin(i2[:1][9:])
+    bar (&i2[0][0]);
+  #pragma acc parallel copyout(j2[3:4][:9])
+    bar (&j2[0][0]);
+  #pragma acc parallel copyin(j2[30:1][5:4])
+    bar (&j2[0][0]);
+  #pragma acc parallel copy(q[1:2])
+    ;
+  #pragma acc parallel copy(q[3:5][:10]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2])
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][0:4])
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][1:][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:3][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][1:]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][:3]) /* { dg-error "array section is not contiguous" } */
+    ;
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/data-clause-2.c b/gcc/testsuite/c-c++-common/goacc/data-clause-2.c
new file mode 100644
index 00000000000..d4603b016dd
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/data-clause-2.c
@@ -0,0 +1,49 @@
+/* Test data clause diagnostics.  */
+
+/* See also corresponding OpenACC C++ variant: '../../g++.dg/goacc/data-clause-2.C'.  */
+
+/* See also corresponding OpenACC 'cache' directive variant: 'cache-3-2.c'.  */
+
+/* See also corresponding OpenMP variant: '../gomp/map-2.c'.  */
+
+void
+foo (int *p, int (*q)[10], int r[10], int s[10][10])
+{
+  int a[10], b[10][10];
+  #pragma acc parallel copy (p[-1:2])
+  ;
+  #pragma acc parallel copy (q[-1:2][0:10])
+  ;
+  #pragma acc parallel copy (q[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (r[-1:2])
+  ;
+  #pragma acc parallel copy (s[-1:2][:])
+  ;
+  #pragma acc parallel copy (s[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (a[-1:2])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (b[-1:2][0:])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (b[1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (p[2:-3])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (q[2:-3][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (q[2:3][0:-1])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (r[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (s[2:-5][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (s[2:5][0:-4])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (a[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (b[2:-5][0:10]) /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (b[2:5][0:-4]) /* { dg-error "negative length in array section in" } */
+  ;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/hsa-indirect-call-1.c b/gcc/testsuite/c-c++-common/gomp/hsa-indirect-call-1.c
new file mode 100644
index 00000000000..67ee6af309a
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/hsa-indirect-call-1.c
@@ -0,0 +1,24 @@
+/* Instead of ICE, we'd like "HSA does not implement indirect calls".  */
+
+/* Reduced from 'libgomp.c/target-39.c'.  */
+
+/* { dg-require-effective-target offload_hsa } */
+/* { dg-additional-options "-Whsa" } to override '{gcc,g++}.dg/gomp/gomp.exp'.  */
+
+typedef void (*fnp) (void);
+void f1 (void) { }
+fnp f2 (void) { return f1; }
+#pragma omp declare target to (f1, f2)
+
+int
+main ()
+{
+  #pragma omp target
+  {
+    fnp fnp = f2 ();
+    fnp (); /* { dg-message "note: support for HSA does not implement indirect calls" } */
+  }
+  return 0;
+}
+
+/* { dg-warning "could not emit HSAIL for the function" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/c-c++-common/gomp/map-1.c b/gcc/testsuite/c-c++-common/gomp/map-1.c
index 5dad7d6a9aa..a8549bc49d9 100644
--- a/gcc/testsuite/c-c++-common/gomp/map-1.c
+++ b/gcc/testsuite/c-c++-common/gomp/map-1.c
@@ -1,5 +1,8 @@
-/* { dg-do compile } */
-/* { dg-options "-fopenmp" } */
+/* Test 'map' clause diagnostics.  */
+
+/* See also corresponding OpenMP C++ variant: '../../g++.dg/gomp/map-1.C'.  */
+
+/* See also corresponding OpenACC variant: '../goacc/data-clause-1.c'.  */
 
 extern int a[][10], a2[][10];
 int b[10], c[10][2], d[10], e[10], f[10];
diff --git a/gcc/testsuite/c-c++-common/gomp/map-2.c b/gcc/testsuite/c-c++-common/gomp/map-2.c
index 101f4047b85..01fb4be869d 100644
--- a/gcc/testsuite/c-c++-common/gomp/map-2.c
+++ b/gcc/testsuite/c-c++-common/gomp/map-2.c
@@ -1,5 +1,8 @@
-/* { dg-do compile } */
-/* { dg-options "-fopenmp" } */
+/* Test 'map' clause diagnostics.  */
+
+/* See also corresponding OpenMP C++ variant: '../../g++.dg/gomp/map-2.C'.  */
+
+/* See also corresponding OpenACC variant: '../goacc/data-clause-2.c'.  */
 
 void
 foo (int *p, int (*q)[10], int r[10], int s[10][10])
diff --git a/gcc/testsuite/c-c++-common/pr94385.c b/gcc/testsuite/c-c++-common/pr94385.c
new file mode 100644
index 00000000000..0611921295c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr94385.c
@@ -0,0 +1,12 @@
+/* PR c++/94385 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+typedef int V __attribute__((__vector_size__(16)));
+typedef float W __attribute__((__vector_size__(16)));
+
+void
+foo (W *x, V *y)
+{
+  *y = (({ __builtin_convertvector (*x, V); }));
+}
diff --git a/gcc/testsuite/c-c++-common/pr94755.c b/gcc/testsuite/c-c++-common/pr94755.c
new file mode 100644
index 00000000000..3520864c77a
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr94755.c
@@ -0,0 +1,11 @@
+/* PR c/94755 */
+/* { dg-do compile } */
+
+extern void foo (void);
+
+void
+bar (double x)
+{
+  if (x == __builtin_speculation_safe_value ())	/* { dg-error "too few arguments to function" } */
+    foo ();
+}
diff --git a/gcc/testsuite/c-c++-common/pr95903.c b/gcc/testsuite/c-c++-common/pr95903.c
new file mode 100644
index 00000000000..6e9f68e200f
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95903.c
@@ -0,0 +1,19 @@
+/* PR middle-end/95903 */
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -fwrapv -fdump-tree-optimized" } */
+/* Verify that for -fwrapv the + 1 addition is performed in the parameter's
+   type before sign extending it.  */
+/* { dg-final { scan-tree-dump-times "off_\[0-9]+\\\(D\\\) \\+ 1" 2 "optimized" } } */
+
+char
+foo (const char *ptr, int off)
+{
+  off += 1;
+  return ptr[off];
+}
+
+char
+bar (const char *ptr, int off)
+{
+  return ptr[off + 1];
+}
diff --git a/gcc/testsuite/c-c++-common/pr96369.c b/gcc/testsuite/c-c++-common/pr96369.c
new file mode 100644
index 00000000000..8c468d9fec2
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr96369.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+int main()
+{
+  const long ONE = 1L;
+  long y = 0L;
+  long x = ((long) (ONE || (y = 1L)) % 8L);
+  if (y != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/c-c++-common/pr96545.c b/gcc/testsuite/c-c++-common/pr96545.c
new file mode 100644
index 00000000000..bc6b0cf345c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr96545.c
@@ -0,0 +1,31 @@
+/* PR c/96545 */
+/* { dg-do compile } */
+
+extern char x[], y[], z[];
+struct S;
+extern struct S s, t, u;
+int v, w;
+
+void
+foo (void)
+{
+  __atomic_exchange (&x, &y, &z, 0);	/* { dg-error "must be a pointer to a complete type" } */
+}
+
+void
+bar (void)
+{
+  __atomic_exchange (&s, &t, &u, 0);	/* { dg-error "must be a pointer to a complete type" } */
+}
+
+void
+baz (void)
+{
+  __atomic_exchange (&v, &t, &w, 0);	/* { dg-error "size mismatch in argument 2 of" } */
+}
+
+void
+qux (void)
+{
+  __atomic_exchange (&v, &w, &t, 0);	/* { dg-error "size mismatch in argument 3 of" } */
+}
diff --git a/gcc/testsuite/c-c++-common/ubsan/pr94641.c b/gcc/testsuite/c-c++-common/ubsan/pr94641.c
new file mode 100644
index 00000000000..b41cb06164d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/ubsan/pr94641.c
@@ -0,0 +1,11 @@
+/* PR c/94641 */
+/* { dg-do compile } */
+/* { dg-options "-fsanitize=undefined -Wpadded" } */
+
+void foo (void *) __attribute__((nonnull));
+
+void
+bar (void *p)
+{
+  foo (p);
+}
diff --git a/gcc/testsuite/g++.dg/abi/mangle72.C b/gcc/testsuite/g++.dg/abi/mangle72.C
index 656a0cae403..308865bd2c6 100644
--- a/gcc/testsuite/g++.dg/abi/mangle72.C
+++ b/gcc/testsuite/g++.dg/abi/mangle72.C
@@ -24,56 +24,50 @@ struct B { padm_t a[2]; };
 template <B> struct Y { };
 
 void g__ (Y<B{{ }}>) { }
-// { dg-final { scan-assembler "_Z3g__1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z3g__1YIXtl1BEEE" } }
 
 void g0_ (Y<B{{ 0 }}>) { }
-// { dg-final { scan-assembler "_Z3g0_1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z3g0_1YIXtl1BEEE" } }
 
 void g00 (Y<B{{ 0, 0 }}>) { }
-// { dg-final { scan-assembler "_Z3g001YIXtl1BtlA2_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z3g001YIXtl1BEEE" } }
 
 void g0x (Y<B{{ 0, &A::a }}>) { }
-// FIXME: This needs to mangle differently from g00.  The space at
-// the end is intentional to make the directive fail so that the xfail
-// can be reminder to change this once the mangling is fixed.
-// { dg-final { scan-assembler "_Z3g0x1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE " { xfail *-*-* } } }
+// { dg-final { scan-assembler "_Z3g0x1YIXtl1BtlA2_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE" } }
 
 void gx_ (Y<B{{ &A::a }}>) { }
-// { dg-final { scan-assembler "_Z3gx_1YIXtl1BtlA2_M1AA2_iLS3_0ELS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z3gx_1YIXtl1BtlA2_M1AA2_iadL_ZNS1_1aEEEEEE" } }
 
 
 struct C { padm_t a[3]; };
 template <C> struct Z { };
 
 void h___ (Z<C{{ }}>) { }
-// { dg-final { scan-assembler "_Z4h___1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h___1ZIXtl1CEEE" } }
 
 void h0__ (Z<C{{ 0 }}>) { }
-// { dg-final { scan-assembler "_Z4h0__1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h0__1ZIXtl1CEEE" } }
 
 void h00_ (Z<C{{ 0, 0 }}>) { }
-// { dg-final { scan-assembler "_Z4h00_1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h00_1ZIXtl1CEEE" } }
 
 void h000 (Z<C{{ 0, 0, 0 }}>) { }
-// { dg-final { scan-assembler "_Z4h0001ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h0001ZIXtl1CEEE" } }
 
 void h00x (Z<C{{ 0, 0, &A::a }}>) { }
-// FIXME: This needs to mangle differently from hx0_ and hx__.
-// { dg-final { scan-assembler "_Z4h00x1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE " { xfail *-*-*} } }
+// { dg-final { scan-assembler "_Z4h00x1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EadL_ZNS1_1aEEEEEE" } }
 
 void h0x0 (Z<C{{ 0, &A::a, 0 }}>) { }
-// { dg-final { scan-assembler "_Z4h0x01ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h0x01ZIXtl1CtlA3_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE" } }
 
 void h0x_ (Z<C{{ 0, &A::a }}>) { }
-// { dg-final { scan-assembler "_Z4h0x_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE" } }
+// { dg-final { scan-assembler "_Z4h0x_1ZIXtl1CtlA3_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE" } }
 
 void hx0_ (Z<C{{ &A::a, 0 }}>) { }
-// FIXME: This needs to mangle differently from h00x and hx__.
-// { dg-final { scan-assembler "_Z4hx0_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE " { xfail *-*-*} } }
+// { dg-final { scan-assembler "_Z4hx0_1ZIXtl1CtlA3_M1AA2_iadL_ZNS1_1aEEEEEE" } }
 
 void hx__ (Z<C{{ &A::a }}>) { }
-// FIXME: This needs to mangle differently from h00x and hx0_.
-// { dg-final { scan-assembler "_Z4hx__1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE " { xfail *-*-* } } }
+// { dg-final { scan-assembler "_Z4hx__1ZIXtl1CtlA3_M1AA2_iadL_ZNS1_1aEEEEEE" } }
 
 
 // Exercise arrays of pointers to function members.
diff --git a/gcc/testsuite/g++.dg/abi/mangle75.C b/gcc/testsuite/g++.dg/abi/mangle75.C
new file mode 100644
index 00000000000..f2661997a33
--- /dev/null
+++ b/gcc/testsuite/g++.dg/abi/mangle75.C
@@ -0,0 +1,13 @@
+// PR c++/91377
+// { dg-do compile { target c++11 } }
+
+struct f {
+  static constexpr int d = 3;
+  typedef int e;
+};
+template <int a> struct x { };
+template <typename g, g j, g m> using n = x<j + m>;
+template <typename ac> auto v() -> n<typename ac::e, 0, ac::d>;
+void af() { v<f>(); }
+
+// { dg-final { scan-assembler "_Z1vI1fE1xIXplLi0EsrT_1dEEv" } }
diff --git a/gcc/testsuite/g++.dg/asan/asan_test.C b/gcc/testsuite/g++.dg/asan/asan_test.C
index a151979946a..549b7cf01a2 100644
--- a/gcc/testsuite/g++.dg/asan/asan_test.C
+++ b/gcc/testsuite/g++.dg/asan/asan_test.C
@@ -2,7 +2,7 @@
 // { dg-skip-if "" { *-*-* } { "*" } { "-O2" } }
 // { dg-skip-if "" { *-*-* } { "-flto" } { "" } }
 // { dg-additional-sources "asan_globals_test-wrapper.cc" }
-// { dg-options "-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -Wno-alloc-size-larger-than -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl" }
+// { dg-options "-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -Wno-alloc-size-larger-than -Wno-stringop-overflow -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl" }
 // { dg-additional-options "-DASAN_NEEDS_SEGV=1" { target { ! arm*-*-* } } }
 // { dg-additional-options "-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0" { target arm*-*-* } }
 // { dg-additional-options "-DASAN_AVOID_EXPENSIVE_TESTS=1" { target { ! run_expensive_tests } } }
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-call5.C b/gcc/testsuite/g++.dg/cpp0x/decltype-call5.C
new file mode 100644
index 00000000000..81ef6e6f9c9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-call5.C
@@ -0,0 +1,7 @@
+// PR c++/95675
+// { dg-do compile { target c++11 } }
+
+struct b {};
+b operator|(b, b) { return {}; }
+b e, f, g;
+using h = decltype(e | f | g);
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-call6.C b/gcc/testsuite/g++.dg/cpp0x/decltype-call6.C
new file mode 100644
index 00000000000..4173b607689
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-call6.C
@@ -0,0 +1,12 @@
+// PR c++/95675
+// { dg-do compile { target c++11 } }
+
+struct a {};
+template <typename> struct b;
+template <typename bq, typename br> struct b<bq(br)> {
+  decltype(bq()(br())) c;
+};
+struct e {
+  operator a();
+};
+b<e (*(e))(a)> d;
diff --git a/gcc/testsuite/g++.dg/cpp0x/dependent3.C b/gcc/testsuite/g++.dg/cpp0x/dependent3.C
new file mode 100644
index 00000000000..caf7e1cd4a4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/dependent3.C
@@ -0,0 +1,28 @@
+// { dg-do compile { target c++11 } }
+
+template<typename c>
+struct d
+{
+  using e = c;
+};
+
+template<class f>
+struct g
+{
+  using h = typename d<f>::e;
+
+  template<class i, class j>
+  auto operator()(i, j k) -> decltype(h{k});
+};
+
+template<class l>
+void m()
+{
+  int a[1];
+  l{}(a, a);
+}
+
+int main()
+{
+  m<g<int *>>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum40.C b/gcc/testsuite/g++.dg/cpp0x/enum40.C
new file mode 100644
index 00000000000..cfdf2a4a18a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum40.C
@@ -0,0 +1,26 @@
+// PR c++/90995
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  enum : int a alignas;		// { dg-error "expected" }
+}
+
+void
+bar ()
+{
+  enum : int a;			// { dg-error "expected" }
+}
+
+void
+baz ()
+{
+  enum class a : int b alignas;	// { dg-error "expected" }
+}
+
+void
+qux ()
+{
+  enum class a : int b;		// { dg-error "expected" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-array13.C b/gcc/testsuite/g++.dg/cpp0x/initlist-array13.C
new file mode 100644
index 00000000000..92fe97164cd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-array13.C
@@ -0,0 +1,16 @@
+// PR c++/63707
+// { dg-do compile { target c++11 } }
+
+struct Child
+{
+  Child (int);
+  ~Child ();
+  Child (const Child &) = delete;
+};
+
+struct Parent
+{
+  Parent () : children {{5}, {7}} {}
+
+  Child children[2];
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-93597.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-93597.C
new file mode 100644
index 00000000000..257d9c7cdfd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-93597.C
@@ -0,0 +1,8 @@
+// PR c++/93597 - ICE with lambda in operator function.
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct S {
+  using T ::operator<;
+  void operator==(T x) { [x] { 0 < x; }; }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr1.C
new file mode 100644
index 00000000000..7cb1e239ebb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr1.C
@@ -0,0 +1,28 @@
+// PR c++/94453
+// { dg-do compile { target c++11 } }
+
+void *ay();
+template <typename f> f ay() { return *static_cast<f *>(ay()); }
+template <typename h>
+void bf() {
+  ay<h>()();
+}
+struct az {
+  template <typename h>
+  az(h);
+  using bk = void (*)();
+  bk bl;
+};
+template <typename h>
+az::az(h) { bl = bf<h>; }
+struct A {};
+void da(az);
+void di(A, int);
+void dk(A, az, az);
+void b() {
+  int data = 0;
+  auto n = [] {};
+  constexpr auto p = A{};
+  auto q = [=] { di(p, data); };
+  da([=] { dk(p, n, q); });
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr2.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr2.C
new file mode 100644
index 00000000000..b1982ab0506
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-constexpr2.C
@@ -0,0 +1,13 @@
+// PR c++/90212
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct tuple {
+    constexpr tuple(T&& t) : t(t) { }
+    int t;
+};
+
+void foo() {
+    constexpr tuple<int> v1{1};
+    constexpr auto v2 = v1;
+    [&]{ constexpr auto v2 = v1; };
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic10.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic10.C
new file mode 100644
index 00000000000..052283e6caa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic10.C
@@ -0,0 +1,12 @@
+// PR c++/92909
+// { dg-do compile { target c++11 } }
+
+template <class ... Ts>
+void foo()
+{
+    []
+    {
+        using T = Ts;
+    }();			// { dg-error "not expanded" }
+}
+template void foo<>();
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-template20.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template20.C
new file mode 100644
index 00000000000..06448d92f12
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template20.C
@@ -0,0 +1,13 @@
+// PR c++/90479
+// { dg-do compile { target c++11 } }
+
+template <int n>
+void foo ()
+{
+  static int i {100};
+  struct { int a {i++}; } b {};
+}
+int main ()
+{
+  foo<0> ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-alias2.C b/gcc/testsuite/g++.dg/cpp0x/variadic-alias2.C
new file mode 100644
index 00000000000..ab64866d35f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-alias2.C
@@ -0,0 +1,103 @@
+// PR c++/91966
+// { dg-do compile { target c++11 } }
+
+// Reduced to this include-free example. Further reduction is hard: Either
+// the bug(?) disappears, or the program becomes meaningless.
+
+template<class...>
+struct list {};
+
+struct nil;
+
+////////////////////////////////////////////////////////////////////////////////
+
+template<int n>
+struct number {
+  constexpr /*implicit*/ operator int() const { return n; }
+  using type = number<n>;
+};
+
+using false_ = number<0>;
+using true_ = number<1>;
+
+static_assert(!false_{}, "");
+static_assert(true_{}, "");
+
+template<int... ns> using numbers = list<number<ns>...>;
+
+////////////////////////////////////////////////////////////////////////////////
+
+template<class lhs, class rhs>
+struct less_impl;
+
+template<int lhs, int rhs>
+struct less_impl<number<lhs>, number<rhs>>
+  : number<(lhs < rhs)> {};
+
+template<class lhs, class rhs> using less = typename less_impl<lhs, rhs>::type;
+
+////////////////////////////////////////////////////////////////////////////////
+
+template<class v0, class... vs>
+struct sum_impl {
+  static_assert(sizeof...(vs) == 0, "see specialization");
+  using type = v0;
+};
+
+template<int v0, int v1, class... vs>
+struct sum_impl<number<v0>, number<v1>, vs...>
+  : sum_impl<number<v0 + v1>, vs...> {};
+
+template<class... nums> using sum = typename sum_impl<nums...>::type;
+
+////////////////////////////////////////////////////////////////////////////////
+
+template<class num>
+struct conditional_impl {
+  static_assert(num{}, "see specialization");
+
+  template<class T, class F>
+  using type = T;
+};
+
+template<>
+struct conditional_impl<false_> {
+  template<class T, class F>
+  using type = F;
+};
+
+template<class num, class T, class F>
+using conditional = typename conditional_impl<num>::template type<T, F>;
+
+////////////////////////////////////////////////////////////////////////////////
+
+template<class seq>
+struct min_filter_impl;
+
+template<class... nums>
+struct min_filter_impl<list<nums...>> {
+  template<class num>
+  using count_better_mins = sum<less<nums, num>...>;
+
+  using type = list<conditional<count_better_mins<nums>, nil, nums>...>;
+
+//using debug = list<conditional<count_better_mins<nums>, nil, void>...>;
+
+// error: expansion pattern 'conditional<typename sum_impl<less<nums, nums>...>::type, nil, void>' contains no parameter packs
+
+};
+
+template<class seq> using min_filter = typename min_filter_impl<seq>::type;
+
+////////////////////////////////////////////////////////////////////////////////
+
+void test_min_filter() {
+  using computed = min_filter<numbers<2, 7, 2>>;
+  using expected = list<number<2>, nil, number<2>>;
+  (void)(computed{} = expected{});// compiles for identical types
+
+// error: no match for 'operator=' (operand types are 'computed' {aka 'list<number<2>, number<7>, number<2> >'} and 'expected' {aka 'list<number<2>, nil, number<2> >'})
+
+}
+
+int main() {}
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic178.C b/gcc/testsuite/g++.dg/cpp0x/variadic178.C
new file mode 100644
index 00000000000..f0e65958de3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic178.C
@@ -0,0 +1,6 @@
+// PR c++/92068
+// { dg-do compile { target c++11 } }
+
+template <typename, typename> struct a;
+template <typename b, typename c, typename... d>
+struct a<b, c, d...> { };	// { dg-error "arguments" }
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction71.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction71.C
new file mode 100644
index 00000000000..2fc71de8d95
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction71.C
@@ -0,0 +1,6 @@
+// PR c++/93248
+// { dg-do compile { target c++17 } }
+
+template <typename T> struct S
+{ template <typename V> S (T, V, long = 0); };
+using U = decltype(S{0, 4u});
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-96862.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-96862.C
new file mode 100644
index 00000000000..0b5c2e81bd1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-96862.C
@@ -0,0 +1,20 @@
+// PR c++/96862
+// { dg-do compile { target c++17 } }
+// { dg-additional-options "-frounding-math" }
+
+constexpr double a = 0x1.0p+100 + 0x1.0p-100;
+const double b = 0x1.0p+100 + 0x1.0p-100;
+const double &&c = 0x1.0p+100 + 0x1.0p-100;
+static_assert (0x1.0p+100 + 0x1.0p-100 == 0x1.0p+100, "");
+
+void
+foo ()
+{
+  constexpr double d = 0x1.0p+100 + 0x1.0p-100;
+  const double e = 0x1.0p+100 + 0x1.0p-100;
+  const double &&f = 0x1.0p+100 + 0x1.0p-100;
+  static_assert (0x1.0p+100 + 0x1.0p-100 == 0x1.0p+100, "");
+}
+
+const double &g = a;
+const double &h = b;
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp51.C b/gcc/testsuite/g++.dg/cpp1z/decomp51.C
new file mode 100644
index 00000000000..fe8b998abc8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp51.C
@@ -0,0 +1,16 @@
+// PR c++/94571
+// { dg-do compile { target c++17 } }
+
+void
+foo ()
+{
+  int e[2], f[2];
+  auto [a,b] = e, [c,d] = f;	// { dg-error "expected ';' before ',' token" }
+}
+
+void
+bar ()
+{
+  int e[2];
+  auto [a, b] = e );		// { dg-error "expected ';' before '\\\)' token" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp53.C b/gcc/testsuite/g++.dg/cpp1z/decomp53.C
new file mode 100644
index 00000000000..b34e6ac7250
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp53.C
@@ -0,0 +1,22 @@
+// PR c++/95328
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+template <typename T>
+struct S
+{
+  int a, b;
+};
+
+template <typename T>
+void
+foo ()
+{
+  auto [a, b] = S<int>();	// { dg-warning "structured bindings only available with" "" { target c++14_down } }
+}
+
+int
+main ()
+{
+  foo<int> ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/fold11.C b/gcc/testsuite/g++.dg/cpp1z/fold11.C
new file mode 100644
index 00000000000..09a30555eee
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/fold11.C
@@ -0,0 +1,12 @@
+// PR c++/94505 - bogus -Wparentheses warning with fold-expression.
+// { dg-do compile { target c++17 } }
+// { dg-options "-Wparentheses" }
+
+template <bool... B>
+bool foo () {
+    return ((B && true) || ...); // { dg-bogus "suggest parentheses" }
+}
+
+int main () {
+    foo<true, false, false, true> ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class-defarg1.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class-defarg1.C
new file mode 100644
index 00000000000..4e7261a203c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class-defarg1.C
@@ -0,0 +1,6 @@
+// PR c++/98810
+// { dg-do compile { target c++2a } }
+
+template <auto> struct a {};
+template <int i, a <i> s = a <i> {}> using b = a <s>;
+template <int i> constexpr auto g (const b <i> &) { return true; }
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class36.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class36.C
new file mode 100644
index 00000000000..1c1e23c10a8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class36.C
@@ -0,0 +1,76 @@
+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array
+   { dg-do compile { target c++2a } }
+   { dg-options "-Wall" } */
+
+struct A { int i; int f (); };
+typedef int A::*MemPtr;
+typedef int (A::*MemFuncPtr)();
+
+struct B { MemPtr a[3]; MemFuncPtr b[3]; };
+
+static const constexpr MemPtr mp0 = { 0 };
+static const constexpr MemPtr mpn = { nullptr };
+static const constexpr MemPtr mp_ = { };
+static const constexpr MemPtr mpi = { &A::i };
+
+template <B> struct X { };
+
+typedef X<B{ }>                               XB;
+typedef X<B{ 0 }>                             XB;
+typedef X<B{{ 0 }}>                           XB;
+typedef X<B{{ MemPtr{ }}}>                    XB;
+typedef X<B{{ MemPtr{ 0 }}}>                  XB;
+typedef X<B{{ MemPtr () }}>                   XB;
+typedef X<B{{ MemPtr{ nullptr }}}>            XB;
+typedef X<B{{ mp_ }}>                         XB;
+typedef X<B{{ mpn }}>                         XB;
+typedef X<B{{ mp0 }}>                         XB;
+
+typedef X<B{ mpi }>                           XBp;
+typedef X<B{ mpi, 0 }>                        XBp;
+typedef X<B{{ mpi, 0 }}>                      XBp;
+typedef X<B{{ mpi, MemPtr{ }}}>               XBp;
+typedef X<B{{ mpi, MemPtr{ 0 }}}>             XBp;
+typedef X<B{{ mpi, MemPtr () }}>              XBp;
+typedef X<B{{ mpi, MemPtr{ nullptr }}}>       XBp;
+typedef X<B{{ mpi, mp_ }}>                    XBp;
+typedef X<B{{ mpi, mpn }}>                    XBp;
+typedef X<B{{ mpi, mp0 }}>                    XBp;
+
+typedef X<B{ mpi, mpi }>                      XBpp;
+typedef X<B{ mpi, mpi, 0 }>                   XBpp;
+typedef X<B{{ mpi, mpi, 0 }}>                 XBpp;
+typedef X<B{{ mpi, mpi, MemPtr{ }}}>          XBpp;
+typedef X<B{{ mpi, mpi, MemPtr{ 0 }}}>        XBpp;
+typedef X<B{{ mpi, mpi, MemPtr () }}>         XBpp;
+typedef X<B{{ mpi, mpi, MemPtr{ nullptr }}}>  XBpp;
+typedef X<B{{ mpi, mpi, mp_ }}>               XBpp;
+typedef X<B{{ mpi, mpi, mpn }}>               XBpp;
+typedef X<B{{ mpi, mpi, mp0 }}>               XBpp;
+
+typedef X<B{ 0, mpi }>                        XB0p;
+typedef X<B{ nullptr, mpi, 0 }>               XB0p;
+typedef X<B{ mp0, mpi, 0 }>                   XB0p;
+
+typedef X<B{ 0, 0, mpi }>                     XB00p;
+typedef X<B{ 0, nullptr, mpi }>               XB00p;
+typedef X<B{ nullptr, 0, mpi }>               XB00p;
+typedef X<B{ nullptr, nullptr, mpi }>         XB00p;
+typedef X<B{ MemPtr{ }, MemPtr{ }, mpi }>     XB00p;
+typedef X<B{ mp0, MemPtr{ }, mpi }>           XB00p;
+typedef X<B{ mpn, mpn, mpi }>                 XB00p;
+typedef X<B{ mpn, mp_, mpi }>                 XB00p;  // { dg-bogus "conflicting declaration" "pr94568" { xfail *-*-* } }
+
+static const constexpr MemFuncPtr mfp0 = { 0 };
+static const constexpr MemFuncPtr mfpn = { nullptr };
+static const constexpr MemFuncPtr mfp_ = { };
+
+typedef X<B{{ }, { }}>                        XB;
+typedef X<B{{ }, { 0 }}>                      XB;
+typedef X<B{{ }, { MemFuncPtr{ }}}>           XB;
+typedef X<B{{ }, { MemFuncPtr{ 0 }}}>         XB;
+typedef X<B{{ }, { MemFuncPtr () }}>          XB;
+typedef X<B{{ }, { MemFuncPtr{ nullptr }}}>   XB;
+typedef X<B{{ }, { mfp_ }}>                   XB;
+typedef X<B{{ }, { mfpn }}>                   XB;
+typedef X<B{{ }, { mfp0 }}>                   XB;
diff --git a/gcc/testsuite/g++.dg/cpp2a/nontype-class37.C b/gcc/testsuite/g++.dg/cpp2a/nontype-class37.C
new file mode 100644
index 00000000000..5649fa2e6dc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/nontype-class37.C
@@ -0,0 +1,80 @@
+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array
+   { dg-do compile { target c++2a } }
+   { dg-options "-Wall" } */
+
+struct A { char a[4]; };
+template <A> struct B { };
+
+constexpr const char c0{ };
+constexpr const char c1{ 1 };
+
+typedef B<A{ }>                     BA;
+typedef B<A{ { } }>                 BA;
+typedef B<A{ { 0 } }>               BA;
+typedef B<A{ { c0 } }>              BA;
+typedef B<A{ { 0, 0 } }>            BA;
+typedef B<A{ { 0, 0, 0 } }>         BA;
+typedef B<A{ { 0, 0, 0, 0 } }>      BA;
+typedef B<A{ { c0, c0, c0 } }>      BA;
+typedef B<A{ { c0, c0, c0, c0 } }>  BA;
+typedef B<A{ "" }>                  BA;
+typedef B<A{ "\0" }>                BA;
+typedef B<A{ "\0\0" }>              BA;
+typedef B<A{ "\0\0\0" }>            BA;
+
+typedef B<A{ 1 }>                   BA1;
+typedef B<A{ { 1 } }>               BA1;
+typedef B<A{ { 1, 0 } }>            BA1;
+typedef B<A{ { 1, 0, 0 } }>         BA1;
+typedef B<A{ { 1, 0, 0, 0 } }>      BA1;
+typedef B<A{ { c1 } }>              BA1;
+typedef B<A{ { c1, c0 } }>          BA1;
+typedef B<A{ { c1, c0, c0 } }>      BA1;
+typedef B<A{ { c1, c0, c0, c0 } }>  BA1;
+typedef B<A{ "\1" }>                BA1;
+typedef B<A{ "\1\0" }>              BA1;
+typedef B<A{ "\1\0\0" }>            BA1;
+
+typedef B<A{ 0, 1 }>                BA01;
+typedef B<A{ { 0, 1 } }>            BA01;
+typedef B<A{ { 0, 1, 0 } }>         BA01;
+typedef B<A{ { 0, 1, 0, 0 } }>      BA01;
+typedef B<A{ { c0, c1 } }>          BA01;
+typedef B<A{ { c0, c1, c0 } }>      BA01;
+typedef B<A{ { c0, c1, c0, c0 } }>  BA01;
+typedef B<A{ "\0\1" }>              BA01;
+typedef B<A{ "\0\1\0" }>            BA01;
+
+
+struct C { int a[4]; };
+template <C> struct D { };
+
+constexpr const int i0{ };
+
+typedef D<C{ }>                     DC;
+typedef D<C{ { } }>                 DC;
+typedef D<C{ { 0 } }>               DC;
+typedef D<C{ { 0, 0 } }>            DC;
+typedef D<C{ { 0, 0, 0 } }>         DC;
+typedef D<C{ { 0, 0, 0, 0 } }>      DC;
+typedef D<C{ { i0 } }>              DC;
+typedef D<C{ { i0, i0 } }>          DC;
+typedef D<C{ { i0, i0, i0 } }>      DC;
+typedef D<C{ { i0, i0, i0, i0 } }>  DC;
+
+
+constexpr const int i1{ 1 };
+
+typedef D<C{ 1 }>                   DC1;
+typedef D<C{ { 1 } }>               DC1;
+typedef D<C{ { 1, 0 } }>            DC1;
+typedef D<C{ { 1, 0, 0 } }>         DC1;
+typedef D<C{ { 1, 0, 0, 0 } }>      DC1;
+typedef D<C{ { i1, i0, i0, i0 } }>  DC1;
+
+typedef D<C{ 0, 1 }>                DC01;
+typedef D<C{ { 0, 1 } }>            DC01;
+typedef D<C{ { 0, 1, 0 } }>         DC01;
+typedef D<C{ { 0, 1, 0, 0 } }>      DC01;
+typedef D<C{ { 0, i1, 0, 0 } }>     DC01;
+typedef D<C{ { i0, i1, i0, i0 } }>  DC01;   // { dg-bogus "conflicting declaration" "pr94567" { xfail *-*-* } }
diff --git a/gcc/testsuite/g++.dg/debug/localclass2.C b/gcc/testsuite/g++.dg/debug/localclass2.C
new file mode 100644
index 00000000000..9897eec5d2d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/localclass2.C
@@ -0,0 +1,24 @@
+// PR c++/97918
+// { dg-do compile { target c++11 } }
+// { dg-require-effective-target lto }
+// { dg-additional-options "-g -O -flto" }
+
+namespace { class A {}; }
+class B {};
+template <typename T> struct H {
+  constexpr static unsigned h = 0;
+};
+
+template <typename T> A bar ()
+{
+  struct J {
+    static void foo();
+  };
+  H<J>();
+  return A ();
+}
+
+void fn ()
+{
+  bar<B>;			// only mentions the function
+}
diff --git a/gcc/testsuite/g++.dg/debug/pr94459.C b/gcc/testsuite/g++.dg/debug/pr94459.C
new file mode 100644
index 00000000000..ebc0cf45cc6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/pr94459.C
@@ -0,0 +1,58 @@
+// PR debug/94459
+// { dg-do compile { target c++14 } }
+// { dg-options "-g -dA" }
+
+template <typename T>
+struct S
+{
+  T v;
+  T w[2];
+  S () : v (0), w { 0, 0 } {}
+  static auto baz () { return (T) 0; }
+  auto m1 () { return v; }
+  auto &m2 () { return v; }
+  auto &&m3 () { return (T&&)v; }
+  const auto m4 () { return v; }
+  const auto &m5 () { return v; }
+  const auto &&m6 () { return (T&&)v; }
+  volatile auto m7 () { return v; }
+  volatile auto &m8 () { return v; }
+  volatile auto &&m9 () { return (T&&)v; }
+  volatile const auto m10 () { return v; }
+  volatile const auto &m11 () { return v; }
+  volatile const auto &&m12 () { return (T&&)v; }
+  const volatile auto m13 () { return v; }
+  const volatile auto &m14 () { return v; }
+  const volatile auto &&m15 () { return (T&&)v; }
+#ifndef __STRICT_ANSI__
+  __restrict const volatile auto &&m16 () { return (T&&)v; }
+  const __restrict auto &m17 () { return v; }
+#endif
+  auto *m18 () { return &v; }
+  auto (S::* (m19 ())) () { return &S::m1; }
+  auto (S::* (m20 ())) { return &S::v; }
+  auto (*m21 ()) () { return S::baz; }
+};
+
+S<long> s, u, v;
+
+long
+foo ()
+{
+  auto x = s.m19 ();
+  auto y = s.m20 ();
+  auto z = s.m21 ();
+  return s.m1 () + s.m2 () + s.m3 () + s.m4 () + s.m5 ()
+	 + s.m6 () + s.m7 () + s.m8 () + s.m9 () + s.m10 ()
+	 + s.m11 () + s.m12 () + s.m13 () + s.m14 () + s.m15 ()
+#ifndef __STRICT_ANSI__
+	 + u.m16 () + v.m17 ()
+#endif
+	 + *s.m18 () + (s.*x) () + s.*y + z ();
+}
+
+int
+main ()
+{
+  return foo ();
+}
diff --git a/gcc/testsuite/g++.dg/eh/seh-xmm-unwind.C b/gcc/testsuite/g++.dg/eh/seh-xmm-unwind.C
new file mode 100644
index 00000000000..07fd805b3fd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/eh/seh-xmm-unwind.C
@@ -0,0 +1,61 @@
+/* PR target/99234 */
+/* Test SEH unwinding of XMM register saves.  */
+
+/* { dg-do run { target { x86_64-*-mingw32 && lp64 } } } */
+
+extern "C" void abort (void);
+extern "C" void exit (int);
+
+void
+foo (void)
+{
+  register __int128 xmm6  asm("xmm6")  = 0;
+  register __int128 xmm7  asm("xmm7")  = 0;
+  register __int128 xmm8  asm("xmm8")  = 0;
+  register __int128 xmm9  asm("xmm9")  = 0;
+  register __int128 xmm10 asm("xmm10") = 0;
+  register __int128 xmm11 asm("xmm11") = 0;
+  register __int128 xmm12 asm("xmm12") = 0;
+  register __int128 xmm13 asm("xmm13") = 0;
+  register __int128 xmm14 asm("xmm14") = 0;
+  register __int128 xmm15 asm("xmm15") = 0;
+
+  __asm__ __volatile__ ("" : "+x" (xmm6),  "+x" (xmm7),  "+x" (xmm8),  "+x" (xmm9),
+			     "+x" (xmm10), "+x" (xmm11), "+x" (xmm12), "+x" (xmm13),
+			     "+x" (xmm14), "+x" (xmm15));
+
+  throw 1;
+}
+
+int
+main (void)
+{
+  register __int128 xmm6  asm("xmm6")  = 6;
+  register __int128 xmm7  asm("xmm7")  = 7;
+  register __int128 xmm8  asm("xmm8")  = 8;
+  register __int128 xmm9  asm("xmm9")  = 9;
+  register __int128 xmm10 asm("xmm10") = 10;
+  register __int128 xmm11 asm("xmm11") = 11;
+  register __int128 xmm12 asm("xmm12") = 12;
+  register __int128 xmm13 asm("xmm13") = 13;
+  register __int128 xmm14 asm("xmm14") = 14;
+  register __int128 xmm15 asm("xmm15") = 15;
+
+  __asm__ __volatile__ ("" : "+x" (xmm6),  "+x" (xmm7),  "+x" (xmm8),  "+x" (xmm9),
+			     "+x" (xmm10), "+x" (xmm11), "+x" (xmm12), "+x" (xmm13),
+			     "+x" (xmm14), "+x" (xmm15));
+
+  try {
+    foo ();
+  } catch (...) {
+    __asm__ __volatile__ ("" : "+x" (xmm6),  "+x" (xmm7),  "+x" (xmm8),  "+x" (xmm9),
+			       "+x" (xmm10), "+x" (xmm11), "+x" (xmm12), "+x" (xmm13),
+			       "+x" (xmm14), "+x" (xmm15));
+
+    if (xmm6 != 6 || xmm7 != 7 || xmm8 != 8 || xmm9 != 9 || xmm10 != 10
+        || xmm11 != 11 || xmm12 != 12 || xmm13 != 13 || xmm14 != 14 || xmm15 != 15)
+      abort ();
+  }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/g++.dg/ext/attr-lambda3.C b/gcc/testsuite/g++.dg/ext/attr-lambda3.C
new file mode 100644
index 00000000000..71d13031f73
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attr-lambda3.C
@@ -0,0 +1,4 @@
+// PR c++/90333
+// { dg-do compile { target c++11 } }
+
+auto x = []() __attribute__((always_inline)) -> int { return 0; };
diff --git a/gcc/testsuite/g++.dg/ext/attr-parm-1.C b/gcc/testsuite/g++.dg/ext/attr-parm-1.C
new file mode 100644
index 00000000000..681a652de1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attr-parm-1.C
@@ -0,0 +1,11 @@
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ia32 || lp64 } } } }
+// PR 94946
+class a {
+#ifdef __LP64__
+  template <typename b> a(b(__attribute__((sysv_abi)) *c)());
+  template <typename b> a(b(__attribute__((ms_abi)) *c)());
+#else
+  template <typename b> a(b (*)());
+  template <typename b> a(b(__attribute__((fastcall)) *c)());
+#endif
+};
diff --git a/gcc/testsuite/g++.dg/ext/attr-type1.C b/gcc/testsuite/g++.dg/ext/attr-type1.C
new file mode 100644
index 00000000000..6e84cccea1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attr-type1.C
@@ -0,0 +1,19 @@
+// PR c++/90750
+// { dg-do compile { target c++11 } }
+
+template <typename> struct S
+{
+  static const int b = 64;
+};
+
+template <typename a> struct T: S<a>
+{
+  using A = S<a>;
+  using A::b;
+  char* __attribute__((aligned(b))) c;
+};
+
+T<int> t;
+
+#define SA(X) static_assert (X,#X)
+SA (alignof(T<int>) == S<int>::b);
diff --git a/gcc/testsuite/g++.dg/gcov/pr97069.C b/gcc/testsuite/g++.dg/gcov/pr97069.C
new file mode 100644
index 00000000000..040e336662a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gcov/pr97069.C
@@ -0,0 +1,20 @@
+// PR gcov-profile/97069
+// { dg-options "--coverage" }
+// { dg-do run { target native } }
+
+# 0 "pr97069.C"
+# 0 "<built-in>"
+# 0 "<command-line>"
+# 1 "/usr/include/stdc-predef.h" 1 3 4
+# 0 "<command-line>" 2
+# 1 "pr97069.C"
+int main()
+{
+  return 0;
+}
+# 0 "pr97069.C"
+void zero_line_directive()
+{
+}
+
+// { dg-final { run-gcov pr97069.C } }
diff --git a/gcc/testsuite/g++.dg/goacc/cache-1.C b/gcc/testsuite/g++.dg/goacc/cache-1.C
new file mode 100644
index 00000000000..a8d5ab32016
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/cache-1.C
@@ -0,0 +1,15 @@
+/* OpenACC 'cache' directive: valid usage.  */
+
+/* See also corresponding C/C++ variant '../../c-c++-common/goacc/cache-1.c'.  */
+
+/* For execution testing, this file is '#include'd from
+   '../../../../libgomp/testsuite/libgomp.oacc-c++/cache-1.C'.  */
+
+#define TEMPLATIZE
+#include "../../c-c++-common/goacc/cache-1.c"
+
+static void
+instantiate ()
+{
+  &test<0>;
+}
diff --git a/gcc/testsuite/g++.dg/goacc/cache-2.C b/gcc/testsuite/g++.dg/goacc/cache-2.C
new file mode 100644
index 00000000000..ef0b8a9e76f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/cache-2.C
@@ -0,0 +1,64 @@
+/* OpenACC 'cache' directive: invalid usage.  */
+
+/* See also corresponding C/C++ variant '../../c-c++-common/goacc/cache-2.c'.  */
+
+template <int N>
+static void
+test ()
+{
+#define N   2
+    int a[N], b[N];
+    int i;
+
+    for (i = 0; i < N; i++)
+    {
+        a[i] = 3;
+        b[i] = 0;
+    }
+
+#pragma acc parallel copyin (a[0:N]) copyout (b[0:N])
+{
+    int ii;
+
+    for (ii = 0; ii < N; ii++)
+    {
+        const int idx = ii;
+        int n = 1;
+        const int len = n;
+
+#pragma acc cache /* { dg-error "expected '\\\(' before end of line" } */
+#pragma acc cache a[0:N] /* { dg-error "expected '\\\(' before 'a'" } */
+	/* { dg-bogus "expected end of line before 'a'" "" { xfail c++ } .-1 } */
+#pragma acc cache (a) /* { dg-error "expected '\\\['" } */
+#pragma acc cache ( /* { dg-error "expected (identifier|unqualified-id) before end of line" } */
+#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
+#pragma acc cache (,) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" } */
+#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
+#pragma acc cache (a[0:N],) /* { dg-error "expected (identifier|unqualified-id) before '(,|\\\))' token" "" { xfail c } } */
+#pragma acc cache (a[0:N]) copyin (a[0:N]) /* { dg-error "expected end of line before 'copyin'" } */
+#pragma acc cache () /* { dg-error "expected (identifier|unqualified-id) before '\\\)' token" } */
+#pragma acc cache (a[0:N] b[0:N]) /* { dg-error "expected '\\\)' before 'b'" } */
+#pragma acc cache (a[0:N] b[0:N}) /* { dg-error "expected '\\\)' before 'b'" } */
+	/* { dg-bogus "expected end of line before '\\\}' token" "" { xfail c++ } .-1 } */
+#pragma acc cache (a[0:N] /* { dg-error "expected '\\\)' before end of line" } */
+#pragma acc cache (a[0:N]) ( /* { dg-error "expected end of line before '\\(' token" } */
+#pragma acc cache (a[0:N]) ii /* { dg-error "expected end of line before 'ii'" } */
+#pragma acc cache (a[0:N] ii) /* { dg-error "expected '\\)' before 'ii'" } */
+
+        b[ii] = a[ii];
+    }
+}
+
+
+    for (i = 0; i < N; i++)
+    {
+        if (a[i] != b[i])
+            __builtin_abort ();
+    }
+}
+
+static void
+instantiate ()
+{
+  &test<0>;
+}
diff --git a/gcc/testsuite/g++.dg/goacc/cache-3-1.C b/gcc/testsuite/g++.dg/goacc/cache-3-1.C
new file mode 100644
index 00000000000..d543db60a9d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/cache-3-1.C
@@ -0,0 +1,123 @@
+/* Test 'cache' directive diagnostics.  */
+
+/* See also corresponding C/C++ variant: '../../c-c++-common/goacc/cache-3-1.c'.  */
+
+/* See also corresponding C++ data clause variant: 'data-clause-1.C'.  */
+
+/* { dg-additional-options "-fopenmp" } for '#pragma omp threadprivate'.  */
+
+/* The current implementation doesn't restrict where a 'cache' directive may
+   appear, so we don't make any special arrangements.  */
+
+extern int a[][10], a2[][10];
+int b[10], c[10][2], d[10], e[10], f[10];
+int b2[10], c2[10][2], d2[10], e2[10], f2[10];
+int k[10], l[10], m[10], n[10], o;
+int *p;
+int **q;
+int r[4][4][4][4][4];
+extern struct s s1;
+extern struct s s2[1]; /* { dg-error "array type has incomplete element type" "" { target c } } */
+int t[10];
+#pragma omp threadprivate (t)
+#pragma acc routine
+void bar (int *);
+
+template <int N>
+void
+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],
+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])
+{
+  #pragma acc cache(bar[2:5]) /* { dg-error "is not a variable" } */
+    ;
+  #pragma acc cache(t[2:5]) /* { dg-error "is threadprivate variable" } */
+    ;
+  #pragma acc cache(k[0.5:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(l[:7.5f]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(m[p:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(n[:p]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc cache(o[2:5]) /* { dg-error "does not have pointer or array type" } */
+    ;
+  #pragma acc cache(s1) /* { dg-error "expected '\\\['" } */
+    ;
+  #pragma acc cache(s2) /* { dg-error "expected '\\\['" } */
+    ;
+  #pragma acc cache(a[:][:]) /* { dg-error "array type length expression must be specified" } */
+    bar (&a[0][0]);
+  #pragma acc cache(b[-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (b);
+  #pragma acc cache(c[:-3][:]) /* { dg-error "negative length in array section" } */
+    bar (&c[0][0]);
+  #pragma acc cache(d[11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (d);
+  #pragma acc cache(e[:11]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (e);
+  #pragma acc cache(f[1:10]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (f);
+  #pragma acc cache(g[:][0:10]) /* { dg-error "for pointer type length expression must be specified" } */
+    bar (&g[0][0]);
+  #pragma acc cache(h[2:1][-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (&h[0][0]);
+  #pragma acc cache(h[:1][:-3]) /* { dg-error "negative length in array section" } */
+    bar (&h[0][0]);
+  #pragma acc cache(i[:1][11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (&i[0][0]);
+  #pragma acc cache(j[3:1][:10]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc cache(j[30:1][5:5]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc cache(a2[:1][2:4])
+    bar (&a2[0][0]);
+  #pragma acc cache(a2[3:5][:])
+    bar (&a2[0][0]);
+  #pragma acc cache(a2[3:5][:10])
+    bar (&a2[0][0]);
+  #pragma acc cache(b2[0:])
+    bar (b2);
+  #pragma acc cache(c2[:3][:])
+    bar (&c2[0][0]);
+  #pragma acc cache(d2[9:])
+    bar (d2);
+  #pragma acc cache(e2[:10])
+    bar (e2);
+  #pragma acc cache(f2[1:9])
+    bar (f2);
+  #pragma acc cache(g2[:1][2:4])
+    bar (&g2[0][0]);
+  #pragma acc cache(h2[2:2][0:])
+    bar (&h2[0][0]);
+  #pragma acc cache(h2[:1][:3])
+    bar (&h2[0][0]);
+  #pragma acc cache(i2[:1][9:])
+    bar (&i2[0][0]);
+  #pragma acc cache(j2[3:4][:9])
+    bar (&j2[0][0]);
+  #pragma acc cache(j2[30:1][5:4])
+    bar (&j2[0][0]);
+  #pragma acc cache(q[1:2])
+    ;
+  #pragma acc cache(q[3:5][:10]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2])
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][0:4])
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][1:][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:3][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][1:]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc cache(r[3:][2:1][1:2][:][:3]) /* { dg-error "array section is not contiguous" } */
+    ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/goacc/cache-3-2.C b/gcc/testsuite/g++.dg/goacc/cache-3-2.C
new file mode 100644
index 00000000000..5561e176a56
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/cache-3-2.C
@@ -0,0 +1,57 @@
+/* Test 'cache' directive diagnostics.  */
+
+/* See also corresponding C/C++ variant: '../../c-c++-common/goacc/cache-3-2.c'.  */
+
+/* See also corresponding C++ data clause variant: 'data-clause-2.C'.  */
+
+/* The current implementation doesn't restrict where a 'cache' directive may
+   appear, so we don't make any special arrangements.  */
+
+template <int N>
+void
+foo (int *p, int (*q)[10], int r[10], int s[10][10])
+{
+  int a[10], b[10][10];
+  #pragma acc cache (p[-1:2])
+  ;
+  #pragma acc cache (q[-1:2][0:10])
+  ;
+  #pragma acc cache (q[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (r[-1:2])
+  ;
+  #pragma acc cache (s[-1:2][:])
+  ;
+  #pragma acc cache (s[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (a[-1:2])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (b[-1:2][0:])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (b[1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc cache (p[2:-3])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (q[2:-3][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (q[2:3][0:-1])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (r[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (s[2:-5][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (s[2:5][0:-4])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (a[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (b[2:-5][0:10]) /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc cache (b[2:5][0:-4]) /* { dg-error "negative length in array section in" } */
+  ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/goacc/data-clause-1.C b/gcc/testsuite/g++.dg/goacc/data-clause-1.C
new file mode 100644
index 00000000000..3de3834efae
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/data-clause-1.C
@@ -0,0 +1,122 @@
+/* Test data clause diagnostics.  */
+
+/* See also corresponding OpenACC C/C++ variant: '../../c-c++-common/goacc/data-clause-1.c'.  */
+
+/* See also corresponding OpenACC 'cache' directive variant: 'cache-3-1.C'.  */
+
+/* See also corresponding OpenMP variant: '../gomp/map-1.C'.  */
+
+/* { dg-additional-options "-fopenmp" } for '#pragma omp threadprivate'.  */
+
+extern int a[][10], a2[][10];
+int b[10], c[10][2], d[10], e[10], f[10];
+int b2[10], c2[10][2], d2[10], e2[10], f2[10];
+int k[10], l[10], m[10], n[10], o;
+int *p;
+int **q;
+int r[4][4][4][4][4];
+extern struct s s1;
+extern struct s s2[1]; /* { dg-error "array type has incomplete element type" "" { target c } } */
+int t[10];
+#pragma omp threadprivate (t)
+#pragma acc routine
+void bar (int *);
+
+template <int N>
+void
+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],
+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])
+{
+  #pragma acc parallel copyin(bar[2:5]) /* { dg-error "is not a variable" } */
+    ;
+  #pragma acc parallel copyout(t[2:5]) /* { dg-error "is threadprivate variable" } */
+    ;
+  #pragma acc parallel copy(k[0.5:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyout(l[:7.5f]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyin(m[p:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copy(n[:p]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma acc parallel copyin(o[2:5]) /* { dg-error "does not have pointer or array type" } */
+    ;
+  #pragma acc parallel create(s1) /* { dg-error "'s1' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma acc parallel create(s2) /* { dg-error "'s2' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma acc parallel copyin(a[:][:]) /* { dg-error "array type length expression must be specified" } */
+    bar (&a[0][0]); /* { dg-error "referenced in target region does not have a mappable type" "PR97996" { xfail *-*-* } } */
+  #pragma acc parallel copy(b[-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (b);
+  #pragma acc parallel copy(c[:-3][:]) /* { dg-error "negative length in array section" } */
+    bar (&c[0][0]);
+  #pragma acc parallel copyout(d[11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (d);
+  #pragma acc parallel copyin(e[:11]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (e);
+  #pragma acc parallel copyin(f[1:10]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (f);
+  #pragma acc parallel copyout(g[:][0:10]) /* { dg-error "for pointer type length expression must be specified" } */
+    bar (&g[0][0]);
+  #pragma acc parallel copyout(h[2:1][-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (&h[0][0]);
+  #pragma acc parallel copy(h[:1][:-3]) /* { dg-error "negative length in array section" } */
+    bar (&h[0][0]);
+  #pragma acc parallel copy(i[:1][11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (&i[0][0]);
+  #pragma acc parallel copyout(j[3:1][:10]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc parallel copyin(j[30:1][5:5]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma acc parallel copyin(a2[:1][2:4])
+    bar (&a2[0][0]);
+  #pragma acc parallel copy(a2[3:5][:])
+    bar (&a2[0][0]);
+  #pragma acc parallel copyin(a2[3:5][:10])
+    bar (&a2[0][0]);
+  #pragma acc parallel copy(b2[0:])
+    bar (b2);
+  #pragma acc parallel copy(c2[:3][:])
+    bar (&c2[0][0]);
+  #pragma acc parallel copyout(d2[9:])
+    bar (d2);
+  #pragma acc parallel copyin(e2[:10])
+    bar (e2);
+  #pragma acc parallel copyin(f2[1:9])
+    bar (f2);
+  #pragma acc parallel copy(g2[:1][2:4])
+    bar (&g2[0][0]);
+  #pragma acc parallel copyout(h2[2:2][0:])
+    bar (&h2[0][0]);
+  #pragma acc parallel copy(h2[:1][:3])
+    bar (&h2[0][0]);
+  #pragma acc parallel copyin(i2[:1][9:])
+    bar (&i2[0][0]);
+  #pragma acc parallel copyout(j2[3:4][:9])
+    bar (&j2[0][0]);
+  #pragma acc parallel copyin(j2[30:1][5:4])
+    bar (&j2[0][0]);
+  #pragma acc parallel copy(q[1:2])
+    ;
+  #pragma acc parallel copy(q[3:5][:10]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2])
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][0:4])
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][1:][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:3][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][1:]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma acc parallel copy(r[3:][2:1][1:2][:][:3]) /* { dg-error "array section is not contiguous" } */
+    ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/goacc/data-clause-2.C b/gcc/testsuite/g++.dg/goacc/data-clause-2.C
new file mode 100644
index 00000000000..57d1823aede
--- /dev/null
+++ b/gcc/testsuite/g++.dg/goacc/data-clause-2.C
@@ -0,0 +1,56 @@
+/* Test data clause diagnostics.  */
+
+/* See also corresponding OpenACC C/C++ variant: '../../c-c++-common/goacc/data-clause-2.c'.  */
+
+/* See also corresponding OpenACC 'cache' directive variant: 'cache-3-2.C'.  */
+
+/* See also corresponding OpenMP variant: '../gomp/map-2.C'.  */
+
+template <int N>
+void
+foo (int *p, int (*q)[10], int r[10], int s[10][10])
+{
+  int a[10], b[10][10];
+  #pragma acc parallel copy (p[-1:2])
+  ;
+  #pragma acc parallel copy (q[-1:2][0:10])
+  ;
+  #pragma acc parallel copy (q[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (r[-1:2])
+  ;
+  #pragma acc parallel copy (s[-1:2][:])
+  ;
+  #pragma acc parallel copy (s[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (a[-1:2])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (b[-1:2][0:])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (b[1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma acc parallel copy (p[2:-3])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (q[2:-3][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (q[2:3][0:-1])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (r[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (s[2:-5][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (s[2:5][0:-4])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (a[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (b[2:-5][0:10]) /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma acc parallel copy (b[2:5][0:-4]) /* { dg-error "negative length in array section in" } */
+  ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/map-1.C b/gcc/testsuite/g++.dg/gomp/map-1.C
new file mode 100644
index 00000000000..c314d55a621
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/map-1.C
@@ -0,0 +1,119 @@
+/* Test 'map' clause diagnostics.  */
+
+/* See also corresponding OpenMP C/C++ variant: '../../c-c++-common/gomp/map-1.c'.  */
+
+/* See also corresponding OpenACC variant: '../goacc/data-clause-1.C'.  */
+
+extern int a[][10], a2[][10];
+int b[10], c[10][2], d[10], e[10], f[10];
+int b2[10], c2[10][2], d2[10], e2[10], f2[10];
+int k[10], l[10], m[10], n[10], o;
+int *p;
+int **q;
+int r[4][4][4][4][4];
+extern struct s s1;
+extern struct s s2[1]; /* { dg-error "array type has incomplete element type" "" { target c } } */
+int t[10];
+#pragma omp threadprivate (t)
+#pragma omp declare target
+void bar (int *);
+#pragma omp end declare target
+
+template <int N>
+void
+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],
+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])
+{
+  #pragma omp target map(to: bar[2:5]) /* { dg-error "is not a variable" } */
+    ;
+  #pragma omp target map(from: t[2:5]) /* { dg-error "is threadprivate variable" } */
+    ;
+  #pragma omp target map(tofrom: k[0.5:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma omp target map(from: l[:7.5f]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma omp target map(to: m[p:]) /* { dg-error "low bound \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma omp target map(tofrom: n[:p]) /* { dg-error "length \[^\n\r]* of array section does not have integral type" } */
+    ;
+  #pragma omp target map(to: o[2:5]) /* { dg-error "does not have pointer or array type" } */
+    ;
+  #pragma omp target map(alloc: s1) /* { dg-error "'s1' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma omp target map(alloc: s2) /* { dg-error "'s2' does not have a mappable type in 'map' clause" } */
+    ;
+  #pragma omp target map(to: a[:][:]) /* { dg-error "array type length expression must be specified" } */
+    bar (&a[0][0]); /* { dg-error "referenced in target region does not have a mappable type" "PR97996" { xfail *-*-* } } */
+  #pragma omp target map(tofrom: b[-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (b);
+  #pragma omp target map(tofrom: c[:-3][:]) /* { dg-error "negative length in array section" } */
+    bar (&c[0][0]);
+  #pragma omp target map(from: d[11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (d);
+  #pragma omp target map(to: e[:11]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (e);
+  #pragma omp target map(to: f[1:10]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (f);
+  #pragma omp target map(from: g[:][0:10]) /* { dg-error "for pointer type length expression must be specified" } */
+    bar (&g[0][0]);
+  #pragma omp target map(from: h[2:1][-1:]) /* { dg-error "negative low bound in array section" } */
+    bar (&h[0][0]);
+  #pragma omp target map(tofrom: h[:1][:-3]) /* { dg-error "negative length in array section" } */
+    bar (&h[0][0]);
+  #pragma omp target map(i[:1][11:]) /* { dg-error "low bound \[^\n\r]* above array section size" } */
+    bar (&i[0][0]);
+  #pragma omp target map(from: j[3:1][:10]) /* { dg-error "length \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma omp target map(to: j[30:1][5:5]) /* { dg-error "high bound \[^\n\r]* above array section size" } */
+    bar (&j[0][0]);
+  #pragma omp target map(to: a2[:1][2:4])
+    bar (&a2[0][0]);
+  #pragma omp target map(a2[3:5][:])
+    bar (&a2[0][0]);
+  #pragma omp target map(to: a2[3:5][:10])
+    bar (&a2[0][0]);
+  #pragma omp target map(tofrom: b2[0:])
+    bar (b2);
+  #pragma omp target map(tofrom: c2[:3][:])
+    bar (&c2[0][0]);
+  #pragma omp target map(from: d2[9:])
+    bar (d2);
+  #pragma omp target map(to: e2[:10])
+    bar (e2);
+  #pragma omp target map(to: f2[1:9])
+    bar (f2);
+  #pragma omp target map(g2[:1][2:4])
+    bar (&g2[0][0]);
+  #pragma omp target map(from: h2[2:2][0:])
+    bar (&h2[0][0]);
+  #pragma omp target map(tofrom: h2[:1][:3])
+    bar (&h2[0][0]);
+  #pragma omp target map(to: i2[:1][9:])
+    bar (&i2[0][0]);
+  #pragma omp target map(from: j2[3:4][:9])
+    bar (&j2[0][0]);
+  #pragma omp target map(to: j2[30:1][5:4])
+    bar (&j2[0][0]);
+  #pragma omp target map(q[1:2])
+    ;
+  #pragma omp target map(tofrom: q[3:5][:10]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma omp target map(r[3:][2:1][1:2])
+    ;
+  #pragma omp target map(r[3:][2:1][1:2][:][0:4])
+    ;
+  #pragma omp target map(r[3:][2:1][1:2][1:][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma omp target map(r[3:][2:1][1:2][:3][0:4]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma omp target map(r[3:][2:1][1:2][:][1:]) /* { dg-error "array section is not contiguous" } */
+    ;
+  #pragma omp target map(r[3:][2:1][1:2][:][:3]) /* { dg-error "array section is not contiguous" } */
+    ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/map-2.C b/gcc/testsuite/g++.dg/gomp/map-2.C
new file mode 100644
index 00000000000..bbe26061fe3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/map-2.C
@@ -0,0 +1,54 @@
+/* Test 'map' clause diagnostics.  */
+
+/* See also corresponding OpenMP C/C++ variant: '../../c-c++-common/gomp/map-2.c'.  */
+
+/* See also corresponding OpenACC variant: '../goacc/data-clause-2.C'.  */
+
+template <int N>
+void
+foo (int *p, int (*q)[10], int r[10], int s[10][10])
+{
+  int a[10], b[10][10];
+  #pragma omp target map (tofrom: p[-1:2])
+  ;
+  #pragma omp target map (tofrom: q[-1:2][0:10])
+  ;
+  #pragma omp target map (tofrom: q[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma omp target map (tofrom: r[-1:2])
+  ;
+  #pragma omp target map (tofrom: s[-1:2][:])
+  ;
+  #pragma omp target map (tofrom: s[-1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma omp target map (tofrom: a[-1:2])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma omp target map (tofrom: b[-1:2][0:])	 /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma omp target map (tofrom: b[1:2][-2:10]) /* { dg-error "negative low bound in array section in" } */
+  ;
+  #pragma omp target map (tofrom: p[2:-3])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: q[2:-3][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: q[2:3][0:-1])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: r[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: s[2:-5][:])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: s[2:5][0:-4])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: a[2:-5])	 /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: b[2:-5][0:10]) /* { dg-error "negative length in array section in" } */
+  ;
+  #pragma omp target map (tofrom: b[2:5][0:-4]) /* { dg-error "negative length in array section in" } */
+  ;
+}
+
+static void
+instantiate ()
+{
+  &foo<0>;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr94477.C b/gcc/testsuite/g++.dg/gomp/pr94477.C
new file mode 100644
index 00000000000..e7fdc23d6d3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr94477.C
@@ -0,0 +1,18 @@
+// PR c++/94477
+// { dg-do compile }
+
+void foo ();
+
+template <int>
+void
+bar ()
+{
+  #pragma omp parallel master
+  foo ();
+}
+
+void
+baz ()
+{
+  bar<0> ();
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr94512.C b/gcc/testsuite/g++.dg/gomp/pr94512.C
new file mode 100644
index 00000000000..8ba0e65795f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr94512.C
@@ -0,0 +1,18 @@
+// PR c++/94512
+
+void
+foo ();
+
+template <int>
+void
+bar ()
+{
+#pragma omp parallel master taskloop
+  foo ();	// { dg-error "for statement expected before" }
+}
+
+void
+baz ()
+{
+  bar<0> ();
+}
diff --git a/gcc/testsuite/g++.dg/guality/pr93888.C b/gcc/testsuite/g++.dg/guality/pr93888.C
new file mode 100644
index 00000000000..d54a4dcc8cc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/guality/pr93888.C
@@ -0,0 +1,24 @@
+// PR debug/93888
+// { dg-do run }
+// { dg-options "-g -fvar-tracking -fno-inline" }
+// { dg-skip-if "" { *-*-* }  { "*" } { "-O0" } }
+
+struct K
+{
+  K () {}
+  K (K const &rhs) { k[0] = 'C'; }
+  char k[8] = {'B','B','B','B','B','B','B','B'};
+};
+
+__attribute__((always_inline)) inline bool
+foo (const K karg)
+{
+  return karg.k[0] != 'C';	// { dg-final { gdb-test 16 "karg.k[0]" "'C'" } }
+}				// { dg-final { gdb-test 16 "karg.k[1]" "'B'" } }
+
+int
+main ()
+{
+  K x;
+  return foo (x);
+}
diff --git a/gcc/testsuite/g++.dg/init/array58.C b/gcc/testsuite/g++.dg/init/array58.C
new file mode 100644
index 00000000000..70e86445c07
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array58.C
@@ -0,0 +1,26 @@
+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array
+   { dg-do compile } */
+
+int ia1[2] = { (void*)0 };              // { dg-error "invalid conversion from 'void\\\*'" }
+int ia2[2] = { (void*)0, 0 };           // { dg-error "invalid conversion from 'void\\\*'" }
+int ia3[] = { (void*)0, 0 };            // { dg-error "invalid conversion from 'void\\\*'" }
+
+int ia4[2] = { __null };                // { dg-warning "\\\[-Wconversion-null" }
+int ia5[2] = { __null, 0 };             // { dg-warning "\\\[-Wconversion-null" }
+int ia6[] = { __null, 0 };              // { dg-warning "\\\[-Wconversion-null" }
+
+
+const char ca1[2] = { (char*)0, 0 };    // { dg-error "invalid conversion from 'char\\\*'" }
+
+const char ca2[2] = { __null, 0 };      // { dg-warning "\\\[-Wconversion-null" }
+
+
+typedef void Func ();
+const char ca6[2] = { (Func*)0, 0 };    // { dg-error "invalid conversion from 'void \\\(\\\*\\\)\\\(\\\)' to 'char'" }
+
+struct S;
+typedef int S::*MemPtr;
+typedef int (S::*MemFuncPtr)();
+
+const char ca4[2] = { (MemPtr)0, 0 };   // { dg-error "cannot convert 'MemPtr' " }
+const char ca5[2] = { (MemFuncPtr)0, 0 };   // { dg-error "cannot convert 'int \\\(S::\\\*\\\)\\\(\\\)' "  }
diff --git a/gcc/testsuite/g++.dg/init/array59.C b/gcc/testsuite/g++.dg/init/array59.C
new file mode 100644
index 00000000000..e8680de9456
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/array59.C
@@ -0,0 +1,42 @@
+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array
+   { dg-do compile { target c++11 } } */
+
+namespace std {
+typedef __typeof__ (nullptr) nullptr_t;
+}
+
+int ia1[2] = { nullptr };                 // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+int ia2[2] = { nullptr, 0 };              // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+int ia3[] = { nullptr, 0 };               // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+
+int ia4[2] = { (std::nullptr_t)0 };      // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+int ia5[2] = { (std::nullptr_t)0, 0 };   // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+int ia6[] = { (std::nullptr_t)0, 0 };    // { dg-error "cannot convert 'std::nullptr_t' to 'int'" }
+
+
+const char ca1[2] = { nullptr, 0 };       // { dg-error "cannot convert 'std::nullptr_t' to 'const char'" }
+
+const char ca2[2] = { (char*)nullptr, 0 };// { dg-error "invalid conversion from 'char\\\*' to 'char'" }
+
+const char ca3[2] = { std::nullptr_t () };// { dg-error "cannot convert 'std::nullptr_t'" }
+
+/* Verify that arrays of member pointers can be initialized by a literal
+   zero as well as nullptr.  */
+
+struct S { };
+typedef int S::*MemPtr;
+typedef int (S::*MemFuncPtr)();
+
+MemPtr mp1[3] = { 0, nullptr, (MemPtr)0 };
+MemPtr mp2[3] = { 0, std::nullptr_t (), MemPtr () };
+
+MemPtr mp3[3] = { 0, (void*)0 };          // { dg-error "cannot convert 'void\\\*' to 'MemPtr' " }
+MemPtr mp4[3] = { 0, (S*)0 };             // { dg-error "cannot convert 'S\\\*' to 'MemPtr' " }
+MemPtr mp5[3] = { 0, S () };              // { dg-error "cannot convert 'S' to 'MemPtr' " }
+
+MemFuncPtr mfp1[3] = { 0, nullptr, (MemFuncPtr)0 };
+MemFuncPtr mfp2[3] = { 0, std::nullptr_t (), MemFuncPtr () };
+
+MemFuncPtr mfp3[3] = { 0, (void*)0 };     // { dg-error "cannot convert 'void\\\*' to 'MemFuncPtr' " }
+MemFuncPtr mfp4[3] = { 0, (S*)0 };        // { dg-error "cannot convert 'S\\\*' to 'MemFuncPtr' " }
+MemFuncPtr mfp5[3] = { 0, S () };         // { dg-error "cannot convert 'S' to 'MemFuncPtr' " }
diff --git a/gcc/testsuite/g++.dg/init/const14.C b/gcc/testsuite/g++.dg/init/const14.C
new file mode 100644
index 00000000000..f29c7e58cfc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/const14.C
@@ -0,0 +1,14 @@
+// PR c++/91529
+// { dg-do run }
+// { dg-additional-options -fmerge-all-constants }
+
+struct A
+{
+  int i[2];
+  ~A() { i[0] = 0; }
+};
+
+int main()
+{
+  const A a = { 1,2 };
+}
diff --git a/gcc/testsuite/g++.dg/lookup/pr84733.C b/gcc/testsuite/g++.dg/lookup/pr84733.C
new file mode 100644
index 00000000000..d0394eab891
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/pr84733.C
@@ -0,0 +1,21 @@
+// { dg-do compile { target c++11 } }
+// PR c++/84733 ICE popping local binding after cleanup region
+
+struct c {
+  ~c();
+} b;
+
+void f() {
+#ifndef OK
+  try {
+  d:
+    ;
+  } catch (int) {
+  }
+#endif
+  decltype(b) a;
+  int e;
+  struct e { } f;
+  e = 5;
+  struct e j;
+}
diff --git a/gcc/testsuite/g++.dg/lto/pr96591_0.C b/gcc/testsuite/g++.dg/lto/pr96591_0.C
new file mode 100644
index 00000000000..ae2dc98efc4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/pr96591_0.C
@@ -0,0 +1,45 @@
+// { dg-lto-do assemble }
+// { dg-lto-options { { -O -flto } } }
+
+template <typename scalar_t, unsigned length>
+struct builtin_simd
+{
+  using type [[gnu::vector_size(sizeof(scalar_t) * length)]] = scalar_t;
+};
+
+struct simd_traits
+{
+  using scalar_type = int;
+
+  template <typename new_scalar_type>
+  using rebind = typename builtin_simd<new_scalar_type, 1>::type;
+};
+
+template <typename simd_t>
+constexpr simd_t fill(typename simd_traits::scalar_type const scalar)
+{
+  return simd_t{scalar};
+}
+
+class Test
+{
+    using score_type = typename builtin_simd<int, 1>::type;
+    score_type data[1]{fill<score_type>(8)};
+};
+
+struct TestFactoryBase
+{
+  virtual Test *CreateTest() = 0;
+};
+
+template <class TestClass>
+struct TestFactoryImpl : public TestFactoryBase
+{
+  Test *CreateTest() override { return new TestClass; }
+};
+
+void MakeAndRegisterTestInfo(TestFactoryBase *factory);
+
+int main() {
+  MakeAndRegisterTestInfo(new TestFactoryImpl<Test>);
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr94618.C b/gcc/testsuite/g++.dg/opt/pr94618.C
new file mode 100644
index 00000000000..e6a81d2c5ab
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr94618.C
@@ -0,0 +1,25 @@
+// PR rtl-optimization/94618
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2 -fnon-call-exceptions -fcompare-debug" }
+
+struct S
+{
+  int a, b, c;
+  int foo () noexcept { return a; }
+  int bar () noexcept { return b; }
+  void baz (int);
+  void qux () { if (c) for (int x = foo (); x != bar (); ) baz (x); }
+};
+
+struct T
+{
+  S s;
+  void foo ();
+};
+
+void
+T::foo ()
+{
+  s.qux ();
+  s.qux ();
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr95080.C b/gcc/testsuite/g++.dg/opt/pr95080.C
new file mode 100644
index 00000000000..2da7df73b72
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr95080.C
@@ -0,0 +1,41 @@
+// PR debug/95080
+// { dg-do compile }
+// { dg-options "-Og -fcse-follow-jumps -fnon-call-exceptions -fcompare-debug" }
+
+char *a;
+
+void baz ();
+
+static inline bool
+bar ()
+{
+  int j = a[0] - 1;
+  switch (j)
+    {
+    case 0:
+    case 2:
+      return true;
+    default:
+      return false;
+    }
+}
+
+static inline bool
+foo ()
+{
+  if (bar ())
+    baz ();
+  return 0;
+}
+
+struct S
+{
+  int h;
+   ~S ();
+};
+
+S::~S ()
+{
+  if (a[0] == 0)
+    foo () != h;
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr96722.C b/gcc/testsuite/g++.dg/opt/pr96722.C
new file mode 100644
index 00000000000..408dfeea8a0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr96722.C
@@ -0,0 +1,20 @@
+// PR tree-optimization/96722
+// { dg-do run }
+// { dg-options "-O2" }
+
+struct S { int s; ~S () {} };
+
+void
+foo (S *a)
+{
+  if (a)
+    return;
+  a->~S ();
+}
+
+int
+main ()
+{
+  S s;
+  foo (&s);
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr98282.C b/gcc/testsuite/g++.dg/opt/pr98282.C
new file mode 100644
index 00000000000..545084104d5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr98282.C
@@ -0,0 +1,80 @@
+// PR tree-optimization/98282
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+template <typename> struct g;
+template <typename b> struct g<b &> { typedef b c; };
+template <typename b> typename g<b>::c &&d(b &&e) {
+  return static_cast<typename g<b>::c &&>(e);
+}
+void *operator new(__SIZE_TYPE__, void *f) { return f; }
+struct h;
+struct k {
+  using i = h *;
+};
+struct D {
+  k::i j;
+};
+struct p : D {
+  p(p &&) : D() {}
+};
+struct r {
+  using l = int;
+  r(r &&) : ad() {}
+  l *ad;
+};
+struct s {
+  static s m();
+};
+struct t {
+  template <typename ah> void operator=(ah);
+};
+struct I {
+  template <typename o> void q(o ai) {
+    *ai = aj();
+    s::m();
+  }
+  h aj();
+};
+template <typename...> class as;
+struct J {
+  int a;
+  char av;
+};
+template <typename...> struct aw : J {
+  void ax(...) {}
+};
+template <typename... ay, typename an, typename... n>
+struct aw<as<ay...>, an, n...> : aw<as<ay...>, n...> {
+  using az = as<ay...>;
+  using ba = aw<az, n...>;
+  char bb;
+  an &bc() { return *reinterpret_cast<an *>(this); }
+  void ax(az *bd) {
+    if (bb)
+      new (bd) an(d(bc()));
+    ba::ax(bd);
+  }
+};
+template <typename... n> struct as : aw<as<n...>, n...> {
+  as();
+  as(as &&be) { be.ax(this); }
+  void operator=(as be) { be.ax(this); }
+};
+struct h {
+  as<decltype(nullptr), r, p> bg;
+};
+using bh = t;
+struct u {
+  bh bj;
+};
+I bk();
+template <typename> void bl() {
+  h a;
+  bk().q(&a);
+}
+template <typename> void bn(int) {
+  u b;
+  b.bj = bl<int>;
+}
+void bp() { bn<int>(0); }
diff --git a/gcc/testsuite/g++.dg/pr93674.C b/gcc/testsuite/g++.dg/pr93674.C
new file mode 100644
index 00000000000..8c59f1b0079
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr93674.C
@@ -0,0 +1,16 @@
+// { dg-do compile }
+// { dg-options "-O3 -std=c++14 -fstrict-enums -pedantic -fdump-tree-optimized" }
+enum some_enum { x = 1000 };
+void sink(some_enum);
+
+int __attribute__((noinline)) func() {
+  int sum = 0;
+  for (int i = 0; i < 3; ++i) {
+      for (int j = 3; j >= 0; --j) {
+          sink((some_enum)(i + j));
+      }
+  }
+  return sum;
+}
+
+// { dg-final { scan-tree-dump-not "some_enum ivtmp" "optimized" } }
diff --git a/gcc/testsuite/g++.dg/pr94666.C b/gcc/testsuite/g++.dg/pr94666.C
new file mode 100644
index 00000000000..a9bfb24f795
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr94666.C
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// { dg-options "-O3" }
+// { dg-additional-options "-march=z13" { target s390*-*-* } }
+
+int a, c;
+struct A {
+  int e() {
+    int f;
+    for (int b = 0; b < 4; b++) {
+      a = __builtin_popcountl(d[b]);
+      f += a;
+    }
+    return f;
+  }
+  long d[4];
+} * g;
+void h() {
+  for (int b; b; b++)
+    c += g[b].e();
+}
diff --git a/gcc/testsuite/g++.dg/pr97627.C b/gcc/testsuite/g++.dg/pr97627.C
new file mode 100644
index 00000000000..81466dc3b81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr97627.C
@@ -0,0 +1,44 @@
+/* PR tree-optimization/97627.  */
+/* { dg-do run } */
+
+struct S { unsigned short x, y; } m = { 1, 0 };
+
+__attribute__((noipa)) void
+baz (int x, int y)
+{
+  if (x != 0 || y != 1)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+bar ()
+{
+  throw 1;
+}
+
+void
+foo ()
+{
+  while (1)
+    {
+      int a = m.x + 1;
+      int b = m.y + 1;
+      for (int c = 0; c < a; c++)
+	for (int d = 0; d < b; d++)
+	  baz (d, b);
+      bar ();
+    }
+}
+
+int
+main ()
+{
+  try
+    {
+      foo ();
+    }
+  catch (int)
+    {
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/alignof3.C b/gcc/testsuite/g++.dg/template/alignof3.C
new file mode 100644
index 00000000000..e573727c5f2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/alignof3.C
@@ -0,0 +1,13 @@
+// PR c++/88115
+// { dg-do compile { target c++11 } }
+
+template<int __v>
+struct integral_constant {
+  static constexpr int value = __v;
+};
+
+template <class T> using StdAlignOf = integral_constant<alignof(T)>;
+template <class T> using GCCAlignOf = integral_constant<__alignof__(T)>;
+
+static_assert(StdAlignOf<double>::value == alignof(double), "");
+static_assert(GCCAlignOf<double>::value == __alignof__(double), "");
diff --git a/gcc/testsuite/g++.dg/template/dependent-name14.C b/gcc/testsuite/g++.dg/template/dependent-name14.C
new file mode 100644
index 00000000000..52d2e72be35
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/dependent-name14.C
@@ -0,0 +1,38 @@
+// PR c++/90711
+// { dg-do compile { target c++11 } }
+
+namespace test {
+    void EXISTS(int);
+}
+
+template<typename... ARGS>
+struct stub_void {
+    typedef void type;
+};
+template<typename... ARGS>
+using stub_void_t = typename stub_void<ARGS...>::type;
+
+#if !defined(SUPPRESS)
+template<typename O, typename = void>
+struct has_to_string {
+    static constexpr bool value = false;
+};
+
+template<typename O>
+struct has_to_string<O, stub_void_t<decltype(EXISTS(O{}))>> {
+    static constexpr bool value = true;
+};
+#endif
+
+template<typename O, typename = void>
+struct has_std_to_string {
+    static constexpr bool value = false;
+};
+
+template<typename O>
+struct has_std_to_string<O, stub_void_t<decltype(test::EXISTS(O{}))>> {
+    static constexpr bool value = true;
+};
+
+static_assert (has_std_to_string<int>::value, "");
+
diff --git a/gcc/testsuite/g++.dg/template/pr98297.C b/gcc/testsuite/g++.dg/template/pr98297.C
new file mode 100644
index 00000000000..0dd63a57b5c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/pr98297.C
@@ -0,0 +1,6 @@
+// PR 98297, ICE
+// { dg-do compile { target c++11 } }
+template <template <class> class a>
+struct [[b]]
+a <int>; // { dg-error "does not declare anything" }
+// { dg-warning "ignored" "" { target *-*-* } .-1 }
diff --git a/gcc/testsuite/g++.dg/template/virtual5.C b/gcc/testsuite/g++.dg/template/virtual5.C
new file mode 100644
index 00000000000..4d9044579ca
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/virtual5.C
@@ -0,0 +1,31 @@
+// PR c++/95158
+// { dg-do run }
+
+class Base {
+    public:
+        virtual void foo()=0;
+};
+
+template <typename T>
+class MiddleA : virtual public Base {
+    public:
+        virtual void foo() {}
+};
+
+class MiddleB : virtual public Base {};
+
+template <typename T>
+class Derived : public MiddleA<T>, public MiddleB {
+    public:
+        void bar()
+        {
+	  Derived d;
+	  d.foo();
+        }
+};
+
+int main()
+{
+  Derived<void> a;
+  a.bar(); // Instantiate the template
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr94303.C b/gcc/testsuite/g++.dg/torture/pr94303.C
new file mode 100644
index 00000000000..45b90a2249d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr94303.C
@@ -0,0 +1,17 @@
+// PR middle-end/94303
+// { dg-do run }
+
+struct A {
+  int d = 9;
+  A () = default;
+  A (int x) : d(x) {}
+  void foo () { if (d < 1) __builtin_abort (); }
+};
+
+A a[3] = { 1 };
+
+int
+main ()
+{
+  a[2].foo ();
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr95717.C b/gcc/testsuite/g++.dg/torture/pr95717.C
new file mode 100644
index 00000000000..362dc10656b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr95717.C
@@ -0,0 +1,12 @@
+// { dg-do compile }
+
+bool a;
+extern bool b[];
+long c, d;
+int *f;
+void g(bool h)
+{
+  for (short e = 0; e < c; e = 4)
+    for (; d; d++)
+      b[d] = a = f[d] ? c ? h : 0 : h;
+}
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr95638.C b/gcc/testsuite/g++.dg/tree-ssa/pr95638.C
new file mode 100644
index 00000000000..d1bea6dffaa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr95638.C
@@ -0,0 +1,150 @@
+// PR tree-optimization/95638
+// { dg-do run }
+// { dg-options "-O2 -std=c++14" }
+
+#include <cassert>
+#include <cstdio>
+#include <cstdint>
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+template <typename Derived>
+class intrusive_ref_counter
+{
+public:
+    intrusive_ref_counter() = default;
+    
+    intrusive_ref_counter(intrusive_ref_counter const&) :
+        _counter(0)
+    {
+    }
+
+    friend void intrusive_ptr_add_ref(const intrusive_ref_counter<Derived>* p)
+    {
+        ++p->_counter;
+    }
+    
+    friend void intrusive_ptr_release(const intrusive_ref_counter<Derived>* p)
+    {
+        if (--p->_counter == 0)
+        {
+            delete static_cast<const Derived*>(p);
+        }
+    }
+    
+private:
+    mutable int _counter = 0;
+};
+
+template <typename T>
+class intrusive_ptr
+{
+public:
+    intrusive_ptr() = default;
+
+    intrusive_ptr(T* p): px(p)
+    {
+        if (px != 0) intrusive_ptr_add_ref(px);
+    }
+
+    intrusive_ptr(intrusive_ptr const & rhs): px(rhs.px)
+    {
+        if (px != 0) intrusive_ptr_add_ref(px);
+    }
+
+    ~intrusive_ptr()
+    {
+        if (px != 0) intrusive_ptr_release(px);
+    }
+
+    intrusive_ptr(intrusive_ptr && rhs) : px(rhs.px)
+    {
+        rhs.px = 0;
+    }
+
+    explicit operator bool() const
+    {
+        return px != 0;
+    }
+    
+private:
+    T* px = nullptr;
+};
+
+template <typename T, uint32_t MaxSize = 1>
+class Storage
+{
+public:
+    Storage() = default;
+
+    Storage(Storage&& other)
+    {
+        for (int i = 0; i < other._size; ++i)
+        {
+            new (data() + i) T(std::move(other.data()[i]));
+            ++_size;
+        }
+    }
+
+    ~Storage()
+    {
+        for (int i = 0; i < _size; ++i)
+        {
+            data()[i].~T();
+        }
+    }
+
+    void push_back(const T& value)
+    {
+        assert(_size < MaxSize);
+
+        new (data() + _size) T(value);
+        ++_size;
+    }
+    
+    T& operator[](size_t idx)
+    {
+        assert(idx < _size);
+        return data()[idx];
+    }
+
+private:
+    T* data()
+    {
+        return reinterpret_cast<T*>(&_data);
+    }
+
+private:
+    uint32_t _size = 0;
+    std::aligned_storage_t<sizeof(T[MaxSize])> _data;
+};
+
+struct Item: intrusive_ref_counter<Item>
+{
+};
+
+using Collection = Storage<intrusive_ptr<Item>>;
+
+struct Holder
+{
+    __attribute__ ((noinline)) Holder(Collection collection) : collection(std::move(collection)) {}
+
+    int64_t dummy = 0; // this is needed to reproduce the issue.
+    Collection collection;
+};
+
+int main()
+{
+    Collection collection;
+    collection.push_back(intrusive_ptr<Item>(new Item()));
+
+    Holder holder(std::move(collection));
+
+    auto item = holder.collection[0];
+    
+    if (!item)
+      __builtin_abort ();
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/vptr-15.C b/gcc/testsuite/g++.dg/ubsan/vptr-15.C
new file mode 100644
index 00000000000..f6f36a58bab
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/vptr-15.C
@@ -0,0 +1,14 @@
+// PR c++/94325
+// { dg-do run { target c++11 } }
+// { dg-options "-fsanitize=vptr -fno-sanitize-recover=vptr" }
+
+struct A { virtual ~A () = default; };
+struct B : public virtual A {};
+struct C : public B {};
+struct D : public C {};
+
+int
+main ()
+{
+  D a;
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr97255.cc b/gcc/testsuite/g++.dg/vect/pr97255.cc
new file mode 100644
index 00000000000..efb7f53fd27
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr97255.cc
@@ -0,0 +1,44 @@
+// { dg-require-effective-target c++11 }
+// { dg-additional-options "-O3" }
+
+template<class T, unsigned N>
+class Array{
+public:
+    T& operator[](unsigned x) {return m_arr[x];}
+private:
+    T m_arr[N];
+};
+
+int
+__attribute__((noipa))
+logicalOr(Array< char, 4 > in1[60],
+          Array< bool, 4 > out[60])
+{
+  for (unsigned k0 = 0u; k0 < 60u; ++k0) {
+      Array< char, 4 > in1m = in1[k0];
+      Array< bool, 4 > x;
+      for (unsigned k1 = 0u; k1 < 4u; ++k1) {
+          char in1s = in1m[k1];
+          x[k1] = in1s != char(0) || in1s != char(0);
+      }
+      out[k0] = x;
+  }
+  return out[0][0];
+}
+
+
+int main()
+{
+  Array< char, 4 > In1[60]{};
+  Array< bool, 4 > Out7[60]{};
+
+  for( int i = 0; i < 60; ++i){
+      for( int j = 0; j < 4; ++j){
+          In1[i][j] = 240 - i*4 - j;
+      }
+  }
+
+  if (logicalOr(In1, Out7) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wreturn-type-12.C b/gcc/testsuite/g++.dg/warn/Wreturn-type-12.C
new file mode 100644
index 00000000000..b35d3faafb0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wreturn-type-12.C
@@ -0,0 +1,23 @@
+// PR c++/94742
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wreturn-type" }
+
+template <class T>
+[[noreturn]] void
+foo (T const &t, char const *)
+{
+  throw T (t);
+}
+
+template <class U>
+int
+bar ()
+{
+  foo (42, __FUNCTION__);
+}	// { dg-bogus "no return statement in function returning non-void" }
+
+int
+main ()
+{
+  bar<long>();
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-3.C b/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-3.C
new file mode 100644
index 00000000000..045dc75563e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-3.C
@@ -0,0 +1,8 @@
+// PR c++/95560
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wshadow=compatible-local" }
+
+template <typename> void fn1() {
+  bool ready;
+  enum class State { ready };
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C b/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C
new file mode 100644
index 00000000000..d0375042e42
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-tmpl.C
@@ -0,0 +1,12 @@
+// PR c++/94951
+// { dg-do compile }
+// { dg-options "-O2 -Wall" }
+
+struct A { int a; };
+template <int N>
+struct B : public A
+{
+  static B<N> foo () { B<N> t; t.a = 4; return t; }	// { dg-bogus "dereferencing type-punned pointer will break strict-aliasing rules" }
+};
+
+B<0> b = B<0>::foo ();
diff --git a/gcc/testsuite/g++.dg/warn/Wunused-var-26.C b/gcc/testsuite/g++.dg/warn/Wunused-var-26.C
index b3e020b6007..89c53de88a4 100644
--- a/gcc/testsuite/g++.dg/warn/Wunused-var-26.C
+++ b/gcc/testsuite/g++.dg/warn/Wunused-var-26.C
@@ -47,10 +47,10 @@ template <class T>
 void f_var_type_unused ()
 {
   // The variable's type is marked unused.
-  T* UNUSED t = new T;   // { dg-bogus "unused variable" "bug 79585" { xfail *-*-* } }
+  T* UNUSED t = new T;   // { dg-bogus "unused variable" "bug 79585" }
 
   typedef T U;
-  U* UNUSED u = new U;   // { dg-bogus "unused variable" "bug 79585" { xfail *-*-* } }
+  U* UNUSED u = new U;   // { dg-bogus "unused variable" "bug 79585" }
 
   typedef T UNUSED U;
   U v = U ();   // { dg-bogus "unused variable" "bug 79585" }
diff --git a/gcc/testsuite/g++.target/aarch64/pr94052.C b/gcc/testsuite/g++.target/aarch64/pr94052.C
new file mode 100644
index 00000000000..d36c9bdc158
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/pr94052.C
@@ -0,0 +1,174 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O2 -std=gnu++11 -w" } */
+
+namespace c {
+typedef int d;
+template <typename e> struct f { typedef e g; };
+template <bool, typename> struct h;
+template <typename e> e aa(typename f<e>::g i) { return i; }
+template <typename, typename> struct j {};
+template <d, typename> struct k;
+template <class l, class m> struct k<1, j<l, m>> { typedef m g; };
+template <d n, class l, class m> typename k<n, j<l, m>>::g ab(j<l, m>);
+} // namespace c
+typedef long d;
+typedef char o;
+typedef int p;
+typedef char q;
+typedef int r;
+namespace {
+struct s;
+constexpr d t = 6;
+template <typename> class ad {
+public:
+  static constexpr d u = t;
+  d v();
+  d x();
+  d y();
+};
+class z : ad<int> {};
+struct ae {
+  p af;
+};
+class ag {
+public:
+  ae ah();
+};
+} // namespace
+typedef __Int32x4_t ai;
+typedef struct {
+  ai aj[2];
+} ak;
+typedef int al;
+void am(p *a, ai b) { __builtin_aarch64_st1v4si(a, b); }
+namespace an {
+class ao {
+public:
+  bool operator==(ao);
+  d v();
+  d x();
+};
+class ap : public ad<r> {};
+class aq {
+public:
+  c::j<int, int> ar();
+  int as();
+  int at();
+};
+class au {
+public:
+  virtual d av(d);
+  virtual ap aw();
+  virtual ag ax();
+};
+class ay {};
+class az {
+  virtual void ba(const ay &, const s &);
+};
+using bb = az;
+class bc;
+class bd : bb {
+  void ba(const ay &, const s &);
+  bc *be;
+  bc *bf;
+  bc *bg;
+  aq bh;
+  int bi;
+  int bj;
+  ao bk;
+};
+namespace bl {
+namespace bm {
+namespace bn {
+class bo;
+}
+} // namespace bm
+} // namespace bl
+namespace bn {
+template <typename ac = c::h<0, bl::bm ::bn::bo>>
+ai bp(ac *, ac *, ac *, al, al, al, d, p);
+template <typename ac = c::h<0, bl::bm ::bn::bo>>
+ak bq(ac *br, ac *bs, ac *bt, al bu, al bv, al bw, d bx, int, int by) {
+  ak{bp(br, bs, bt, bu, bv, bw, bx, by), bp(br, bs, bt, bu, bv, bw, bx, by)};
+}
+template <typename ac = c::h<0, bl::bm ::bn::bo>>
+ak bz(ac *, ac *, ac *, al, al, al &, int, p);
+template <int> void ca(p *, const ak &);
+template <> void ca<1>(p *buffer, const ak &cb) {
+  am(buffer, cb.aj[0]);
+  am(buffer + 4, cb.aj[1]);
+}
+int cc(int, int);
+} // namespace bn
+class bc {
+public:
+  virtual au *cd();
+};
+class ce {
+public:
+  q *cf();
+};
+template <d> struct cg {
+  template <typename ch> static void ci(ay, z cj, ch ck) { ck(cj); }
+};
+template <typename ch> void cl(ay w, ch ck) {
+  z cj;
+  cg<z::u>::ci(w, cj, c::aa<ch>(ck));
+}
+namespace {
+template <typename T1, typename cm, int cn> class co {
+public:
+  static void convolve(ay, int cs, bc *cp, bc *cq, bc *cr, aq cw, int, ao ct) {
+    int by = cp->cd()->ax().ah().af;
+    int cu = cq->cd()->ax().ah().af;
+    cp->cd()->aw().v();
+    int cv = cp->cd()->aw().x();
+    cp->cd()->aw().y();
+    cp->cd()->aw();
+    int da = cr->cd()->aw().x();
+    int cx = cq->cd()->aw().x();
+    cq->cd()->aw().y();
+    int cy = cr->cd()->av(0);
+    int cz = cr->cd()->av(1);
+    bn::cc(cs, cn);
+    int de = c::ab<1>(cw.ar());
+    cw.as();
+    cw.at();
+    ay db;
+    ce dc;
+    ce dd;
+    ce w;
+    q *di = w.cf();
+    cl(db, [&](z) {
+      int df;
+      dc;
+      di;
+      cx;
+      auto dg(cu);
+      auto dh(cu);
+      auto dl(cu);
+      for (; cz; df += de) {
+        auto br = reinterpret_cast<T1 *>(cv);
+        auto bs = reinterpret_cast<T1 *>(cv);
+        auto bt = reinterpret_cast<T1 *>(df * ct.x());
+        auto dj = reinterpret_cast<cm *>(dd.cf() + da);
+        for (int dk; dk < cy; dk += cs, dj += cs)
+          if (ct == ao()) {
+            auto vres = bn::bz(br, bs, bt, dg, dh, dl, cn, by);
+            bn::ca<cn>(dj, vres);
+          } else
+            bn::bq(br, bs, bt, dg, dh, dl, ct.v(), cn, by);
+      }
+    });
+  }
+};
+template <typename T1, typename cm>
+void bz(ay dm, int cs, bc *cp, bc *cq, bc *cr, aq cw, int dn, ao ct) {
+  co<T1, cm, 1>::convolve(dm, cs, cp, cq, cr, cw, dn, ct);
+  co<T1, cm, 2>::convolve(dm, cs, cp, cq, cr, cw, dn, ct);
+}
+} // namespace
+void bd::ba(const ay &dm, const s &) {
+  bz<o, p>(dm, bi, be, bg, bf, bh, bj, bk);
+}
+} // namespace an
diff --git a/gcc/testsuite/g++.target/aarch64/pr94514.C b/gcc/testsuite/g++.target/aarch64/pr94514.C
new file mode 100644
index 00000000000..ae925cafeb6
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/pr94514.C
@@ -0,0 +1,27 @@
+/* PR target/94514. Unwind across mixed pac-ret and non-pac-ret frames.  */
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+
+__attribute__((noinline, target("branch-protection=pac-ret")))
+static void do_throw (void)
+{
+  throw 42;
+  __builtin_abort ();
+}
+
+__attribute__((noinline, target("branch-protection=none")))
+static void no_pac_ret (void)
+{
+  do_throw ();
+  __builtin_abort ();
+}
+
+int main ()
+{
+  try {
+    no_pac_ret ();
+  } catch (...) {
+    return 0;
+  }
+  __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.target/aarch64/pr94515-1.C b/gcc/testsuite/g++.target/aarch64/pr94515-1.C
new file mode 100644
index 00000000000..20ae81215fc
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/pr94515-1.C
@@ -0,0 +1,44 @@
+/* PR target/94515. Check .cfi_window_save with multiple return paths.  */
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-additional-options "-O2 --save-temps" } */
+
+volatile int zero = 0;
+
+__attribute__((noinline, target("branch-protection=none")))
+void unwind (void)
+{
+  if (zero == 0)
+    throw 42;
+}
+
+__attribute__((noinline, noipa, target("branch-protection=pac-ret")))
+int test (int z)
+{
+  if (z) {
+    asm volatile ("":::"x20","x21");
+    unwind ();
+    return 1;
+  } else {
+    unwind ();
+    return 2;
+  }
+}
+
+__attribute__((target("branch-protection=none")))
+int main ()
+{
+  try {
+    test (zero);
+    __builtin_abort ();
+  } catch (...) {
+    return 0;
+  }
+  __builtin_abort ();
+}
+
+/* This check only works if there are two return paths in test and
+   cfi_window_save is used for both instead of cfi_remember_state
+   plus cfi_restore_state.  This is currently the case with -O2.  */
+
+/* { dg-final { scan-assembler-times {\t\.cfi_window_save\n} 4 } } */
diff --git a/gcc/testsuite/g++.target/aarch64/pr94515-2.C b/gcc/testsuite/g++.target/aarch64/pr94515-2.C
new file mode 100644
index 00000000000..e73df499070
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/pr94515-2.C
@@ -0,0 +1,41 @@
+/* PR target/94515. Check .cfi_window_save with multiple return paths.  */
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-additional-options "-O2 -mbranch-protection=pac-ret" } */
+
+volatile int zero = 0;
+int global = 0;
+
+__attribute__((noinline))
+int bar(void)
+{
+  if (zero == 0) return 3;
+  return 0;
+}
+
+__attribute__((noinline, noreturn))
+void unwind (void)
+{
+  throw 42;
+}
+
+__attribute__((noinline, noipa))
+int test(int x)
+{
+  if (x==1) return 2; /* This return path may not use the stack.  */
+  int y = bar();
+  if (y > global) global=y;
+  if (y==3) unwind(); /* This return path must have RA mangle state set.  */
+  return 0;
+}
+
+int main ()
+{
+  try {
+    test (zero);
+    __builtin_abort ();
+  } catch (...) {
+    return 0;
+  }
+  __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.target/aarch64/pr95114.C b/gcc/testsuite/g++.target/aarch64/pr95114.C
new file mode 100644
index 00000000000..1689159e47c
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/pr95114.C
@@ -0,0 +1,3 @@
+template<typename T> struct foo { virtual void f() = 0; };
+extern foo<__Int8x8_t> &x;
+void f() { x.f(); }
diff --git a/gcc/testsuite/g++.target/riscv/pr97682.C b/gcc/testsuite/g++.target/riscv/pr97682.C
new file mode 100644
index 00000000000..03c7a447de5
--- /dev/null
+++ b/gcc/testsuite/g++.target/riscv/pr97682.C
@@ -0,0 +1,160 @@
+/* PR target/97682 */
+/* { dg-do compile } */
+/* { dg-options "-fPIC -O2 -march=rv64g -mabi=lp64" } */
+
+template <typename ab, int ac> struct g { ab b[ac]; };
+long i, m;
+
+namespace std
+{
+  template <typename c> struct t
+  {
+    int a;
+    c h;
+  };
+
+  struct ad
+  {
+    enum { j };
+  };
+
+  template <typename k> k l(k);
+  struct al {};
+  template <typename k> k aa(k);
+
+  struct v
+  {
+    template <typename n, typename q> static q o(n, n, q);
+  };
+
+  template <int, typename n, typename q> void p(n z, n ao, q ap)
+  {
+    v::o(z, ao, ap);
+  }
+
+  template <int ae, typename n, typename q> void r(n z, n ao, q ap)
+  {
+    p<ae>(z, ao, ap);
+  }
+
+  template <int ae, typename n, typename q> void af(n z, n ao, q)
+  {
+    r<ae>(aa(z), aa(ao), 0);
+  }
+
+  template <typename n, typename q> void ag(n z, n ao, q ap)
+  {
+    af<ad::j>(l(z), l(ao), ap);
+  }
+
+  template <typename> class allocator;
+  template <typename ah, typename ai, typename aj> void ak(ah, ai, aj);
+
+  template <typename s> class aq
+  {
+    template <typename am> struct ar { using f = am *; };
+  public:
+    using an = typename ar<s>::f;
+  };
+
+  template <typename s> class as
+  {
+  public:
+    using an = typename aq<s>::an;
+    an operator->();
+  };
+
+  struct ay
+  {
+    int at();
+  };
+
+  template <typename s, typename = allocator<s>> class vector : ay
+  {
+  public:
+    long au();
+    long x;
+    void av() { _M_default_append(x); }
+    void _M_default_append(unsigned long);
+    void aw();
+    long ax(int);
+  };
+
+  template <typename s, typename y>
+  void vector<s, y>::_M_default_append(unsigned long z)
+  {
+    long az = au();
+    int w = at(), bc = at();
+    i = ax(w);
+    m = ax(w);
+    if (i || m)
+      aw();
+    ak(az, z, bc);
+  }
+}
+
+namespace llvm
+{
+  template <int bd> class bh
+  {
+    enum { bf = bd } * bg[bf];
+  };
+
+  template <class> class bi;
+
+  class bm
+  {
+    using bj = bi<int>;
+    std::as<bj> bk;
+    void bl();
+  };
+
+  template <class> struct bn;
+
+  class br
+  {
+    bh<8> bo;
+  };
+
+  class ca
+  {
+    int *d;
+    int e;
+  };
+
+  template <class bp> class bv : std::al, br
+  {
+    g<std::t<ca>, 8> b;
+  };
+
+  template <class ab> bv<ab> bt(ab);
+
+  class BlockFrequencyInfoImplBase
+  {
+  public:
+    struct FrequencyData;
+    std::vector<FrequencyData> bu;
+  };
+
+  template <class> struct cb { using bw = int; };
+  template <class bx> class bi : BlockFrequencyInfoImplBase
+  {
+    using bw = typename cb<bx>::bw;
+  public:
+    void bl();
+  };
+
+  template <class bx> void bi<bx>::bl()
+  {
+    const bw *by;
+    bv<const int *> bz;
+    ag(bz, bt(by), 0);
+    bu.av();
+  }
+
+  template <> struct bn<const int *> { using u = ca; };
+  void bm::bl() { bk->bl(); }
+}
+
+/* The t1 register is to initial symbol reference for call instruction.  */
+/* { dg-final { scan-assembler "la\tt1,.*FrequencyData.*_M_default_append.*" } } */
diff --git a/gcc/testsuite/gcc.c-torture/compile/packed-aligned-1.c b/gcc/testsuite/gcc.c-torture/compile/packed-aligned-1.c
new file mode 100644
index 00000000000..9f0923e29ee
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/packed-aligned-1.c
@@ -0,0 +1,11 @@
+struct c {
+  double a;
+} __attribute((packed)) __attribute((aligned));
+
+void f(struct c *, struct c);
+
+void g(struct c *ptr)
+{
+  ptr++;
+  f(ptr, *ptr);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr94488.c b/gcc/testsuite/gcc.c-torture/compile/pr94488.c
new file mode 100644
index 00000000000..6e20a4168de
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr94488.c
@@ -0,0 +1,22 @@
+/* PR target/94488 */
+
+typedef unsigned long V __attribute__((__vector_size__(16)));
+typedef long W __attribute__((__vector_size__(16)));
+
+void
+foo (V *x, unsigned long y)
+{
+  *x = *x >> (unsigned int) y;
+}
+
+void
+bar (V *x, unsigned long y)
+{
+  *x = *x << (unsigned int) y;
+}
+
+void
+baz (W *x, unsigned long y)
+{
+  *x = *x >> (unsigned int) y;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr94621.c b/gcc/testsuite/gcc.c-torture/compile/pr94621.c
new file mode 100644
index 00000000000..0d98dfd53a5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr94621.c
@@ -0,0 +1,16 @@
+/* PR tree-optimization/94621 */
+
+struct S { int c, e[]; };
+
+static inline int
+foo (struct S *m, int r, int c)
+{
+  int (*a)[][m->c] = (int (*)[][m->c])&m->e;
+  return (*a)[r][c];
+}
+
+void
+bar (struct S *a)
+{
+  foo (a, 0, 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr96426.c b/gcc/testsuite/gcc.c-torture/compile/pr96426.c
new file mode 100644
index 00000000000..bd573fe5366
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr96426.c
@@ -0,0 +1,10 @@
+/* PR middle-end/96426 */
+
+typedef long long V __attribute__((vector_size(16)));
+typedef double W __attribute__((vector_size(16)));
+
+void
+foo (V *v)
+{
+  __builtin_convertvector (*v, W);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/packed-aligned.c b/gcc/testsuite/gcc.c-torture/execute/packed-aligned.c
new file mode 100644
index 00000000000..f768af0ab02
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/packed-aligned.c
@@ -0,0 +1,28 @@
+struct c {
+  double a;
+} __attribute((packed)) __attribute((aligned));
+
+extern void abort(void);
+
+double g_expect = 32.25;
+
+void f(unsigned x, struct c y)
+{
+  if (x != 0)
+    abort();
+
+  if (y.a != g_expect)
+    abort();
+}
+
+struct c e = { 64.25 };
+
+int main(void)
+{
+  struct c d = { 32.25 };
+  f(0, d);
+
+  g_expect = 64.25;
+  f(0, e);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94130.c b/gcc/testsuite/gcc.c-torture/execute/pr94130.c
new file mode 100644
index 00000000000..044e578d373
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94130.c
@@ -0,0 +1,16 @@
+/* PR tree-optimization/94130 */
+
+int
+main ()
+{
+  int a[8];
+  char *b = __builtin_memset (a, 0, sizeof (a));
+  a[0] = 1;
+  a[1] = 2;
+  a[2] = 3;
+  if (b != (char *) a)
+    __builtin_abort ();
+  else
+    asm volatile ("" : : "g" (a) : "memory");
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94134.c b/gcc/testsuite/gcc.c-torture/execute/pr94134.c
new file mode 100644
index 00000000000..b1b44c3b184
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94134.c
@@ -0,0 +1,14 @@
+/* PR target/94134 */
+
+static volatile int a = 0;
+static volatile int b = 1;
+
+int
+main ()
+{
+  a++;
+  b++;
+  if (a != 1 || b != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94412.c b/gcc/testsuite/gcc.c-torture/execute/pr94412.c
new file mode 100644
index 00000000000..6c806bbd90c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94412.c
@@ -0,0 +1,28 @@
+/* PR middle-end/94412 */
+
+typedef unsigned V __attribute__ ((__vector_size__ (sizeof (unsigned) * 2)));
+
+void
+foo (V *v, V *w)
+{
+  *w = -*v / 11;
+}
+
+void
+bar (V *v, V *w)
+{
+  *w = -18 / -*v;
+}
+
+int
+main ()
+{
+  V a = (V) { 1, 0 };
+  V b = (V) { 3, __INT_MAX__ };
+  V c, d;
+  foo (&a, &c);
+  bar (&b, &d);
+  if (c[0] != -1U / 11 || c[1] != 0 || d[0] != 0 || d[1] != -18U / -__INT_MAX__)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94524-1.c b/gcc/testsuite/gcc.c-torture/execute/pr94524-1.c
new file mode 100644
index 00000000000..e7365ad97fd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94524-1.c
@@ -0,0 +1,19 @@
+/* PR tree-optimization/94524 */
+
+typedef signed char __attribute__ ((__vector_size__ (16))) V;
+
+static __attribute__ ((__noinline__, __noclone__)) V
+foo (V c)
+{
+  c %= (signed char) -19;
+  return (V) c;
+}
+
+int
+main ()
+{
+  V x = foo ((V) { 31 });
+  if (x[0] != 12)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94524-2.c b/gcc/testsuite/gcc.c-torture/execute/pr94524-2.c
new file mode 100644
index 00000000000..9c74b7be403
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94524-2.c
@@ -0,0 +1,25 @@
+/* PR tree-optimization/94524 */
+
+typedef signed char __attribute__ ((__vector_size__ (16))) V;
+
+static __attribute__ ((__noinline__, __noclone__)) V
+foo (V c)
+{
+  c %= (signed char) -128;
+  return (V) c;
+}
+
+int
+main ()
+{
+  V x = foo ((V) { -128 });
+  if (x[0] != 0)
+    __builtin_abort ();
+  x = foo ((V) { -127 });
+  if (x[0] != -127)
+    __builtin_abort ();
+  x = foo ((V) { 127 });
+  if (x[0] != 127)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94591.c b/gcc/testsuite/gcc.c-torture/execute/pr94591.c
new file mode 100644
index 00000000000..42271ad8bce
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94591.c
@@ -0,0 +1,32 @@
+typedef unsigned __attribute__((__vector_size__(8))) V2SI_u;
+typedef int __attribute__((__vector_size__(8))) V2SI_d;
+
+typedef unsigned long __attribute__((__vector_size__(16))) V2DI_u;
+typedef long __attribute__((__vector_size__(16))) V2DI_d;
+
+void id_V2SI(V2SI_d *v)
+{
+  *v = __builtin_shuffle(*v, (V2SI_d)(V2SI_u) { 0, 1 });
+}
+
+void id_V2DI(V2DI_d *v)
+{
+  *v = __builtin_shuffle(*v, (V2DI_d)(V2DI_u) { 0, 1 });
+}
+
+extern void abort(void);
+
+int main(void)
+{
+  V2SI_d si = { 35, 42 };
+  id_V2SI(&si);
+
+  if (si[0] != 35 || si[1] != 42)
+    abort();
+
+  V2DI_d di = { 63, 38 };
+  id_V2DI(&di);
+
+  if (di[0] != 63 || di[1] != 38)
+    abort();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr94809.c b/gcc/testsuite/gcc.c-torture/execute/pr94809.c
new file mode 100644
index 00000000000..ce55e8f92d4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr94809.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/94809 */
+
+int
+main ()
+{
+  int a = 0;
+  unsigned long long one = 1;
+  ((-1ULL / one) < a++, one);
+  if (a != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr97073.c b/gcc/testsuite/gcc.c-torture/execute/pr97073.c
new file mode 100644
index 00000000000..1955e6b8bd2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr97073.c
@@ -0,0 +1,21 @@
+/* PR middle-end/97073 */
+/* { dg-additional-options "-mno-stv" { target i?86-*-* x86_64-*-* } } */
+
+typedef unsigned long long L;
+union U { L i; struct T { unsigned k; L l; } j; } u;
+
+__attribute__((noinline,noclone)) void
+foo (L x)
+{
+  u.j.l = u.i & x;
+}
+
+int
+main ()
+{
+  u.i = 5;
+  foo (-1ULL);
+  if (u.j.l != 5)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr97404.c b/gcc/testsuite/gcc.c-torture/execute/pr97404.c
new file mode 100644
index 00000000000..7e5ce231725
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr97404.c
@@ -0,0 +1,28 @@
+/* PR ipa/97404 */
+/* { dg-additional-options "-fno-inline" } */
+
+char a, b;
+long c;
+short d, e;
+long *f = &c;
+int g;
+char h(signed char i) { return 0; }
+static short j(short i, int k) { return i < 0 ? 0 : i >> k; }
+void l(void);
+void m(void)
+{
+  e = j(d | 9766, 11);
+    *f = e;
+}
+void l(void)
+{
+  a = 5 | g;
+    b = h(a);
+}
+int main()
+{
+  m();
+  if (c != 4)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr97421-1.c b/gcc/testsuite/gcc.c-torture/execute/pr97421-1.c
new file mode 100644
index 00000000000..e32fb129f18
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr97421-1.c
@@ -0,0 +1,23 @@
+/* PR rtl-optimization/97421 */
+/* { dg-additional-options "-fmodulo-sched" } */
+
+int a, b, d, e;
+int *volatile c = &a;
+
+__attribute__((noinline))
+void f(void)
+{
+  for (int g = 2; g >= 0; g--) {
+    d = 0;
+    for (b = 0; b <= 2; b++)
+      ;
+    e = *c;
+  }
+}
+
+int main(void)
+{
+  f();
+  if (b != 3)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr97421-2.c b/gcc/testsuite/gcc.c-torture/execute/pr97421-2.c
new file mode 100644
index 00000000000..142bcbcee91
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr97421-2.c
@@ -0,0 +1,18 @@
+/* PR rtl-optimization/97421 */
+/* { dg-additional-options "-fmodulo-sched -fno-dce -fno-strict-aliasing" } */
+
+static int a, b, c;
+int *d = &c;
+int **e = &d;
+int ***f = &e;
+int main()
+{
+  int h;
+  for (a = 2; a; a--)
+    for (h = 0; h <= 2; h++)
+      for (b = 0; b <= 2; b++)
+        ***f = 6;
+
+  if (b != 3)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr97421-3.c b/gcc/testsuite/gcc.c-torture/execute/pr97421-3.c
new file mode 100644
index 00000000000..3f1485a4a3d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr97421-3.c
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/97421 */
+/* { dg-additional-options "-fmodulo-sched" } */
+
+int a, b, c;
+short d;
+void e(void) {
+  unsigned f = 0;
+  for (; f <= 2; f++) {
+    int g[1];
+    int h = (long)g;
+    c = 0;
+    for (; c < 10; c++)
+      g[0] = a = 0;
+    for (; a <= 2; a++)
+      b = d;
+  }
+}
+int main(void) {
+  e();
+  if (a != 3)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.dg/Wunused-var-4.c b/gcc/testsuite/gcc.dg/Wunused-var-4.c
new file mode 100644
index 00000000000..08ddcf4407e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wunused-var-4.c
@@ -0,0 +1,33 @@
+/* PR c/96571 */
+/* { dg-do compile } */
+/* { dg-options "-std=c99 -O2 -Wunused-but-set-variable" } */
+
+enum E { V };
+
+int
+foo (void)
+{
+  enum E v;				/* { dg-bogus "set but not used" } */
+  return _Generic (v, enum E : 0);
+}
+
+int
+bar (void)
+{
+  int a = 0;				/* { dg-bogus "set but not used" } */
+  return _Generic (0, int : a);
+}
+
+int
+baz (void)
+{
+  int a;				/* { dg-bogus "set but not used" } */
+  return _Generic (0, long long : a, int : 0);
+}
+
+int
+qux (void)
+{
+  int a;				/* { dg-bogus "set but not used" } */
+  return _Generic (0, long long : a, default: 0);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr80166.c b/gcc/testsuite/gcc.dg/asan/pr80166.c
index 629dd23a31c..5e153b274fa 100644
--- a/gcc/testsuite/gcc.dg/asan/pr80166.c
+++ b/gcc/testsuite/gcc.dg/asan/pr80166.c
@@ -1,5 +1,6 @@
 /* PR sanitizer/80166 */
 /* { dg-do run } */
+/* { dg-additional-options "-Wno-stringop-overflow" } */
 
 #include <sys/types.h>
 #include <unistd.h>
diff --git a/gcc/testsuite/gcc.dg/dfp/pr94111.c b/gcc/testsuite/gcc.dg/dfp/pr94111.c
new file mode 100644
index 00000000000..ea3a132270a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/pr94111.c
@@ -0,0 +1,12 @@
+/* PR middle-end/94111 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+int
+main ()
+{
+  _Decimal32 d = (_Decimal32) __builtin_inff ();
+  if (!__builtin_isinf ((double) d))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/dfp/pr97439.c b/gcc/testsuite/gcc.dg/dfp/pr97439.c
new file mode 100644
index 00000000000..7fcf834043c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/pr97439.c
@@ -0,0 +1,27 @@
+// { dg-do run }
+// { dg-options "-O1" }
+
+static int
+foo(_Decimal128 x, _Decimal128 y)
+{
+  if (x > y)
+    return 1;
+
+  return 0;
+}
+
+int __attribute__((noinline))
+bar(_Decimal128 x)
+{
+  return foo (x, -1.0DL * __builtin_infd32());
+}
+
+int
+main (void)
+{
+  int res = bar (0.0DL);
+  if (res != 1)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/gomp/pr82374.c b/gcc/testsuite/gcc.dg/gomp/pr82374.c
index 453266ed84e..e63a2f5c62d 100644
--- a/gcc/testsuite/gcc.dg/gomp/pr82374.c
+++ b/gcc/testsuite/gcc.dg/gomp/pr82374.c
@@ -1,6 +1,9 @@
 /* PR tree-optimization/82374 */
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-tree-vectorize -fdump-tree-vect-details" } */
+/* Option -fno-common makes vectorizer able to force alignment and ensures
+   vectorization can succeed even on targets lacking of unaligned vector
+   load/store.  */
+/* { dg-options "-O2 -fno-tree-vectorize -fdump-tree-vect-details -fno-common" } */
 /* { dg-additional-options "-mavx -mno-avx2" { target i?86-*-* x86_64-*-* } } */
 /* { dg-additional-options "-mvsx" { target powerpc_vsx_ok } } */
 
diff --git a/gcc/testsuite/gcc.dg/gomp/pr95108.c b/gcc/testsuite/gcc.dg/gomp/pr95108.c
new file mode 100644
index 00000000000..b492333686b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gomp/pr95108.c
@@ -0,0 +1,18 @@
+/* PR middle-end/95108 */
+/* { dg-do compile { target vect_simd_clones } } */
+/* { dg-options "-O2 -fopenmp-simd -w" } */
+
+int *v;
+
+#pragma omp declare simd
+void
+foo (int x)
+{
+  int *a = &x + 1;
+
+  for (;;)
+    {
+      *v = *a;
+      a = v;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/graphite/pr93964.c b/gcc/testsuite/gcc.dg/graphite/pr93964.c
new file mode 100644
index 00000000000..80fc523b855
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/pr93964.c
@@ -0,0 +1,19 @@
+/* { dg-do compile }  */
+/* { dg-options "-O -floop-nest-optimize" } */
+
+int *
+eo (void);
+
+void
+g4 (int *nt)
+{
+  int dh, t2 = (__INTPTR_TYPE__)eo ();
+
+  for (dh = 0; dh < 2; ++dh)
+    {
+      int m7;
+
+      for (m7 = 0; m7 < t2; ++m7)
+        nt[m7] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr93399.c b/gcc/testsuite/gcc.dg/pr93399.c
new file mode 100644
index 00000000000..3d9299018be
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr93399.c
@@ -0,0 +1,17 @@
+/* PR middle-end/93399 */
+/* { dg-do assemble } */
+/* { dg-options "-fverbose-asm -dA -g -O3" } */
+
+extern inline __attribute__ ((__always_inline__, __gnu_inline__)) char *
+strstr (const char *haystack, const char *needle)
+{
+  return __builtin_strstr (haystack, needle);
+}
+
+int
+main (int argc, const char **argv)
+{
+  char *substr = strstr (argv[0], "\n");
+  char *another = strstr (argv[0], "\r\n");
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94001.c b/gcc/testsuite/gcc.dg/pr94001.c
new file mode 100644
index 00000000000..f83873fa2bd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94001.c
@@ -0,0 +1,11 @@
+/* PR tree-optimization/94001 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-dce" } */
+
+void
+bar (int e)
+{
+  bar (3);
+  int c;
+  c = -e;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94114.c b/gcc/testsuite/gcc.dg/pr94114.c
new file mode 100644
index 00000000000..8d6d0eb5c2a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94114.c
@@ -0,0 +1,13 @@
+/* PR tree-optimization/94114 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-loop-distribute-patterns -ftrapv" } */
+
+void
+foo (int *x, int *y, int *z, long int w)
+{
+  while (y + w > z)
+    {
+      x[w] = 0;
+      --w;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr94121.c b/gcc/testsuite/gcc.dg/pr94121.c
new file mode 100644
index 00000000000..2a4261ae02d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94121.c
@@ -0,0 +1,16 @@
+/* PR target/94121 */
+/* { dg-do compile { target pie } } */
+/* { dg-options "-O2 -fpie -w" } */
+
+#define DIFF_MAX __PTRDIFF_MAX__
+#define DIFF_MIN (-DIFF_MAX - 1)
+
+extern void foo (char *);
+extern char v[];
+
+void
+bar (void)
+{
+  char *p = v;
+  foo (&p[DIFF_MIN]);
+}
diff --git a/gcc/testsuite/gcc.dg/pr94167.c b/gcc/testsuite/gcc.dg/pr94167.c
new file mode 100644
index 00000000000..4b819d3a869
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94167.c
@@ -0,0 +1,33 @@
+/* PR debug/94167 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+struct S { int g, h; signed char i; int j; signed char k; int l[4]; } a, c;
+struct T { signed char g; } e;
+int *b, d;
+static void foo ();
+
+void
+bar (void)
+{
+  while (d)
+    {
+      int k;
+      struct T f[3];
+      foo (bar, a);
+      for (k = 0;; k++)
+	f[k] = e;
+    }
+}
+
+static inline void
+foo (int x, struct S y, struct T z)
+{
+  for (z.g = 2; z.g; z.g--)
+    {
+      c = a = y;
+      *b |= 6;
+      if (y.g)
+	break;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr94172-1.c b/gcc/testsuite/gcc.dg/pr94172-1.c
new file mode 100644
index 00000000000..12f84af42dd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94172-1.c
@@ -0,0 +1,12 @@
+/* PR c/94172 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern enum E e;
+enum E { l = 0x100000000ULL };
+
+unsigned long long
+foo (void)
+{
+  return e;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94172-2.c b/gcc/testsuite/gcc.dg/pr94172-2.c
new file mode 100644
index 00000000000..bb7b060d7b2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94172-2.c
@@ -0,0 +1,19 @@
+/* PR c/94172 */
+/* { dg-do compile } */
+/* { dg-options "-Os -g -fshort-enums" } */
+
+extern enum E e;
+extern void bar (int a);
+enum E { F };
+
+void
+foo (int a)
+{
+  int l = e;
+  if (a)
+    {
+      __asm volatile ("nop");
+      l = 0;
+    }
+  bar (l);
+}
diff --git a/gcc/testsuite/gcc.dg/pr94189.c b/gcc/testsuite/gcc.dg/pr94189.c
new file mode 100644
index 00000000000..f927d55279a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94189.c
@@ -0,0 +1,11 @@
+/* PR middle-end/94189 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+const char a[] = { 'a', 'b', 'c', 'd' };/* { dg-message "declared here" } */
+
+int
+foo (void)
+{
+  return __builtin_strnlen (a, 5);	/* { dg-warning "specified bound 5 exceeds the size 4 of unterminated array" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr94211.c b/gcc/testsuite/gcc.dg/pr94211.c
new file mode 100644
index 00000000000..3e160e457fe
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94211.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/94211 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+long
+foo (long a, long b)
+{
+  if (__builtin_expect (b == 1, 1))
+    return a;
+  int e = a + 1;
+  return a / b;
+}
diff --git a/gcc/testsuite/gcc.dg/pr94277.c b/gcc/testsuite/gcc.dg/pr94277.c
new file mode 100644
index 00000000000..dfe38e401a9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94277.c
@@ -0,0 +1,11 @@
+/* PR debug/94277 */
+/* { dg-do compile } */
+/* { dg-options "-fcompare-debug" } */
+
+static void foo (void);	/* { dg-warning "used but never defined" } */
+
+void
+bar (void)
+{
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr94283.c b/gcc/testsuite/gcc.dg/pr94283.c
new file mode 100644
index 00000000000..ac162d6ac7b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94283.c
@@ -0,0 +1,16 @@
+/* PR debug/94283 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fno-tree-dce -fcompare-debug" } */
+
+void
+foo (int *n)
+{
+  for (int i = 0; i < 32; i++)
+    {
+      int x = 0;
+      x++;
+      if (i & 4)
+	x++;
+      x++;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr94368.c b/gcc/testsuite/gcc.dg/pr94368.c
new file mode 100644
index 00000000000..1267b822098
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94368.c
@@ -0,0 +1,25 @@
+/* PR target/94368 */
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-fpic -O1 -fcommon" } */
+
+int b, c, d, e, f, h;
+short g;
+int foo (int) __attribute__ ((__const__));
+
+void
+bar (void)
+{
+  while (1)
+    {
+      while (1)
+	{
+	  __atomic_load_n (&e, 0);
+	  if (foo (2))
+	    __sync_val_compare_and_swap (&c, 0, f);
+	  b = 1;
+	  if (h == e)
+	    break;
+	}
+      __sync_val_compare_and_swap (&g, -1, f);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr94705.c b/gcc/testsuite/gcc.dg/pr94705.c
new file mode 100644
index 00000000000..96392ab60ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94705.c
@@ -0,0 +1,13 @@
+/* PR c/94705 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void foo ();
+
+int
+bar (void)
+{
+  foo (baz);	/* { dg-error "'baz' undeclared" } */
+		/* { dg-message "only once" "" { target *-*-* } .-1 } */
+  void __attribute__ ((noinline)) baz (void);
+}
diff --git a/gcc/testsuite/gcc.dg/pr94780.c b/gcc/testsuite/gcc.dg/pr94780.c
new file mode 100644
index 00000000000..c4b723e24b2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94780.c
@@ -0,0 +1,13 @@
+/* PR target/94780 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Atomic double x;
+
+double
+foo (void)
+{
+  double bar () { return x; }
+  x /= 3;
+  return bar ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr94842.c b/gcc/testsuite/gcc.dg/pr94842.c
new file mode 100644
index 00000000000..33d9d42644c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94842.c
@@ -0,0 +1,11 @@
+/* PR c/94842 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+_Atomic float x = 5;
+
+void
+foo (void)
+{
+  void bar (float y[(int) (x += 2)]) {}
+}
diff --git a/gcc/testsuite/gcc.dg/pr94873.c b/gcc/testsuite/gcc.dg/pr94873.c
new file mode 100644
index 00000000000..36152176fbf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94873.c
@@ -0,0 +1,27 @@
+/* PR rtl-optimization/94873 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O -fno-merge-constants -fno-split-wide-types -fno-tree-fre" } */
+
+__attribute__((noipa)) void
+foo (const char *p, int q)
+{
+  if (p[0] != '%' || p[1] != '0' || p[2] != '2' || p[3] != 'x' || p[4] != '\0')
+    __builtin_abort ();
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  if ((unsigned char) q != 0x95)
+    __builtin_abort ();
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  if ((unsigned char) q != 0)
+    __builtin_abort ();
+#endif
+}
+
+int
+main ()
+{
+  union U { __int128 a; char b[sizeof (__int128)]; };
+  char x = ((union U){ .a = 0xF4409395252B9560ULL}).b[1];
+  for (unsigned i = 0; i < sizeof (x); i++)
+    foo ("%02x", i[(volatile unsigned char *) &x]);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr95133.c b/gcc/testsuite/gcc.dg/pr95133.c
new file mode 100644
index 00000000000..523decaf90e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr95133.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+extern int a[16];
+void f (int *ip, int x)
+{
+  int *xp = a;
+  for (int i=0; i<8; ++i)
+  {
+    base: if (x) return;
+  }
+  *xp++ = *ip;
+  goto *(&&base + *ip);
+}
diff --git a/gcc/testsuite/gcc.dg/pr95857.c b/gcc/testsuite/gcc.dg/pr95857.c
new file mode 100644
index 00000000000..41506ea6893
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr95857.c
@@ -0,0 +1,37 @@
+/* PR tree-optimization/95857 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct E { int e; };
+int bar (void), baz (void);
+void qux (void *);
+
+void
+foo (int x)
+{
+  struct E a = { 0 };
+  struct E i = { 0 };
+  qux (&&lab2);
+  if (baz ())
+    i.e = 1;
+  else
+    a.e = -2;
+  switch (a.e)
+    {
+    case -2:
+    lab1:
+      switch (i.e)
+	{
+	case -3:
+	case 2:
+	  if (i.e-- != 2)
+	    __builtin_unreachable ();
+	lab2:
+	  baz ();
+	  goto lab1;
+	case 0:
+	  bar ();
+	}
+      break;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr96370.c b/gcc/testsuite/gcc.dg/pr96370.c
new file mode 100644
index 00000000000..b939b2141d6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr96370.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O2 -ffast-math" } */
+
+void c(_Decimal128);
+void a(_Decimal128 b)
+{
+  c(-b * b);
+}
diff --git a/gcc/testsuite/gcc.dg/pr96514.c b/gcc/testsuite/gcc.dg/pr96514.c
new file mode 100644
index 00000000000..891b4da2b1e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr96514.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+
+int __attribute__ ((pure, returns_twice))
+r0 (void);
+
+void
+vy (int t7)
+{
+  while (t7 == 0)
+    r0 ();
+}
+
+void
+qw (int t7)
+{
+  vy (t7);
+
+  if (0)
+    r0 ();
+}
+
+void __attribute__ ((simd))
+un (int t7)
+{
+  qw (t7);
+  qw (t7);
+}
diff --git a/gcc/testsuite/gcc.dg/pr96579.c b/gcc/testsuite/gcc.dg/pr96579.c
new file mode 100644
index 00000000000..982f8ac17a5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr96579.c
@@ -0,0 +1,4 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O -fno-tree-forwprop -ffast-math -fno-tree-vrp" } */
+
+#include "pr96370.c"
diff --git a/gcc/testsuite/gcc.dg/pr99224.c b/gcc/testsuite/gcc.dg/pr99224.c
new file mode 100644
index 00000000000..f6e9ac8eba3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr99224.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+
+void f (char *c, ...)
+{
+  __builtin_next_arg (*c); /* { dg-warning "not last named argument" } */
+}
diff --git a/gcc/testsuite/gcc.dg/store_merging_31.c b/gcc/testsuite/gcc.dg/store_merging_31.c
new file mode 100644
index 00000000000..32c21eb053c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/store_merging_31.c
@@ -0,0 +1,27 @@
+/* PR tree-optimization/97053 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+struct S { short a; char b[9]; int c; char d; int e; };
+
+__attribute__((noipa)) void
+foo (char *x, char *y)
+{
+  if (__builtin_strcmp (x, "ABCDXXXX") != 0
+      || __builtin_strcmp (y, "ABCDXXXX") != 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  char a[9] = "XXXXXXXX";
+  struct S b = {};
+  __builtin_memcpy (a, "ABCD", 4);
+  b.a = 5;
+  __builtin_memcpy (b.b, a, 8); 
+  b.d = 'X';
+  b.e = 1;
+  foo (a, b.b);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/store_merging_32.c b/gcc/testsuite/gcc.dg/store_merging_32.c
new file mode 100644
index 00000000000..8c90489bdeb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/store_merging_32.c
@@ -0,0 +1,129 @@
+/* PR tree-optimization/97053 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-dse" } */
+
+struct __attribute__((packed, may_alias)) S { long long s; };
+struct __attribute__((packed, may_alias)) T { short t; };
+
+__attribute__((noipa)) void
+test (char *p, char *q, int s)
+{
+  if ((s & 1) == 0)
+    {
+      if (*(short __attribute__((may_alias)) *) &p[sizeof (short)]
+	  != *(short __attribute__((may_alias)) *) &q[sizeof (short)]
+	  || (((struct S __attribute__((may_alias)) *) &p[1])->s
+	      != ((struct S __attribute__((may_alias)) *) &q[1])->s)
+	  || (*(short __attribute__((may_alias)) *) &p[2 * sizeof (short)]
+	      != *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)]))
+	__builtin_abort ();
+    }
+  else
+    {
+      if (*(short __attribute__((may_alias)) *) &p[sizeof (short)]
+	  != *(short __attribute__((may_alias)) *) &q[sizeof (short)]
+	  || (((struct S __attribute__((may_alias)) *) &p[1])->s
+	      != ((struct S __attribute__((may_alias)) *) &q[1])->s)
+	  || (((struct T __attribute__((may_alias)) *) &p[2 * sizeof (short) - 1])->t
+	      != ((struct T __attribute__((may_alias)) *) &q[2 * sizeof (short) - 1])->t)
+	  || p[3 * sizeof (short) - 2] != q[3 * sizeof (short) - 2])
+	__builtin_abort ();
+    }
+}
+
+__attribute__((noipa)) void
+foo (long long *p, char *q, char *r, char *s)
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = 2;
+  *(short __attribute__((may_alias)) *) &q[sizeof (short)] = 1;
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &s[2 * sizeof (short)] = 2;
+  test (a, q, 0);
+}
+
+__attribute__((noipa)) void
+bar (long long *p, char *q, char *r, char *s, char *t)
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  ((struct T __attribute__((may_alias)) *) &a[2 * sizeof (short) - 1])->t = 2;
+  a[3 * sizeof (short) - 2] = 3;
+  *(short __attribute__((may_alias)) *) &q[sizeof (short)] = 1;
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  ((struct T __attribute__((may_alias)) *) &s[2 * sizeof (short) - 1])->t = 2;
+  t[3 * sizeof (short) - 2] = 3;
+  test (a, q, 1);
+}
+
+__attribute__((noipa)) void
+baz (long long *p, char *q, char *r, char *s)
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = 2;
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;
+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = 2;
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = 1;
+  test (a, q, 2);
+}
+
+__attribute__((noipa)) void
+qux (long long *p, char *q, char *r, char *s, char *t)
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short) - 1] = 2;
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  a[3 * sizeof (short) - 2] = 3;
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;
+  ((struct T __attribute__((may_alias)) *) &q[2 * sizeof (short) - 1])->t = 2;
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  s[3 * sizeof (short) - 2] = 3;
+  ((struct T __attribute__((may_alias)) *) &t[sizeof (short)])->t = 1;
+  test (a, q, 3);
+}
+
+__attribute__((noipa)) void
+corge (long long *p, char *q, char *r, char *s, short u[3])
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = u[2];
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = u[1];
+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = u[2];
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = u[1];
+  test (a, q, 4);
+}
+
+__attribute__((noipa)) void
+garply (long long *p, char *q, char *r, char *s, short u[3])
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = u[1];
+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = u[2];
+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = u[1];
+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];
+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = u[2];
+  test (a, q, 6);
+}
+
+int
+main ()
+{
+  char a[64] __attribute__((aligned (__alignof (short))));
+  long long p = -1LL;
+  short u[] = { 1, 2, 3 };
+  foo (&p, &a[0], &a[0], &a[0]);
+  bar (&p, &a[0], &a[0], &a[0], &a[0]);
+  baz (&p, &a[0], &a[0], &a[0]);
+  qux (&p, &a[0], &a[0], &a[0], &a[0]);
+  corge (&p, &a[0], &a[0], &a[0], u);
+  garply (&p, &a[0], &a[0], &a[0], u);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/strncmp-2.c b/gcc/testsuite/gcc.dg/strncmp-2.c
index f5555ba4081..40a4f501448 100644
--- a/gcc/testsuite/gcc.dg/strncmp-2.c
+++ b/gcc/testsuite/gcc.dg/strncmp-2.c
@@ -40,6 +40,7 @@ static void test_driver_strncmp (void (test_strncmp)(const char *, const char *,
     e = lib_memcmp(buf1,p2,sz);
     (*test_memcmp)(buf1,p2,e);
   }
+  mprotect (buf2+pgsz,pgsz,PROT_READ|PROT_WRITE);
   free(buf2);
 }
 
diff --git a/gcc/testsuite/gcc.dg/tls/pr99466-1.c b/gcc/testsuite/gcc.dg/tls/pr99466-1.c
new file mode 100644
index 00000000000..446850e148b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/pr99466-1.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-require-effective-target tls_emulated } */
+/* { dg-add-options tls } */
+__attribute__((weak))
+__thread int tlsvar = 3;
+/* { dg-final { scan-assembler ".weak_definition ___emutls_t.tlsvar" { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler-not ".private_extern ___emutls_t.tlsvar" { target *-*-darwin* } } } */
diff --git a/gcc/testsuite/gcc.dg/tls/pr99466-2.c b/gcc/testsuite/gcc.dg/tls/pr99466-2.c
new file mode 100644
index 00000000000..86ffaad7f48
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/pr99466-2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-require-visibility "" } */
+/* { dg-require-effective-target tls_emulated } */
+/* { dg-add-options tls } */
+__attribute__((weak))
+__attribute__((visibility ("hidden")))
+__thread int tlsvar = 3;
+/* { dg-final { scan-assembler ".weak_definition ___emutls_t.tlsvar" { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler ".private_extern ___emutls_t.tlsvar" { target *-*-darwin* } } } */
diff --git a/gcc/testsuite/gcc.dg/torture/pr94206.c b/gcc/testsuite/gcc.dg/torture/pr94206.c
new file mode 100644
index 00000000000..9e54bba4ed4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr94206.c
@@ -0,0 +1,17 @@
+/* { dg-do run { target lp64 } } */
+
+struct {
+    unsigned long x:33;
+} s;
+typedef __typeof__(s.x + 0) uint33;
+
+int main()
+{
+  uint33 x;
+  __builtin_memset(&x, -1, sizeof x);
+  unsigned long u;
+  __builtin_memcpy(&u, &x, sizeof u);
+  if (u != -1ul)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr94479.c b/gcc/testsuite/gcc.dg/torture/pr94479.c
new file mode 100644
index 00000000000..53285bb4f38
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr94479.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-stack-check "specific" } */
+/* { dg-additional-options "-fstack-check -w" } */
+
+int a;
+struct b {
+    char c;
+    void *d;  
+};
+struct b e() {
+    struct b f[] = {{}, "", f, a};
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr94482.c b/gcc/testsuite/gcc.dg/torture/pr94482.c
new file mode 100644
index 00000000000..9264842e349
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr94482.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-additional-options "-Wno-psabi -w" } */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+
+typedef unsigned V __attribute__ ((__vector_size__ (16)));
+union U
+{
+  V j;
+  unsigned long long i __attribute__ ((__vector_size__ (16)));
+};
+
+static inline __attribute__((always_inline)) V
+foo (unsigned long long a)
+{
+  union U z = { .j = (V) {} };
+  for (unsigned long i = 0; i < 1; i++)
+    z.i[i] = a;
+  return z.j;
+}
+
+static inline __attribute__((always_inline)) V
+bar (V a, unsigned long long i, int q)
+{
+  union U z = { .j = a };
+  z.i[q] = i;
+  return z.j;
+}
+
+int
+main ()
+{
+  union U z = { .j = bar (foo (1729), 2, 1) };
+  if (z.i[0] != 1729)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr94947-1.c b/gcc/testsuite/gcc.dg/torture/pr94947-1.c
new file mode 100644
index 00000000000..ab8b488c6fc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr94947-1.c
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr94947-2.c" } */
+/* { dg-additional-options "-fipa-pta -flto-partition=1to1" } */
+
+extern void abort ();
+extern void baz ();
+extern void (*baz_call)();
+static int *p;
+
+static void foo ()
+{
+  if (*p != 1)
+    abort ();
+}
+
+int main()
+{
+  int x = 1;
+  p = &x;
+  baz_call = foo;
+  baz ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr94947-2.c b/gcc/testsuite/gcc.dg/torture/pr94947-2.c
new file mode 100644
index 00000000000..670dd61c1e9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr94947-2.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+
+void (*baz_call)();
+void baz ()
+{
+  baz_call ();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr95049.c b/gcc/testsuite/gcc.dg/torture/pr95049.c
new file mode 100644
index 00000000000..164bfdbdcfc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr95049.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+
+void a()
+{
+  for (int b; b; b = !b)
+    ;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr97812.c b/gcc/testsuite/gcc.dg/torture/pr97812.c
new file mode 100644
index 00000000000..4d468adf8fa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr97812.c
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fdisable-tree-evrp" } */
+
+unsigned char c;
+
+int main() {
+volatile short b = 4066;
+  unsigned short bp = b;
+  unsigned d = bp & 2305;
+  signed char e = d;
+  c = e ? : e;
+  if (!d)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr98117.c b/gcc/testsuite/gcc.dg/torture/pr98117.c
new file mode 100644
index 00000000000..f2160257263
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr98117.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fno-tree-scev-cprop" } */
+
+unsigned char c;
+void __attribute__((noipa))
+e()
+{
+  do
+    {
+    }
+  while (++c);
+}
+int main()
+{
+  e();
+  if (c != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr98758.c b/gcc/testsuite/gcc.dg/torture/pr98758.c
new file mode 100644
index 00000000000..7b9fdb2b613
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr98758.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+
+long *a, *b;
+long c;
+void d(void)
+{
+  b = a;
+  while (c) {
+    *a = (__INTPTR_TYPE__)(a += (long)1 << (sizeof(long) * 8 - 10));
+    c = b[0];
+    b = a;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr99694.c b/gcc/testsuite/gcc.dg/torture/pr99694.c
new file mode 100644
index 00000000000..df316961673
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr99694.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-w" } */
+
+#include <stdint.h>
+
+int a, b, c;
+void d() {
+  uint16_t e;
+  int32_t *f;
+  int32_t *g;
+  if (a) {
+    int32_t *k;
+    for (;; *k += 1) {
+      int32_t **i = &f;
+      int32_t **l = &g;
+      for (e = 6; e; e++) {
+        g = k = f;
+      j:
+        **l = 0;
+      }
+      *i = c;
+    }
+  }
+  uint16_t i = &e;
+  b = i / 0;
+  goto j;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr93435.c b/gcc/testsuite/gcc.dg/tree-ssa/pr93435.c
new file mode 100644
index 00000000000..cb8e7495b15
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr93435.c
@@ -0,0 +1,159 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef signed char int8_T;
+typedef int int32_T;
+
+typedef struct {
+  int8_T a;
+} struct0_T;
+
+typedef struct {
+  struct0_T f10[4];
+} struct_T;
+
+typedef struct {
+  struct_T f9[4];
+} b_struct_T;
+
+typedef struct {
+  b_struct_T f8[4];
+} c_struct_T;
+
+typedef struct {
+  c_struct_T f7[4];
+} d_struct_T;
+
+typedef struct {
+  d_struct_T f6[4];
+} e_struct_T;
+
+typedef struct {
+  e_struct_T f5[4];
+} f_struct_T;
+
+typedef struct {
+  f_struct_T f4[4];
+} g_struct_T;
+
+typedef struct {
+  g_struct_T f3[4];
+} h_struct_T;
+
+typedef struct {
+  h_struct_T f2[4];
+} i_struct_T;
+
+typedef struct {
+  i_struct_T f1[4];
+} j_struct_T;
+
+typedef struct {
+  struct {
+    j_struct_T ds21[4];
+    i_struct_T ds20[4];
+    i_struct_T r9;
+  } f0;
+} deep_struct_arraysStackData;
+
+/* Function Definitions */
+void deep_struct_arrays(deep_struct_arraysStackData *SD,
+  int8_T in1, int8_T inCount, int8_T *out1, int8_T *out2, struct0_T out3[4])
+{
+  struct0_T r;
+  struct_T r1;
+  b_struct_T r2;
+  c_struct_T r3;
+  d_struct_T r4;
+  e_struct_T r5;
+  f_struct_T r6;
+  g_struct_T r7;
+  h_struct_T r8;
+  int32_T count;
+  int32_T i;
+
+  /*  Check properties of input in1 */
+  /*  Check properties of input inCount */
+  /*  Copyright 2006 The MathWorks, Inc. */
+  r.a = in1;
+  r1.f10[0] = r;
+  r1.f10[1] = r;
+  r1.f10[2] = r;
+  r1.f10[3] = r;
+  r2.f9[0] = r1;
+  r2.f9[1] = r1;
+  r2.f9[2] = r1;
+  r2.f9[3] = r1;
+  r3.f8[0] = r2;
+  r3.f8[1] = r2;
+  r3.f8[2] = r2;
+  r3.f8[3] = r2;
+  r4.f7[0] = r3;
+  r4.f7[1] = r3;
+  r4.f7[2] = r3;
+  r4.f7[3] = r3;
+  r5.f6[0] = r4;
+  r5.f6[1] = r4;
+  r5.f6[2] = r4;
+  r5.f6[3] = r4;
+  r6.f5[0] = r5;
+  r6.f5[1] = r5;
+  r6.f5[2] = r5;
+  r6.f5[3] = r5;
+  r7.f4[0] = r6;
+  r7.f4[1] = r6;
+  r7.f4[2] = r6;
+  r7.f4[3] = r6;
+  r8.f3[0] = r7;
+  r8.f3[1] = r7;
+  r8.f3[2] = r7;
+  r8.f3[3] = r7;
+  SD->f0.r9.f2[0] = r8;
+  SD->f0.r9.f2[1] = r8;
+  SD->f0.r9.f2[2] = r8;
+  SD->f0.r9.f2[3] = r8;
+  SD->f0.ds20[0] = SD->f0.r9;
+  SD->f0.ds20[3] = SD->f0.r9;
+  count = 0;
+  while (count < inCount) {
+    i = in1 + SD->f0.ds20[0].f2[0].f3[0].f4[0].f5[0].f6[0].f7[0].f8[0].f9[0]
+      .f10[0].a;
+    if (i > 127) {
+      i = 127;
+    } else {
+      if (i < -128) {
+        i = -128;
+      }
+    }
+
+    SD->f0.ds20[0].f2[0].f3[0].f4[0].f5[0].f6[0].f7[0].f8[0].f9[0].f10[0].a =
+      (int8_T)i;
+    i = SD->f0.ds20[3].f2[3].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3].f10[3].a
+      + 3;
+    if (i > 127) {
+      i = 127;
+    }
+
+    SD->f0.ds20[3].f2[3].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3].f10[3].a =
+      (int8_T)i;
+    count++;
+  }
+
+  if (inCount > 10) {
+    SD->f0.ds21[0].f1[1].f2[2].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3].f10[3].
+      a = 14;
+  } else {
+    SD->f0.ds21[0].f1[1].f2[2].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3].f10[3].
+      a = 16;
+  }
+
+  *out1 = SD->f0.ds20[0].f2[0].f3[0].f4[0].f5[0].f6[0].f7[0].f8[0].f9[0].f10[0].
+    a;
+  *out2 = SD->f0.ds20[3].f2[3].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3].f10[3].
+    a;
+  out3[0] = r;
+  out3[1] = r;
+  out3[2] = r;
+  out3[3] = SD->f0.ds21[0].f1[1].f2[2].f3[3].f4[3].f5[3].f6[3].f7[3].f8[3].f9[3]
+    .f10[3];
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr94125.c b/gcc/testsuite/gcc.dg/tree-ssa/pr94125.c
new file mode 100644
index 00000000000..c339e51f482
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr94125.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+unsigned char b, f;
+short d[1][8][1], *g = &d[0][3][0];
+
+void __attribute__((noinline)) foo ()
+{
+  int k[256] = { 0, 0, 0, 4, 0, 0 };
+  for (int c = 252; c >= 0; c--)
+    {
+      b = f;
+      *g = k[c + 3];
+      k[c + 1] = 0;
+    }
+  for (int i = 0; i < 8; i++)
+    if (d[0][i][0] != 0)
+      __builtin_abort ();
+}
+
+void __attribute__((noinline)) bar ()
+{
+  int k[256] = { 0, 0, 0, 4, 0, 0 };
+  k[255] = 4;
+  for (int c = 0; c <=252; c++)
+    {
+      b = f;
+      *g = k[c + 3];
+      k[c + 1] = 0;
+    }
+  for (int i = 0; i < 8; i++)
+    if ((i == 3 && d[0][i][0] != 4) || (i != 3 && d[0][i][0] != 0))
+      __builtin_abort ();
+}
+
+int main ()
+{
+  foo ();
+  bar ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr94482-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr94482-2.c
new file mode 100644
index 00000000000..fcac9d5e439
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr94482-2.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+typedef unsigned long V __attribute__ ((__vector_size__ (8)));
+typedef _Complex int Ci;
+typedef _Complex float Cf;
+
+union U
+{
+  Ci ci;
+  Cf cf;
+};
+
+volatile Ci vgi;
+
+Cf foo (Cf c)
+{
+  __real c = 0x1ffp10;
+  return c;
+}
+
+Ci ioo (Ci c)
+{
+  __real c = 50;
+  return c;
+}
+
+
+int main (int argc, char *argv[])
+{
+  union U u;
+
+  __real u.ci = 500;
+  __imag u.ci = 1000;
+  vgi = u.ci;
+
+  u.ci = ioo (u.ci);
+  __imag u.ci = 100;
+
+  if (__real u.ci != 50 || __imag u.ci != 100)
+    __builtin_abort();
+
+  u.cf = foo (u.cf);
+  __imag u.cf = 0x1p3;
+
+  if (__real u.cf != 0x1ffp10 || __imag u.cf != 0x1p3)
+    __builtin_abort();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr94969.c b/gcc/testsuite/gcc.dg/tree-ssa/pr94969.c
new file mode 100644
index 00000000000..f15046122ff
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr94969.c
@@ -0,0 +1,28 @@
+/* PR tree-optimization/52267 */
+/* { dg-do run } */
+/* { dg-options "-O3 -fdump-tree-ldist-details" } */
+
+int a = 0, b = 0, c = 0;
+struct S {
+  signed m : 7;
+  signed e : 2;
+};
+struct S f[2] = {{0, 0}, {0, 0}};
+struct S g = {0, 0};
+
+void __attribute__((noinline))
+k()
+{
+  for (; c <= 1; c++) {
+    f[b] = g;
+    f[b].e ^= 1;
+  }
+}
+int main()
+{
+  k();
+  if (f[b].e != 1)
+    __builtin_abort ();
+}
+
+/* { dg-final { scan-tree-dump-not "Loop 1 distributed: split to 3 loops" "ldist" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr95804.c b/gcc/testsuite/gcc.dg/tree-ssa/pr95804.c
new file mode 100644
index 00000000000..83c0ab45cf5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr95804.c
@@ -0,0 +1,18 @@
+/* PR tree-optimization/95804 */
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+
+int a, b, c, d, e, f;
+void g() {
+  short *h = (short*)&d;
+  char *i = (char*)&b;
+  for (; e; e++) {
+    for (; f; f++) {
+      b = 3;
+      if ((c = 8) >= *i)
+        a = 5 ? *h : 0;
+      h = (short*)g;
+    }
+    i = (char*)&c;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr97009.c b/gcc/testsuite/gcc.dg/tree-ssa/pr97009.c
new file mode 100644
index 00000000000..741dbc270c3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr97009.c
@@ -0,0 +1,66 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+static int __attribute__((noipa))
+get_5 (void)
+{
+  return 5;
+}
+
+static int __attribute__((noipa))
+verify_5 (int v)
+{
+  if (v != 5)
+    __builtin_abort ();
+}
+
+struct T
+{
+  int w;
+  int a[4];
+};
+
+struct S
+{
+  int v;
+  int x;
+  struct T t[2];
+  char alotofstuff[128];
+};
+
+volatile int vol;
+
+void __attribute__((noipa))
+consume_t (struct T t)
+{
+  vol = t.a[0];
+}
+
+int __attribute__((noipa))
+foo (int l1, int l2)
+{
+  struct S s1, s2, s3;
+  int i, j;
+
+  s1.v = get_5 ();
+  for (i = 0; i < l1; i++)
+    {
+      for (j = 0; j < l2; j++)
+	s1.t[i].a[j] = get_5 ();
+      consume_t(s1.t[i]);
+    }
+
+  s2 = s1;
+
+  s3 = s2;
+  for (i = 0; i < l1; i++)
+    for (j = 0; j < l2; j++)
+      verify_5 (s3.t[i].a[j]);
+}
+
+int
+main (int argc, char *argv[])
+{
+  foo (2, 4);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/ubsan/pr94423.c b/gcc/testsuite/gcc.dg/ubsan/pr94423.c
new file mode 100644
index 00000000000..76f831f26e2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ubsan/pr94423.c
@@ -0,0 +1,17 @@
+/* PR middle-end/94423 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fsanitize=object-size" } */
+
+void foo (void);
+typedef struct { long buf[22]; } jmp_buf[1];
+extern int sigsetjmp (jmp_buf, int) __attribute__ ((__nothrow__));
+jmp_buf buf;
+
+void
+bar (int *c)
+{
+  while (*c)
+    foo ();
+  while (*c)
+    sigsetjmp (buf, 0);
+}
diff --git a/gcc/testsuite/gcc.dg/ubsan/pr95810.c b/gcc/testsuite/gcc.dg/ubsan/pr95810.c
new file mode 100644
index 00000000000..535ace69089
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ubsan/pr95810.c
@@ -0,0 +1,13 @@
+/* PR middle-end/95810 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=undefined -fno-sanitize-recover=undefined" } */
+
+int
+main ()
+{
+  int x = -__INT_MAX__ - 1;
+  x = (x <= 0 ? x : -x);
+  if (x != -__INT_MAX__ - 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c b/gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c
index 3750fb79c12..042b7e9ea1b 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c
@@ -63,4 +63,4 @@ main (void)
 /* { dg-final { scan-tree-dump "demoting int to signed short" "slp2" { target { ! vect_widen_shift } } } } */
 /* { dg-final { scan-tree-dump "demoting int to unsigned short" "slp2" { target { ! vect_widen_shift } } } } */
 /* { dg-final { scan-tree-dump {\.AVG_FLOOR} "slp2" { target vect_avg_qi } } } */
-/* { dg-final { scan-tree-dump-times "basic block vectorized" 2 "slp2" } } */
+/* { dg-final { scan-tree-dump-times "basic block vectorized" 2 "slp2" { target vect_hw_misalign } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-1.c b/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-1.c
index 3bfe498ef0a..1bc35d9ec5f 100644
--- a/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-1.c
+++ b/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-1.c
@@ -5,8 +5,8 @@ void
 vadd (int *dst, int *op1, int *op2, int count)
 {
 /* { dg-prune-output " version\[^\n\r]* alignment" } */
-/* { dg-optimized "loop vectorized" "" { target *-*-* } .+2 } */
-/* { dg-optimized "loop versioned for vectorization because of possible aliasing" "" { target *-*-* } .+1 } */
+/* { dg-optimized "3: loop vectorized" "" { target *-*-* } .+2 } */
+/* { dg-optimized "3: loop versioned for vectorization because of possible aliasing" "" { target *-*-* } .+1 } */
   for (int i = 0; i < count; ++i)
     dst[i] = op1[i] + op2[i];
 }
diff --git a/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-2.c b/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-2.c
index 94c55a92bb4..c426d19eb41 100644
--- a/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-2.c
+++ b/gcc/testsuite/gcc.dg/vect/nodump-vect-opt-info-2.c
@@ -6,7 +6,7 @@ extern void accumulate (int x, int *a);
 int test_missing_function_defn (int *arr, int n) /* { dg-message "vectorized 0 loops in function" } */
 {
   int sum = 0;
-  for (int i = 0; i < n; ++i) /* { dg-missed "couldn't vectorize loop" } */
-    accumulate (arr[i], &sum); /* { dg-missed "statement clobbers memory: accumulate \\(.*\\);" } */
+  for (int i = 0; i < n; ++i) /* { dg-missed "3: couldn't vectorize loop" } */
+    accumulate (arr[i], &sum); /* { dg-missed "5: statement clobbers memory: accumulate \\(.*\\);" } */
   return sum;
 }
diff --git a/gcc/testsuite/gcc.dg/vect/pr93069.c b/gcc/testsuite/gcc.dg/vect/pr93069.c
new file mode 100644
index 00000000000..45c740dbe9e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr93069.c
@@ -0,0 +1,10 @@
+/* PR target/93069 */
+/* { dg-do assemble { target vect_simd_clones } } */
+/* { dg-options "-O2 -fopenmp-simd" } */
+
+#pragma omp declare simd
+int
+foo (int x, int y)
+{
+  return x == 0 ? x : y;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr94443.c b/gcc/testsuite/gcc.dg/vect/pr94443.c
new file mode 100644
index 00000000000..f8cbaf1b9ce
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr94443.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=znver2" { target { x86_64-*-* i?86-*-* } } } */
+
+/* Check it to be compiled successfully without any ICE.  */
+
+int a;
+unsigned *b;
+
+void foo()
+{
+  for (unsigned i; i <= a; ++i, ++b)
+    ;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr97081-2.c b/gcc/testsuite/gcc.dg/vect/pr97081-2.c
new file mode 100644
index 00000000000..98ad3c3fe17
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr97081-2.c
@@ -0,0 +1,32 @@
+/* PR tree-optimization/97081 */
+
+#include "tree-vect.h"
+
+unsigned short s[1024];
+unsigned char c[1024];
+
+__attribute__((noipa)) void
+foo (int n)
+{
+  for (int i = 0; i < 1024; i++)
+    s[i] = (s[i] << n) | (s[i] >> (__SIZEOF_SHORT__ * __CHAR_BIT__ - n));
+  for (int i = 0; i < 1024; i++)
+    c[i] = (c[i] << n) | (c[i] >> (__CHAR_BIT__ - n));
+}
+
+int
+main ()
+{
+  check_vect ();
+  for (int i = 0; i < 1024; i++)
+    {
+      s[i] = i;
+      c[i] = i;
+    }
+  foo (3);
+  for (int i = 0; i < 1024; i++)
+    if (s[i] != (unsigned short) ((i << 3) | (i >> (__SIZEOF_SHORT__ * __CHAR_BIT__ - 3)))
+        || c[i] != (unsigned char) ((((unsigned char) i) << 3) | (((unsigned char) i) >> (__CHAR_BIT__ - 3))))
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr97081.c b/gcc/testsuite/gcc.dg/vect/pr97081.c
new file mode 100644
index 00000000000..bc83c88c019
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr97081.c
@@ -0,0 +1,26 @@
+#include "tree-vect.h"
+
+#define EXEC_ROR2(a, b, sz)     (a >> b) | (a << (64 - b))
+
+#define TYPE __UINT64_TYPE__
+
+void __attribute__((noipa))
+exec_VRORudi_i(TYPE *__restrict__ pvd,
+	       TYPE *__restrict__ const pva, unsigned char IMM)
+{
+  unsigned char I2 = IMM & 63;
+
+  for (unsigned i = 0; i < 4; i++)
+    pvd[i] = EXEC_ROR2(pva[i], I2, 8);
+}
+
+int main()
+{
+  check_vect ();
+
+  TYPE pvd[4], pva[4] = { 0x0102030405060708, 0x0102030405060708, 0x0102030405060708, 0x0102030405060708 };
+  exec_VRORudi_i (pvd, pva, 7);
+  if (pvd[0] != 0x10020406080a0c0e)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr97236.c b/gcc/testsuite/gcc.dg/vect/pr97236.c
new file mode 100644
index 00000000000..9d3dc20d953
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr97236.c
@@ -0,0 +1,43 @@
+typedef unsigned char __uint8_t;
+typedef __uint8_t uint8_t;
+typedef struct plane_t {
+  uint8_t *p_pixels;
+  int i_lines;
+  int i_pitch;
+} plane_t;
+
+typedef struct {
+  plane_t p[5];
+} picture_t;
+
+#define N 4
+
+void __attribute__((noipa))
+picture_Clone(picture_t *picture, picture_t *res)
+{
+  for (int i = 0; i < N; i++) {
+    res->p[i].p_pixels = picture->p[i].p_pixels;
+    res->p[i].i_lines = picture->p[i].i_lines;
+    res->p[i].i_pitch = picture->p[i].i_pitch;
+  }
+}
+
+int
+main()
+{
+  picture_t aaa, bbb;
+  uint8_t pixels[10] = {1, 1, 1, 1, 1, 1, 1, 1};
+
+  for (unsigned i = 0; i < N; i++)
+    aaa.p[i].p_pixels = pixels;
+
+  picture_Clone (&aaa, &bbb);
+
+  uint8_t c = 0;
+  for (unsigned i = 0; i < N; i++)
+    c += bbb.p[i].p_pixels[0];
+
+  if (c != N)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr99856.c b/gcc/testsuite/gcc.dg/vect/pr99856.c
new file mode 100644
index 00000000000..e5d2a45be57
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr99856.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+/* { dg-require-effective-target vect_unpack } */
+/* { dg-require-effective-target vect_pack_trunc } */
+
+#define SHIFTFORDIV255(a)\
+    ((((a) >> 8) + a) >> 8)
+
+#define DIV255(a)\
+    SHIFTFORDIV255(a + 0x80)
+
+typedef unsigned char uint8_t;
+
+void
+opSourceOver_premul(uint8_t* restrict Rrgba,
+                    const uint8_t* restrict Srgba,
+                    const uint8_t* restrict Drgba, int len)
+{
+  Rrgba = __builtin_assume_aligned (Rrgba, __BIGGEST_ALIGNMENT__);
+  Srgba = __builtin_assume_aligned (Rrgba, __BIGGEST_ALIGNMENT__);
+  Drgba = __builtin_assume_aligned (Rrgba, __BIGGEST_ALIGNMENT__);
+  int i = 0;
+  for (; i < len*4; i += 4)
+    {
+      uint8_t Sa = Srgba[i + 3];
+      Rrgba[i + 0] = DIV255(Srgba[i + 0] * 255 + Drgba[i + 0] * (255 - Sa));
+      Rrgba[i + 1] = DIV255(Srgba[i + 1] * 255 + Drgba[i + 1] * (255 - Sa));
+      Rrgba[i + 2] = DIV255(Srgba[i + 2] * 255 + Drgba[i + 2] * (255 - Sa));
+      Rrgba[i + 3] = DIV255(Srgba[i + 3] * 255 + Drgba[i + 3] * (255 - Sa));
+    }
+}
+
+/* { dg-final { scan-tree-dump "vectorized 1 loops in function" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/slp-46.c b/gcc/testsuite/gcc.dg/vect/slp-46.c
new file mode 100644
index 00000000000..1f39d397170
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/slp-46.c
@@ -0,0 +1,96 @@
+/* { dg-require-effective-target vect_double } */
+
+#include "tree-vect.h"
+
+double x[1024], y[1024];
+
+void __attribute__((noipa)) foo()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = y[i];
+      x[2*i+1] = y[i];
+    }
+}
+
+void __attribute__((noipa)) bar()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = y[2*i];
+      x[2*i+1] = y[2*i];
+    }
+}
+
+void __attribute__((noipa)) baz()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = y[511-i];
+      x[2*i+1] = y[511-i];
+    }
+}
+
+void __attribute__((noipa)) boo()
+{
+  for (int i = 0; i < 512; ++i)
+    {
+      x[2*i] = y[2*(511-i)];
+      x[2*i+1] = y[2*(511-i)];
+    }
+}
+
+int 
+main ()
+{
+  check_vect ();
+
+  for (int i = 0; i < 1024; ++i)
+    {
+      x[i] = 0;
+      y[i] = i;
+      __asm__ volatile ("");
+    }
+
+  foo ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != y[i/2])
+      abort ();
+
+  for (int i = 0; i < 1024; ++i)
+    {
+      x[i] = 0;
+      __asm__ volatile ("");
+    }
+
+  bar ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != y[2*(i/2)])
+      abort ();
+
+  for (int i = 0; i < 1024; ++i)
+    {
+      x[i] = 0;
+      __asm__ volatile ("");
+    }
+
+  baz ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != y[511 - i/2])
+      abort ();
+
+  for (int i = 0; i < 1024; ++i)
+    {
+      x[i] = 0;
+      __asm__ volatile ("");
+    }
+
+  boo ();
+  for (int i = 0; i < 1024; ++i)
+    if (x[i] != y[2*(511 - i/2)])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail vect_load_lanes } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/slp-perm-12.c b/gcc/testsuite/gcc.dg/vect/slp-perm-12.c
index 4d4c5344402..113223ab0f9 100644
--- a/gcc/testsuite/gcc.dg/vect/slp-perm-12.c
+++ b/gcc/testsuite/gcc.dg/vect/slp-perm-12.c
@@ -49,4 +49,4 @@ int main()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target vect_perm } } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "vect" { target { vect_perm && vect_hw_misalign } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/tree-vect.h b/gcc/testsuite/gcc.dg/vect/tree-vect.h
index 69c93ac8092..eb890745a00 100644
--- a/gcc/testsuite/gcc.dg/vect/tree-vect.h
+++ b/gcc/testsuite/gcc.dg/vect/tree-vect.h
@@ -52,7 +52,7 @@ check_vect (void)
     want_level = 1, want_d = bit_SSE2;
 # endif
 
-    if (!__get_cpuid (want_level, &a, &b, &c, &d)
+    if (!__get_cpuid_count (want_level, 0, &a, &b, &c, &d)
 	|| ((b & want_b) | (c & want_c) | (d & want_d)) == 0)
       exit (0);
   }
diff --git a/gcc/testsuite/gcc.dg/vect/vect-over-widen-17.c b/gcc/testsuite/gcc.dg/vect/vect-over-widen-17.c
index 04482607b04..333d74ac3e7 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-over-widen-17.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-over-widen-17.c
@@ -41,6 +41,9 @@ main (void)
 }
 
 /* { dg-final { scan-tree-dump-not {vect_recog_over_widening_pattern: detected} "vect" } } */
-/* { dg-final { scan-tree-dump-not {vector[^\n]*char} "vect" } } */
+/* On Power, if there is no vect_hw_misalign support, unaligned vector access
+   adopts realign_load scheme.  It requires rs6000_builtin_mask_for_load to
+   generate mask whose return type is vector char.  */
+/* { dg-final { scan-tree-dump-not {vector[^\n]*char} "vect" { target vect_hw_misalign } } } */
 /* { dg-final { scan-tree-dump-not {vector[^ ]* int} "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loop" 1 "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vmx/ops.c b/gcc/testsuite/gcc.dg/vmx/ops.c
index 6aff80bbd1a..4a0650c06bd 100644
--- a/gcc/testsuite/gcc.dg/vmx/ops.c
+++ b/gcc/testsuite/gcc.dg/vmx/ops.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-maltivec -mabi=altivec -std=gnu99 -mno-vsx -Wno-deprecated" } */
+/* { dg-options "-maltivec -mabi=altivec -std=gnu99 -mno-vsx -Wno-deprecated -flax-vector-conversions" } */
 #include <altivec.h>
 #include <stdlib.h>
 extern char * *var_char_ptr;
diff --git a/gcc/testsuite/gcc.misc-tests/gcov-pr94029.c b/gcc/testsuite/gcc.misc-tests/gcov-pr94029.c
new file mode 100644
index 00000000000..84d9b9b2749
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/gcov-pr94029.c
@@ -0,0 +1,14 @@
+/* PR gcov-profile/94029 */
+/* { dg-options "-ftest-coverage" } */
+/* { dg-do compile } */
+
+#define impl_test(name) void test_##name() { }
+impl_test(t1
+) impl_test(t2)
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { run-gcov remove-gcda gcov-pr94029.c } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/jcvt_1.c b/gcc/testsuite/gcc.target/aarch64/acle/jcvt_1.c
new file mode 100644
index 00000000000..0c900b1b57c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/jcvt_1.c
@@ -0,0 +1,15 @@
+/* Test the __jcvt ACLE intrinsic.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.3-a" } */
+
+#include <arm_acle.h>
+
+#ifdef __ARM_FEATURE_JCVT
+int32_t
+test_jcvt (double a)
+{
+  return __jcvt (a);
+}
+#endif
+
+/* { dg-final { scan-assembler-times "fjcvtzs\tw\[0-9\]+, d\[0-9\]+\n" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/jcvt_2.c b/gcc/testsuite/gcc.target/aarch64/acle/jcvt_2.c
new file mode 100644
index 00000000000..ea2dfd14cf2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/jcvt_2.c
@@ -0,0 +1,33 @@
+/* Test the __jcvt ACLE intrinsic.  */
+/* { dg-do run } */
+/* { dg-options "-O2 -march=armv8.3-a -save-temps" } */
+/* { dg-require-effective-target aarch64_fjcvtzs_hw } */
+
+#include <arm_acle.h>
+
+extern void abort (void);
+
+#ifdef __ARM_FEATURE_JCVT
+volatile int32_t x;
+
+int __attribute__((noinline))
+foo (double a, int b, int c)
+{
+  b = b > c;
+  x = __jcvt (a);
+  return b;
+}
+
+int
+main (void)
+{
+  int x = foo (1.1, 2, 3);
+  if (x)
+    abort ();
+
+  return 0;
+}
+
+#endif
+
+/* { dg-final { scan-assembler-times "fjcvtzs\tw\[0-9\]+, d\[0-9\]+\n" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/rintnzx_1.c b/gcc/testsuite/gcc.target/aarch64/acle/rintnzx_1.c
new file mode 100644
index 00000000000..12572084856
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/rintnzx_1.c
@@ -0,0 +1,73 @@
+/* Test the __rint[32,64][z,x] intrinsics.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.5-a" } */
+
+#include <arm_acle.h>
+
+#ifdef __ARM_FEATURE_FRINT
+float
+foo_32z_f32_scal (float a)
+{
+  return __rint32zf (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\ts\[0-9\]+, s\[0-9\]+\n" 1 } } */
+
+double
+foo_32z_f64_scal (double a)
+{
+  return __rint32z (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float
+foo_32x_f32_scal (float a)
+{
+  return __rint32xf (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\ts\[0-9\]+, s\[0-9\]+\n" 1 } } */
+
+double
+foo_32x_f64_scal (double a)
+{
+  return __rint32x (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float
+foo_64z_f32_scal (float a)
+{
+  return __rint64zf (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\ts\[0-9\]+, s\[0-9\]+\n" 1 } } */
+
+double
+foo_64z_f64_scal (double a)
+{
+  return __rint64z (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float
+foo_64x_f32_scal (float a)
+{
+  return __rint64xf (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\ts\[0-9\]+, s\[0-9\]+\n" 1 } } */
+
+double
+foo_64x_f64_scal (double a)
+{
+  return __rint64x (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+#endif
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/rng_1.c b/gcc/testsuite/gcc.target/aarch64/acle/rng_1.c
new file mode 100644
index 00000000000..1fbdb627663
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/rng_1.c
@@ -0,0 +1,53 @@
+/* Test the __rndr ACLE intrinsic.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.5-a+rng" } */
+
+#include <arm_acle.h>
+
+#ifdef __ARM_FEATURE_RNG
+/* Check that instruction is generated when status result is unused.  */
+uint64_t
+test_rndr_no_stat (void)
+{
+  uint64_t res;
+  __rndr (&res);
+  return res;
+}
+
+/* Check that instruction is generated when random number result
+   is unused.  */
+int
+test_rndr_error_check (void)
+{
+  uint64_t res;
+  int fail = __rndr (&res);
+  if (fail)
+    return 0;
+  return -1;
+}
+
+/* { dg-final { scan-assembler-times "mrs\tx..?, RNDR\n" 2 } } */
+
+/* Check that instruction is generated when status result is unused.  */
+uint64_t
+test_rndrrs_no_stat (void)
+{
+  uint64_t res;
+  __rndrrs (&res);
+  return res;
+}
+
+/* Check that instruction is generated when random number result
+   is unused.  */
+int
+test_rndrrs_error_check (void)
+{
+  uint64_t res;
+  int fail = __rndrrs (&res);
+  if (fail)
+    return 0;
+  return -1;
+}
+
+/* { dg-final { scan-assembler-times "mrs\tx..?, RNDRRS\n" 2 } } */
+#endif
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/rng_2.c b/gcc/testsuite/gcc.target/aarch64/acle/rng_2.c
new file mode 100644
index 00000000000..206136cfc1f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/rng_2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.5-a+rng" } */
+
+#include <arm_acle.h>
+
+int test_rndr (uint64_t *addr)
+{
+  return  __rndr (addr);
+}
+
+/* { dg-final { scan-assembler-times {cset\t...?, eq} 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
index fde6029b7fc..791972c737e 100644
--- a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h
@@ -460,6 +460,8 @@ static void clean_results (void)
 #endif
   CLEAN(result, float, 32, 4);
 
+  AARCH64_ONLY(CLEAN(result, float, 64, 2));
+
 #if defined(__aarch64__)
   /* On AArch64, make sure to return DefaultNaN to have the same
      results as on AArch32.  */
@@ -544,7 +546,8 @@ static void clean_results (void)
   DECL_VARIABLE(VAR, poly, 16, 8);		\
   DECL_VARIABLE_CRYPTO(VAR, poly, 64, 2);	\
   DECL_VARIABLE(VAR, float, 16, 8);		\
-  DECL_VARIABLE(VAR, float, 32, 4)
+  DECL_VARIABLE(VAR, float, 32, 4);		\
+  AARCH64_ONLY(DECL_VARIABLE(VAR, float, 64, 2))
 #else
 #define DECL_VARIABLE_128BITS_VARIANTS(VAR)	\
   DECL_VARIABLE_128BITS_SIGNED_VARIANTS(VAR);	\
@@ -552,7 +555,8 @@ static void clean_results (void)
   DECL_VARIABLE(VAR, poly, 8, 16);		\
   DECL_VARIABLE(VAR, poly, 16, 8);		\
   DECL_VARIABLE_CRYPTO(VAR, poly, 64, 2);	\
-  DECL_VARIABLE(VAR, float, 32, 4)
+  DECL_VARIABLE(VAR, float, 32, 4);		\
+  AARCH64_ONLY(DECL_VARIABLE(VAR, float, 64, 2))
 #endif
 /* Declare all variants.  */
 #define DECL_VARIABLE_ALL_VARIANTS(VAR)		\
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1x4.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1x4.c
new file mode 100644
index 00000000000..451a0afc6aa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vld1x4.c
@@ -0,0 +1,83 @@
+/* We haven't implemented these intrinsics for arm yet.  */
+/* { dg-xfail-if "" { arm*-*-* } } */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+
+extern void abort (void);
+
+#define TESTMETH(BASE, ELTS, SUFFIX)			\
+int __attribute__ ((noinline))				\
+test_vld1##SUFFIX##_x4 ()				\
+{							\
+  BASE##_t data[ELTS * 4];				\
+  BASE##_t temp[ELTS * 4];				\
+  BASE##x##ELTS##x##4##_t vectors;			\
+  int i,j;						\
+  for (i = 0; i < ELTS * 4; i++)			\
+    data [i] = (BASE##_t) 4*i;				\
+  asm volatile ("" : : : "memory");			\
+  vectors = vld1##SUFFIX##_x4 (data);			\
+  vst1##SUFFIX (temp, vectors.val[0]);			\
+  vst1##SUFFIX (&temp[ELTS], vectors.val[1]);		\
+  vst1##SUFFIX (&temp[ELTS * 2], vectors.val[2]);	\
+  vst1##SUFFIX (&temp[ELTS * 3], vectors.val[3]);	\
+  asm volatile ("" : : : "memory");			\
+  for (j = 0; j < ELTS * 4; j++)			\
+    if (temp[j] != data[j])				\
+      return 1;						\
+  return 0;						\
+}
+
+#define VARIANTS_1(VARIANT)	\
+VARIANT (uint8, 8, _u8)		\
+VARIANT (uint16, 4, _u16)	\
+VARIANT (uint32, 2, _u32)	\
+VARIANT (uint64, 1, _u64)	\
+VARIANT (int8, 8, _s8)		\
+VARIANT (int16, 4, _s16)	\
+VARIANT (int32, 2, _s32)	\
+VARIANT (int64, 1, _s64)	\
+VARIANT (poly8, 8, _p8)		\
+VARIANT (poly16, 4, _p16)	\
+VARIANT (poly64, 1, _p64)	\
+VARIANT (float16, 4, _f16)	\
+VARIANT (float32, 2, _f32)	\
+VARIANT (uint8, 16, q_u8)	\
+VARIANT (uint16, 8, q_u16)	\
+VARIANT (uint32, 4, q_u32)	\
+VARIANT (uint64, 2, q_u64)	\
+VARIANT (int8, 16, q_s8)	\
+VARIANT (int16, 8, q_s16)	\
+VARIANT (int32, 4, q_s32)	\
+VARIANT (int64, 2, q_s64)	\
+VARIANT (poly8, 16, q_p8)	\
+VARIANT (poly16, 8, q_p16)	\
+VARIANT (poly64, 2, q_p64)	\
+VARIANT (float16, 8, q_f16)	\
+VARIANT (float32, 4, q_f32)
+
+#ifdef __aarch64__
+#define VARIANTS(VARIANT) VARIANTS_1(VARIANT)	\
+VARIANT (float64, 1, _f64)			\
+VARIANT (float64, 2, q_f64)
+#else
+#define VARIANTS(VARIANT) VARIANTS_1(VARIANT)
+#endif
+
+/* Tests of vld1_x4 and vld1q_x4.  */
+VARIANTS (TESTMETH)
+
+#define CHECKS(BASE, ELTS, SUFFIX)	\
+  if (test_vld1##SUFFIX##_x4 () != 0)	\
+    fprintf (stderr, "test_vld1##SUFFIX##_x4");
+
+int
+main (int argc, char **argv)
+{
+  VARIANTS (CHECKS)
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vreinterpret_p128.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vreinterpret_p128.c
index 25b348223f3..67f809c7065 100644
--- a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vreinterpret_p128.c
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vreinterpret_p128.c
@@ -33,6 +33,10 @@ VECT_VAR_DECL(vreint_expected_q_p128_f32,poly,64,2) [] = { 0xc1700000c1800000,
 							   0xc1500000c1600000 };
 VECT_VAR_DECL(vreint_expected_q_p128_f16,poly,64,2) [] = { 0xca80cb00cb80cc00,
 							   0xc880c900c980ca00 };
+#ifdef __aarch64__
+VECT_VAR_DECL(vreint_expected_q_p128_f64,poly,64,2) [] = { 0xc030000000000000,
+							   0xc02e000000000000 };
+#endif
 
 /* Expected results: vreinterpretq_*_p128.  */
 VECT_VAR_DECL(vreint_expected_q_s8_p128,int,8,16) [] = { 0xf0, 0xff, 0xff, 0xff,
@@ -75,6 +79,10 @@ VECT_VAR_DECL(vreint_expected_q_f16_p128,hfloat,16,8) [] = { 0xfff0, 0xffff,
 							     0xffff, 0xffff,
 							     0xfff1, 0xffff,
 							     0xffff, 0xffff };
+#ifdef __aarch64__
+VECT_VAR_DECL(vreint_expected_q_f64_p128,hfloat,64,2) [] = { 0xfffffffffffffff0,
+							     0xfffffffffffffff1 };
+#endif
 
 int main (void)
 {
@@ -90,6 +98,10 @@ int main (void)
 #endif
   VLOAD(vreint_vector, buffer, q, float, f, 32, 4);
 
+#ifdef __aarch64__
+  VLOAD(vreint_vector, buffer, q, float, f, 64, 2);
+#endif
+
   /* vreinterpretq_p128_* tests.  */
 #undef TEST_MSG
 #define TEST_MSG "VREINTERPRETQ_P128_*"
@@ -121,6 +133,10 @@ int main (void)
 #endif
   TEST_VREINTERPRET128(q, poly, p, 128, 1, float, f, 32, 4, vreint_expected_q_p128_f32);
 
+#ifdef __aarch64__
+  TEST_VREINTERPRET128(q, poly, p, 128, 1, float, f, 64, 2, vreint_expected_q_p128_f64);
+#endif
+
   /* vreinterpretq_*_p128 tests.  */
 #undef TEST_MSG
 #define TEST_MSG "VREINTERPRETQ_*_P128"
@@ -161,5 +177,8 @@ int main (void)
 #endif
   TEST_VREINTERPRET_FP_FROM_P128(q, float, f, 32, 4, poly, p, 128, 1, vreint_expected_q_f32_p128);
 
+#ifdef __aarch64__
+  TEST_VREINTERPRET_FP_FROM_P128(q, float, f, 64, 2, poly, p, 128, 1, vreint_expected_q_f64_p128);
+#endif
   return 0;
 }
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst1x4.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst1x4.c
new file mode 100644
index 00000000000..1f17b5342de
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vst1x4.c
@@ -0,0 +1,83 @@
+/* We haven't implemented these intrinsics for arm yet.  */
+/* { dg-xfail-if "" { arm*-*-* } } */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+#include <arm_neon.h>
+#include "arm-neon-ref.h"
+
+extern void abort (void);
+
+#define TESTMETH(BASE, ELTS, SUFFIX)			\
+int __attribute__ ((noinline))				\
+test_vst1##SUFFIX##_x4 ()				\
+{							\
+  BASE##_t data[ELTS * 4];				\
+  BASE##_t temp[ELTS * 4];				\
+  BASE##x##ELTS##x##4##_t vectors;			\
+  int i,j;						\
+  for (i = 0; i < ELTS * 4; i++)			\
+    data [i] = (BASE##_t) 4*i;				\
+  asm volatile ("" : : : "memory");			\
+  vectors.val[0] = vld1##SUFFIX (data);			\
+  vectors.val[1] = vld1##SUFFIX (&data[ELTS]);		\
+  vectors.val[2] = vld1##SUFFIX (&data[ELTS * 2]);	\
+  vectors.val[3] = vld1##SUFFIX (&data[ELTS * 3]);	\
+  vst1##SUFFIX##_x4 (temp, vectors);			\
+  asm volatile ("" : : : "memory");			\
+  for (j = 0; j < ELTS * 4; j++)			\
+    if (temp[j] != data[j])				\
+      return 1;						\
+  return 0;						\
+}
+
+#define VARIANTS_1(VARIANT)	\
+VARIANT (uint8, 8, _u8)		\
+VARIANT (uint16, 4, _u16)	\
+VARIANT (uint32, 2, _u32)	\
+VARIANT (uint64, 1, _u64)	\
+VARIANT (int8, 8, _s8)		\
+VARIANT (int16, 4, _s16)	\
+VARIANT (int32, 2, _s32)	\
+VARIANT (int64, 1, _s64)	\
+VARIANT (poly8, 8, _p8)		\
+VARIANT (poly16, 4, _p16)	\
+VARIANT (poly64, 1, _p64)	\
+VARIANT (float16, 4, _f16)	\
+VARIANT (float32, 2, _f32)	\
+VARIANT (uint8, 16, q_u8)	\
+VARIANT (uint16, 8, q_u16)	\
+VARIANT (uint32, 4, q_u32)	\
+VARIANT (uint64, 2, q_u64)	\
+VARIANT (int8, 16, q_s8)	\
+VARIANT (int16, 8, q_s16)	\
+VARIANT (int32, 4, q_s32)	\
+VARIANT (int64, 2, q_s64)	\
+VARIANT (poly8, 16, q_p8)	\
+VARIANT (poly16, 8, q_p16)	\
+VARIANT (poly64, 2, q_p64)	\
+VARIANT (float16, 8, q_f16)	\
+VARIANT (float32, 4, q_f32)
+
+#ifdef __aarch64__
+#define VARIANTS(VARIANT) VARIANTS_1(VARIANT)	\
+VARIANT (float64, 1, _f64)			\
+VARIANT (float64, 2, q_f64)
+#else
+#define VARIANTS(VARIANT) VARIANTS_1(VARIANT)
+#endif
+
+/* Tests of vst1_x4 and vst1q_x4.  */
+VARIANTS (TESTMETH)
+
+#define CHECKS(BASE, ELTS, SUFFIX)	\
+  if (test_vst1##SUFFIX##_x4 () != 0)	\
+    fprintf (stderr, "test_vst1##SUFFIX##_x4");
+
+int
+main (int argc, char **argv)
+{
+  VARIANTS (CHECKS)
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c
index 63f820fbf5a..25a0f198518 100644
--- a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c
@@ -73,11 +73,8 @@ void exec_vtrn_half (void)
   /* Input vector can only have 64 bits.  */
   DECL_VARIABLE_ALL_VARIANTS(vector);
   DECL_VARIABLE_ALL_VARIANTS(vector2);
-  DECL_VARIABLE(vector, float, 64, 2);
-  DECL_VARIABLE(vector2, float, 64, 2);
 
   DECL_VARIABLE_ALL_VARIANTS(vector_res);
-  DECL_VARIABLE(vector_res, float, 64, 2);
 
   clean_results ();
   /* We don't have vtrn1_T64x1, so set expected to the clean value.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c
index 8706f248591..2e6b666b71d 100644
--- a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c
@@ -70,11 +70,8 @@ void exec_vuzp_half (void)
   /* Input vector can only have 64 bits.  */
   DECL_VARIABLE_ALL_VARIANTS(vector);
   DECL_VARIABLE_ALL_VARIANTS(vector2);
-  DECL_VARIABLE(vector, float, 64, 2);
-  DECL_VARIABLE(vector2, float, 64, 2);
 
   DECL_VARIABLE_ALL_VARIANTS(vector_res);
-  DECL_VARIABLE(vector_res, float, 64, 2);
 
   clean_results ();
   /* We don't have vuzp1_T64x1, so set expected to the clean value.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip_half.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip_half.c
index 619d6b2e6ed..ef42451c82e 100644
--- a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip_half.c
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip_half.c
@@ -73,11 +73,8 @@ void exec_vzip_half (void)
   /* Input vector can only have 64 bits.  */
   DECL_VARIABLE_ALL_VARIANTS(vector);
   DECL_VARIABLE_ALL_VARIANTS(vector2);
-  DECL_VARIABLE(vector, float, 64, 2);
-  DECL_VARIABLE(vector2, float, 64, 2);
 
   DECL_VARIABLE_ALL_VARIANTS(vector_res);
-  DECL_VARIABLE(vector_res, float, 64, 2);
 
   clean_results ();
   /* We don't have vzip1_T64x1, so set expected to the clean value.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c b/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c
index 49ca5d0d09c..a828a72aa75 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-comp-swap-release-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf -mno-outline-atomics" } */
 
 #include "atomic-comp-swap-release-acquire.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c
index 74f26348e42..6823ce381b2 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-acq_rel.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-acq_rel.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c
index 66c1b1efe20..87937de378a 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-acquire.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c
index c09d0434ecf..60955e57da3 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-char.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-char.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c
index 5783ab84f5c..16cb11aeeaf 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-consume.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-consume.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
index 18b8f0b04e9..bcab4e481e3 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 int v = 0;
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c
index 8520f0839ba..040e4a8d168 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-int.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-int.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c
index d011f8c5ce2..fc88b92cd3e 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-long.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 long v = 0;
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c
index ed96bfdb978..503d62b0280 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-relaxed.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-relaxed.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c
index fc4be17de89..efe14aea7e4 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-release.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-release.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c
index 613000fe490..09973bf82ba 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-seq_cst.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-seq_cst.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c b/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c
index e82c8118ece..e1dcebb0f89 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic-op-short.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "atomic-op-short.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_reg_1.c b/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_reg_1.c
index f2a21ddf2e1..29246979bfb 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_reg_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_reg_1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -march=armv8-a+nolse" } */
+/* { dg-options "-O2 -march=armv8-a+nolse -mno-outline-atomics" } */
 /* { dg-skip-if "" { *-*-* } { "-mcpu=*" } { "" } } */
 
 int
diff --git a/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_strong_1.c b/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_strong_1.c
index 8d2ae67dfbe..6daf9b08f5a 100644
--- a/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_strong_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/atomic_cmp_exchange_zero_strong_1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -march=armv8-a+nolse" } */
+/* { dg-options "-O2 -march=armv8-a+nolse -mno-outline-atomics" } */
 /* { dg-skip-if "" { *-*-* } { "-mcpu=*" } { "" } } */
 
 int
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/aarch64-cpunative.exp b/gcc/testsuite/gcc.target/aarch64/cpunative/aarch64-cpunative.exp
new file mode 100644
index 00000000000..ce80ca04b8d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/aarch64-cpunative.exp
@@ -0,0 +1,35 @@
+# Copyright (C) 2014-2020 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an AArch64 target.
+if ![istarget aarch64*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"" ""
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_0 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_0
new file mode 100644
index 00000000000..ef4a3f606fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_0
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 asimddp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_1 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_1
new file mode 100644
index 00000000000..0f434bca285
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_1
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: fp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_10 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_10
new file mode 100644
index 00000000000..c6e9d7ca9e2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_10
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: 
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_11 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_11
new file mode 100644
index 00000000000..fb76f7d45bc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_11
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp sb
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_12 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_12
new file mode 100644
index 00000000000..9b6aa7bc248
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_12
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp ssbs
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_13 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_13
new file mode 100644
index 00000000000..ef4a3f606fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_13
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 asimddp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_14 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_14
new file mode 100644
index 00000000000..33897571513
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_14
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: Lorem ipsum dolor sit ametd rebum expetendis per at Dolor lucilius referrentur ei mei virtute eruditi eum ne Iisque verterem tacimates eu mea ei autem asimd fp asimddp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_15 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_15
new file mode 100644
index 00000000000..bc645394556
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_15
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: Lorem ipsum dolor sit ametd rebum expetendis per at Dolor lucilius referrentur ei mei virtute eruditi eum ne Iisque verter svesm4 asimd fp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_2 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_2
new file mode 100644
index 00000000000..965d37760ac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_2
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_3 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_3
new file mode 100644
index 00000000000..0c276f884a8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_3
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_4 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_4
new file mode 100644
index 00000000000..716210c1417
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_4
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp aes pmull sha1 sha2
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_5 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_5
new file mode 100644
index 00000000000..7a002e1c4c8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_5
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp fphp asimdhp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_6 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_6
new file mode 100644
index 00000000000..d341dfe86f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_6
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp aes pmull sha1 sha2 fphp asimdhp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_7 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_7
new file mode 100644
index 00000000000..ccb784915d5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_7
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd pmull sha1 fp aes sha2 fphp asimdhp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_8 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_8
new file mode 100644
index 00000000000..d6d9d03a2a2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_8
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd sve fp
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_9 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_9
new file mode 100644
index 00000000000..c9aa4a9a07d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_9
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 100.00
+Features	: asimd fp svesm4
+CPU implementer	: 0x41
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xd08
+CPU revision	: 2
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_0.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_0.c
new file mode 100644
index 00000000000..f155f51bae7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_0.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_0" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+crypto\+crc\+dotprod} } } */
+
+/* Test a normal looking procinfo.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_1.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_1.c
new file mode 100644
index 00000000000..2cf0e89994b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_1" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+nosimd} } } */
+
+/* Test one where fp is on by default so turn off simd.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_10.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_10.c
new file mode 100644
index 00000000000..6a753965c52
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_10.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_10" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+nofp\+nosimd} } } */
+
+/* Test one with no entry in feature list.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_13.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_13.c
new file mode 100644
index 00000000000..b7b3a8e13df
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_13.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_13" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+crypto\+crc\+dotprod} } } */
+
+/* Test one with mixed order of feature bits.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_14.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_14.c
new file mode 100644
index 00000000000..781ab1ebbfb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_14.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_14" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+dotprod} } } */
+
+/* Test one where valid feature bits are at a boundary > buffer size.   */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_2.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_2.c
new file mode 100644
index 00000000000..aad71f4347d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_2" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+nofp\+nosimd} } } */
+
+/* Test one where asimd is provided byt no fp.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_3.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_3.c
new file mode 100644
index 00000000000..50685c297db
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_3.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_3" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a} } } */
+
+/* Test where asimd and fp are the only ones provided, these are default
+   and so shouldn't emit anything.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_4.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_4.c
new file mode 100644
index 00000000000..91ae809757a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_4.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_4" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+crypto} } } */
+
+/* Test one where all crypto bits are given so crypto should be enabled.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_5.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_5.c
new file mode 100644
index 00000000000..84139e58ee0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_5.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_5" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+fp16} } } */
+
+/* Test one where fp16 is available and so should be emitted.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_6.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_6.c
new file mode 100644
index 00000000000..da72052e623
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_6.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_6" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+crypto\+fp16} } } */
+
+/* Test one where the feature bits for crypto and fp16 are given in
+   same order as declared in options file.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_7.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_7.c
new file mode 100644
index 00000000000..96ad4c14db1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_7.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_7" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+crypto\+fp16} } } */
+
+/* Test one where the crypto and fp16 options are specified in different
+   order from what is in the options file.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_8.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_8.c
new file mode 100644
index 00000000000..7a5a2144a39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_8.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_8" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8-a\+sve} } } */
+
+/* Test one where sve is enabled.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_11.c b/gcc/testsuite/gcc.target/aarch64/options_set_11.c
new file mode 100644
index 00000000000..d083bfdbd5c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_11.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc} } } */
+
+ /* FP is default on, no need to pass on to assembler.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_12.c b/gcc/testsuite/gcc.target/aarch64/options_set_12.c
new file mode 100644
index 00000000000..58a09fda2c1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_12.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp16" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+fp16} } } */
+
+ /* fp16 not default, should be emitted.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_13.c b/gcc/testsuite/gcc.target/aarch64/options_set_13.c
new file mode 100644
index 00000000000..2a517ecb58f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_13.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp16+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+fp16} } } */
+
+ /* FP is part of FP16, don't emit it.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_14.c b/gcc/testsuite/gcc.target/aarch64/options_set_14.c
new file mode 100644
index 00000000000..c192bf6cb63
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_14.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp16fml" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+fp16fml} } } */
+
+ /* fmp16fml is smallest option to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_15.c b/gcc/testsuite/gcc.target/aarch64/options_set_15.c
new file mode 100644
index 00000000000..32ec3ea4643
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_15.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp16fml+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+fp16fml*} } } */
+
+ /* fp included in fp16fml, only emit latter.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_16.c b/gcc/testsuite/gcc.target/aarch64/options_set_16.c
new file mode 100644
index 00000000000..b45c01a915b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_16.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+fp16fml+fp16+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+fp16fml} } } */
+
+ /* fp16fml is smallest options to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_17.c b/gcc/testsuite/gcc.target/aarch64/options_set_17.c
new file mode 100644
index 00000000000..c490e1f47a0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_17.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+dotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.2-a\+crc\+dotprod} } } */
+
+ /* dotprod needs to be emitted pre armv8.4.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_18.c b/gcc/testsuite/gcc.target/aarch64/options_set_18.c
new file mode 100644
index 00000000000..61587dbbd63
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_18.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+dotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc} } } */
+
+ /* dotprod is default in armv8.4-a, don't emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_19.c b/gcc/testsuite/gcc.target/aarch64/options_set_19.c
new file mode 100644
index 00000000000..72b58126182
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_19.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc} } } */
+
+ /* fp default, don't emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_20.c b/gcc/testsuite/gcc.target/aarch64/options_set_20.c
new file mode 100644
index 00000000000..b383e0aced2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_20.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_21.c b/gcc/testsuite/gcc.target/aarch64/options_set_21.c
new file mode 100644
index 00000000000..19fcd6fda6e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_21.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_22.c b/gcc/testsuite/gcc.target/aarch64/options_set_22.c
new file mode 100644
index 00000000000..77ae4089f39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_22.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16fml" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_23.c b/gcc/testsuite/gcc.target/aarch64/options_set_23.c
new file mode 100644
index 00000000000..dee637c5d2c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_23.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16fml+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_24.c b/gcc/testsuite/gcc.target/aarch64/options_set_24.c
new file mode 100644
index 00000000000..54b0e3d4a83
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_24.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16fml+fp16" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_25.c b/gcc/testsuite/gcc.target/aarch64/options_set_25.c
new file mode 100644
index 00000000000..a3b2d63c06e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_25.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16fml+fp+fp16" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_26.c b/gcc/testsuite/gcc.target/aarch64/options_set_26.c
new file mode 100644
index 00000000000..b383e0aced2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_26.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+fp16" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8\.4-a\+crc\+fp16} } } */
+
+ /* fp16 smallest set to emit.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr94435.c b/gcc/testsuite/gcc.target/aarch64/pr94435.c
new file mode 100644
index 00000000000..5713c14d5f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr94435.c
@@ -0,0 +1,25 @@
+/* PR target/94435 */
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -moutline-atomics" } */
+
+int b, c, d, e, f, h;
+short g;
+int foo (int) __attribute__ ((__const__));
+
+void
+bar (void)
+{
+  while (1)
+    {
+      while (1)
+	{
+	  __atomic_load_n (&e, 0);
+	  if (foo (2))
+	    __sync_val_compare_and_swap (&c, 0, f);
+	  b = 1;
+	  if (h == e)
+	    break;
+	}
+      __sync_val_compare_and_swap (&g, -1, f);
+    }
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr94514.c b/gcc/testsuite/gcc.target/aarch64/pr94514.c
new file mode 100644
index 00000000000..cbc940421d2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr94514.c
@@ -0,0 +1,77 @@
+/* PR target/94514. Unwind across mixed pac-ret and non-pac-ret frames.  */
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-fexceptions -O2" } */
+
+#include <unwind.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#define die() \
+  do { \
+    printf ("%s:%d: reached unexpectedly.\n", __FILE__, __LINE__); \
+    fflush (stdout); \
+    abort (); \
+  } while (0)
+
+static struct _Unwind_Exception exc;
+
+static _Unwind_Reason_Code
+force_unwind_stop (int version, _Unwind_Action actions,
+                   _Unwind_Exception_Class exc_class,
+                   struct _Unwind_Exception *exc_obj,
+                   struct _Unwind_Context *context,
+                   void *stop_parameter)
+{
+  printf ("%s: CFA: %p PC: %p actions: %d\n",
+	  __func__,
+	  (void *)_Unwind_GetCFA (context),
+	  (void *)_Unwind_GetIP (context),
+	  (int)actions);
+  if (actions & _UA_END_OF_STACK)
+    die ();
+  return _URC_NO_REASON;
+}
+
+static void force_unwind (void)
+{
+#ifndef __USING_SJLJ_EXCEPTIONS__
+  _Unwind_ForcedUnwind (&exc, force_unwind_stop, 0);
+#else
+  _Unwind_SjLj_ForcedUnwind (&exc, force_unwind_stop, 0);
+#endif
+}
+
+__attribute__((noinline, target("branch-protection=pac-ret")))
+static void f2_pac_ret (void)
+{
+  force_unwind ();
+  die ();
+}
+
+__attribute__((noinline, target("branch-protection=none")))
+static void f1_no_pac_ret (void)
+{
+  f2_pac_ret ();
+  die ();
+}
+
+__attribute__((noinline, target("branch-protection=pac-ret")))
+static void f0_pac_ret (void)
+{
+  f1_no_pac_ret ();
+  die ();
+}
+
+static void cleanup_handler (void *p)
+{
+  printf ("%s: Success.\n", __func__);
+  exit (0);
+}
+
+int main ()
+{
+  char dummy __attribute__((cleanup (cleanup_handler)));
+  f0_pac_ret ();
+  die ();
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr94530.c b/gcc/testsuite/gcc.target/aarch64/pr94530.c
new file mode 100644
index 00000000000..1f98201c50a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr94530.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -mcpu=falkor -mpc-relative-literal-loads -mcmodel=large" } */
+
+extern void bar(const char *);
+
+void foo(void) {
+  for (;;)
+    bar("");
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr94748.c b/gcc/testsuite/gcc.target/aarch64/pr94748.c
new file mode 100644
index 00000000000..2a2850d2fac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr94748.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+__attribute__ ((target("branch-protection=bti")))
+int foo ()
+{
+label:
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not {hint (36|38) // bti (j|jc)} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr96313.c b/gcc/testsuite/gcc.target/aarch64/pr96313.c
new file mode 100644
index 00000000000..0bf7604092f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr96313.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+
+#include <arm_neon.h>
+
+uint32_t (*fp3)(int64_t) = vqmovund_s64;
+uint8_t (*fp4)(int16_t) = vqmovunh_s16;
+uint16_t (*fp5)(int32_t) = vqmovuns_s32;
+
diff --git a/gcc/testsuite/gcc.target/aarch64/pr96402.c b/gcc/testsuite/gcc.target/aarch64/pr96402.c
new file mode 100644
index 00000000000..fa2dddfac15
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr96402.c
@@ -0,0 +1,16 @@
+/* PR target/96402 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-moutline-atomics" } */
+
+int
+main ()
+{
+  __int128 a = 0;
+  __sync_val_compare_and_swap (&a, (__int128) 0, (__int128) 1);
+  if (a != 1)
+    __builtin_abort ();
+  __sync_val_compare_and_swap (&a, (__int128) 1, (((__int128) 0xdeadbeeffeedbac1ULL) << 64) | 0xabadcafe00c0ffeeULL);
+  if (a != ((((__int128) 0xdeadbeeffeedbac1ULL) << 64) | 0xabadcafe00c0ffeeULL))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr97150.c b/gcc/testsuite/gcc.target/aarch64/pr97150.c
new file mode 100644
index 00000000000..7abdd8cf347
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr97150.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+
+#include <arm_neon.h>
+
+uint8_t  (*fp0)(uint8_t, int8_t)   = vqshlb_u8;
+uint16_t (*fp1)(uint16_t, int16_t) = vqshlh_u16;
+uint32_t (*fp2)(uint32_t, int32_t) = vqshls_u32;
+uint64_t (*fp3)(uint64_t, int64_t) = vqshld_u64;
+uint8_t  (*fp4)(uint8_t, int8_t)   = vqrshlb_u8;
+uint16_t (*fp5)(uint16_t, int16_t) = vqrshlh_u16;
+uint32_t (*fp6)(uint32_t, int32_t) = vqrshls_u32;
+uint64_t (*fp7)(uint64_t, int64_t) = vqrshld_u64;
+uint64_t (*fp8)(uint64_t, int64_t) = vshld_u64;
+
diff --git a/gcc/testsuite/gcc.target/aarch64/pr97535.c b/gcc/testsuite/gcc.target/aarch64/pr97535.c
new file mode 100644
index 00000000000..7d4db485f1f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr97535.c
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { ! ilp32 } } } */
+
+#include <string.h>
+
+#define SIZE 2181038080
+
+extern char raw_buffer[SIZE];
+
+void setRaw(const void *raw)
+{
+        memcpy(raw_buffer, raw, SIZE);
+}
+
+/* At any optimization level this should be a function call
+   and not inlined.  */
+/* { dg-final { scan-assembler "bl\tmemcpy" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/return_address_sign_1.c b/gcc/testsuite/gcc.target/aarch64/return_address_sign_1.c
index 0140bee194f..232ba67ade0 100644
--- a/gcc/testsuite/gcc.target/aarch64/return_address_sign_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/return_address_sign_1.c
@@ -41,12 +41,12 @@ func3 (int a, int b, int c)
 void __attribute__ ((target ("arch=armv8.3-a")))
 func4 (long offset, void *handler, int *ptr, int imm1, int imm2)
 {
-  /* paciasp */
+  /* no paciasp */
   *ptr = imm1 + foo (imm1) + imm2;
   __builtin_eh_return (offset, handler);
-  /* autiasp */
+  /* no autiasp */
   return;
 }
 
-/* { dg-final { scan-assembler-times "autiasp" 4 } } */
-/* { dg-final { scan-assembler-times "paciasp" 4 } } */
+/* { dg-final { scan-assembler-times "autiasp" 3 } } */
+/* { dg-final { scan-assembler-times "paciasp" 3 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c b/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c
index d943989768d..c2e13b651e9 100644
--- a/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c
+++ b/gcc/testsuite/gcc.target/aarch64/scalar_intrinsics.c
@@ -661,7 +661,7 @@ test_vqnegs_s32 (int32_t a)
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\tb\[0-9\]+" 1 } } */
 
-int8_t
+uint8_t
 test_vqmovunh_s16 (int16_t a)
 {
   return vqmovunh_s16 (a);
@@ -669,7 +669,7 @@ test_vqmovunh_s16 (int16_t a)
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\th\[0-9\]+" 1 } } */
 
-int16_t
+uint16_t
 test_vqmovuns_s32 (int32_t a)
 {
   return vqmovuns_s32 (a);
@@ -677,7 +677,7 @@ test_vqmovuns_s32 (int32_t a)
 
 /* { dg-final { scan-assembler-times "\\tsqxtun\\ts\[0-9\]+" 1 } } */
 
-int32_t
+uint32_t
 test_vqmovund_s64 (int64_t a)
 {
   return vqmovund_s64 (a);
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/pr97349.c b/gcc/testsuite/gcc.target/aarch64/simd/pr97349.c
new file mode 100644
index 00000000000..026767a7243
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/pr97349.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+#include <arm_neon.h>
+
+poly16x8_t  (*fp0)(poly16_t) = vdupq_n_p16;
+poly64x2_t  (*fp1)(poly64_t) = vdupq_n_p64;
+poly8x16_t  (*fp2)(poly8_t)  = vdupq_n_p8;
+int16x8_t   (*fp3)(int16_t)  = vdupq_n_s16;
+int8x16_t   (*fp4)(int8_t)   = vdupq_n_s8;
+uint16x8_t  (*fp5)(uint16_t) = vdupq_n_u16;
+uint8x16_t  (*fp6)(uint8_t)  = vdupq_n_u8;
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/trn_zip_p64_1.c b/gcc/testsuite/gcc.target/aarch64/simd/trn_zip_p64_1.c
new file mode 100644
index 00000000000..a47321db80b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/trn_zip_p64_1.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+poly64x2_t
+foo (poly64x2_t a, poly64x2_t b)
+{
+  return vtrn1q_p64 (a, b);
+}
+
+poly64x2_t
+foo1 (poly64x2_t a, poly64x2_t b)
+{
+  return vtrn2q_p64 (a, b);
+}
+
+poly64x2_t
+foo2 (poly64x2_t a, poly64x2_t b)
+{
+  return vuzp1q_p64 (a, b);
+}
+
+poly64x2_t
+foo3 (poly64x2_t a, poly64x2_t b)
+{
+  return vuzp2q_p64 (a, b);
+}
+
+poly64x2_t
+foo4 (poly64x2_t a, poly64x2_t b)
+{
+  return vzip1q_p64 (a, b);
+}
+
+poly64x2_t
+foo5 (poly64x2_t a, poly64x2_t b)
+{
+  return vzip2q_p64 (a, b);
+}
+
+/* { dg-final { scan-assembler-times {zip1\tv0.2d, v0.2d, v1.2d} 3 } } */
+/* { dg-final { scan-assembler-times {zip2\tv0.2d, v0.2d, v1.2d} 3 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vadd_poly_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vadd_poly_1.c
new file mode 100644
index 00000000000..a5cdf290b0d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vadd_poly_1.c
@@ -0,0 +1,50 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+poly8x8_t
+foo (poly8x8_t a, poly8x8_t b)
+{
+  return vadd_p8 (a, b);
+}
+
+poly16x4_t
+foo16 (poly16x4_t a, poly16x4_t b)
+{
+  return vadd_p16 (a, b);
+}
+
+poly64x1_t
+foo64 (poly64x1_t a, poly64x1_t b)
+{
+  return vadd_p64 (a, b);
+}
+
+poly8x16_t
+fooq (poly8x16_t a, poly8x16_t b)
+{
+  return vaddq_p8 (a, b);
+}
+
+poly16x8_t
+fooq16 (poly16x8_t a, poly16x8_t b)
+{
+  return vaddq_p16 (a, b);
+}
+
+poly64x2_t
+fooq64 (poly64x2_t a, poly64x2_t b)
+{
+  return vaddq_p64 (a, b);
+}
+
+poly128_t
+fooq128 (poly128_t a, poly128_t b)
+{
+  return vaddq_p128 (a, b);
+}
+
+/* { dg-final { scan-assembler-times "eor\\tv\[0-9\]+\.8b, v\[0-9\]+\.8b, v\[0-9\]+\.8b" 3 } } */
+/* { dg-final { scan-assembler-times "eor\\tv\[0-9\]+\.16b, v\[0-9\]+\.16b, v\[0-9\]+\.16b" 3 } } */
+/* { dg-final { scan-assembler-times "eor\\tx\[0-9\]+, x\[0-9\]+, x\[0-9\]+" 2 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vceq_poly_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vceq_poly_1.c
new file mode 100644
index 00000000000..7d43352266c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vceq_poly_1.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+uint64x2_t
+foo (poly64x2_t a, poly64x2_t b)
+{
+  return vceqq_p64 (a, b);
+}
+
+/* { dg-final { scan-assembler-times "cmeq\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, v\[0-9\]+\.2d" 1 } } */
+
+uint64x1_t
+fooz (poly64x1_t a)
+{
+  return vceqz_p64 (a);
+}
+
+/* { dg-final { scan-assembler-times "cmeq\\td\[0-9\]+, d\[0-9\]+, #0" 1 } } */
+
+uint64x2_t
+fooqz (poly64x2_t a)
+{
+  return vceqzq_p64 (a);
+}
+
+/* { dg-final { scan-assembler-times "cmeq\\tv\[0-9\]+\.2d, v\[0-9\]+\.2d, #0" 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vcls_unsigned_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vcls_unsigned_1.c
new file mode 100644
index 00000000000..f7078d1a67c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vcls_unsigned_1.c
@@ -0,0 +1,54 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+int16x8_t
+test_16x8 (uint16x8_t a)
+{
+  return vclsq_u16 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.8h, v\[0-9\]+\.8h" 1 } } */
+
+
+int8x16_t
+test_8x16 (uint8x16_t a)
+{
+  return vclsq_u8 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.16b, v\[0-9\]+\.16b" 1 } } */
+
+int32x4_t
+test_32x4 (uint32x4_t a)
+{
+  return vclsq_u32 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s" 1 } } */
+
+int16x4_t
+test_16x4 (uint16x4_t a)
+{
+  return vcls_u16 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.4h, v\[0-9\]+\.4h" 1 } } */
+
+int8x8_t
+test_8x8 (uint8x8_t a)
+{
+  return vcls_u8 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.8b, v\[0-9\]+\.8b" 1 } } */
+
+int32x2_t
+test32x2 (uint32x2_t a)
+{
+  return vcls_u32 (a);
+}
+
+/* { dg-final { scan-assembler-times "cls\\tv\[0-9\]+\.2s, v\[0-9\]+\.2s" 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vldrq_p128_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vldrq_p128_1.c
new file mode 100644
index 00000000000..9c7e01b9e10
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vldrq_p128_1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+poly128_t
+test (poly128_t * p)
+{
+  return vldrq_p128 (p);
+}
+
+/* { dg-final { scan-assembler-times {ldp.*x0,.*x1,.*[x0]} 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vrndns_f32_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vrndns_f32_1.c
new file mode 100644
index 00000000000..960e4f6f768
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vrndns_f32_1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+float32_t
+test (float32_t a)
+{
+  return vrndns_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frintn\\ts\[0-9\]+, s\[0-9\]+" 1 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vrndnzx_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vrndnzx_1.c
new file mode 100644
index 00000000000..0399b838df9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vrndnzx_1.c
@@ -0,0 +1,137 @@
+/* Test the vrnd[32,64][z,x] intrinsics.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.5-a" } */
+
+#include "arm_neon.h"
+
+#ifdef __ARM_FEATURE_FRINT
+
+float32x2_t
+foo_32z (float32x2_t a)
+{
+  return vrnd32z_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\tv\[0-9\]+\.2s, v\[0-9\]+\.2s\n" 1 } } */
+
+float32x4_t
+foo_32z_q (float32x4_t a)
+{
+  return vrnd32zq_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\tv\[0-9\]+\.4s, v\[0-9\]+\.4s\n" 1 } } */
+
+float64x1_t
+foo_32z_f64 (float64x1_t a)
+{
+  return vrnd32z_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float64x2_t
+foo_32z_q_f64 (float64x2_t a)
+{
+  return vrnd32zq_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32z\tv\[0-9\]+\.2d, v\[0-9\]+\.2d\n" 1 } } */
+
+float32x2_t
+foo_32x (float32x2_t a)
+{
+  return vrnd32x_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\tv\[0-9\]+\.2s, v\[0-9\]+\.2s\n" 1 } } */
+
+float32x4_t
+foo_32x_q (float32x4_t a)
+{
+  return vrnd32xq_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\tv\[0-9\]+\.4s, v\[0-9\]+\.4s\n" 1 } } */
+
+float64x1_t
+foo_32x_f64 (float64x1_t a)
+{
+  return vrnd32x_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float64x2_t
+foo_32x_q_f64 (float64x2_t a)
+{
+  return vrnd32xq_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint32x\tv\[0-9\]+\.2d, v\[0-9\]+\.2d\n" 1 } } */
+
+float32x2_t
+foo_64z (float32x2_t a)
+{
+  return vrnd64z_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\tv\[0-9\]+\.2s, v\[0-9\]+\.2s\n" 1 } } */
+
+float32x4_t
+foo_64z_q (float32x4_t a)
+{
+  return vrnd64zq_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\tv\[0-9\]+\.4s, v\[0-9\]+\.4s\n" 1 } } */
+
+float64x1_t
+foo_64z_f64 (float64x1_t a)
+{
+  return vrnd64z_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float64x2_t
+foo_64z_q_f64 (float64x2_t a)
+{
+  return vrnd64zq_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64z\tv\[0-9\]+\.2d, v\[0-9\]+\.2d\n" 1 } } */
+
+float32x2_t
+foo_64x (float32x2_t a)
+{
+  return vrnd64x_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\tv\[0-9\]+\.2s, v\[0-9\]+\.2s\n" 1 } } */
+
+float32x4_t
+foo_64x_q (float32x4_t a)
+{
+  return vrnd64xq_f32 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\tv\[0-9\]+\.4s, v\[0-9\]+\.4s\n" 1 } } */
+
+float64x1_t
+foo_64x_f64 (float64x1_t a)
+{
+  return vrnd64x_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\td\[0-9\]+, d\[0-9\]+\n" 1 } } */
+
+float64x2_t
+foo_64x_q_f64 (float64x2_t a)
+{
+  return vrnd64xq_f64 (a);
+}
+
+/* { dg-final { scan-assembler-times "frint64x\tv\[0-9\]+\.2d, v\[0-9\]+\.2d\n" 1 } } */
+#endif
diff --git a/gcc/testsuite/gcc.target/aarch64/simd/vstrq_p128_1.c b/gcc/testsuite/gcc.target/aarch64/simd/vstrq_p128_1.c
new file mode 100644
index 00000000000..8d036fde0f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/simd/vstrq_p128_1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <arm_neon.h>
+
+void
+test (poly128_t *ptr, poly128_t a)
+{
+  vstrq_p128 (ptr, a);
+}
+
+/* { dg-final { scan-assembler-times {stp.*x2,.*x3,.*[x0]} 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c
new file mode 100644
index 00000000000..b1fb754c7b6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c
@@ -0,0 +1,40 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-mharden-sls=blr -mbranch-protection=bti" } */
+/*
+   Ensure that the SLS hardening of BLR leaves no BLR instructions.
+   Here we also check that there are no BR instructions with anything except an
+   x16 or x17 register.  This is because a `BTI c` instruction can be branched
+   to using a BLR instruction using any register, but can only be branched to
+   with a BR using an x16 or x17 register.
+  */
+typedef int (foo) (int, int);
+typedef void (bar) (int, int);
+struct sls_testclass {
+    foo *x;
+    bar *y;
+    int left;
+    int right;
+};
+
+/* We test both RTL patterns for a call which returns a value and a call which
+   does not.  */
+int blr_call_value (struct sls_testclass x)
+{
+  int retval = x.x(x.left, x.right);
+  if (retval % 10)
+    return 100;
+  return 9;
+}
+
+int blr_call (struct sls_testclass x)
+{
+  x.y(x.left, x.right);
+  if (x.left % 10)
+    return 100;
+  return 9;
+}
+
+/* { dg-final { scan-assembler-not {\tblr\t} } } */
+/* { dg-final { scan-assembler-not {\tbr\tx(?!16|17)} } } */
+/* { dg-final { scan-assembler {\tbr\tx(16|17)} } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr.c b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr.c
new file mode 100644
index 00000000000..88baffffe54
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr.c
@@ -0,0 +1,33 @@
+/* { dg-additional-options "-mharden-sls=blr -save-temps" } */
+/* Ensure that the SLS hardening of BLR leaves no BLR instructions.
+   We only test that all BLR instructions have been removed, not that the
+   resulting code makes sense.  */
+typedef int (foo) (int, int);
+typedef void (bar) (int, int);
+struct sls_testclass {
+    foo *x;
+    bar *y;
+    int left;
+    int right;
+};
+
+/* We test both RTL patterns for a call which returns a value and a call which
+   does not.  */
+int blr_call_value (struct sls_testclass x)
+{
+  int retval = x.x(x.left, x.right);
+  if (retval % 10)
+    return 100;
+  return 9;
+}
+
+int blr_call (struct sls_testclass x)
+{
+  x.y(x.left, x.right);
+  if (x.left % 10)
+    return 100;
+  return 9;
+}
+
+/* { dg-final { scan-assembler-not {\tblr\t} } } */
+/* { dg-final { scan-assembler {\tbr\tx[0-9][0-9]?} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c
new file mode 100644
index 00000000000..7656123ee7b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c
@@ -0,0 +1,15 @@
+/* Avoid ILP32 since pacret is only available for LP64 */
+/* { dg-do compile { target { ! ilp32 } } } */
+/* { dg-additional-options "-mharden-sls=retbr -mbranch-protection=pac-ret -march=armv8.3-a" } */
+
+/* Testing the do_return pattern for retaa.  */
+long retbr_subcall(void);
+long retbr_do_return_retaa(void)
+{
+    return retbr_subcall()+1;
+}
+
+/* Ensure there are no BR or RET instructions which are not directly followed
+   by a speculation barrier.  */
+/* { dg-final { scan-assembler-not {\t(br|ret|retaa)\tx[0-9][0-9]?\n\t(?!dsb\tsy\n\tisb)} } } */
+/* { dg-final { scan-assembler-not {ret\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c
new file mode 100644
index 00000000000..573b30cdc16
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c
@@ -0,0 +1,119 @@
+/* We ensure that -Wpedantic is off since it complains about the trampolines
+   we explicitly want to test.  */
+/* { dg-additional-options "-mharden-sls=retbr -Wno-pedantic " } */
+/*
+   Ensure that the SLS hardening of RET and BR leaves no unprotected RET/BR
+   instructions.
+  */
+typedef int (foo) (int, int);
+typedef void (bar) (int, int);
+struct sls_testclass {
+    foo *x;
+    bar *y;
+    int left;
+    int right;
+};
+
+int
+retbr_sibcall_value_insn (struct sls_testclass x)
+{
+  return x.x(x.left, x.right);
+}
+
+void
+retbr_sibcall_insn (struct sls_testclass x)
+{
+  x.y(x.left, x.right);
+}
+
+/* Aim to test two different returns.
+   One that introduces a tail call in the middle of the function, and one that
+   has a normal return.  */
+int
+retbr_multiple_returns (struct sls_testclass x)
+{
+  int temp;
+  if (x.left % 10)
+    return x.x(x.left, 100);
+  else if (x.right % 20)
+    {
+      return x.x(x.left * x.right, 100);
+    }
+  temp = x.left % x.right;
+  temp *= 100;
+  temp /= 2;
+  return temp % 3;
+}
+
+void
+retbr_multiple_returns_void (struct sls_testclass x)
+{
+  if (x.left % 10)
+    {
+      x.y(x.left, 100);
+    }
+  else if (x.right % 20)
+    {
+      x.y(x.left * x.right, 100);
+    }
+  return;
+}
+
+/* Testing the casesi jump via register.  */
+__attribute__ ((optimize ("Os")))
+int
+retbr_casesi_dispatch (struct sls_testclass x)
+{
+  switch (x.left)
+    {
+    case -5:
+      return -2;
+    case -3:
+      return -1;
+    case 0:
+      return 0;
+    case 3:
+      return 1;
+    case 5:
+      break;
+    default:
+      __builtin_unreachable ();
+    }
+  return x.right;
+}
+
+/* Testing the BR in trampolines is mitigated against.  */
+void f1 (void *);
+void f3 (void *, void (*)(void *));
+void f2 (void *);
+
+int
+retbr_trampolines (void *a, int b)
+{
+  if (!b)
+    {
+      f1 (a);
+      return 1;
+    }
+  if (b)
+    {
+      void retbr_tramp_internal (void *c)
+      {
+	if (c == a)
+	  f2 (c);
+      }
+      f3 (a, retbr_tramp_internal);
+    }
+  return 0;
+}
+
+/* Testing the indirect_jump pattern.  */
+void
+retbr_indirect_jump (int *buf)
+{
+  __builtin_longjmp(buf, 1);
+}
+
+/* Ensure there are no BR or RET instructions which are not directly followed
+   by a speculation barrier.  */
+/* { dg-final { scan-assembler-not {\t(br|ret|retaa)\tx[0-9][0-9]?\n\t(?!dsb\tsy\n\tisb|sb)} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-mitigation.exp b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-mitigation.exp
new file mode 100644
index 00000000000..812250379f8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-mitigation.exp
@@ -0,0 +1,73 @@
+#  Regression driver for SLS mitigation on AArch64.
+#  Copyright (C) 2020 Free Software Foundation, Inc.
+#  Contributed by ARM Ltd.
+#
+#  This file is part of GCC.
+#
+#  GCC is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 3, or (at your option)
+#  any later version.
+#
+#  GCC is distributed in the hope that it will be useful, but
+#  WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GCC; see the file COPYING3.  If not see
+#  <http://www.gnu.org/licenses/>.  */
+
+# Exit immediately if this isn't an AArch64 target.
+if {![istarget aarch64*-*-*] } then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+load_lib torture-options.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " "
+}
+
+# Initialize `dg'.
+dg-init
+torture-init
+
+# Use different architectures as well as the normal optimisation options.
+# (i.e. use both SB and DSB+ISB barriers).
+
+set save-dg-do-what-default ${dg-do-what-default}
+# Main loop.
+# Run with torture tests (i.e. a bunch of different optimisation levels) just
+# to increase test coverage.
+set dg-do-what-default assemble
+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"-save-temps" $DEFAULT_CFLAGS
+
+# Run the same tests but this time with SB extension.
+# Since not all supported assemblers will support that extension we decide
+# whether to assemble or just compile based on whether the extension is
+# supported for the available assembler.
+
+set templist {}
+foreach x $DG_TORTURE_OPTIONS {
+  lappend templist "$x -march=armv8.3-a+sb "
+  lappend templist "$x -march=armv8-a+sb "
+}
+set-torture-options $templist
+if { [check_effective_target_aarch64_asm_sb_ok] } {
+    set dg-do-what-default assemble
+} else {
+    set dg-do-what-default compile
+}
+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"-save-temps" $DEFAULT_CFLAGS
+set dg-do-what-default ${save-dg-do-what-default}
+
+# All done.
+torture-finish
+dg-finish
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-protector-1.c b/gcc/testsuite/gcc.target/aarch64/stack-protector-1.c
new file mode 100644
index 00000000000..73e83bc413f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-protector-1.c
@@ -0,0 +1,89 @@
+/* { dg-do run } */
+/* { dg-require-effective-target fstack_protector } */
+/* { dg-options "-fstack-protector-all -O2" } */
+
+extern volatile long *stack_chk_guard_ptr;
+
+volatile long *
+get_ptr (void)
+{
+  return stack_chk_guard_ptr;
+}
+
+void __attribute__ ((noipa))
+f (void)
+{
+  volatile int x;
+  x = 1;
+  x += 1;
+}
+
+#define CHECK(REG) "\tcmp\tx0, " #REG "\n\tbeq\t1f\n"
+
+asm (
+"	.pushsection .data\n"
+"	.align	3\n"
+"	.globl	stack_chk_guard_ptr\n"
+"stack_chk_guard_ptr:\n"
+#if __ILP32__
+"	.word	__stack_chk_guard\n"
+#else
+"	.xword	__stack_chk_guard\n"
+#endif
+"	.weak	__stack_chk_guard\n"
+"__stack_chk_guard:\n"
+"	.word	0xdead4321\n"
+"	.word	0xbeef8765\n"
+"	.text\n"
+"	.globl	main\n"
+"	.type	main, %function\n"
+"main:\n"
+"	bl	get_ptr\n"
+"	str	x0, [sp, #-16]!\n"
+"	bl	f\n"
+"	str	x0, [sp, #8]\n"
+"	ldr	x0, [sp]\n"
+#if __ILP32__
+"	ldr     w0, [x0]\n"
+#else
+"	ldr     x0, [x0]\n"
+#endif
+	CHECK (x1)
+	CHECK (x2)
+	CHECK (x3)
+	CHECK (x4)
+	CHECK (x5)
+	CHECK (x6)
+	CHECK (x7)
+	CHECK (x8)
+	CHECK (x9)
+	CHECK (x10)
+	CHECK (x11)
+	CHECK (x12)
+	CHECK (x13)
+	CHECK (x14)
+	CHECK (x15)
+	CHECK (x16)
+	CHECK (x17)
+	CHECK (x18)
+	CHECK (x19)
+	CHECK (x20)
+	CHECK (x21)
+	CHECK (x22)
+	CHECK (x23)
+	CHECK (x24)
+	CHECK (x25)
+	CHECK (x26)
+	CHECK (x27)
+	CHECK (x28)
+	CHECK (x29)
+	CHECK (x30)
+"	ldr	x1, [sp]\n"
+	CHECK (x1)
+"	mov	x0, #0\n"
+"	b	exit\n"
+"1:\n"
+"	b	abort\n"
+"	.size	main, .-main\n"
+"	.popsection"
+);
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-protector-2.c b/gcc/testsuite/gcc.target/aarch64/stack-protector-2.c
new file mode 100644
index 00000000000..266c36fdbc6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-protector-2.c
@@ -0,0 +1,6 @@
+/* { dg-do run } */
+/* { dg-require-effective-target fstack_protector } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fstack-protector-all -O2 -fpic" } */
+
+#include "stack-protector-1.c"
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr94605.c b/gcc/testsuite/gcc.target/aarch64/sve/pr94605.c
new file mode 100644
index 00000000000..593e959e292
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr94605.c
@@ -0,0 +1,12 @@
+/* { dg-options "-O2 -msve-vector-bits=256" } */
+
+typedef int v8si __attribute__((vector_size(32)));
+int g (v8si, v8si);
+
+void
+f (void)
+{
+  v8si x = {}, y = {};
+  while (g (x, y))
+    asm ("" : "+w" (x), "+w" (y));
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c b/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
index d7e46b059e4..fc6a4f3ec78 100644
--- a/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
+++ b/gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c
@@ -1,12 +1,12 @@
-/* { dg-do compile } */
+/* { dg-do link } */
 /* { dg-options "-O3 -save-temps -mcmodel=tiny" } */
 
-int fixed_regs[0x00200000];
+char fixed_regs[0x00080000];
 
 int
-foo()
+main ()
 {
-  return fixed_regs[0x00080000];
+  return fixed_regs[0x000ff000];
 }
 
 /* { dg-final { scan-assembler-not "adr\tx\[0-9\]+, fixed_regs\\\+" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/symbol-range.c b/gcc/testsuite/gcc.target/aarch64/symbol-range.c
index 6574cf43104..d8e82fa1b28 100644
--- a/gcc/testsuite/gcc.target/aarch64/symbol-range.c
+++ b/gcc/testsuite/gcc.target/aarch64/symbol-range.c
@@ -1,12 +1,12 @@
-/* { dg-do compile } */
+/* { dg-do link } */
 /* { dg-options "-O3 -save-temps -mcmodel=small" } */
 
-int fixed_regs[0x200000000ULL];
+char fixed_regs[0x80000000];
 
 int
-foo()
+main ()
 {
-  return fixed_regs[0x100000000ULL];
+  return fixed_regs[0xfffff000];
 }
 
 /* { dg-final { scan-assembler-not "adrp\tx\[0-9\]+, fixed_regs\\\+" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
index e571b2f13b3..f56415f3354 100644
--- a/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
+++ b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf -mno-outline-atomics" } */
 
 #include "sync-comp-swap.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
index 357bf1be3b2..39b3144aa36 100644
--- a/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "sync-op-acquire.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-full.c b/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
index c6ba1629965..6b8b2043f40 100644
--- a/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-march=armv8-a+nolse -O2" } */
+/* { dg-options "-march=armv8-a+nolse -O2 -mno-outline-atomics" } */
 
 #include "sync-op-full.x"
 
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
new file mode 100644
index 00000000000..509fb039e84
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -moutline-atomics" } */
+
+int b, c, d, e, f, h;
+short g;
+int foo (int) __attribute__ ((__const__));
+
+__attribute__ ((target ("no-outline-atomics")))
+void
+bar (void)
+{
+  while (1)
+    {
+      while (1)
+	{
+	  __atomic_load_n (&e, 0);
+	  if (foo (2))
+	    __sync_val_compare_and_swap (&c, 0, f);
+	  b = 1;
+	  if (h == e)
+	    break;
+	}
+      __sync_val_compare_and_swap (&g, -1, f);
+    }
+}
+
+/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_acq_rel" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
new file mode 100644
index 00000000000..acace4c8f2a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -mno-outline-atomics" } */
+
+int b, c, d, e, f, h;
+short g;
+int foo (int) __attribute__ ((__const__));
+
+__attribute__ ((target ("outline-atomics")))
+void
+bar (void)
+{
+  while (1)
+    {
+      while (1)
+	{
+	  __atomic_load_n (&e, 0);
+	  if (foo (2))
+	    __sync_val_compare_and_swap (&c, 0, f);
+	  b = 1;
+	  if (h == e)
+	    break;
+	}
+      __sync_val_compare_and_swap (&g, -1, f);
+    }
+}
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_acq_rel" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/with-tune-config.c b/gcc/testsuite/gcc.target/aarch64/with-tune-config.c
new file mode 100644
index 00000000000..0940e9eea89
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/with-tune-config.c
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { tune_cortex_a76 } } } */
+/* { dg-additional-options " -dA " } */
+
+void foo ()
+{}
+
+/* { dg-final { scan-assembler "//.tune cortex-a76" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/with-tune-march.c b/gcc/testsuite/gcc.target/aarch64/with-tune-march.c
new file mode 100644
index 00000000000..61039adea71
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/with-tune-march.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { tune_cortex_a76 } } } */
+/* { dg-additional-options " -dA -march=armv8.6-a " } */
+
+void foo ()
+{}
+
+/* { dg-final { scan-assembler "//.tune cortex-a76" } } */
+/* { dg-final { scan-assembler ".arch armv8.6-a" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/with-tune-mcpu.c b/gcc/testsuite/gcc.target/aarch64/with-tune-mcpu.c
new file mode 100644
index 00000000000..4f8267a5c16
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/with-tune-mcpu.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { tune_cortex_a76 } } } */
+/* { dg-additional-options " -dA -mcpu=cortex-a73" } */
+
+void foo ()
+{}
+
+/* { dg-final { scan-assembler "//.tune cortex-a73" } } */
+/* { dg-final { scan-assembler ".arch armv8-a" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/with-tune-mtune.c b/gcc/testsuite/gcc.target/aarch64/with-tune-mtune.c
new file mode 100644
index 00000000000..60f795a3919
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/with-tune-mtune.c
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { tune_cortex_a76 } } } */
+/* { dg-additional-options " -dA -mtune=cortex-a73" } */
+
+void foo ()
+{}
+
+/* { dg-final { scan-assembler "//.tune cortex-a73" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr78353-1.c b/gcc/testsuite/gcc.target/arm/pr78353-1.c
new file mode 100644
index 00000000000..a107e300269
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr78353-1.c
@@ -0,0 +1,9 @@
+/* { dg-do link }  */
+/* { dg-require-effective-target arm_arch_v7a_multilib } */
+/* { dg-options "-march=armv7-a -mthumb -O2 -flto -Wa,-mimplicit-it=always" }  */
+
+int main(int x)
+{
+  asm("teq %0, #0; addne %0, %0, #1" : "=r" (x));
+  return x;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr78353-2.c b/gcc/testsuite/gcc.target/arm/pr78353-2.c
new file mode 100644
index 00000000000..2589e6135aa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr78353-2.c
@@ -0,0 +1,10 @@
+/* { dg-do link }  */
+/* { dg-require-effective-target arm_arch_v7a_multilib } */
+/* { dg-options "-march=armv7-a -mthumb -O2 -flto -Wa,-mimplicit-it=always,-mthumb" }  */
+
+int main(int x)
+{
+  asm("teq %0, #0; addne %0, %0, #1" : "=r" (x));
+  return x;
+}
+
diff --git a/gcc/testsuite/gcc.target/arm/pr91816.c b/gcc/testsuite/gcc.target/arm/pr91816.c
new file mode 100644
index 00000000000..f1269141690
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr91816.c
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-additional-options "-mthumb" }  */
+/* { dg-timeout-factor 4.0 } */
+
+int printf(const char *, ...);
+
+#define HW0	printf("Hello World!\n");
+#define HW1	HW0 HW0 HW0 HW0 HW0 HW0 HW0 HW0 HW0 HW0
+#define HW2	HW1 HW1 HW1 HW1 HW1 HW1 HW1 HW1 HW1 HW1
+#define HW3	HW2 HW2 HW2 HW2 HW2 HW2 HW2 HW2 HW2 HW2
+#define HW4	HW3 HW3 HW3 HW3 HW3 HW3 HW3 HW3 HW3 HW3
+#define HW5	HW4 HW4 HW4 HW4 HW4 HW4 HW4 HW4 HW4 HW4
+#define HW6	HW5 HW5
+
+__attribute__((noinline,noclone)) void f1 (int a)
+{
+  if (a) { HW0 }
+}
+
+__attribute__((noinline,noclone)) void f2 (int a)
+{
+  if (a) { HW3 }
+}
+
+
+__attribute__((noinline,noclone)) void f3 (int a)
+{
+  if (a) { HW6 }
+}
+
+__attribute__((noinline,noclone)) void f4 (int a)
+{
+  if (a == 1) { HW0 }
+}
+
+__attribute__((noinline,noclone)) void f5 (int a)
+{
+  if (a == 1) { HW3 }
+}
+
+
+__attribute__((noinline,noclone)) void f6 (int a)
+{
+  if (a == 1) { HW6 }
+}
+
+
+int main(void)
+{
+	f1(0);
+	f2(0);
+	f3(0);
+	f4(0);
+	f5(0);
+	f6(0);
+	return 0;
+}
+
+
+/* { dg-final { scan-assembler-times "beq\\t.L\[0-9\]" 2 } } */
+/* { dg-final { scan-assembler-times "beq\\t.Lbcond\[0-9\]" 1 } } */
+/* { dg-final { scan-assembler-times "bne\\t.L\[0-9\]" 2 } } */
+/* { dg-final { scan-assembler-times "bne\\t.Lbcond\[0-9\]" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr97528.c b/gcc/testsuite/gcc.target/arm/pr97528.c
new file mode 100644
index 00000000000..6cc59f2158c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr97528.c
@@ -0,0 +1,28 @@
+/* PR target/97528 */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O1" }  */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+typedef __simd64_int16_t T;
+typedef __simd64_uint16_t U;
+unsigned short c;
+int d;
+U e;
+
+void
+foo (void)
+{
+  unsigned short *dst = &c;
+  int g = d, b = 4;
+  U dc = e;
+  for (int h = 0; h < b; h++)
+    {
+      unsigned short *i = dst;
+      U j = dc;
+      vst1_s16 ((int16_t *) i, (T) j);
+      dst += g;
+    }
+}
diff --git a/gcc/testsuite/gcc.target/arm/pure-code/pr94538-1.c b/gcc/testsuite/gcc.target/arm/pure-code/pr94538-1.c
new file mode 100644
index 00000000000..31061d5d445
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pure-code/pr94538-1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "skip override" { *-*-* } { "-mfloat-abi=hard" } { "" } } */
+/* { dg-options "-mpure-code -mcpu=cortex-m23 -march=armv8-m.base -mthumb -mfloat-abi=soft" } */
+
+typedef int __attribute__ ((__vector_size__ (16))) V;
+
+V v;
+
+void
+foo (void)
+{
+  v += (V){4095};
+}
diff --git a/gcc/testsuite/gcc.target/arm/pure-code/pr94538-2.c b/gcc/testsuite/gcc.target/arm/pure-code/pr94538-2.c
new file mode 100644
index 00000000000..c1789da6780
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pure-code/pr94538-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mpure-code" } */
+
+typedef int __attribute__ ((__vector_size__ (16))) V;
+
+V v;
+
+void
+foo (void)
+{
+  v += (V){4095};
+}
diff --git a/gcc/testsuite/gcc.target/arm/stack-protector-1.c b/gcc/testsuite/gcc.target/arm/stack-protector-1.c
new file mode 100644
index 00000000000..8d28b0a847c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/stack-protector-1.c
@@ -0,0 +1,63 @@
+/* { dg-do run } */
+/* { dg-require-effective-target fstack_protector } */
+/* { dg-options "-fstack-protector-all -O2" } */
+
+extern volatile long *stack_chk_guard_ptr;
+
+volatile long *
+get_ptr (void)
+{
+  return stack_chk_guard_ptr;
+}
+
+void __attribute__ ((noipa))
+f (void)
+{
+  volatile int x;
+  x = 1;
+  x += 1;
+}
+
+#define CHECK(REG) "\tcmp\tr0, " #REG "\n\tbeq\t1f\n"
+
+asm (
+"	.data\n"
+"	.align	3\n"
+"	.globl	stack_chk_guard_ptr\n"
+"stack_chk_guard_ptr:\n"
+"	.word	__stack_chk_guard\n"
+"	.weak	__stack_chk_guard\n"
+"__stack_chk_guard:\n"
+"	.word	0xdead4321\n"
+"	.text\n"
+"	.globl	main\n"
+"	.type	main, %function\n"
+"main:\n"
+"	bl	get_ptr\n"
+"	sub	sp, sp, #8\n"
+"	str	r0, [sp]\n"
+"	bl	f\n"
+"	str	r0, [sp, #4]\n"
+"	ldr     r0, [sp]\n"
+"	ldr     r0, [r0]\n"
+	CHECK (r1)
+	CHECK (r2)
+	CHECK (r3)
+	CHECK (r4)
+	CHECK (r5)
+	CHECK (r6)
+	CHECK (r7)
+	CHECK (r8)
+	CHECK (r9)
+	CHECK (r10)
+	CHECK (r11)
+	CHECK (r12)
+	CHECK (r14)
+"	ldr	r1, [sp, #4]\n"
+	CHECK (r1)
+"	mov	r0, #0\n"
+"	b	exit\n"
+"1:\n"
+"	b	abort\n"
+"	.size	main, .-main"
+);
diff --git a/gcc/testsuite/gcc.target/arm/stack-protector-2.c b/gcc/testsuite/gcc.target/arm/stack-protector-2.c
new file mode 100644
index 00000000000..266c36fdbc6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/stack-protector-2.c
@@ -0,0 +1,6 @@
+/* { dg-do run } */
+/* { dg-require-effective-target fstack_protector } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fstack-protector-all -O2 -fpic" } */
+
+#include "stack-protector-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/avx2-pr94460.c b/gcc/testsuite/gcc.target/i386/avx2-pr94460.c
new file mode 100644
index 00000000000..75b7a7bf313
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx2-pr94460.c
@@ -0,0 +1,31 @@
+/* PR target/94460 */
+/* { dg-do run { target { avx2 && int128 } } } */
+/* { dg-options "-O2 -mavx2" } */
+
+#include <x86intrin.h>
+#include "avx2-check.h"
+
+typedef __int128 v2ti __attribute__ ((__vector_size__ (32)));
+
+static inline v2ti
+foo (__v16hi b)
+{
+  return (v2ti) _mm256_hsub_epi16 ((__m256i) b, (__m256i) b);
+}
+
+static inline v2ti
+bar (__v8si b)
+{
+  return (v2ti) _mm256_hsub_epi32 ((__m256i) b, (__m256i) b);
+}
+
+static void
+avx2_test (void)
+{
+  v2ti x = foo ((__v16hi) { 1 });
+  if (x[0] != ((__int128)1 << 64 | 1) || x[1] != 0)
+    abort ();
+  x = bar ((__v8si) { 1 });
+  if (x[0] != ((__int128)1 << 64 | 1) || x[1] != 0)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr94438.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr94438.c
new file mode 100644
index 00000000000..9e56f2846ee
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr94438.c
@@ -0,0 +1,13 @@
+/* PR target/94438 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-mavx512bw" } */
+
+typedef __attribute__ ((__vector_size__ (4 * sizeof (__int128)))) __int128 V;
+void bar (V);
+
+void
+foo (V w)
+{
+  V v = 0 <= (0 >= w);
+  bar (v);
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr94500.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr94500.c
new file mode 100644
index 00000000000..7effdac5a17
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr94500.c
@@ -0,0 +1,28 @@
+/* PR target/94500 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O3 -mavx512bw -mprefer-vector-width=512" } */
+
+#define AVX512BW
+#include "avx512f-helper.h"
+
+__attribute__((noipa)) signed char
+foo (signed char *p)
+{
+  signed char r = 0;
+  int i;
+  for (i = 0; i < 256; i++)
+    if (p[i] > r) r = p[i];
+  return r;
+}
+
+signed char buf[256];
+
+static void
+TEST (void)
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    buf[i] = i - 128;
+  if (foo (buf) != 127)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-1.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-1.c
new file mode 100644
index 00000000000..6cd79b7443f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-1.c
@@ -0,0 +1,30 @@
+/* PR target/94509 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O2 -mavx512bw" } */
+
+#define AVX512BW
+#include "avx512f-helper.h"
+
+typedef unsigned short __attribute__ ((__vector_size__ (64))) V;
+
+__attribute__((noipa)) V
+foo (V x)
+{
+  return __builtin_shuffle (x, (V) { 0, 0, 0, 0, 0, 0, 0, 0,
+				     15, 15, 15, 15, 15, 15, 15, 15,
+				     0, 0, 0, 0, 0, 0, 0, 0,
+				     15, 15, 15, 15, 15, 15, 15, 15 });
+}
+
+static void
+TEST (void)
+{
+  V v = foo ((V) { 1, 2, 3, 4, 5, 6, 7, 8,
+		   9, 10, 11, 12, 13, 14, 15, 16,
+		   17, 18, 19, 20, 21, 22, 23, 24,
+		   25, 26, 27, 28, 29, 30, 31, 32 });
+  unsigned int i;
+  for (i = 0; i < sizeof (v) / sizeof (v[0]); i++)
+    if (v[i] != ((i & 8) ? 16 : 1))
+      abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-2.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-2.c
new file mode 100644
index 00000000000..089e3f211b9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr94509-2.c
@@ -0,0 +1,38 @@
+/* PR target/94509 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O2 -mavx512bw" } */
+
+#define AVX512BW
+#include "avx512f-helper.h"
+
+typedef unsigned char __attribute__ ((__vector_size__ (64))) V;
+
+__attribute__((noipa)) V
+foo (V x)
+{
+  return __builtin_shuffle (x, (V) { 0, 1, 0, 1, 0, 1, 0, 1,
+				     0, 1, 0, 1, 0, 1, 0, 1,
+				     30, 31, 30, 31, 30, 31, 30, 31,
+				     30, 31, 30, 31, 30, 31, 30, 31,
+				     0, 1, 0, 1, 0, 1, 0, 1,
+				     0, 1, 0, 1, 0, 1, 0, 1,
+				     30, 31, 30, 31, 30, 31, 30, 31,
+				     30, 31, 30, 31, 30, 31, 30, 31 });
+}
+
+static void
+TEST (void)
+{
+  V v = foo ((V) { 1, 2, 3, 4, 5, 6, 7, 8,
+		   9, 10, 11, 12, 13, 14, 15, 16,
+		   17, 18, 19, 20, 21, 22, 23, 24,
+		   25, 26, 27, 28, 29, 30, 31, 32,
+		   33, 34, 35, 36, 37, 38, 39, 40,
+		   41, 42, 43, 44, 45, 46, 47, 48,
+		   49, 50, 51, 52, 53, 54, 55, 56,
+		   57, 58, 59, 60, 61, 62, 63, 64 });
+  unsigned int i;
+  for (i = 0; i < sizeof (v) / sizeof (v[0]); i++)
+    if (v[i] != ((i & 16) ? 31 : 1) + (i & 1))
+      abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr97028.c b/gcc/testsuite/gcc.target/i386/avx512f-pr97028.c
new file mode 100644
index 00000000000..2719108a411
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr97028.c
@@ -0,0 +1,18 @@
+/* PR target/97028 */
+/* { dg-do assemble { target avx512f } } */
+/* { dg-require-effective-target masm_intel } */
+/* { dg-options "-O2 -mavx512f -masm=intel" } */
+
+#include <x86intrin.h>
+
+__m512
+foo (__m512 x, float *y)
+{
+  return _mm512_mul_ps (x, _mm512_set1_ps (*y));
+}
+
+__m512
+bar (__m512 x, float *y)
+{
+  return _mm512_div_ps (x, _mm512_set1_ps (*y));
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcmppd-3.c b/gcc/testsuite/gcc.target/i386/avx512f-vcmppd-3.c
new file mode 100644
index 00000000000..3d36eca78fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcmppd-3.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -mavx512f" } */
+
+#include "avx512f-vcmppd-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcmpps-3.c b/gcc/testsuite/gcc.target/i386/avx512f-vcmpps-3.c
new file mode 100644
index 00000000000..af797aad2de
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcmpps-3.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -mavx512f" } */
+
+#include "avx512f-vcmpps-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr93069.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr93069.c
new file mode 100644
index 00000000000..b38b5ad32bb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr93069.c
@@ -0,0 +1,12 @@
+/* PR target/93069 */
+/* { dg-do assemble { target vect_simd_clones } } */
+/* { dg-options "-O2 -fopenmp-simd -mtune=skylake-avx512" } */
+/* { dg-additional-options "-mavx512vl" { target avx512vl } } */
+/* { dg-additional-options "-mavx512dq" { target avx512dq } } */
+
+#pragma omp declare simd
+int
+foo (int x, int y)
+{
+  return x == 0 ? x : y;
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512vlbw-pr94438.c b/gcc/testsuite/gcc.target/i386/avx512vlbw-pr94438.c
new file mode 100644
index 00000000000..a0c52e426c8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512vlbw-pr94438.c
@@ -0,0 +1,13 @@
+/* PR target/94438 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-mavx512bw -mavx512vl" } */
+
+typedef __attribute__ ((__vector_size__ (sizeof (__int128)))) __int128 V;
+void bar (V);
+
+void
+foo (V w)
+{
+  V v = 0 <= (0 >= w);
+  bar (v);
+}
diff --git a/gcc/testsuite/gcc.target/i386/movdir64b.c b/gcc/testsuite/gcc.target/i386/movdir64b.c
new file mode 100644
index 00000000000..01451a8eb9b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movdir64b.c
@@ -0,0 +1,29 @@
+/* { dg-do run { target movdir } } */
+/* { dg-options "-mmovdir64b -O2" } */
+
+#include <x86intrin.h>
+#include <cpuid.h>
+#include <string.h>
+
+unsigned long long int src[8] = {1, 2, 3, 4, 5, 6, 7, 8};
+unsigned long long int dest[8] __attribute__ ((aligned (64)))
+  = {-1, -1, -1, -1, -1, -1, -1, -1};
+
+int
+main ()
+{
+  unsigned int eax, ebx, ecx, edx;
+
+  if (!__get_cpuid_count (7, 0, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  if ((ecx & bit_MOVDIR64B) == 0)
+    return 0;
+
+  _movdir64b (dest, src);
+
+  if (memcmp (dest, src, sizeof (dest)) != 0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/movdiri32.c b/gcc/testsuite/gcc.target/i386/movdiri32.c
new file mode 100644
index 00000000000..04a412f9bf3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movdiri32.c
@@ -0,0 +1,26 @@
+/* { dg-do run { target movdir } } */
+/* { dg-options "-mmovdiri -O2" } */
+
+#include <x86intrin.h>
+#include <cpuid.h>
+
+unsigned int dest = -1;
+
+int
+main ()
+{
+  unsigned int eax, ebx, ecx, edx;
+
+  if (!__get_cpuid_count (7, 0, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  if ((ecx & bit_MOVDIRI) == 0)
+    return 0;
+
+  _directstoreu_u32 (&dest, 0xbadbeef);
+
+  if (dest != 0xbadbeef)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/movdiri64.c b/gcc/testsuite/gcc.target/i386/movdiri64.c
new file mode 100644
index 00000000000..e0cb6081496
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movdiri64.c
@@ -0,0 +1,26 @@
+/* { dg-do run { target { movdir && { ! ia32 } } } } */
+/* { dg-options "-mmovdiri -O2" } */
+
+#include <x86intrin.h>
+#include <cpuid.h>
+
+unsigned long long int dest = -1LL;
+
+int
+main ()
+{
+  unsigned int eax, ebx, ecx, edx;
+
+  if (!__get_cpuid_count (7, 0, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  if ((ecx & bit_MOVDIRI) == 0)
+    return 0;
+
+  _directstoreu_u64 (&dest, 0x12345678badbeef);
+
+  if (dest != 0x12345678badbeef)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr93654.c b/gcc/testsuite/gcc.target/i386/pr93654.c
new file mode 100644
index 00000000000..ec5bdce86a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr93654.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcf-protection -mfunction-return=thunk-extern -mindirect-branch=thunk-extern" } */
+
+int
+bar (void (*foo) (void))
+{
+  foo (); 
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94103.c b/gcc/testsuite/gcc.target/i386/pr94103.c
new file mode 100644
index 00000000000..91b5fc64b5e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94103.c
@@ -0,0 +1,17 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O3" } */
+
+int main()
+{
+  long double x;
+  unsigned long u[2] = {0xEEEEEEEEEEEEEEEEUL, 0xEEEEEEEEEEEEEEEEUL};
+  __builtin_memcpy(&x, &u, sizeof x);
+  __builtin_memcpy(&u, &x, sizeof u);
+  ++*(unsigned char *)&x;
+  (void)-x;
+  __builtin_memcpy(&u, &x, sizeof u);
+  if (u[1] != 0xEEEEEEEEEEEEEEEEUL
+      || u[0] != 0xEEEEEEEEEEEEEEEFUL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94283.c b/gcc/testsuite/gcc.target/i386/pr94283.c
new file mode 100644
index 00000000000..4982f7d01d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94283.c
@@ -0,0 +1,5 @@
+/* PR debug/94283 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fcompare-debug -mavx2" } */
+
+#include "../../gcc.dg/fold-bopcond-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr94417-1.c b/gcc/testsuite/gcc.target/i386/pr94417-1.c
new file mode 100644
index 00000000000..5bbe057fa8f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94417-1.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O2 -fcf-protection -mcmodel=large" } */
+/* { dg-final { scan-assembler-times {\mendbr} 2 } } */
+
+extern void ext (void);
+
+__attribute((noclone, noinline))
+static
+void
+foo (void)
+{
+  ext ();
+}
+
+void
+bar (void)
+{
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94417-2.c b/gcc/testsuite/gcc.target/i386/pr94417-2.c
new file mode 100644
index 00000000000..9e9c277e07f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94417-2.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-O2 -fpic -mcmodel=large -fcf-protection" } */
+/* { dg-final { scan-assembler-times {\mendbr} 4 } } */
+
+extern void ext (void);
+
+__attribute((noclone, noinline))
+static
+void
+foo (void)
+{
+  ext ();
+}
+
+void
+bar (void)
+{
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94417-3.c b/gcc/testsuite/gcc.target/i386/pr94417-3.c
new file mode 100644
index 00000000000..07c451796c2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94417-3.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcf-protection -mforce-indirect-call" } */
+/* { dg-final { scan-assembler-times {\mendbr} 2 } } */
+
+extern void ext (void);
+
+__attribute((noclone, noinline))
+static
+void
+foo (void)
+{
+  ext ();
+}
+
+void
+bar (void)
+{
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94494.c b/gcc/testsuite/gcc.target/i386/pr94494.c
new file mode 100644
index 00000000000..ba0171e59f8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94494.c
@@ -0,0 +1,23 @@
+/* PR target/94494 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -msse -mno-sse2" } */
+
+void
+foo (float *item, float *f, float *out,
+     int threshold, int wi, int lo, int hi, int value)
+{
+  for (int i = 0; i < wi; i++) {
+    if (item[i] > 0) {
+      int found = 0;
+
+      for (int k = lo; k < hi; k++)
+        if (f[k] > 0)
+          found = 1;
+
+      if (found > 0)
+        out[i] = threshold;
+      else if (out[i] > value)
+        out[i] -= 1;
+    }
+  }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr94603.c b/gcc/testsuite/gcc.target/i386/pr94603.c
new file mode 100644
index 00000000000..34a1e069eac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr94603.c
@@ -0,0 +1,11 @@
+/* PR target/94603 */
+/* { dg-do compile } */
+/* { dg-options "-Wno-implicit-function-declaration -msse -mno-sse2" } */
+
+typedef long long __attribute__ ((__vector_size__ (16))) V;
+
+V
+foo (V v)
+{
+  return __builtin_ia32_movq128 (v);  /* { dg-error "" } */
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr96793-1.c b/gcc/testsuite/gcc.target/i386/pr96793-1.c
new file mode 100644
index 00000000000..b205d39f63c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr96793-1.c
@@ -0,0 +1,28 @@
+/* PR target/96793 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-require-effective-target fenv } */
+/* { dg-options "-O2 -frounding-math -msse2 -mno-sse4 -mfpmath=sse" } */
+
+#include <fenv.h>
+
+double
+__attribute__((noinline))
+test (double value)
+{
+  return __builtin_trunc (value);
+}
+
+int
+main ()
+{
+  double result;
+
+  fesetround (FE_DOWNWARD);
+
+  result = test (0.25);
+
+  if (__builtin_signbit (result) != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr96793-2.c b/gcc/testsuite/gcc.target/i386/pr96793-2.c
new file mode 100644
index 00000000000..14efaab9faa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr96793-2.c
@@ -0,0 +1,28 @@
+/* PR target/96793 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-require-effective-target fenv } */
+/* { dg-options "-O2 -frounding-math -msse2 -mno-sse4 -mfpmath=sse" } */
+
+#include <fenv.h>
+
+double
+__attribute__((noinline))
+test (double value)
+{
+  return __builtin_rint (value);
+}
+
+int
+main ()
+{
+  double result;
+
+  fesetround (FE_DOWNWARD);
+
+  result = test (0.25);
+
+  if (__builtin_signbit (result) != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr96793.c b/gcc/testsuite/gcc.target/i386/pr96793.c
new file mode 100644
index 00000000000..4a96478e31e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr96793.c
@@ -0,0 +1,28 @@
+/* PR target/96793 */
+/* { dg-do run { target sse2_runtime } } */
+/* { dg-require-effective-target fenv } */
+/* { dg-options "-O2 -frounding-math -msse2 -mno-sse4 -mfpmath=sse" } */
+
+#include <fenv.h>
+
+double
+__attribute__((noinline))
+test (double value)
+{
+  return __builtin_floor (value);
+}
+
+int
+main ()
+{
+  double result;
+
+  fesetround (FE_DOWNWARD);
+
+  result = test (0.25);
+
+  if (__builtin_signbit (result) != 0)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr97032.c b/gcc/testsuite/gcc.target/i386/pr97032.c
new file mode 100644
index 00000000000..7cbbe9bc22a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr97032.c
@@ -0,0 +1,23 @@
+/* { dg-do compile { target { ia32 && fstack_protector } } } */
+/* { dg-options "-O2 -mincoming-stack-boundary=2 -fstack-protector-all" } */
+
+#include <stdarg.h>
+
+extern int *__errno_location (void);
+
+long
+sys_socketcall (int op, ...)
+{
+  long int res;
+  va_list ap;
+  va_start (ap, op);
+  asm volatile ("push %%ebx; movl %2, %%ebx; int $0x80; pop %%ebx"
+  /* { dg-warning "listing the stack pointer register" "" { target *-*-* } .-1 } */
+		: "=a" (res) : "0" (102), "ri" (16), "c" (ap) : "memory", "esp");
+  if (__builtin_expect (res > 4294963200UL, 0))
+    *__errno_location () = -res;
+  va_end (ap);
+  return res;
+}
+
+/* { dg-final { scan-assembler "call\[ \t\]*_?__errno_location" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr98086.c b/gcc/testsuite/gcc.target/i386/pr98086.c
new file mode 100644
index 00000000000..254a3b9bef6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr98086.c
@@ -0,0 +1,17 @@
+/* PR target/98086 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#ifdef __x86_64__
+typedef __int128 T;
+#else
+typedef long long T;
+#endif
+
+T x;
+
+void
+foo (void)
+{
+  __asm ("" : "=@ccc" (x));
+}
diff --git a/gcc/testsuite/gcc.target/i386/xsave-avx-1.c b/gcc/testsuite/gcc.target/i386/xsave-avx-1.c
new file mode 100644
index 00000000000..ca87a791446
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/xsave-avx-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mxsave -mno-avx" } */
+
+#include <immintrin.h>
+
+extern int m;
+
+void
+avx_imply_save (void)
+{
+  _xgetbv (m);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-1-p9-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-1-p9-runnable.c
index 0e4ab48f555..0e6eeff4b7e 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-1-p9-runnable.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-1-p9-runnable.c
@@ -1,25 +1,50 @@
-/* { dg-do run { target { powerpc*-*-linux* && { lp64 && p9vector_hw } } } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-do run { target { powerpc*-*-linux* && p9vector_hw } } } */
+/* { dg-require-effective-target p9vector_hw } */
 /* { dg-options "-O2 -mdejagnu-cpu=power9" } */
 
 #include <altivec.h>
+#include <stdio.h>
 
 void abort (void);
 
 int main() {
   int i;
   vector float vfa, vfb;
-  vector unsigned short vur, vuexpt;
+  vector unsigned short vresult, vexpected;
 
-  vfa = (vector float){3.4, 5.0, 20.0, 50.9 };
-  vfb = (vector float){10.0, 40.0, 70.0, 100.0 };
-  vuexpt = (vector unsigned short){ 3, 5, 20, 50,
-                                    10, 40, 70, 100};
+  vfa = (vector float){0.4, 1.6, 20.0, 99.9 };
+  vfb = (vector float){10.0, -2.0, 70.0, 999.0 };
 
-  vur = vec_pack_to_short_fp32 (vfa, vfb);
+  /* Expected results.  */
+  vexpected = (vector unsigned short) { 0x3666, 0x3e66, 0x4d00, 0x563e,
+					0x4900, 0xc000, 0x5460, 0x63ce};
+
+/*
+     vresult = vec_pack_to_short_fp32 (vfa, vfb);
+  This built-in converts a pair of vector floats into a single vector of
+  packed half-precision (F16) values.  The result type is a vector of
+  signed shorts.
+  The expected codegen for this builtin is
+    xvcvsphp t, vfa
+    xvcvsphp u, vfb
+    if (little endian)
+      vpkuwum vresult, t, u
+    else
+      vpkuwum vresult, u, t
+*/
+
+  vresult = vec_pack_to_short_fp32 (vfa, vfb);
+
+#ifdef DEBUG
+  for(i = 0; i< 4; i++) { printf("i=[%d] %f  \n",i,vfa[i]); }
+  for(i = 0; i< 4; i++) { printf("i=[%d] %f  \n",i+4,vfb[i]); }
+  for(i = 0; i< 8; i++) { printf("i=[%d] %d  \n",i,vresult[i]); }
+#endif
 
   for(i = 0; i< 8; i++) {
-    if (vur[i] != vuexpt[i])
+    if (vresult[i] != vexpected[i]) {
+	printf("i=[%d] 0x%x != 0x%x \n",i,vresult[i],vexpected[i]);
       abort();
+    }
   }
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-8-p9-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-8-p9-runnable.c
index b2f7dc855e8..19457eebfc4 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-8-p9-runnable.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-8-p9-runnable.c
@@ -103,6 +103,31 @@ int main() {
      The element index in natural element order is returned for the
      first match or the number of elements if there is no match.  */
   /* char */
+  char_src1 = (vector signed char) { 0x40, 0, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40 };
+				    
+  char_src2 = (vector signed char) {0, 0, 0, 0, 0, 0, 0, 0,
+				    0, 0, 0, 0, 0, 0, 0, 0};
+  expected_result = 1;
+
+  result = vec_first_match_index (char_src1, char_src2);
+
+#ifdef DEBUG2
+  print_signed_char("src1", char_src1);
+  print_signed_char("src2", char_src2);
+  printf(" vec_first_match_index = %d\n\n", result);
+#endif
+
+  if (result != expected_result)
+#ifdef DEBUG
+    printf("Error: char first match result (%d) does not match expected result (%d)\n",
+	   result, expected_result);
+#else
+    abort();
+#endif
+
   char_src1 = (vector signed char) {-1, 2, 3, 4, -5, 6, 7, 8,
 				    9, 10, 11, 12, 13, 14, 15, 16};
   char_src2 = (vector signed char) {-1, 2, 3, 20, -5, 6, 7, 8,
@@ -367,6 +392,50 @@ int main() {
      The element index in BE order is returned for the first mismatch
      or the number of elements if there is no match.   */
   /* char */
+  char_src1 = (vector signed char) {1, 2, 0, 4, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  char_src2 = (vector signed char) {1, 2, 0, 20, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  expected_result = 3;
+
+  result = vec_first_mismatch_index (char_src1, char_src2);
+
+#ifdef DEBUG2
+  print_signed_char("src1", char_src1);
+  print_signed_char("src2", char_src2);
+  printf("vec_first_mismatch_index = %d\n\n", result);
+#endif
+
+  if (result != expected_result)
+#ifdef DEBUG
+    printf("Error: char first mismatch result (%d) does not match expected result (%d)\n",
+	   result, expected_result);
+#else
+    abort();
+#endif
+
+  char_src1 = (vector signed char) {0, 2, 3, 4, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  char_src2 = (vector signed char) {0, 2, 3, 20, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  expected_result = 3;
+
+  result = vec_first_mismatch_index (char_src1, char_src2);
+
+#ifdef DEBUG2
+  print_signed_char("src1", char_src1);
+  print_signed_char("src2", char_src2);
+  printf("vec_first_mismatch_index = %d\n\n", result);
+#endif
+
+  if (result != expected_result)
+#ifdef DEBUG
+    printf("Error: char first mismatch result (%d) does not match expected result (%d)\n",
+	   result, expected_result);
+#else
+    abort();
+#endif
+
   char_src1 = (vector signed char) {-1, 2, 3, 4, -5, 6, 7, 8,
 				    9, 10, 11, 12, 13, 14, 15, 16};
   char_src2 = (vector signed char) {-1, 2, 3, 20, -5, 6, 7, 8,
@@ -673,6 +742,33 @@ int main() {
      The element index in BE order is returned for the first match
      or the number of elements if there is no match.  */
   /* char */
+  char_src1 = (vector signed char) { 0x40, 0, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40 };
+				    
+  char_src2 = (vector signed char) { 0x41, 0, 0x43, 0x44,
+				     0x45, 0x46, 0x47, 0x40,
+				     0x40, 0x40, 0x40, 0x40,
+				     0x40, 0x40, 0x40, 0x40 };
+  expected_result = 1;
+
+  result = vec_first_match_or_eos_index (char_src1, char_src2);
+
+#ifdef DEBUG2
+  print_signed_char("src1", char_src1);
+  print_signed_char("src2", char_src2);
+  printf("vec_first_match_or_eos_index = %d\n\n", result);
+#endif
+
+  if (result != expected_result)
+#ifdef DEBUG
+    printf("Error: char first match result (%d) does not match expected result (%d)\n",
+	   result, expected_result);
+#else
+    abort();
+#endif
+
   char_src1 = (vector signed char) {-1, 2, 3, 4, -5, 6, 7, 8,
 				    9, 10, 11, 12, 13, 14, 15, 16};
   char_src2 = (vector signed char) {-1, 2, 3, 20, -5, 6, 7, 8,
@@ -1065,6 +1161,28 @@ int main() {
      The element index in BE order is returned for the first mismatch
      or the number of elements if there is no match.   */
   /* char */
+  char_src1 = (vector signed char) {1, 2, 0, 4, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  char_src2 = (vector signed char) {1, 2, 0, 20, -5, 6, 7, 8,
+				    9, 10, 11, 12, 13, 14, 15, 16};
+  expected_result = 2;
+
+  result = vec_first_mismatch_or_eos_index (char_src1, char_src2);
+
+#ifdef DEBUG2
+  print_signed_char("src1", char_src1);
+  print_signed_char("src2", char_src2);
+  printf("vec_first_mismatch_or_eos_index = %d\n\n", result);
+#endif
+
+  if (result != expected_result)
+#ifdef DEBUG
+    printf("Error: char first mismatch or EOS result (%d) does not match expected result (%d)\n",
+	   result, expected_result);
+#else
+    abort();
+#endif
+
   char_src1 = (vector signed char) {-1, 2, 3, 4, -5, 6, 7, 8,
 				    9, 10, 11, 12, 13, 14, 15, 16};
   char_src2 = (vector signed char) {-1, 2, 3, 20, -5, 6, 7, 8,
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-msum-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-msum-runnable.c
new file mode 100644
index 00000000000..0fa5c319b6d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-msum-runnable.c
@@ -0,0 +1,74 @@
+/* { dg-do run { target { p9vector_hw } } } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2" } */
+
+#include <altivec.h>
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+void abort (void);
+
+int
+main()
+{
+  vector __uint128_t arg_uint128, result_uint128, expected_uint128;
+  vector __int128_t arg_int128, result_int128, expected_int128;
+
+  arg_uint128[0] = 0x1627384950617243;
+  arg_uint128[0] = arg_uint128[0] << 64;
+  arg_uint128[0] |= 0x9405182930415263;
+  expected_uint128[0] = 0x1627384950617243;
+  expected_uint128[0] = expected_uint128[0] << 64;
+  expected_uint128[0] |= 0xb6b07e42a570e5fe;
+  vector unsigned long long arg_vull2 = {0x12345678,0x44445555};
+  vector unsigned long long arg_vull3 = {0x6789abcd,0x66667777};
+  result_uint128 = vec_msum (arg_vull2, arg_vull3, arg_uint128);
+
+  if (result_uint128[0] != expected_uint128[0])
+    {
+#ifdef DEBUG
+       printf("result_uint128[0] doesn't match expected_u128[0]\n");
+       printf("arg_vull2  %llx %llx \n",  arg_vull2[0], arg_vull2[1]);
+       printf("arg_vull3  %llx %llx \n",  arg_vull3[0], arg_vull3[1]);
+       printf("arg_uint128[0] =  %llx ", arg_uint128[0] >> 64);
+       printf(" %llx\n",	 arg_uint128[0] & 0xFFFFFFFFFFFFFFFF);
+
+       printf("result_uint128[0] =  %llx ", result_uint128[0] >> 64);
+       printf(" %llx\n", result_uint128[0] & 0xFFFFFFFFFFFFFFFF);
+
+       printf("expected_uint128[0] =  %llx ", expected_uint128[0] >> 64);
+       printf(" %llx\n", expected_uint128[0] & 0xFFFFFFFFFFFFFFFF);
+#else
+       abort();
+#endif
+    }
+
+  arg_int128[0] = 0x1627384950617283;
+  arg_int128[0] = arg_int128[0] << 64;
+  arg_int128[0] |= 0x9405182930415263;
+  expected_int128[0] = 0x1627384950617283;
+  expected_int128[0] = expected_int128[0] << 64;
+  expected_int128[0] |= 0xd99f35969c11cbfa;
+  vector signed long long arg_vll2 = { 0x567890ab, 0x1233456 };
+  vector signed long long arg_vll3 = { 0xcdef0123, 0x9873451 };
+  result_int128 = vec_msum (arg_vll2, arg_vll3, arg_int128);
+
+  if (result_int128[0] != expected_int128[0])
+    {
+#ifdef DEBUG
+       printf("result_int128[0] doesn't match expected128[0]\n");
+       printf("arg_int128[0] =  %llx ", arg_int128[0] >> 64);
+       printf(" %llx\n",	 arg_int128[0] & 0xFFFFFFFFFFFFFFFF);
+
+       printf("result_int128[0] =  %llx ", result_int128[0] >> 64);
+       printf(" %llx\n", result_int128[0] & 0xFFFFFFFFFFFFFFFF);
+
+       printf("expected_int128[0] =  %llx ", expected_int128[0] >> 64);
+       printf(" %llx\n", expected_int128[0] & 0xFFFFFFFFFFFFFFFF);
+#else
+       abort();
+#endif
+    }
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-longlong.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-longlong.c
index 76bece11a99..ad760f55fac 100644
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-longlong.c
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ands-longlong.c
@@ -3,7 +3,9 @@
 
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2" } */
+/* Disable ipa-icf to avoid compiler to generate tail call for some function,
+   we can not get the expected assembly due the omitted function body.  */
+/* { dg-options "-mvsx -O2 -fno-ipa-icf" } */
 
 #include <altivec.h>
 
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-longlong.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-longlong.c
index 10c69d3d87b..9aa3738d77a 100644
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-longlong.c
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-logical-ors-longlong.c
@@ -3,7 +3,9 @@
 
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mpower8-vector -O2" } */
+/* Disable ipa-icf to avoid compiler to generate tail call for some function,
+   we can not get the expected assembly due the omitted function body.  */
+/* { dg-options "-mpower8-vector -O2 -fno-ipa-icf" } */
 
 #include <altivec.h>
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-minmax-3.c b/gcc/testsuite/gcc.target/powerpc/p9-minmax-3.c
new file mode 100644
index 00000000000..141603e05b4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/p9-minmax-3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -mpower9-minmax" } */
+/* { dg-final { scan-assembler-not "xsmaxcdp"   } } */
+/* { dg-final { scan-assembler-not "xsmincdp"   } } */
+
+double
+dbl_max1 (double a, double b)
+{
+  return a < b ? b : a;
+}
+
+double
+dbl_min1 (double a, double b)
+{
+  return a > b ? b : a;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr64505.c b/gcc/testsuite/gcc.target/powerpc/pr64505.c
index 8601f2d7e9f..42b961f3df5 100644
--- a/gcc/testsuite/gcc.target/powerpc/pr64505.c
+++ b/gcc/testsuite/gcc.target/powerpc/pr64505.c
@@ -1,231 +1,52 @@
-/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-do compile } */
 /* { dg-skip-if "" { powerpc*-*-aix* } } */
-/* { dg-options "-O2 -mpowerpc64" } */
+/* { dg-options "-w -O2 -mpowerpc64" } */
 
 /*
- * (below is inlined and simplified from previously included headers)
+ * (below is minimized test case)
  */
 
-struct fltcom_st {
-    short fltbuf[950];
-} fltcom_  __attribute__((common))  ;
-#define CM_PLIBOR (*(((double *)&fltcom_ + 1)))
-#define CM_QMRG (*(((double *)&fltcom_ + 2)))
+extern double pow(double x, double y);
+extern long func ();
+short global0, global1;
+static int i0, i1, i2, i3, i4, i5;
+double dbl, *array0, *array1;
 
-struct fltcom2_st {
-    short fltbuf2[56];
-} fltcom2_  __attribute__((common))  ;
-#define CM_FLPRV ((short *)&fltcom2_ + 17)
-#define CM_FLNXT ((short *)&fltcom2_ + 20)
-#define CM_FLCPN (*(((double *)&fltcom2_)))
-#define CM_FLCNT (*(((short *)&fltcom2_ + 12)))
-
-struct aidatcm_st {
-    double cm_aid, cm_ext, cm_basis;
-    short cm_aiday, cm_exday, cm_dperd, cm_aiexf, cm_aidex, cm_aiok,
-            cm_aigdo, cm_aildo, cm_prev[3], cm_next[3], cm_aid_pad[2];
-    double cm_rvgfact, cm_ai1st, cm_ai2nd;
-    int cm_aieurok;
-} aidatcm_  __attribute__((common))  ;
-#define CM_EXDAY aidatcm_.cm_exday
-#define CM_BASIS aidatcm_.cm_basis
-#define CM_PREV aidatcm_.cm_prev
-
-struct cshfcm_st {
-    short bufff[10862];
-} cshfcm_  __attribute__((common))  ;
-#define CM_FNUM (*(((short *)&cshfcm_ + 9038)))
-#define CM_FIFLX ((double *)&cshfcm_ + 1)
-#define CM_FEXTX ((double *)&cshfcm_ + 1201)
-#define CM_FSHDT ((short *)&cshfcm_ + 7230)
-
-struct calctsdb_st {
-    short calctsdbbuff[115];
-} calctsdb_  __attribute__((common))  ;
-#define CM_CTUP_GOOD_TO_GO (*(((short *)&calctsdb_ + 16)))
-#define CM_PAYMENT_FREQUENCY (*(((short *)&calctsdb_ + 61)))
-#define CM_DISCOUNTING_DAYTYP (*(((short *)&calctsdb_ + 59)))
-
-struct cf600cm_st {
-    short bufcf[14404];
-} cf600cm_  __attribute__((common)) ;
-#define CM_FLT_RFIXRATES ((double *)&cf600cm_ + 600)
-
-typedef struct { int id; int type; const char *name; } bregdb_bitinfo_t;
-
-int
-bregdb_eval_bbitcxt_bool_rv(const bregdb_bitinfo_t * const bbit,
-                            const int bbit_default,
-                            const void * const bregucxt);
-
-static const bregdb_bitinfo_t bbit_calc_dr_d33 =
-  { 160667, 5, "bbit_calc_dr_d33" };
-#define bbit_calc_dr_d33__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d33, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_sx_b24 =
-  { 158854, 5, "bbit_calc_sx_b24" };
-#define bbit_calc_sx_b24__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_sx_b24, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_dr_d36 =
-  { 161244, 5, "bbit_calc_dr_d36" };
-#define bbit_calc_dr_d36__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d36, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_dr_d37 =
-  { 161315, 5, "bbit_calc_dr_d37" };
-#define bbit_calc_dr_d37__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d37, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_dr_d47 =
-  { 163259, 5, "bbit_calc_dr_d47" };
-#define bbit_calc_dr_d47__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d47, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_dr_d46 =
-  { 163239, 5, "bbit_calc_dr_d46" };
-#define bbit_calc_dr_d46__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d46, 0, 0)
-static const bregdb_bitinfo_t bbit_calc_dr_d62 =
-  { 166603, 5, "bbit_calc_dr_d62" };
-#define bbit_calc_dr_d62__value() \
-  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d62, 0, 0)
-
-
-
-int dtyp_is_actact_(short *daytyp);
-double rnd_trunc_numb(double in, short num_digits, short rnd_or_trunc);
-void datetrn_(const short* dt, short* dt2);
-short difday_(short* daytyp_in, short* srtdti, short* enddti, short* ercode);
-
-
-double pow(double x, double y);
-
-
-/*
- * (above is inlined and simplified from previously included headers)
- */
-
-
-void calc_1566(
-  short  sCalcType,
-  short  sDayType,
-  short  sFreq,
-  short  asSettleDt[3],
-  short  asMtyDt[3],
-  short  asIssueDt[3],
-  short  asFCpnDt[3],
-  double dCpn,
-  short  *psNoPer,
-  double *pdExt,
-  double *pdAI,
-  double *pdAI2,
-  double *pdFCpn,
-  short  *psRcode)
+void
+pr64505 (short *arg0, double *arg1)
 {
-
-    short ercode = 0;
-    int isactact;
-    short days_to_next_cpn = 0;
-    const short discDaytype = CM_DISCOUNTING_DAYTYP;
-
-    if(bbit_calc_sx_b24__value())
-        isactact = (dtyp_is_actact_(&sDayType) != 0);
-    else
-        isactact = (sDayType == 1 || sDayType == 10);
-
-    short days_in_current_period = difday_(&sDayType,CM_FLPRV,CM_FLNXT,&ercode);
-    const short sfreq1 = (CM_CTUP_GOOD_TO_GO == 1 && CM_PAYMENT_FREQUENCY == 1);
-
-    for (int j = 0; j < CM_FNUM; j++) {
-
-        if(j == 0) {
-            days_to_next_cpn = difday_(&sDayType,asSettleDt,CM_FLNXT,&ercode);
-
-            if(isactact) {
-                CM_FIFLX[j] = CM_FLCPN / sFreq;
-                CM_FEXTX[j] = (double)days_to_next_cpn / (double)days_in_current_period;
-            }
-            else {
-                CM_FIFLX[j] = CM_FLCPN * days_in_current_period;
-                CM_FEXTX[j] = (double)days_to_next_cpn / (double)(1/sfreq1);
-            }
-
-            if(CM_FNUM == 1) {
-                CM_FEXTX[j] = (double)days_to_next_cpn / ((double)1/sfreq1);
-            }
-        }
-        else {
-
-            short days_from_settle, days_in_period;
-
-            if(bbit_calc_dr_d46__value()){
-             days_from_settle = difday_(&sDayType,asSettleDt,
-                                             &CM_FSHDT[j*3],&ercode);
-             days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],
-                                            &CM_FSHDT[j*3],&ercode);
-            }
-
-            double cpn_rate = CM_PLIBOR;
-
-            if(bbit_calc_dr_d62__value()) {
-              if(j < CM_FLCNT && CM_FLT_RFIXRATES[j] != 0) cpn_rate = CM_FLT_RFIXRATES[j];
-            }
-            else {
-              if(j < CM_FLCNT ) cpn_rate = CM_FLT_RFIXRATES[j];
-            }
-
-            if(bbit_calc_dr_d37__value()&& j >= CM_FLCNT && sCalcType == 1570) {
-                cpn_rate = CM_PLIBOR + CM_QMRG;
-
-                if(bbit_calc_dr_d36__value()){
-                double projected_rate = pow((1 + CM_PLIBOR/100.0),
-                                            (days_in_period)) - 1;
-
-                projected_rate = projected_rate + CM_QMRG/100.0 * days_in_period;
-                cpn_rate = 100 * projected_rate * (1/days_in_period);
-                }
-            }
-
-
-            if(isactact) {
-                CM_FIFLX[j] = cpn_rate / sFreq;
-                CM_FEXTX[j] = CM_FEXTX[j-1] + 1;
-
-                if(bbit_calc_dr_d46__value() && discDaytype != 0) {
-                    CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);
-                }
-            }
-            else {
-                if(!bbit_calc_dr_d46__value()){
-                days_from_settle = difday_(&sDayType,asSettleDt,
-                                               &CM_FSHDT[j*3],&ercode);
-                days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],
-                                               &CM_FSHDT[j*3],&ercode);
-
-                }
-
-                CM_FIFLX[j] = cpn_rate * days_in_period;
-                CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);
-            }
-
-        }
-
-        if(bbit_calc_dr_d33__value() && CM_CTUP_GOOD_TO_GO != 0) {
-            CM_FIFLX[j] = rnd_trunc_numb (CM_FIFLX[j], 0, 0);
-        }
-
+  int error = 0;
+  short num = func (&global1 + 15, &error);
+  for (int j = 0; j < array0[0]; j++)
+    {
+      if (j == 0)
+	{
+	  func (arg0, &global1 + 20, &error);
+	  array0[0] = num;
+	}
+      else
+	{
+	  double cr = (&dbl)[1];
+	  if (func (&i4))
+	    func (0, &(&array0)[j]);
+	  if (func (&i5))
+	    {
+	      if ((&global1)[12])
+		cr = array1[j];
+	    }
+	  if (func (&i2)
+	      && (&global1)[12])
+	    {
+	      if (func (&i1))
+	        pow ((&dbl)[1], 2);
+	    }
+	    array0[j] = cr;
+	}
+      if (func (&i0) && global0)
+        func (((short *) array0 + 1)[j]);
     }
-
-
-    short accrued_days = difday_(&sDayType,CM_FLPRV,asSettleDt,&ercode);
-
-    if(!bbit_calc_dr_d47__value()) {
-    if(isactact) {
-        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)days_in_current_period);
-    }
-    else{
-        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)1/sFreq);
-    }
-    }
-
-    CM_EXDAY = days_to_next_cpn;
-    CM_BASIS = days_in_current_period;
-    datetrn_(CM_FLPRV,CM_PREV);
+  short ad = func (&global1 + 15, 0);
+  if (func (&i3) && func ())
+    *arg1 = *((double *) &global1) * ad;
+  func (&global1 + 15);
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/pr71763.c b/gcc/testsuite/gcc.target/powerpc/pr71763.c
index b36ddfa26b0..b8888394393 100644
--- a/gcc/testsuite/gcc.target/powerpc/pr71763.c
+++ b/gcc/testsuite/gcc.target/powerpc/pr71763.c
@@ -1,5 +1,6 @@
 // PR target/71763
 // { dg-do compile }
+// { dg-require-effective-target powerpc_vsx_ok }
 // { dg-options "-O1 -mvsx" }
 
 int a, b;
diff --git a/gcc/testsuite/gcc.target/powerpc/pr90763.c b/gcc/testsuite/gcc.target/powerpc/pr90763.c
new file mode 100644
index 00000000000..55f1d461e82
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr90763.c
@@ -0,0 +1,88 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* PR90763: PowerPC vec_xl_len should take const.
+*/
+
+#include <altivec.h>
+
+vector unsigned char vec_load_uc(unsigned char *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned char vec_load_const_uc(const unsigned char *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed char vec_load_sc(signed char *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed char vec_load_const_sc(const signed char *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector signed short vec_load_ss(signed short *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed short vec_load_const_ss(const signed short *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned short vec_load_us(unsigned short *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned short vec_load_const_us(const unsigned short *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector signed int vec_load_si(signed int *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed int vec_load_const_si(const signed int *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned int vec_load_ui(unsigned int *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned int vec_load_const_ui(const unsigned int *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector signed long long vec_load_sll(signed long long *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed long long vec_load_const_sll(const signed long long *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned long long vec_load_ull(unsigned long long *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned long long vec_load_const_ull(const unsigned long long *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector signed __int128 vec_load_si128(signed __int128 *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector signed __int128 vec_load_const_si128(const signed __int128 *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned __int128 vec_load_ui128(unsigned __int128 *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector unsigned __int128 vec_load_const_ui128(const unsigned __int128 *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector float vec_load_f(float *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector float vec_load_const_f(const float *p, int num) {
+    return vec_xl_len(p, num);
+}
+
+vector double vec_load_d(double *p, int num) {
+    return vec_xl_len(p, num);
+}
+vector double vec_load_const_d(const double *p, int num) {
+    return vec_xl_len(p, num);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92923-1.c b/gcc/testsuite/gcc.target/powerpc/pr92923-1.c
new file mode 100644
index 00000000000..f901244fcf7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92923-1.c
@@ -0,0 +1,453 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -O2 -fdump-tree-gimple" } */
+
+/* Verify that overloaded built-ins for "and", "andc", "nor", "or" and "xor"
+   do not produce VIEW_CONVERT_EXPR operations on their operands.  Like so:
+
+  _1 = VIEW_CONVERT_EXPR<__vector signed int>(x);
+  _2 = VIEW_CONVERT_EXPR<__vector signed int>(y);
+  _3 = __builtin_altivec_vand (_1, _2);
+  D.3245 = VIEW_CONVERT_EXPR<bcvec_t>(_3);
+*/
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) char bcvec_t;
+typedef __attribute__((altivec(vector__))) signed char scvec_t;
+typedef __attribute__((altivec(vector__))) unsigned char ucvec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) short bsvec_t;
+typedef __attribute__((altivec(vector__))) signed short ssvec_t;
+typedef __attribute__((altivec(vector__))) unsigned short usvec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) int bivec_t;
+typedef __attribute__((altivec(vector__))) signed int sivec_t;
+typedef __attribute__((altivec(vector__))) unsigned int uivec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) long long bllvec_t;
+typedef __attribute__((altivec(vector__))) signed long long sllvec_t;
+typedef __attribute__((altivec(vector__))) unsigned long long ullvec_t;
+
+typedef __attribute__((altivec(vector__))) double dvec_t;
+typedef __attribute__((altivec(vector__))) float fvec_t;
+
+bcvec_t
+and_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+scvec_t
+and_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+ucvec_t
+and_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+bsvec_t
+and_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+ssvec_t
+and_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+usvec_t
+and_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+bivec_t
+and_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+sivec_t
+and_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+uivec_t
+and_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+bllvec_t
+and_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+sllvec_t
+and_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+ullvec_t
+and_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+dvec_t
+and_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+fvec_t
+and_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_and (x, y);
+}
+
+bcvec_t
+andc_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+scvec_t
+andc_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+ucvec_t
+andc_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+bsvec_t
+andc_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+ssvec_t
+andc_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+usvec_t
+andc_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+bivec_t
+andc_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+sivec_t
+andc_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+uivec_t
+andc_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+bllvec_t
+andc_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+sllvec_t
+andc_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+ullvec_t
+andc_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+dvec_t
+andc_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+fvec_t
+andc_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_andc (x, y);
+}
+
+bcvec_t
+nor_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+scvec_t
+nor_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+ucvec_t
+nor_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+bsvec_t
+nor_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+ssvec_t
+nor_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+usvec_t
+nor_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+bivec_t
+nor_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+sivec_t
+nor_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+uivec_t
+nor_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+bllvec_t
+nor_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+sllvec_t
+nor_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+ullvec_t
+nor_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+dvec_t
+nor_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+fvec_t
+nor_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_nor (x, y);
+}
+
+bcvec_t
+or_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+scvec_t
+or_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+ucvec_t
+or_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+bsvec_t
+or_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+ssvec_t
+or_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+usvec_t
+or_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+bivec_t
+or_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+sivec_t
+or_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+uivec_t
+or_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+bllvec_t
+or_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+sllvec_t
+or_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+ullvec_t
+or_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+dvec_t
+or_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+fvec_t
+or_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_or (x, y);
+}
+
+bcvec_t
+xor_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+scvec_t
+xor_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+ucvec_t
+xor_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+bsvec_t
+xor_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+ssvec_t
+xor_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+usvec_t
+xor_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+bivec_t
+xor_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+sivec_t
+xor_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+uivec_t
+xor_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+bllvec_t
+xor_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+sllvec_t
+xor_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+ullvec_t
+xor_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+dvec_t
+xor_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+fvec_t
+xor_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_xor (x, y);
+}
+
+/* { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR" "gimple" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92923-2.c b/gcc/testsuite/gcc.target/powerpc/pr92923-2.c
new file mode 100644
index 00000000000..ebecb69915f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr92923-2.c
@@ -0,0 +1,285 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mdejagnu-cpu=power8 -O2 -fdump-tree-gimple" } */
+
+/* Verify that overloaded built-ins for "eqv", "nand" and "orc" do not
+   produce VIEW_CONVERT_EXPR operations on their operands.  Like so:
+
+  _1 = VIEW_CONVERT_EXPR<__vector signed int>(x);
+  _2 = VIEW_CONVERT_EXPR<__vector signed int>(y);
+  _3 = __builtin_altivec_vand (_1, _2);
+  D.3245 = VIEW_CONVERT_EXPR<bcvec_t>(_3);
+*/
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) char bcvec_t;
+typedef __attribute__((altivec(vector__))) signed char scvec_t;
+typedef __attribute__((altivec(vector__))) unsigned char ucvec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) short bsvec_t;
+typedef __attribute__((altivec(vector__))) signed short ssvec_t;
+typedef __attribute__((altivec(vector__))) unsigned short usvec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) int bivec_t;
+typedef __attribute__((altivec(vector__))) signed int sivec_t;
+typedef __attribute__((altivec(vector__))) unsigned int uivec_t;
+
+typedef __attribute__((altivec(vector__))) __attribute__((altivec(bool__))) long long bllvec_t;
+typedef __attribute__((altivec(vector__))) signed long long sllvec_t;
+typedef __attribute__((altivec(vector__))) unsigned long long ullvec_t;
+
+typedef __attribute__((altivec(vector__))) double dvec_t;
+typedef __attribute__((altivec(vector__))) float fvec_t;
+
+bcvec_t
+eqv_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+scvec_t
+eqv_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+ucvec_t
+eqv_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+bsvec_t
+eqv_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+ssvec_t
+eqv_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+usvec_t
+eqv_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+bivec_t
+eqv_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+sivec_t
+eqv_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+uivec_t
+eqv_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+bllvec_t
+eqv_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+sllvec_t
+eqv_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+ullvec_t
+eqv_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+dvec_t
+eqv_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+fvec_t
+eqv_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_eqv (x, y);
+}
+
+bcvec_t
+nand_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+scvec_t
+nand_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+ucvec_t
+nand_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+bsvec_t
+nand_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+ssvec_t
+nand_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+usvec_t
+nand_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+bivec_t
+nand_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+sivec_t
+nand_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+uivec_t
+nand_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+bllvec_t
+nand_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+sllvec_t
+nand_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+ullvec_t
+nand_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+dvec_t
+nand_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+fvec_t
+nand_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_nand (x, y);
+}
+
+bcvec_t
+orc_0 (bcvec_t x, bcvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+scvec_t
+orc_1 (scvec_t x, scvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+ucvec_t
+orc_2 (ucvec_t x, ucvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+bsvec_t
+orc_3 (bsvec_t x, bsvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+ssvec_t
+orc_4 (ssvec_t x, ssvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+usvec_t
+orc_5 (usvec_t x, usvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+bivec_t
+orc_6 (bivec_t x, bivec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+sivec_t
+orc_7 (sivec_t x, sivec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+uivec_t
+orc_8 (uivec_t x, uivec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+bllvec_t
+orc_9 (bllvec_t x, bllvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+sllvec_t
+orc_10 (sllvec_t x, sllvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+ullvec_t
+orc_11 (ullvec_t x, ullvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+dvec_t
+orc_12 (dvec_t x, dvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+fvec_t
+orc_13 (fvec_t x, fvec_t y)
+{
+  return __builtin_vec_orc (x, y);
+}
+
+/* { dg-final { scan-tree-dump-not "VIEW_CONVERT_EXPR" "gimple" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr93800.c b/gcc/testsuite/gcc.target/powerpc/pr93800.c
new file mode 100644
index 00000000000..f8dfbe7c082
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr93800.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-mcpu=860 -O2" } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-final { scan-assembler-not "\\.p2align 4" } } */
+
+volatile int g;
+int f(int a, int b)
+{
+	int i;
+
+	for (i = 0; i < b; i++)
+		a += g;
+	return a;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96139-a.c b/gcc/testsuite/gcc.target/powerpc/pr96139-a.c
new file mode 100644
index 00000000000..12a3383902c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96139-a.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -m32 -mvsx" } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+
+#include <stdio.h>
+#include <altivec.h>
+
+void
+try_printing_longlong_a (
+                        __vector signed char cval,
+                        __vector signed int ival,
+                        __vector signed long long int llval,
+                        int x, int y, int z)
+{
+  printf (" %016llx \n", llval[x]);
+  printf (" %016x \n", ival[z]);
+  printf (" %c \n", cval[y]);
+}
+
+void
+try_printing_unsigned_longlong_a (
+                        __vector unsigned char cval,
+                        __vector unsigned int ival,
+                        __vector unsigned long long int llval,
+                        int x, int y, int z)
+{
+  printf (" %016llx \n", llval[x]);
+  printf (" %016x \n", ival[z]);
+  printf (" %c \n", cval[y]);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96139-b.c b/gcc/testsuite/gcc.target/powerpc/pr96139-b.c
new file mode 100644
index 00000000000..379849a591a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96139-b.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -m64 -mvsx" } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+
+#include <stdio.h>
+#include <altivec.h>
+
+void
+try_printing_longlong_a (
+                        __vector signed char cval,
+                        __vector signed int ival,
+                        __vector signed long long int llval,
+                        int x, int y, int z)
+{
+  printf (" %016llx \n", llval[x]);
+  printf (" %016x \n", ival[z]);
+  printf (" %c \n", cval[y]);
+}
+
+
+void
+try_printing_unsigned_longlong_a (
+                        __vector unsigned char cval,
+                        __vector unsigned int ival,
+                        __vector unsigned long long int llval,
+                        int x, int y, int z)
+{
+  printf (" %016llx \n", llval[x]);
+  printf (" %016x \n", ival[z]);
+  printf (" %c \n", cval[y]);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96139-c.c b/gcc/testsuite/gcc.target/powerpc/pr96139-c.c
new file mode 100644
index 00000000000..3ada2603428
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96139-c.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -Wall -maltivec" } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+
+/*
+ * Based on test created by sjmunroe for pr96139
+ */
+
+#include <stdio.h>
+#include <altivec.h>
+
+volatile vector long long llfoo;
+
+void
+print_v2xint64_b () {
+  printf (" %016llx \n", llfoo[0]);
+  printf (" %016llx \n", llfoo[1]);
+}
+
+int 
+main() {
+llfoo[0]=12345678;
+llfoo[1]=34567890;
+print_v2xint64_b();
+return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pragma_misc9.c b/gcc/testsuite/gcc.target/powerpc/pragma_misc9.c
new file mode 100644
index 00000000000..e03099bd084
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pragma_misc9.c
@@ -0,0 +1,47 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mdejagnu-cpu=power9 -maltivec -O2" } */
+
+/* Ensure that if we set a pragma gcc target for an
+   older processor, we do not compile builtins that
+   the older target does not support.  */
+
+#include <altivec.h>
+
+vector bool int
+test1 (vector signed int a, vector signed int b)
+{
+  return vec_cmpnez (a, b);
+}
+
+#pragma GCC target ("cpu=power8")
+vector bool int
+test2 (vector signed int a, vector signed int b)
+{
+  return vec_cmpnez (a, b);
+  /* { dg-error "'__builtin_altivec_vcmpnezw' requires the '-mcpu=power9' option" "" { target *-*-* } .-1 } */
+}
+
+#pragma GCC target ("cpu=power7")
+vector signed int
+test3 (vector signed int a, vector signed int b)
+{
+  return vec_mergee (a, b);
+  /* { dg-error "'__builtin_altivec_vmrgew_v4si' requires the '-mpower8-vector' option" "" { target *-*-* } .-1 } */
+}
+
+#pragma GCC target ("cpu=power6")
+vector signed int
+test4 (vector int a, vector int b)
+{
+  return vec_sldw (a, b, 2);
+  /* { dg-error "'__builtin_vsx_xxsldwi_4si' requires the '-mvsx' option" "" { target *-*-* } .-1 } */
+}
+
+vector int
+test5 (vector int a, vector int b)
+{
+  return vec_add (a, b);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pragma_power6.c b/gcc/testsuite/gcc.target/powerpc/pragma_power6.c
new file mode 100644
index 00000000000..a9120b77415
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pragma_power6.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-mdejagnu-cpu=power6 -maltivec -O2" } */
+
+#include <altivec.h>
+
+#pragma GCC target ("cpu=power6,altivec")
+#ifdef _ARCH_PWR6
+vector int
+isa_2_05 (vector int a, vector int b)
+{
+  return vec_add (a, b);
+}
+#else
+#error failed power6 pragma target
+#endif
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pragma_power7.c b/gcc/testsuite/gcc.target/powerpc/pragma_power7.c
new file mode 100644
index 00000000000..2e5b7c2b369
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pragma_power7.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mdejagnu-cpu=power6 -maltivec -O2" } */
+
+#include <altivec.h>
+
+#pragma GCC target ("cpu=power6,altivec")
+#ifdef _ARCH_PWR6
+vector int
+test1 (vector int a, vector int b)
+{
+  return vec_add (a, b);
+}
+#else
+#error failed power6 pragma target
+#endif
+
+#pragma GCC target ("cpu=power7")
+/* Force a re-read of altivec.h with new cpu target. */
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR7
+vector signed int
+test2 (vector signed int a, vector signed int b)
+{
+  return vec_sldw (a, b, 3);
+}
+#else
+#error failed to set power7 pragma target
+#endif
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pragma_power8.c b/gcc/testsuite/gcc.target/powerpc/pragma_power8.c
new file mode 100644
index 00000000000..c8d2cdd6c1a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pragma_power8.c
@@ -0,0 +1,52 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mdejagnu-cpu=power6 -maltivec -O2" } */
+
+#include <altivec.h>
+
+#pragma GCC target ("cpu=power6,altivec")
+#ifdef _ARCH_PWR6
+vector int
+test1 (vector int a, vector int b)
+{
+  return vec_add (a, b);
+}
+#else
+#error failed power6 pragma target
+#endif
+
+#pragma GCC target ("cpu=power7")
+/* Force a re-read of altivec.h with new cpu target. */
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR7
+vector signed int
+test2 (vector signed int a, vector signed int b)
+{
+  return vec_sldw (a, b, 3);
+}
+#else
+#error failed to set power7 pragma target
+#endif
+
+#pragma GCC target ("cpu=power8")
+/* Force a re-read of altivec.h with new cpu target. */
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR8
+vector int
+test3 (vector int a, vector int b)
+{
+  return vec_mergee (a, b);
+}
+typedef __attribute__((altivec(vector__))) long vec_t;
+int
+test3b (vec_t a, vec_t b)
+{
+  return __builtin_vec_vcmpeq_p (2, a, b);
+}
+#else
+#error failed to set power8 pragma target.
+#endif
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pragma_power9.c b/gcc/testsuite/gcc.target/powerpc/pragma_power9.c
new file mode 100644
index 00000000000..e33aad1aaf7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pragma_power9.c
@@ -0,0 +1,63 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mdejagnu-cpu=power6 -maltivec -O2" } */
+
+#include <altivec.h>
+
+#ifdef _ARCH_PWR6
+vector int
+test1 (vector int a, vector int b)
+{
+  return vec_add (a, b);
+}
+#else
+#error failed on default power6 pragma target
+#endif
+
+#pragma GCC target ("cpu=power7")
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR7
+vector signed int
+test2 (vector signed int a, vector signed int b)
+{
+  return vec_sldw (a, b, 3);
+}
+#else
+#error failed to set power7 pragma target
+#endif
+
+#pragma GCC target ("cpu=power8")
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR8
+vector int
+test3 (vector int a, vector int b)
+{
+  return vec_mergee (a, b);
+}
+
+typedef __attribute__((altivec(vector__))) long vec_t;
+int
+test3b (vec_t a, vec_t b)
+{
+  return __builtin_vec_vcmpeq_p (2, a, b);
+}
+#else
+#error failed to set power8 pragma target.
+#endif
+
+#pragma GCC target ("cpu=power9,power9-vector")
+#undef _ALTIVEC_H
+#include <altivec.h>
+#ifdef _ARCH_PWR9
+vector bool int
+test4 (vector signed int a, vector signed int b)
+{
+  return vec_cmpnez (a, b);
+}
+#else
+#error Failed to set cpu=power9 pragma target.
+#endif
+
diff --git a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
index 93a8ec24516..41377efba1a 100644
--- a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
+++ b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
@@ -14,17 +14,21 @@ int main ()
   union blah {
     double d;
     unsigned long long ll;
-  } conv_val;
+  } mffs_val, mffsl_val;
 
   /* Test reading the FPSCR register.  */
   __asm __volatile ("mffs %0" : "=f"(f14));
-  conv_val.d = f14;
+  mffs_val.d = f14;
+  /* Select the same bits as mffsl.  */
+  mffs_val.ll &= 0x70007f0ffLL;
 
-  if (conv_val.d != __builtin_mffsl())
+  mffsl_val.d = __builtin_mffsl ();
+
+  if (mffs_val.ll != mffsl_val.ll)
     {
 #ifdef DEBUG
       printf("ERROR, __builtin_mffsl() returned 0x%llx, not the expecected value 0x%llx\n",
-	     __builtin_mffsl(), conv_val.d);
+	     mffsl_val.ll, mffs_val.ll);
 #else
       abort();
 #endif
diff --git a/gcc/testsuite/gcc.target/powerpc/vsu/vec-all-nez-7.c b/gcc/testsuite/gcc.target/powerpc/vsu/vec-all-nez-7.c
index 980893fa891..f53c6dca0a9 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsu/vec-all-nez-7.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsu/vec-all-nez-7.c
@@ -11,5 +11,6 @@ test_all_not_equal_and_not_zero (vector unsigned short *arg1_p,
   vector unsigned short arg_1 = *arg1_p;
   vector unsigned short arg_2 = *arg2_p;
 
-  return __builtin_vec_vcmpnez_p (__CR6_LT, arg_1, arg_2);	/* { dg-error "builtin function '__builtin_vec_vcmpnez_p' not supported in this compiler configuration" } */
+  return __builtin_vec_vcmpnez_p (__CR6_LT, arg_1, arg_2);
+  /* { dg-error "'__builtin_altivec_vcmpnezh_p' requires the '-mcpu=power9' option" "" { target *-*-* } .-1 } */
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/vsu/vec-any-eqz-7.c b/gcc/testsuite/gcc.target/powerpc/vsu/vec-any-eqz-7.c
index 9fdbd5f9840..757acd93110 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsu/vec-any-eqz-7.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsu/vec-any-eqz-7.c
@@ -10,5 +10,6 @@ test_any_equal (vector unsigned int *arg1_p, vector unsigned int *arg2_p)
   vector unsigned int arg_1 = *arg1_p;
   vector unsigned int arg_2 = *arg2_p;
 
-  return __builtin_vec_vcmpnez_p (__CR6_LT_REV, arg_1, arg_2);	/* { dg-error "builtin function '__builtin_vec_vcmpnez_p' not supported in this compiler configuration" } */
+  return __builtin_vec_vcmpnez_p (__CR6_LT_REV, arg_1, arg_2);
+  /* { dg-error "'__builtin_altivec_vcmpnezw_p' requires the '-mcpu=power9' option" "" { target *-*-* } .-1 } */
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-msum.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-msum.c
new file mode 100644
index 00000000000..058ca0b0fe4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-msum.c
@@ -0,0 +1,26 @@
+/* Verify that overloaded built-ins for vec_msum with __int128
+   inputs generate the proper code.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-require-effective-target int128 } */
+/* { dg-options "-mdejagnu-cpu=power9  -O3" } */
+
+#include <altivec.h>
+
+vector signed __int128
+test_msum_si (vector signed long long vsll_1, vector signed long long vsll_2,
+	   vector signed __int128 vsi128)
+{
+  return vec_msum (vsll_1, vsll_2, vsi128);
+}
+
+vector unsigned __int128
+test_msum_ui (vector unsigned long long vull_1, vector unsigned long long vull_2,
+	   vector unsigned __int128 vui128)
+{
+  return vec_msum (vull_1, vull_2, vui128);
+}
+
+/* { dg_final { scan_assembler_times "vmsumudm" 2 } } */
+
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
index a891b64e6fa..0106e8d2901 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
@@ -1,167 +1,154 @@
-/* This test code is included into vsx-vector-6-be.c and vsx-vector-6-le.c.  
-   The two files have the tests for the number of instructions generated for
-   LE versus BE.  */
+/* This test code is included into vsx-vector-6.p7.c, vsx-vector-6.p8.c
+   and vsx-vector-6.p9.c.  The .c files have the tests for the number
+   of instructions generated for each cpu type.  */
 
 #include <altivec.h>
 
-void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b,
-	  vector unsigned char *p_uc, int *i, vector float *p_f,
-	  vector bool char *outbc, vector bool int *outbi,
-	  vector bool short *outbsi, vector int *outsi,
-	  vector unsigned int *outui, vector signed char *outsc,
-	  vector unsigned char *outuc)
+typedef struct {
+  vector double d;
+  vector float f;
+  vector long sl;
+  vector int si;
+  vector short ss;
+  vector char sc;
+  vector unsigned int ui;
+  vector unsigned short int us;
+  vector unsigned char uc;
+  vector bool long long bll;
+  vector bool long bl;
+  vector bool int bi;
+  vector bool short bs;
+  vector bool char bc;
+} opnd_t;
+
+void
+func_1op (opnd_t *dst, opnd_t *src)
 {
-  vector double in0 = in[0];
-  vector double in1 = in[1];
-  vector double in2 = in[2];
-  vector long inl = *p_l;
-  vector bool long inb = *p_b;
-  vector bool long long inbl0;
-  vector bool long long inbl1;
-  vector unsigned char uc = *p_uc;
-  vector float inf0;
-  vector float inf1;
-  vector float inf2;
-  vector char inc0;
-  vector char inc1;
-  vector bool char inbc0;
-  vector bool char inbc1;
-  vector bool short inbs0;
-  vector bool short inbs1;
-  vector bool int inbi0;
-  vector bool int inbi1;
-  vector signed short int inssi0, inssi1;
-  vector unsigned short int inusi0, inusi1;
-  vector signed int insi0, insi1;
-  vector unsigned int inui0, inui1;
-  vector unsigned char inuc0, inuc1;
-  
-  *out++ = vec_abs (in0);
-  *out++ = vec_add (in0, in1);
-  *out++ = vec_and (in0, in1);
-  *out++ = vec_and (in0, inb);
-  *out++ = vec_and (inb, in0);
-  *out++ = vec_andc (in0, in1);
-  *out++ = vec_andc (in0, inb);
-  *out++ = vec_andc (inb, in0);
-  *out++ = vec_andc (inbl0, in0);
-  *out++ = vec_andc (in0, inbl0);
-
-  *out++ = vec_ceil (in0);
-  *p_b++ = vec_cmpeq (in0, in1);
-  *p_b++ = vec_cmpgt (in0, in1);
-  *p_b++ = vec_cmpge (in0, in1);
-  *p_b++ = vec_cmplt (in0, in1);
-  *p_b++ = vec_cmple (in0, in1);
-  *out++ = vec_div (in0, in1);
-  *out++ = vec_floor (in0);
-  *out++ = vec_madd (in0, in1, in2);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_max (in0, in1);
-  *out++ = vec_min (in0, in1);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_mul (in0, in1);
-  *out++ = vec_nearbyint (in0);
-  *out++ = vec_nmadd (in0, in1, in2);
-  *out++ = vec_nmsub (in0, in1, in2);
-  *out++ = vec_nor (in0, in1);
-  *out++ = vec_or (in0, in1);
-  *out++ = vec_or (in0, inb);
-  *out++ = vec_or (inb, in0);
-  *out++ = vec_perm (in0, in1, uc);
-  *out++ = vec_rint (in0);
-  *out++ = vec_sel (in0, in1, inl);
-  *out++ = vec_sel (in0, in1, inb);
-  *out++ = vec_sub (in0, in1);
-  *out++ = vec_sqrt (in0);
-  *out++ = vec_trunc (in0);
-  *out++ = vec_xor (in0, in1);
-  *out++ = vec_xor (in0, inb);
-  *out++ = vec_xor (inb, in0);
-
-  *i++ = vec_all_eq (in0, in1);
-  *i++ = vec_all_ge (in0, in1);
-  *i++ = vec_all_gt (in0, in1);
-  *i++ = vec_all_le (in0, in1);
-  *i++ = vec_all_lt (in0, in1);
-  *i++ = vec_all_nan (in0);
-  *i++ = vec_all_ne (in0, in1);
-  *i++ = vec_all_nge (in0, in1);
-  *i++ = vec_all_ngt (in0, in1);
-  *i++ = vec_all_nle (in0, in1);
-  *i++ = vec_all_nlt (in0, in1);
-  *i++ = vec_all_numeric (in0);
-  *i++ = vec_any_eq (in0, in1);
-  *i++ = vec_any_ge (in0, in1);
-  *i++ = vec_any_gt (in0, in1);
-  *i++ = vec_any_le (in0, in1);
-  *i++ = vec_any_lt (in0, in1);
-  *i++ = vec_any_nan (in0);
-  *i++ = vec_any_ne (in0, in1);
-  *i++ = vec_any_nge (in0, in1);
-  *i++ = vec_any_ngt (in0, in1);
-  *i++ = vec_any_nle (in0, in1);
-  *i++ = vec_any_nlt (in0, in1);
-  *i++ = vec_any_numeric (in0);
-
-  *p_f++ = vec_msub (inf0, inf1, inf2);
-  *p_f++ = vec_nmsub (inf0, inf1, inf2);
-  *p_f++ = vec_nmadd (inf0, inf1, inf2);
-  *p_f++ = vec_or (inf0, inf1);
-  *p_f++ = vec_trunc (inf0);
-  
-  *out++ = vec_or (inbl0, in0);
-  *out++ = vec_or (in0, inbl0);
-
-  *out++ = vec_nor (in0, in1);
-
-  *outbc++ = vec_nor (inbc0, inbc1);
-  *outbc++ = vec_andc (inbc0, inbc1);
-  *outbc++ = vec_or (inbc0, inbc1);
-
-  *outuc++ = vec_max (inuc0, inuc1);
-
-  *outbi++ = vec_andc (inbi0, inbi1);
-  *outbsi++ = vec_andc (inbs0, inbs1);
-
-  *outbsi++ = vec_andc (inbs0, inbs1);
-
-  *outbi++ = vec_nor (inbi0, inbi1);
-  *outbi++ = vec_or (inbi0, inbi1);
-
-  *outbsi++ = vec_nor (inbs0, inbs1);
-  *outbsi++ = vec_or (inbs0, inbs1);
-
-  *outsi++ = vec_msums(inssi0, inssi1, insi0);
-  *outui++ = vec_msums(inusi0, inusi1, inui0);
-
-  *p_f++ = vec_nor (inf0, inf1);
-
-  *p_f++ = vec_andc (inf0, inf1);
-  *p_f++ = vec_andc (inbi0, inf0);
-  *p_f++ = vec_andc (inf0, inbi0);
-
-  *in++ = vec_andc (inbl0, in1);
-  *in++ = vec_andc (in0, inbl1);
+  dst[0].d = vec_abs (src[0].d);
+  dst[1].d = vec_ceil (src[1].d);
+  dst[2].d = vec_floor (src[2].d);
+  dst[3].d = vec_nearbyint (src[3].d);
+  dst[4].d = vec_rint (src[4].d);
+  dst[5].d = vec_sqrt (src[5].d);
+  dst[6].d = vec_trunc (src[6].d);
+  dst[7].f = vec_trunc (src[7].f);
 }
 
-int main()
+void
+func_2op (opnd_t *dst, opnd_t *src0, opnd_t *src1)
 {
-  vector double *out;
-  vector double *in;
-  vector long *p_l;
-  vector bool long *p_b;
-  vector unsigned char *p_uc;
-  int *i;
-  vector float *p_f;
-  vector bool char *outbc;
-  vector bool int *outbi;
-  vector bool short *outbsi;
-  vector int *outsi;
-  vector unsigned int *outui;
-  vector signed char *outsc;
-  vector unsigned char *outuc;
-
-  foo (out, in, p_l, p_b, p_uc, i, p_f, outbc,
-       outbi, outbsi, outsi, outui, outsc, outuc);
+  dst[0].d = vec_add (src0[0].d, src1[0].d);
+  dst[1].d = vec_div (src0[1].d, src1[1].d);
+  dst[2].d = vec_max (src0[2].d, src1[2].d);
+  dst[3].uc = vec_max (src0[3].uc, src1[3].uc);
+  dst[4].d = vec_min (src0[4].d, src1[4].d);
+  dst[5].d = vec_mul (src0[5].d, src1[5].d);
+  dst[6].d = vec_sub (src0[6].d, src1[6].d);
+}
+
+void
+func_2lop (opnd_t *dst, opnd_t *src0, opnd_t *src1)
+{
+  dst[0].d = vec_and (src0[0].d, src1[0].d);
+  dst[1].d = vec_and (src0[1].d, src1[1].bl);
+  dst[2].d = vec_and (src0[2].bl, src1[2].d);
+
+  dst[3].d = vec_andc (src0[3].d, src1[3].d);
+  dst[4].d = vec_andc (src0[4].d, src1[4].bl);
+  dst[5].d = vec_andc (src0[5].bl, src1[5].d);
+  dst[6].d = vec_andc (src0[6].bll, src1[6].d);
+  dst[7].d = vec_andc (src0[7].d, src1[7].bll);
+  dst[8].bi = vec_andc (src0[8].bi, src1[8].bi);
+  dst[9].bs = vec_andc (src0[9].bs, src1[9].bs);
+  dst[10].bc = vec_andc (src0[10].bc, src1[10].bc);
+  dst[11].f = vec_andc (src0[11].f, src1[11].f);
+  dst[12].f = vec_andc (src0[12].bi, src1[12].f);
+  dst[13].f = vec_andc (src0[13].f, src1[13].bi);
+  dst[14].d = vec_andc (src0[14].bll, src1[14].d);
+  dst[15].d = vec_andc (src0[15].d, src1[15].bll);
+
+  dst[16].d = vec_nor (src0[16].d, src1[16].d);
+  dst[17].f = vec_nor (src0[17].f, src1[17].f);
+  dst[18].bi = vec_nor (src0[18].bi, src1[18].bi);
+  dst[19].bs = vec_nor (src0[19].bs, src1[19].bs);
+  dst[20].bc = vec_nor (src0[20].bc, src1[20].bc);
+
+  dst[21].d = vec_or (src0[21].d, src1[21].d);
+  dst[22].d = vec_or (src0[22].d, src1[22].bl);
+  dst[23].d = vec_or (src0[23].bl, src1[23].d);
+  dst[24].d = vec_or (src0[24].bll, src1[24].d);
+  dst[25].d = vec_or (src0[25].d, src1[25].bll);
+  dst[26].f = vec_or (src0[26].f, src1[26].f);
+  dst[27].bi = vec_or (src0[27].bi, src1[27].bi);
+  dst[28].bs = vec_or (src0[28].bs, src1[28].bs);
+  dst[29].bc = vec_or (src0[29].bc, src1[29].bc);
+
+  dst[30].d = vec_xor (src0[30].d, src1[30].d);
+  dst[31].d = vec_xor (src0[31].d, src1[31].bl);
+  dst[32].d = vec_xor (src0[32].bl, src1[32].d);
+}
+
+void
+func_cmp (opnd_t *dst, opnd_t *src0, opnd_t *src1)
+{
+  dst[0].bl = vec_cmpeq (src0[0].d, src1[0].d);
+  dst[1].bl = vec_cmpgt (src0[1].d, src1[1].d);
+  dst[2].bl = vec_cmpge (src0[2].d, src1[2].d);
+  dst[3].bl = vec_cmplt (src0[3].d, src1[3].d);
+  dst[4].bl = vec_cmple (src0[4].d, src1[4].d);
+}
+
+void
+func_all_cmp (int *dst, opnd_t *src0, opnd_t *src1)
+{
+  dst[0] = vec_all_eq (src0[0].d, src1[0].d);
+  dst[1] = vec_all_ge (src0[1].d, src1[1].d);
+  dst[2] = vec_all_gt (src0[2].d, src1[2].d);
+  dst[3] = vec_all_le (src0[3].d, src1[3].d);
+  dst[4] = vec_all_lt (src0[4].d, src1[4].d);
+  dst[5] = vec_all_nan (src0[5].d);
+  dst[6] = vec_all_ne (src0[6].d, src1[6].d);
+  dst[7] = vec_all_nge (src0[7].d, src1[7].d);
+  dst[8] = vec_all_ngt (src0[8].d, src1[8].d);
+  dst[9] = vec_all_nle (src0[9].d, src1[9].d);
+  dst[10] = vec_all_nlt (src0[10].d, src1[10].d);
+  dst[11] = vec_all_numeric (src0[11].d);
+  dst[12] = vec_any_eq (src0[12].d, src1[12].d);
+  dst[13] = vec_any_ge (src0[13].d, src1[13].d);
+  dst[14] = vec_any_gt (src0[14].d, src1[14].d);
+  dst[15] = vec_any_le (src0[15].d, src1[15].d);
+  dst[16] = vec_any_lt (src0[16].d, src1[16].d);
+  dst[17] = vec_any_nan (src0[17].d);
+  dst[18] = vec_any_ne (src0[18].d, src1[18].d);
+  dst[19] = vec_any_nge (src0[19].d, src1[19].d);
+  dst[20] = vec_any_ngt (src0[20].d, src1[20].d);
+  dst[21] = vec_any_nle (src0[21].d, src1[21].d);
+  dst[22] = vec_any_nlt (src0[22].d, src1[22].d);
+  dst[23] = vec_any_numeric (src0[23].d);
+}
+
+void
+func_3op (opnd_t *dst, opnd_t *src0, opnd_t *src1, opnd_t *src2)
+{
+  dst[0].d = vec_madd (src0[0].d, src1[0].d, src2[0].d);
+  dst[1].d = vec_msub (src0[1].d, src1[1].d, src2[1].d);
+  dst[2].d = vec_nmadd (src0[2].d, src1[2].d, src2[2].d);
+  dst[3].d = vec_nmsub (src0[3].d, src1[3].d, src2[3].d);
+
+  dst[4].f = vec_madd (src0[4].f, src1[4].f, src2[4].f);
+  dst[5].f = vec_msub (src0[5].f, src1[5].f, src2[5].f);
+  dst[6].f = vec_nmsub (src0[6].f, src1[6].f, src2[6].f);
+  dst[7].f = vec_nmadd (src0[7].f, src1[7].f, src2[7].f);
+
+#if defined (__BIG_ENDIAN__) || defined (_ARCH_PWR9)
+  dst[8].d = vec_perm (src0[8].d, src1[8].d, src2[8].uc);
+#else
+  dst[8].d = vec_perm (src0[8].d, src1[8].d, ~src2[8].uc);
+#endif
+
+  dst[9].d = vec_sel (src0[9].d, src1[9].d, src2[9].d);
+  dst[10].d = vec_sel (src0[10].d, src1[10].d, src2[10].bl);
+
+  dst[11].si = vec_msums(src0[11].ss, src1[11].ss, src2[11].si);
+  dst[12].ui = vec_msums(src0[12].us, src1[12].us, src2[12].ui);
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
index 0be7e7c6895..ff560dd8d4f 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
@@ -1,41 +1,43 @@
-/* { dg-do compile { target { lp64 && be } } } */
+/* { dg-do compile { target lp64 } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2 -mdejagnu-cpu=power7 -dp" } */
-
-/* Expected instruction counts for Power 7 */
-
-/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
-/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 1 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 6 } } */
-/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
-/* { dg-final { scan-assembler-times "vperm" 2 } } */
-/* { dg-final { scan-assembler-times "xvrdpic" 2 } } */
-/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
-/* { dg-final { scan-assembler-times "vmsumshs" 2 } } */
-/* { dg-final { scan-assembler-times "xxland" 13 } } */
-/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
-/* { dg-final { scan-assembler-times "xxsel" 4 } } */
-/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
-/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpi" 7 } } */
+/* { dg-options "-O2 -mdejagnu-cpu=power7" } */
 
 /* Source code for the test in vsx-vector-6.h */
 #include "vsx-vector-6.h"
+
+/* { dg-final { scan-assembler-times {\mvmaxub\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumshs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumuhs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvperm\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvabsdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvadddp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvdivdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmaxdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmindp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmuldp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpi\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpic\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpim\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpip\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrspiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvsqrtdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvsubdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxxland\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxlandc\M} 13 } } */
+/* { dg-final { scan-assembler-times {\mxxlnor\M} 5 } } */
+/* { dg-final { scan-assembler-times {\mxxlor\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxxlxor\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxsel\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
index 09a1d96e6be..a99da650492 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
@@ -1,49 +1,43 @@
 /* { dg-do compile { target lp64 } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2 -mdejagnu-cpu=power8" } */
-
-/* Expected instruction counts for Power 8.  */
-
-/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
-/* { dg-final { scan-assembler-times "xxlnor" 6 { target le } } } */
-/* { dg-final { scan-assembler-times "xxlnor" 5 { target be } } } */
-
-/* We generate xxlor instructions for many reasons other than or'ing vector
-   operands or calling __builtin_vec_or(), which  means we cannot rely on
-   their usage counts being stable.  Therefore, we just ensure at least one
-   xxlor instruction was generated.  */
-/* { dg-final { scan-assembler "xxlor" } } */
-
-/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 6 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 2 } } */
-/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 4 } } */
-/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
-/* { dg-final { scan-assembler-times "vperm" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
-/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
-/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
-/* { dg-final { scan-assembler-times "xxland" 13 } } */
-/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
-/* { dg-final { scan-assembler-times "xxsel" 2 } } */
-/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
-/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpi" 5 } } */
+/* { dg-options "-O2 -mdejagnu-cpu=power8" } */
 
 /* Source code for the test in vsx-vector-6.h */
 #include "vsx-vector-6.h"
+
+/* { dg-final { scan-assembler-times {\mvmaxub\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumshs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumuhs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvperm\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvabsdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvadddp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvdivdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmaxdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmindp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmuldp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpi\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpic\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpim\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpip\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrspiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvsqrtdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvsubdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxxland\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxlandc\M} 13 } } */
+/* { dg-final { scan-assembler-times {\mxxlnor\M} 5 } } */
+/* { dg-final { scan-assembler-times {\mxxlor\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxxlxor\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxsel\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
index 5f1bafcde17..eabdf71a7be 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
@@ -1,38 +1,42 @@
 /* { dg-do compile { target lp64 } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mvsx -O2 -mdejagnu-cpu=power9" } */
-
-/* Expected instruction counts for Power9. */
-
-/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
-/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
-
-/* We generate xxlor instructions for many reasons other than or'ing vector
-   operands or calling __builtin_vec_or(), which  means we cannot rely on
-   their usage counts being stable.  Therefore, we just ensure at least one
-   xxlor instruction was generated.  */
-/* { dg-final { scan-assembler "xxlor" } } */
-
-/* { dg-final { scan-assembler-times "xvcmpeqdp" 5 } } */
-/* { dg-final { scan-assembler-times "xvcmpgtdp" 8 } } */
-/* { dg-final { scan-assembler-times "xvcmpgedp" 8 } } */
-/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
-/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
-/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
-/* { dg-final { scan-assembler-times "vperm" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
-/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
-/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
-/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
-/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
-/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
-/* { dg-final { scan-assembler-times "xxland" 13 } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power9" } */
 
 /* Source code for the test in vsx-vector-6.h */
 #include "vsx-vector-6.h"
+
+/* { dg-final { scan-assembler-times {\mvmaxub\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumshs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvmsumuhs\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mvpermr?\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvabsdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvadddp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\M} 10 } } */
+/* { dg-final { scan-assembler-times {\mxvdivdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmaxdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmindp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmuldp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmadd[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvnmsub[am]sp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpi\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpic\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpim\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpip\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrdpiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvrspiz\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvsqrtdp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvmsub[am]dp\M} 1 } } */
+/* { dg-final { scan-assembler-times {\mxxland\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxlandc\M} 13 } } */
+/* { dg-final { scan-assembler-times {\mxxlnor\M} 5 } } */
+/* { dg-final { scan-assembler-times {\mxxlor\M} 9 } } */
+/* { dg-final { scan-assembler-times {\mxxlxor\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mxxsel\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/riscv/interrupt-3.c b/gcc/testsuite/gcc.target/riscv/interrupt-3.c
index bc9e0c14f05..3d1d44df45e 100644
--- a/gcc/testsuite/gcc.target/riscv/interrupt-3.c
+++ b/gcc/testsuite/gcc.target/riscv/interrupt-3.c
@@ -1,4 +1,4 @@
-/* Verify t1 is saved before use.  */
+/* Verify t0 is saved before use.  */
 /* { dg-do compile } */
 /* { dg-options "-O0 -fomit-frame-pointer" } */
 void __attribute__ ((interrupt))
@@ -6,4 +6,4 @@ foo (void)
 {
   char array[4096];
 }
-/* { dg-final { scan-assembler "s\[wd\]\tt1" } } */
+/* { dg-final { scan-assembler "s\[wd\]\tt0" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/interrupt-4.c b/gcc/testsuite/gcc.target/riscv/interrupt-4.c
index b6fdd19095c..658aa176e77 100644
--- a/gcc/testsuite/gcc.target/riscv/interrupt-4.c
+++ b/gcc/testsuite/gcc.target/riscv/interrupt-4.c
@@ -1,4 +1,4 @@
-/* Verify t1 is saved before use.  */
+/* Verify t0 is saved before use.  */
 /* { dg-do compile } */
 /* { dg-options "-O0 -fomit-frame-pointer" } */
 void __attribute__ ((interrupt))
@@ -15,4 +15,4 @@ foo2 (void)
   COUNTER++;
 #endif
 }
-/* { dg-final { scan-assembler "s\[wd\]\tt1" } } */
+/* { dg-final { scan-assembler "s\[wd\]\tt0" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/pr99702.c b/gcc/testsuite/gcc.target/riscv/pr99702.c
new file mode 100644
index 00000000000..a28724c0958
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/pr99702.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+char n;
+void *i, *j;
+void foo(void) {
+  __builtin_memcpy(i, j, n);
+}
diff --git a/gcc/testsuite/gcc.target/s390/vector/align-1.c b/gcc/testsuite/gcc.target/s390/vector/align-1.c
index cc7777ad22a..6997af2ddcd 100644
--- a/gcc/testsuite/gcc.target/s390/vector/align-1.c
+++ b/gcc/testsuite/gcc.target/s390/vector/align-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -march=z14" } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
 
 /* The user alignment ends up in DECL_ALIGN of the VAR_DECL and is
    currently ignored if it is smaller than the alignment of the type.
diff --git a/gcc/testsuite/gcc.target/s390/vector/align-2.c b/gcc/testsuite/gcc.target/s390/vector/align-2.c
index e4e2fba6a58..00e09d3eadb 100644
--- a/gcc/testsuite/gcc.target/s390/vector/align-2.c
+++ b/gcc/testsuite/gcc.target/s390/vector/align-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O3 -mzarch -march=z14" } */
+/* { dg-options "-O3 -mzarch -march=z13" } */
 
 /* The user alignment ends up in TYPE_ALIGN of the type of the
    VAR_DECL.  */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/pr94613.c b/gcc/testsuite/gcc.target/s390/zvector/pr94613.c
new file mode 100644
index 00000000000..c3581d82ede
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/pr94613.c
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-require-effective-target s390_vx } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector -std=gnu99 --save-temps" } */
+
+#include <vecintrin.h>
+
+/* The initial implementation of vec_sel used an IF_THEN_ELSE rtx.
+   This did NOT match what the vsel instruction does.  vsel is a
+   bit-wise operation.  Using IF_THEN_ELSE made the + operation to be
+   simplified away in combine.  A plus operation affects other bits in
+   the same element. Hence per-element simplifications are wrong for
+   vsel.  */
+vector unsigned char __attribute__((noinline))
+foo (vector unsigned char a, vector unsigned char b, vector unsigned char c)
+{
+  return vec_sel (a + b, c, a);
+}
+
+/* FIXME: The OR operation still should be optimized away in that case.  */
+vector unsigned char __attribute__((noinline))
+bar (vector unsigned char a, vector unsigned char b, vector unsigned char c)
+{
+  return vec_sel (a | b, c, a);
+}
+
+int
+main ()
+{
+  vector unsigned char v = (vector unsigned char){ 1 };
+
+  if (foo (v, v, v)[0] != 3)
+      __builtin_abort ();
+
+  if (bar (v, v, v)[0] != 1)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec_load_len_r.c b/gcc/testsuite/gcc.target/s390/zvector/vec_load_len_r.c
new file mode 100644
index 00000000000..5d22bf61c7c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec_load_len_r.c
@@ -0,0 +1,94 @@
+/* { dg-do run } */
+/* { dg-require-effective-target s390_vxe2 } */
+/* { dg-options "-O3 -mzarch -march=arch13 -mzvector --save-temps" } */
+
+#include <string.h>
+#include <vecintrin.h>
+
+typedef vector unsigned char uv16qi;
+
+const unsigned char test_vec[16] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
+
+#define NUM_TEST_LENGTHS 3
+
+unsigned int test_len[NUM_TEST_LENGTHS] = { 0, 12, 18 };
+
+
+/* Proceeding from left to right, the specified number (LEN+1) of
+   bytes from SOURCE are stored right-justified in TARGET.  */
+void __attribute__((noinline, noclone, target ("arch=zEC12")))
+emul (const unsigned char *source, unsigned char *target, unsigned int len)
+{
+  int start = 15 - len;
+  if (start < 0)
+    start = 0;
+  for (int s = 0, t = start; t < 16; s++, t++)
+    target[t] = source[s];
+}
+
+uv16qi __attribute__((noinline, noclone))
+vec_load_len_r_reg (const unsigned char *s, unsigned int len)
+{
+  return vec_load_len_r (s, len);
+}
+
+void __attribute__((noinline, noclone))
+vec_load_len_r_mem (const unsigned char *s, uv16qi *t, unsigned int *len)
+{
+  *t = vec_load_len_r (s, *len);
+}
+
+#define GEN_CONST_FUNC(CONST)				\
+  static uv16qi inline						\
+  vec_load_len_r_const##CONST (const unsigned char *s)	\
+  {							\
+    return vec_load_len_r (s, CONST);			\
+  }
+
+#define GEN_CONST_TEST(CONST)				\
+  memset (exp_result, 0, 16);				\
+  emul (test_vec, exp_result, CONST);			\
+  result = (uv16qi) { 0 };				\
+  result = vec_load_len_r_const##CONST (test_vec);	\
+  if (memcmp ((char*)&result, exp_result, 16) != 0)	\
+    __builtin_abort ();
+
+GEN_CONST_FUNC(0)
+GEN_CONST_FUNC(12)
+GEN_CONST_FUNC(18)
+
+int
+main ()
+{
+  unsigned char exp_result[16];
+  uv16qi result;
+
+  for (int i = 0; i < NUM_TEST_LENGTHS; i++)
+    {
+      memset (exp_result, 0, 16);
+
+      emul (test_vec, exp_result, test_len[i]);
+
+      result = (uv16qi) { 0 };
+      result = vec_load_len_r_reg (test_vec, test_len[i]);
+      if (memcmp ((char*)&result, exp_result, 16) != 0)
+	__builtin_abort ();
+
+      result = (uv16qi) { 0 };
+      vec_load_len_r_mem (test_vec, &result, &test_len[i]);
+      if (memcmp ((char*)&result, exp_result, 16) != 0)
+	__builtin_abort ();
+    }
+
+  GEN_CONST_TEST(0)
+  GEN_CONST_TEST(12)
+  GEN_CONST_TEST(18)
+
+  return 0;
+}
+
+/* vec_load_len_r_reg and vec_load_len_r_mem */
+/* { dg-final { scan-assembler-times "vlrlr\t" 2 } } */
+
+/* For the 2 constants.  The 3. should be implemented with vl.  */
+/* { dg-final { scan-assembler-times "vlrl\t" 2 } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec_sel-1.c b/gcc/testsuite/gcc.target/s390/zvector/vec_sel-1.c
new file mode 100644
index 00000000000..d310f70d3a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec_sel-1.c
@@ -0,0 +1,211 @@
+/* { dg-do run } */
+/* { dg-require-effective-target s390_vxe } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector --save-temps -Wno-attributes" } */
+
+#include <string.h>
+#include <vecintrin.h>
+
+typedef vector signed char v16qi;
+typedef vector unsigned char uv16qi;
+typedef vector bool char bv16qi;
+
+typedef vector signed short int v8hi;
+typedef vector unsigned short int uv8hi;
+typedef vector bool short int bv8hi;
+
+typedef vector signed int v4si;
+typedef vector unsigned int uv4si;
+typedef vector bool int bv4si;
+
+typedef vector signed long long v2di;
+typedef vector unsigned long long uv2di;
+typedef vector bool long long bv2di;
+
+typedef vector float v4sf;
+typedef vector double v2df;
+
+#define NUM_CONSTS 8
+
+const v16qi v16qi_vals[NUM_CONSTS] =
+  { (v16qi){ 1 },
+    (v16qi){ 2 },
+    (v16qi){ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
+    (v16qi){ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2 },
+    (v16qi){ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 },
+    (v16qi){ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
+    (v16qi){ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
+    (v16qi){ 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1 }
+  };
+
+const v8hi v8hi_vals[NUM_CONSTS] =
+  { (v8hi){ 1 },
+    (v8hi){ 2 },
+    (v8hi){ 1,1,1,1,1,1,1,1 },
+    (v8hi){ 2,2,2,2,2,2,2,2 },
+    (v8hi){ -1,-1,-1,-1,-1,-1,-1,-1 },
+    (v8hi){ 0,0,0,0,0,0,0,0 },
+    (v8hi){ 1,2,3,4,5,6,7,8 },
+    (v8hi){ 8,7,6,5,4,3,2,1 }
+  };
+
+const v4si v4si_vals[NUM_CONSTS] =
+  { (v4si){ 1 },
+    (v4si){ 2 },
+    (v4si){ 1,1,1,1 },
+    (v4si){ 2,2,2,2 },
+    (v4si){ -1,-1,-1,-1 },
+    (v4si){ 0,0,0,0 },
+    (v4si){ 1,2,3,4 },
+    (v4si){ 4,3,2,1 }
+  };
+
+const v2di v2di_vals[NUM_CONSTS] =
+  { (v2di){ 1 },
+    (v2di){ 2 },
+    (v2di){ 1,1 },
+    (v2di){ 2,2 },
+    (v2di){ -1,-1 },
+    (v2di){ 0,0 },
+    (v2di){ 1,2 },
+    (v2di){ 2,1 }
+  };
+
+const v4sf v4sf_vals[NUM_CONSTS] =
+  { (v4sf){ 1.0f },
+    (v4sf){ 2.0f },
+    (v4sf){ 1.0f,1.0f,1.0f,1.0f },
+    (v4sf){ 2.0f,2.0f,2.0f,2.0f },
+    (v4sf){ -1.0f,-1.0f,-1.0f,-1.0f },
+    (v4sf){ 0.0f,0.0f,0.0f,0.0f },
+    (v4sf){ 1.1f,2.1f,3.1f,4.1f },
+    (v4sf){ 4.1f,3.1f,2.1f,1.1f }
+  };
+
+const v2df v2df_vals[NUM_CONSTS] =
+  { (v2df){ 1.0 },
+    (v2df){ 2.0 },
+    (v2df){ 1.0,1.0 },
+    (v2df){ 2.0,2.0 },
+    (v2df){ -1.0,-1.0 },
+    (v2df){ 0.0,0.0 },
+    (v2df){ 1.1,2.1 },
+    (v2df){ 2.1,1.1 }
+  };
+
+/* Each bit of the result vector has the value of the corresponding
+   bit of A if the corresponding bit of C is 0, or the value of the
+   corresponding bit of B otherwise.  */
+void __attribute__((noinline, noclone, target ("arch=zEC12")))
+emul (unsigned char *result, unsigned char *a,
+      unsigned char *b, unsigned char *c)
+{
+  for (int i = 0; i < 16; i++)
+    result[i] = (a[i] & ~c[i]) | (b[i] & c[i]);
+}
+
+#define GENFUNC(NAME, T1, T2)						\
+  T1 __attribute__((noinline, noclone))					\
+  NAME##_reg (T1 a, T1 b, T2 c) { return vec_sel (a, b, c); }		\
+  void __attribute__((noinline, noclone))				\
+  NAME##_mem (T1 *a, T1 *b, T2 *c, T1 *out) { *out = vec_sel (*a, *b, *c); } \
+  T1 __attribute__((always_inline))					\
+  NAME##_const (T1 a, T1 b, T2 c) { return vec_sel (a, b, c); }
+
+GENFUNC (vec_sel_b8_a, bv16qi, uv16qi)
+GENFUNC (vec_sel_b8_b, bv16qi, bv16qi)
+GENFUNC (vec_sel_s8_a,  v16qi, uv16qi)
+GENFUNC (vec_sel_s8_b,  v16qi, bv16qi)
+GENFUNC (vec_sel_u8_a, uv16qi, uv16qi)
+GENFUNC (vec_sel_u8_b, uv16qi, bv16qi)
+
+GENFUNC (vec_sel_b16_a, bv8hi, uv8hi)
+GENFUNC (vec_sel_b16_b, bv8hi, bv8hi)
+GENFUNC (vec_sel_s16_a,  v8hi, uv8hi)
+GENFUNC (vec_sel_s16_b,  v8hi, bv8hi)
+GENFUNC (vec_sel_u16_a, uv8hi, uv8hi)
+GENFUNC (vec_sel_u16_b, uv8hi, bv8hi)
+
+GENFUNC (vec_sel_b32_a, bv4si, uv4si)
+GENFUNC (vec_sel_b32_b, bv4si, bv4si)
+GENFUNC (vec_sel_s32_a,  v4si, uv4si)
+GENFUNC (vec_sel_s32_b,  v4si, bv4si)
+GENFUNC (vec_sel_u32_a, uv4si, uv4si)
+GENFUNC (vec_sel_u32_b, uv4si, bv4si)
+
+GENFUNC (vec_sel_b64_a, bv2di, uv2di)
+GENFUNC (vec_sel_b64_b, bv2di, bv2di)
+GENFUNC (vec_sel_s64_a,  v2di, uv2di)
+GENFUNC (vec_sel_s64_b,  v2di, bv2di)
+GENFUNC (vec_sel_u64_a, uv2di, uv2di)
+GENFUNC (vec_sel_u64_b, uv2di, bv2di)
+
+GENFUNC (vec_sel_flt_a,  v4sf, uv4si)
+GENFUNC (vec_sel_flt_b,  v4sf, bv4si)
+
+GENFUNC (vec_sel_dbl_a,  v2df, uv2di)
+GENFUNC (vec_sel_dbl_b,  v2df, bv2di)
+
+#define TESTFUNC(NAME, T1, T2, VAL_TYPE)				\
+  for (int i = 0; i < NUM_CONSTS; i++)					\
+    for (int j = 0; j < NUM_CONSTS; j++)				\
+      for (int k = 0; k < NUM_CONSTS; k++)				\
+	{								\
+	  unsigned char result[16];					\
+	  T1 in1 = (T1)VAL_TYPE##_vals[i];				\
+	  T1 in2 = (T1)VAL_TYPE##_vals[j];				\
+	  T2 in3 = (T2)VAL_TYPE##_vals[k];				\
+	  emul (result, (char*)&in1, (char*)&in2, (char*)&in3);		\
+									\
+	  T1 reg = NAME##_reg (in1, in2, in3);				\
+	  if (memcmp ((char*)&reg, result, 16) != 0)			\
+	    __builtin_abort ();						\
+									\
+	  T1 mem;							\
+	  NAME##_mem (&in1, &in2, &in3, &mem);				\
+	  if (memcmp ((char*)&mem, result, 16) != 0)			\
+	    __builtin_abort ();						\
+									\
+	  T1 cons = NAME##_const (in1, in2, in3);			\
+	  if (memcmp ((char*)&cons, result, 16) != 0)			\
+	    __builtin_abort ();						\
+	}
+
+int
+main ()
+{
+  TESTFUNC (vec_sel_b8_a, bv16qi, uv16qi, v16qi);
+  TESTFUNC (vec_sel_b8_b, bv16qi, bv16qi, v16qi);
+  TESTFUNC (vec_sel_s8_a,  v16qi, uv16qi, v16qi);
+  TESTFUNC (vec_sel_s8_b,  v16qi, bv16qi, v16qi);
+  TESTFUNC (vec_sel_u8_a, uv16qi, uv16qi, v16qi);
+  TESTFUNC (vec_sel_u8_b, uv16qi, bv16qi, v16qi);
+
+  TESTFUNC (vec_sel_b16_a, bv8hi, uv8hi, v8hi);
+  TESTFUNC (vec_sel_b16_b, bv8hi, bv8hi, v8hi);
+  TESTFUNC (vec_sel_s16_a,  v8hi, uv8hi, v8hi);
+  TESTFUNC (vec_sel_s16_b,  v8hi, bv8hi, v8hi);
+  TESTFUNC (vec_sel_u16_a, uv8hi, uv8hi, v8hi);
+  TESTFUNC (vec_sel_u16_b, uv8hi, bv8hi, v8hi);
+
+  TESTFUNC (vec_sel_b32_a, bv4si, uv4si, v4si);
+  TESTFUNC (vec_sel_b32_b, bv4si, bv4si, v4si);
+  TESTFUNC (vec_sel_s32_a,  v4si, uv4si, v4si);
+  TESTFUNC (vec_sel_s32_b,  v4si, bv4si, v4si);
+  TESTFUNC (vec_sel_u32_a, uv4si, uv4si, v4si);
+  TESTFUNC (vec_sel_u32_b, uv4si, bv4si, v4si);
+
+  TESTFUNC (vec_sel_b64_a, bv2di, uv2di, v2di);
+  TESTFUNC (vec_sel_b64_b, bv2di, bv2di, v2di);
+  TESTFUNC (vec_sel_s64_a,  v2di, uv2di, v2di);
+  TESTFUNC (vec_sel_s64_b,  v2di, bv2di, v2di);
+  TESTFUNC (vec_sel_u64_a, uv2di, uv2di, v2di);
+  TESTFUNC (vec_sel_u64_b, uv2di, bv2di, v2di);
+
+  TESTFUNC (vec_sel_flt_a,  v4sf, uv4si, v4sf);
+  TESTFUNC (vec_sel_flt_b,  v4sf, bv4si, v4sf);
+
+  TESTFUNC (vec_sel_dbl_a,  v2df, uv2di, v2df);
+  TESTFUNC (vec_sel_dbl_b,  v2df, bv2di, v2df);
+}
+
+/* { dg-final { scan-assembler {\n\tvsel\t} } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec_store_len_r.c b/gcc/testsuite/gcc.target/s390/zvector/vec_store_len_r.c
new file mode 100644
index 00000000000..83ef90a2b10
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec_store_len_r.c
@@ -0,0 +1,94 @@
+/* { dg-do run } */
+/* { dg-require-effective-target s390_vxe2 } */
+/* { dg-options "-O3 -mzarch -march=arch13 -mzvector --save-temps" } */
+
+#include <string.h>
+#include <vecintrin.h>
+
+typedef vector unsigned char uv16qi;
+
+uv16qi test_vec = (uv16qi){ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
+
+#define NUM_TEST_LENGTHS 3
+
+unsigned int test_len[NUM_TEST_LENGTHS] = { 0, 12, 18 };
+
+
+/* Proceeding from left to right, the specified number (LEN+1) of
+   rightmost bytes from SOURCE are stored in TARGET.  */
+void __attribute__((noinline, noclone, target ("arch=zEC12")))
+emul (unsigned char *source, unsigned char *target, unsigned int len)
+{
+  int start = 15 - len;
+  if (start < 0)
+    start = 0;
+  for (int s = start, t = 0; s < 16; s++, t++)
+    target[t] = source[s];
+}
+
+void __attribute__((noinline, noclone))
+vec_store_len_r_reg (uv16qi s, unsigned char *t, unsigned int len)
+{
+  vec_store_len_r (s, t, len);
+}
+
+void __attribute__((noinline, noclone))
+vec_store_len_r_mem (uv16qi *s, unsigned char *t, unsigned int *len)
+{
+  vec_store_len_r (*s, t, *len);
+}
+
+#define GEN_CONST_FUNC(CONST)					\
+  static void inline						\
+  vec_store_len_r_const##CONST (uv16qi s, unsigned char *t)	\
+  {								\
+    vec_store_len_r (s, t, CONST);				\
+  }
+
+#define GEN_CONST_TEST(CONST)					\
+  memset (exp_result, 0, 16);					\
+  emul ((unsigned char*)&test_vec, exp_result, CONST);		\
+  memset (result, 0, 16);					\
+  vec_store_len_r_const##CONST (test_vec, result);		\
+  if (memcmp (result, exp_result, 16) != 0)			\
+    __builtin_abort ();
+
+GEN_CONST_FUNC(0)
+GEN_CONST_FUNC(12)
+GEN_CONST_FUNC(18)
+
+int
+main ()
+{
+  unsigned char exp_result[16];
+  unsigned char result[16];
+
+  for (int i = 0; i < NUM_TEST_LENGTHS; i++)
+    {
+      memset (exp_result, 0, 16);
+
+      emul ((unsigned char*)&test_vec, exp_result, test_len[i]);
+
+      memset (result, 0, 16);
+      vec_store_len_r_reg (test_vec, result, test_len[i]);
+      if (memcmp (result, exp_result, 16) != 0)
+	__builtin_abort ();
+
+      memset (result, 0, 16);
+      vec_store_len_r_mem (&test_vec, result, &test_len[i]);
+      if (memcmp (result, exp_result, 16) != 0)
+	__builtin_abort ();
+    }
+
+  GEN_CONST_TEST(0)
+  GEN_CONST_TEST(12)
+  GEN_CONST_TEST(18)
+
+  return 0;
+}
+
+/* vec_store_len_r_reg and vec_store_len_r_mem */
+/* { dg-final { scan-assembler-times "vstrlr\t" 2 } } */
+
+/* For the 2 constants.  The 3. should be implemented with vst.  */
+/* { dg-final { scan-assembler-times "vstrl\t" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-6.c b/gcc/testsuite/gcc.target/sparc/overflow-6.c
new file mode 100644
index 00000000000..11aafc581da
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/overflow-6.c
@@ -0,0 +1,20 @@
+/* PR target/97939 */
+/* Reported by Vincent Lefevre <vincent-gcc@vinc17.net> */
+
+/* { dg-do run } */
+
+#include <limits.h>
+
+long add (long i)
+{
+  long r;
+  if (!__builtin_add_overflow (i, 4096, &r))
+    __builtin_abort ();
+  return r;
+}
+
+int main (void)
+{
+  add (LONG_MAX);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/xtensa/pr91880.c b/gcc/testsuite/gcc.target/xtensa/pr91880.c
new file mode 100644
index 00000000000..f4895a1bb8e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/xtensa/pr91880.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fomit-frame-pointer -fno-tree-vectorize" } */
+
+void foo (unsigned int n, char *a, char *b)
+{
+  int i;
+
+  for (i = 0; i <= n - 1; ++i)
+    a[i] = b[i];
+}
diff --git a/gcc/testsuite/gcc.target/xtensa/pr94584.c b/gcc/testsuite/gcc.target/xtensa/pr94584.c
new file mode 100644
index 00000000000..1577285b8a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/xtensa/pr94584.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mserialize-volatile" } */
+
+unsigned long load32 (volatile unsigned long *s)
+{
+  return *s;
+}
+
+short load16s (volatile short *s)
+{
+  return *s;
+}
+
+unsigned short load16u (volatile unsigned short *s)
+{
+  return *s;
+}
+
+unsigned char load8 (volatile unsigned char *s)
+{
+  return *s;
+}
+
+/* { dg-final { scan-assembler-times "memw" 4 } } */
diff --git a/gcc/testsuite/gcc.target/xtensa/xtensa.exp b/gcc/testsuite/gcc.target/xtensa/xtensa.exp
new file mode 100644
index 00000000000..8720327f526
--- /dev/null
+++ b/gcc/testsuite/gcc.target/xtensa/xtensa.exp
@@ -0,0 +1,41 @@
+# Copyright (C) 2019 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an Xtensa target.
+if ![istarget xtensa*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
+	"" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gdc.dg/imports/pr92216.d b/gcc/testsuite/gdc.dg/imports/pr92216.d
new file mode 100644
index 00000000000..b8c71c03420
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr92216.d
@@ -0,0 +1,22 @@
+module imports.pr92216;
+
+class B : I
+{
+    protected override void getStruct(){}
+    mixin A!();
+
+}
+
+mixin template A()
+{
+    public void* getS()
+    {
+        return null;
+    }
+}
+
+public interface I
+{
+    public void* getS();
+    protected void getStruct();
+}
diff --git a/gcc/testsuite/gdc.dg/pr92216.d b/gcc/testsuite/gdc.dg/pr92216.d
new file mode 100644
index 00000000000..89a99e599be
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr92216.d
@@ -0,0 +1,13 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92216
+// { dg-options "-I $srcdir/gdc.dg" }
+// { dg-do compile }
+// { dg-final { scan-assembler "_DT(4|8|16)_D7imports7pr922161B8__mixin24getSMFZPv\[: \t\n\]" } }
+// { dg-final { scan-assembler-not "(.globl|.global)\[         \]+_DT(4|8|16)_D7imports7pr922161B8__mixin24getSMFZPv" } }
+module pr92216;
+
+private import imports.pr92216;
+
+class C : B
+{
+    protected override void getStruct() {}
+}
diff --git a/gcc/testsuite/gdc.dg/pr94970.d b/gcc/testsuite/gdc.dg/pr94970.d
new file mode 100644
index 00000000000..4c3387e3d4b
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr94970.d
@@ -0,0 +1,20 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94970
+// { dg-do compile }
+
+struct S94970
+{
+    string index() { return null; }
+    ~this() { }
+}
+
+static m() { return S94970(); }
+
+auto concat()
+{
+    return m.index ~ ' ';
+}
+
+auto newarray()
+{
+    return new int[][](m.index.length, 1);
+}
diff --git a/gcc/testsuite/gdc.dg/pr95173.d b/gcc/testsuite/gdc.dg/pr95173.d
new file mode 100644
index 00000000000..2a4b2ed8232
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr95173.d
@@ -0,0 +1,10 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95173
+// { dg-do compile }
+// { dg-options "-Wattributes" }
+
+import gcc.attribute;
+
+@attribute("foo") // { dg-warning "unknown attribute .foo." }
+void f95173() 
+{
+}
diff --git a/gcc/testsuite/gdc.dg/pr95250.d b/gcc/testsuite/gdc.dg/pr95250.d
new file mode 100644
index 00000000000..dfb8abb732f
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr95250.d
@@ -0,0 +1,18 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95250
+// { dg-do compile }
+
+template Unsigned(T)
+{
+    static assert(false, "Type " ~ T.stringof ~
+                  " does not have an Unsigned counterpart");
+}
+
+
+void* f(T)(T a, T b)
+{
+        alias UnsignedVoid = Unsigned!(T);
+        return cast(T)(cast(T)(cast(UnsignedVoid)(a-b) / 2));
+}
+
+static assert(is(typeof(f!(void*)(null, null)) == void*));
+// { dg-error "static assert  \(.*\) is false" "" { target *-*-* } .-1 }
diff --git a/gcc/testsuite/gdc.dg/pr96140.d b/gcc/testsuite/gdc.dg/pr96140.d
new file mode 100644
index 00000000000..d25bb5d3360
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr96140.d
@@ -0,0 +1,15 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96140
+// { dg-do compile }
+module pr94140;
+
+import core.stdc.stdarg;
+
+void test_va_arg(ref int a, ...)
+{
+    return va_arg!int(_argptr, a);
+}
+
+void test_va_start(ref va_list a, ...)
+{
+    return va_start(a, a);
+}
diff --git a/gcc/testsuite/gdc.dg/pr98277.d b/gcc/testsuite/gdc.dg/pr98277.d
new file mode 100644
index 00000000000..d3b859fcbda
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr98277.d
@@ -0,0 +1,13 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98277
+// { dg-do compile }
+
+enum Side
+{
+    left,
+    right
+}
+
+ref int getSide(Side side, ref int left, ref int right)
+{
+    return side == Side.left ? left : right;
+}
diff --git a/gcc/testsuite/gdc.test/compilable/imports/pr9471a.d b/gcc/testsuite/gdc.test/compilable/imports/pr9471a.d
new file mode 100644
index 00000000000..79b78e1e52a
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/imports/pr9471a.d
@@ -0,0 +1,2 @@
+import imports.pr9471c;
+class AggregateDeclaration : ScopeDsymbol { }
diff --git a/gcc/testsuite/gdc.test/compilable/imports/pr9471b.d b/gcc/testsuite/gdc.test/compilable/imports/pr9471b.d
new file mode 100644
index 00000000000..a46a12c496f
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/imports/pr9471b.d
@@ -0,0 +1,5 @@
+import imports.pr9471a;
+class ClassDeclaration : AggregateDeclaration
+{
+    void isBaseOf();
+}
diff --git a/gcc/testsuite/gdc.test/compilable/imports/pr9471c.d b/gcc/testsuite/gdc.test/compilable/imports/pr9471c.d
new file mode 100644
index 00000000000..d80a61480ce
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/imports/pr9471c.d
@@ -0,0 +1,18 @@
+import imports.pr9471b;
+
+struct Array(T)
+{
+    static if (is(typeof(T.opCmp))) { }
+}
+alias ClassDeclarations = Array!ClassDeclaration;
+
+class Dsymbol
+{
+    void addObjcSymbols(ClassDeclarations);
+}
+
+class ScopeDsymbol : Dsymbol
+{
+    import imports.pr9471d;
+    void importScope();
+}
diff --git a/gcc/testsuite/gdc.test/compilable/imports/pr9471d.d b/gcc/testsuite/gdc.test/compilable/imports/pr9471d.d
new file mode 100644
index 00000000000..187b9083294
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/imports/pr9471d.d
@@ -0,0 +1 @@
+// Module needs to be imported to trigger bug.
diff --git a/gcc/testsuite/gdc.test/compilable/pr9471.d b/gcc/testsuite/gdc.test/compilable/pr9471.d
new file mode 100644
index 00000000000..37ff32e4957
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/pr9471.d
@@ -0,0 +1,6 @@
+// PERMUTE_ARGS:
+// EXTRA_FILES: imports/pr9471a.d imports/pr9471b.d imports/pr9471c.d imports/pr9471d.d
+import imports.pr9471a;
+import imports.pr9471b;
+
+static assert (__traits(getVirtualIndex, ClassDeclaration.isBaseOf) == 7);
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail21001.d b/gcc/testsuite/gdc.test/fail_compilation/fail21001.d
new file mode 100644
index 00000000000..0faeb4038ef
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail21001.d
@@ -0,0 +1,12 @@
+/*
+TEST_OUTPUT:
+---
+fail_compilation/fail21001.d(12): Error: undefined identifier `Alias`
+---
+*/
+
+module fail21001;
+
+import imports.fail21001b;
+
+void main() { Alias var; }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/imports/fail21001b.d b/gcc/testsuite/gdc.test/fail_compilation/imports/fail21001b.d
new file mode 100644
index 00000000000..69c1c20a356
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/imports/fail21001b.d
@@ -0,0 +1,5 @@
+module imports.fail21001b;
+
+private struct S { Alias member; }
+
+private alias Alias = int;
diff --git a/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295ast_node.d b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295ast_node.d
new file mode 100644
index 00000000000..d9298bf972d
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295ast_node.d
@@ -0,0 +1,5 @@
+module imports.issue21295ast_node;
+import imports.issue21295visitor : Visitor;
+class ASTNode {
+    void accept(Visitor);
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295astcodegen.d b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295astcodegen.d
new file mode 100644
index 00000000000..5eccf6ac028
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295astcodegen.d
@@ -0,0 +1,4 @@
+module imports.issue21295astcodegen;
+struct ASTCodegen {
+    import imports.issue21295dtemplate;
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295dtemplate.d b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295dtemplate.d
new file mode 100644
index 00000000000..8864f9ea27e
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295dtemplate.d
@@ -0,0 +1,3 @@
+module imports.issue21295dtemplate;
+import imports.issue21295ast_node;
+class TemplateParameter : ASTNode { }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295visitor.d b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295visitor.d
new file mode 100644
index 00000000000..3665a7fe8c2
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/imports/issue21295visitor.d
@@ -0,0 +1,3 @@
+module imports.issue21295visitor;
+import imports.issue21295astcodegen;
+class Visitor { }
diff --git a/gcc/testsuite/gdc.test/fail_compilation/issue21295.d b/gcc/testsuite/gdc.test/fail_compilation/issue21295.d
new file mode 100644
index 00000000000..9916e9ba2a7
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/issue21295.d
@@ -0,0 +1,9 @@
+/*
+REQUIRED_ARGS: -de
+TEST_OUTPUT:
+---
+fail_compilation/issue21295.d(9): Deprecation: imports.issue21295ast_node.Visitor is not visible from module issue21295
+---
+*/
+import imports.issue21295ast_node;
+Visitor should_fail;
diff --git a/gcc/testsuite/gfortran.dg/bessel_5_redux.f90 b/gcc/testsuite/gfortran.dg/bessel_5_redux.f90
new file mode 100644
index 00000000000..72d2db43959
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bessel_5_redux.f90
@@ -0,0 +1,85 @@
+! { dg-do compile }
+! { dg-options "-Wall" }
+!
+! Check fix for PR94246 in which the errors in line 63 caused a segfault
+! because the cleanup was not done correctly without the -fno-range-check option.
+!
+! This is a copy of bessel_5.f90 with the error messages added.
+!
+! -Wall has been specified to disabled -pedantic, which warns about the
+! negative order (GNU extension) to the order of the Bessel functions of
+! first and second kind.
+!
+
+implicit none
+integer :: i
+
+
+! Difference to mpfr_jn <= 1 epsilon
+
+if (any (abs (BESSEL_JN(2, 5, 2.457) - [(BESSEL_JN(i, 2.457), i = 2, 5)]) &
+          > epsilon(0.0))) then
+  print *, 'FAIL 1'
+  STOP 1
+end if
+
+
+! Difference to mpfr_yn <= 4 epsilon
+
+if (any (abs (BESSEL_YN(2, 5, 2.457) - [(BESSEL_YN(i, 2.457), i = 2, 5)]) &
+         > epsilon(0.0)*4)) then
+  STOP 2
+end if
+
+
+! Difference to mpfr_jn <= 1 epsilon
+
+if (any (abs (BESSEL_JN(0, 10, 4.457) &
+              - [ (BESSEL_JN(i, 4.457), i = 0, 10) ]) &
+         > epsilon(0.0))) then
+  STOP 3
+end if
+
+
+! Difference to mpfr_yn <= 192 epsilon
+
+if (any (abs (BESSEL_YN(0, 10, 4.457) &
+              - [ (BESSEL_YN(i, 4.457), i = 0, 10) ]) &
+         > epsilon(0.0)*192)) then
+  STOP 4
+end if
+
+
+! Difference to mpfr_jn: None.  (Special case: X = 0.0)
+
+if (any (BESSEL_JN(0, 10, 0.0) /= [ (BESSEL_JN(i, 0.0), i = 0, 10) ])) &
+then
+  STOP 5
+end if
+
+
+! Difference to mpfr_yn: None.  (Special case: X = 0.0)
+
+if (any (BESSEL_YN(0, 10, 0.0) /= [ (BESSEL_YN(i, 0.0), i = 0, 10) ])) & ! { dg-error "overflows|-INF" }
+then
+  STOP 6
+end if
+
+
+! Difference to mpfr_jn <= 1 epsilon
+
+if (any (abs (BESSEL_JN(0, 10, 1.0) &
+              - [ (BESSEL_JN(i, 1.0), i = 0, 10) ]) &
+         > epsilon(0.0)*1)) then
+ STOP 7
+end if
+
+! Difference to mpfr_yn <= 32 epsilon
+
+if (any (abs (BESSEL_YN(0, 10, 1.0) &
+              - [ (BESSEL_YN(i, 1.0), i = 0, 10) ]) &
+         > epsilon(0.0)*32)) then
+  STOP 8
+end if
+
+end
diff --git a/gcc/testsuite/gfortran.dg/char_length_23.f90 b/gcc/testsuite/gfortran.dg/char_length_23.f90
new file mode 100644
index 00000000000..e9ddbc7b8fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/char_length_23.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+!
+! Test the fix for PRs 96100 and 96101.
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+program p
+   type t
+      character(:), allocatable :: c(:)
+   end type
+   type(t) :: x
+   character(:), allocatable :: w
+
+! PR96100
+   allocate(x%c(2), source = 'def')
+   associate (y => [x%c(1:1)])       ! ICE
+     print *,y
+   end associate
+
+! PR96101
+   associate (y => ([w(:)]))
+      print *, y                     ! ICE
+   end associate
+
+end
diff --git a/gcc/testsuite/gfortran.dg/charlen_18.f90 b/gcc/testsuite/gfortran.dg/charlen_18.f90
new file mode 100644
index 00000000000..5ad287448b4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/charlen_18.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! Check fix for PR98517
+!
+! Contributed by Eric Reischer  <emr-gnu@hev.psu.edu>
+!
+      SUBROUTINE TEST_BUG
+      IMPLICIT NONE
+
+      CHARACTER*(*) DEF_VAL
+      PARAMETER (DEF_VAL = 'ABCDEFGH')
+
+      STRUCTURE /SOME_STRUCT/
+          CHARACTER*64    SOME_VAR /DEF_VAL/
+      END STRUCTURE
+
+      END
diff --git a/gcc/testsuite/gfortran.dg/class_allocate_25.f90 b/gcc/testsuite/gfortran.dg/class_allocate_25.f90
new file mode 100644
index 00000000000..4e5855f8fb8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_allocate_25.f90
@@ -0,0 +1,58 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! In the course of fixing PR83118, lots of issues came up with class array
+! assignment, where temporaries are generated. This testcase checks that
+! the use of assignment by allocate with source is OK, especially with array
+! constructors using class arrays. While this test did run previously, the
+! temporaries for such arrays were malformed with the class as the type and
+! element lengths of 72 bytes rather than the 4 bytes of the decalred type.
+!
+! Contributed by Dominique d'Humieres  <dhumieres.dominique@free.fr>
+!
+type t1
+   integer :: i = 5
+end type t1
+type, extends(t1) :: t2
+   integer :: j = 6
+end type t2
+
+class(t1), allocatable :: a(:), b(:), c(:)
+integer :: i
+
+allocate(t2 :: a(3))
+allocate(t2 :: b(5))
+if (.not.check_t1 (a, [(5, i = 1, 3)], 2)) stop 1
+
+allocate(c, source=[a, b ]) ! F2008, PR 44672
+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 2
+
+deallocate(c)
+allocate(c(8), source=[ a, b ])
+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 3
+
+deallocate(c)
+c = [t1 :: a, b ] ! F2008, PR 43366
+if (.not.check_t1 (c, [(5, i = 1, 8)], 1)) stop 4
+deallocate(a, b, c)
+
+contains
+
+  logical function check_t1 (arg, array, t)
+    class(t1) :: arg(:)
+    integer :: array (:), t
+    check_t1 = .true.
+    select type (arg)
+    type is (t1)
+      if (any (arg%i .ne. array)) check_t1 = .false.
+      if (t .eq. 2) check_t1 = .false.
+    type is (t2)
+      if (any (arg%i .ne. array)) check_t1 = .false.
+      if (t .eq. 1) check_t1 = .false.
+    class default
+      check_t1 = .false.
+    end select
+  end function check_t1
+
+end
+! { dg-final { scan-tree-dump-times "elem_len=72" 0 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/class_assign_4.f90 b/gcc/testsuite/gfortran.dg/class_assign_4.f90
new file mode 100644
index 00000000000..2a77d8111b5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_assign_4.f90
@@ -0,0 +1,185 @@
+! { dg-do run }
+!
+! In the course of fixing PR83118, lots of issues came up with class array
+! assignment, where temporaries are generated. This testcase checks that
+! it all works correctly.
+!
+! Contributed by Paul Thomas  <pault@gcc.gnu.org>
+!
+module m
+  implicit none
+  type :: t1
+    integer :: i
+  CONTAINS
+  end type
+  type, extends(t1) :: t2
+    real :: r
+  end type
+
+  interface operator(+)
+    module procedure add_t1
+  end interface
+
+contains
+  function add_t1 (a, b) result (c)
+    class(t1), intent(in) :: a(:), b(:)
+    class(t1), allocatable :: c(:)
+    allocate (c, source = a)
+    c%i = a%i + b%i
+    select type (c)
+      type is (t2)
+      select type (b)
+        type is (t2)
+          c%r = c%r + b%r
+      end select
+    end select
+  end function add_t1
+
+end module m
+
+subroutine test_t1
+  use m
+  implicit none
+
+  class(t1), dimension(:), allocatable :: x, y
+
+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]
+  if (.not.check_t1 (x, [1,2,3], 2, [10, 20, 30]) ) stop 1
+
+  y = x
+  x = realloc_t1 (y)
+  if (.not.check_t1 (x, [3,2,1], 1) ) stop 2
+
+  x = realloc_t1 (x)
+  if (.not.check_t1 (x, [2,3,1], 1) ) stop 3
+
+  x = x([3,1,2])
+  if (.not.check_t1 (x, [1,2,3], 1) ) stop 4
+
+  x = x(3:1:-1) + y
+  if (.not.check_t1 (x, [4,4,4], 1) ) stop 5
+
+  x = y + x(3:1:-1)
+  if (.not.check_t1 (x, [5,6,7], 2) ) stop 6
+
+! Now check that the dynamic type survives assignments.
+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]
+  y = x
+
+  x = y(3:1:-1)
+  if (.not.check_t1 (x, [3,2,1], 2, [30,20,10]) ) stop 7
+
+  x = x(3:1:-1) + y
+  if (.not.check_t1 (x, [2,4,6], 2, [20,40,60]) ) stop 8
+
+  x = x(3:1:-1)
+  if (.not.check_t1 (x, [6,4,2], 2, [60,40,20]) ) stop 9
+
+  x = x([3,2,1])
+  if (.not.check_t1 (x, [2,4,6], 2, [20,40,60]) ) stop 10
+
+contains
+
+  function realloc_t1 (arg) result (res)
+    class(t1), dimension(:), allocatable :: arg
+    class(t1), dimension(:), allocatable :: res
+    select type (arg)
+      type is (t2)
+        allocate (res, source = [t1 (arg(3)%i), t1 (arg(2)%i), t1 (arg(1)%i)])
+      type is (t1)
+        allocate (res, source = [t1 (arg(2)%i), t1 (arg(1)%i), t1 (arg(3)%i)])
+    end select
+  end function realloc_t1
+
+  logical function check_t1 (arg, array, t, array2)
+    class(t1) :: arg(:)
+    integer :: array (:), t
+    integer, optional :: array2(:)
+    check_t1 = .true.
+    select type (arg)
+    type is (t1)
+      if (any (arg%i .ne. array)) check_t1 = .false.
+      if (t .eq. 2) check_t1 = .false.
+    type is (t2)
+      if (any (arg%i .ne. array)) check_t1 = .false.
+      if (t .eq. 1) check_t1 = .false.
+      if (present (array2)) then
+        if (any(int (arg%r) .ne. array2)) check_t1 = .false.
+      end if
+    class default
+      check_t1 = .false.
+    end select
+  end function check_t1
+
+end subroutine test_t1
+
+subroutine test_star
+  use m
+  implicit none
+
+  class(*), dimension(:), allocatable :: x, y
+
+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]
+  if (.not.check_star (x, [1,2,3], 2) ) stop 11
+
+  y = x
+  x = realloc_star (y)
+  if (.not.check_star (x, [3,2,1], 1) ) stop 12
+
+  x = realloc_star (x)
+  if (.not.check_star (x, [2,3,1], 1) ) stop 13
+
+  x = x([3,1,2])
+  if (.not.check_star (x, [1,2,3], 1) ) stop 14
+
+  x = x(3:1:-1)
+  if (.not.check_star (x, [3,2,1], 1) ) stop 15
+
+! Make sure that all is similarly well with type t2.
+  x = [t2(1,10.0),t2(2,20.0),t2(3,30.0)]
+
+  x = x([3,1,2])
+  if (.not.check_star (x, [3,1,2], 2, [30,10,20]) ) stop 16
+
+  x = x(3:1:-1)
+  if (.not.check_star (x, [2,1,3], 2, [20,10,30]) ) stop 17
+
+contains
+
+  function realloc_star (arg) result (res)
+    class(*), dimension(:), allocatable :: arg
+    class(*), dimension(:), allocatable :: res
+    select type (arg)
+      type is (t2)
+         allocate (res, source = [t1 (arg(3)%i), t1 (arg(2)%i), t1 (arg(1)%i)])
+      type is (t1)
+         allocate (res, source = [t1 (arg(2)%i), t1 (arg(1)%i), t1 (arg(3)%i)])
+    end select
+  end function realloc_star
+
+  logical function check_star (arg, array, t, array2)
+    class(*) :: arg(:)
+    integer :: array (:), t
+    integer, optional :: array2(:)
+    check_star = .true.
+    select type (arg)
+      type is (t1)
+        if (any (arg%i .ne. array)) check_star = .false.
+        if (t .eq. 2) check_star = .false.
+      type is (t2)
+        if (any (arg%i .ne. array)) check_star = .false.
+        if (t .eq. 1) check_star = .false.
+        if (present (array2)) then
+          if (any (int(arg%r) .ne. array2)) check_star = .false.
+        endif
+      class default
+        check_star = .false.
+    end select
+  end function check_star
+
+end subroutine test_star
+
+
+  call test_t1
+  call test_star
+end
diff --git a/gcc/testsuite/gfortran.dg/class_defined_operator_2.f03 b/gcc/testsuite/gfortran.dg/class_defined_operator_2.f03
new file mode 100644
index 00000000000..b7d53b84e2a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_defined_operator_2.f03
@@ -0,0 +1,31 @@
+! { dg-do run }
+!
+! Test the fix for PR99124 which used to ICE as shown.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+module m
+   type t
+      integer :: i
+   contains
+      procedure :: f
+      generic :: operator(+) => f
+   end type
+contains
+   elemental function f(a, b) result(c)
+      class(t), intent(in) :: a, b
+      type(t) :: c
+      c = t(a%i + b%i)
+   end
+end
+program p
+   use m
+   class(t), allocatable :: x(:), y(:), z
+   allocate (x, source = [t(1), t(2)])
+   allocate (y, source = [t(1), t(2)])
+   x = x(2) + y                               ! ICE
+   if (any (x%i .ne. [3, 4])) stop 1
+   z = x(1)
+   x = z + y                                  ! ICE
+   if (any (x%i .ne. [4, 5])) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/contiguous_10.f90 b/gcc/testsuite/gfortran.dg/contiguous_10.f90
new file mode 100644
index 00000000000..82b8ed54f5b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/contiguous_10.f90
@@ -0,0 +1,69 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/91640
+!
+! Based on G. Steinmetz's test case
+!
+program p
+   implicit none (type, external)
+   real, target :: z(3) = 1.0
+   real :: res(3)
+   real, pointer :: xxx(:)
+
+   res = 42.0
+   call sub (-z, res)
+   if (any (abs (res - (-1.0)) > epsilon(res))) stop 1
+   if (any (abs (z - 1.0) > epsilon(z))) stop 2
+
+   res = 43.0
+   call sub (z*2.0, res)
+   if (any (abs (res - 2.0) > epsilon(res))) stop 3
+   if (any (abs (z - 1.0) > epsilon(z))) stop 4
+
+   res = 44.0
+   call sub(get_var(), res)
+   if (any (abs (res - 1.0) > epsilon(res))) stop 5
+   if (any (abs (z - 1.0) > epsilon(z))) stop 6
+
+   call double(get_var())
+   if (any (abs (z - 2.0) > epsilon(z))) stop 7
+
+   call double(get_var_cont())
+   if (any (abs (z - 4.0) > epsilon(z))) stop 8
+
+   ! For cross check for copy-out:
+   xxx => z
+   if (any (abs (z - 4.0) > epsilon(z))) stop 10
+   if (any (abs (xxx - 4.0) > epsilon(z))) stop 11
+   call double (xxx)
+   if (any (abs (z - 8.0) > epsilon(z))) stop 12
+   if (any (abs (xxx - 8.0) > epsilon(z))) stop 13
+
+contains
+   subroutine sub (x, res)
+      real, contiguous :: x(:)
+      real :: res(3)
+      res = x
+   end
+   subroutine double (x)
+      real, contiguous :: x(:)
+      x = x * 2.0
+   end
+   function get_var()
+     real, pointer :: get_var(:)
+     get_var => z
+   end
+   function get_var_cont()
+     real, pointer, contiguous :: get_var_cont(:)
+     get_var_cont => z
+   end
+end
+
+! only 'xxx' should have a copy out:
+! { dg-final { scan-tree-dump-times "D\\.\[0-9\].* = .*atmp\\.\[0-9\]*\\.data" 1 "original" } }
+! { dg-final { scan-tree-dump-times "D\\.\[0-9\].*xxx\\.span.* = .*atmp\\.\[0-9\]*\\.data" 1 "original" } }
+
+! Only once 'z... = ' – for:   static real(kind=4) z[3] = {[0 ... 2]=1.0e+0};
+! but don't match '(si)ze'
+! { dg-final { scan-tree-dump-times "z\[^e\].* = " 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/coverage.f90 b/gcc/testsuite/gfortran.dg/coverage.f90
new file mode 100644
index 00000000000..e0800f869c1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coverage.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-additional-options "-fprofile-arcs -ftest-coverage" }
+!
+! PR fortran/95847
+!
+module foo
+contains
+    subroutine sbr()
+    end subroutine sbr
+end module foo
+
+function foo_suite() result(suite)
+   use foo
+   integer :: bar
+   integer :: res
+   res = bar(sbr)
+end function foo_suite
diff --git a/gcc/testsuite/gfortran.dg/data_inquiry_ref.f90 b/gcc/testsuite/gfortran.dg/data_inquiry_ref.f90
new file mode 100644
index 00000000000..de320f178ed
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/data_inquiry_ref.f90
@@ -0,0 +1,39 @@
+! { dg-do compile }
+!
+! Test the fix for PR98022. Code is in place to deliver the expected result.
+! However, it was determined that the data statements below violate F18(R841)
+! and so an error results.
+!
+! Contributed by Arseny Solokha  <asolokha@gmx.com>
+!
+module ur
+contains
+! The reporter's test.
+  function kn1() result(hm2)
+    complex :: hm(1:2), hm2(1:3), scalar
+    data (hm(md)%re, md=1,2)/1.0, 2.0/, scalar%re/42.0/     ! { dg-error "neither an array-element" }
+    data (hm(md)%im, md=1,2)/0.0, 0.0/, scalar%im/-42.0/    ! { dg-error "neither an array-element" }
+    hm2(1:2) = hm
+    hm2(3) = scalar
+  end function kn1
+
+! Check for derived types with complex components.
+  function kn2() result(hm2)
+    type t
+      complex :: c
+      integer :: i
+    end type
+    type (t) :: hm(1:2), scalar
+    complex :: hm2(1:3)
+    data (hm(md)%c%re, md=1,2)/0.0, 0.0/, scalar%c%re/42.0/  ! { dg-error "neither an array-element" }
+    data (hm(md)%c%im, md=1,2)/1.0, 2.0/, scalar%c%im/-42.0/ ! { dg-error "neither an array-element" }
+    data (hm(md)%i, md=1,2)/1, 2/
+    hm2(1:2) = hm%c
+    hm2(3) = scalar%c
+  end function kn2
+end module ur
+
+!  use ur
+!  if (any (kn1() .ne. [(1.0,0.0),(2.0,0.0),(42.0,-42.0)])) stop 1
+!  if (any (kn2() .ne. [(0.0,1.0),(0.0,2.0),(42.0,-42.0)])) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_28.f90 b/gcc/testsuite/gfortran.dg/dec_structure_28.f90
new file mode 100644
index 00000000000..bab08b2d5c3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_structure_28.f90
@@ -0,0 +1,35 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure -fdec-static" }
+!
+! PR fortran/85982
+!
+! Test a regression wherein some component attributes were erroneously accepted
+! within a DEC structure.
+!
+
+structure /s/
+  integer :: a
+  integer, intent(in) :: b ! { dg-error "is not allowed" }
+  integer, intent(out) :: c ! { dg-error "is not allowed" }
+  integer, intent(inout) :: d ! { dg-error "is not allowed" }
+  integer, dimension(1,1) :: e ! OK
+  integer, external, pointer :: f ! { dg-error "is not allowed" }
+  integer, intrinsic :: f ! { dg-error "is not allowed" }
+  integer, optional :: g ! { dg-error "is not allowed" }
+  integer, parameter :: h ! { dg-error "is not allowed" }
+  integer, protected :: i ! { dg-error "is not allowed" }
+  integer, private :: j ! { dg-error "is not allowed" }
+  integer, static :: k ! { dg-error "is not allowed" }
+  integer, automatic :: l ! { dg-error "is not allowed" }
+  integer, public :: m ! { dg-error "is not allowed" }
+  integer, save :: n ! { dg-error "is not allowed" }
+  integer, target :: o ! { dg-error "is not allowed" }
+  integer, value :: p ! { dg-error "is not allowed" }
+  integer, volatile :: q ! { dg-error "is not allowed" }
+  integer, bind(c) :: r ! { dg-error "is not allowed" }
+  integer, asynchronous :: t ! { dg-error "is not allowed" }
+  character(len=3) :: v ! OK
+  integer(kind=4) :: w ! OK
+end structure
+
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_36.f90 b/gcc/testsuite/gfortran.dg/deferred_character_36.f90
new file mode 100644
index 00000000000..65f2464e54e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_36.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+!
+! Test the fix for PR93833, which ICEd as shown.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), allocatable :: c
+   c = "wxyz"
+contains
+   subroutine s
+      associate (y => [c])
+         if (any(y /= [c])) stop 1
+      end associate
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/dependency_60.f90 b/gcc/testsuite/gfortran.dg/dependency_60.f90
new file mode 100644
index 00000000000..bf108122f3e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dependency_60.f90
@@ -0,0 +1,19 @@
+! { dg-do run }
+! PR 92755 - this used to cause an ICE (see dependency_57.f90)
+! PR83118 - fixed so that it would run :-)
+! Original test case by Gerhard Steinmetz
+program p
+   type t
+     integer :: i
+   end type
+   type t2
+      class(t), allocatable :: a(:)
+   end type
+   type(t2) :: z
+   z%a = [t(1),t(2),t(3)]
+   z%a = [z%a]
+   select type (y => z%a)
+     type is (t)
+       if (any (y%i .ne. [1, 2, 3])) stop 1
+   end select
+end
diff --git a/gcc/testsuite/gfortran.dg/elemental_result_2.f90 b/gcc/testsuite/gfortran.dg/elemental_result_2.f90
new file mode 100644
index 00000000000..490c2ef68de
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/elemental_result_2.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+!
+! Test part of the fix for PR99124 which adds errors for class results
+! That violate F2018, C15100.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+module m
+   type t
+      integer :: i
+   contains
+      procedure :: f
+      generic :: operator(+) => f
+   end type
+contains
+   elemental function f(a, b) &
+   result(c)                     ! { dg-error "shall not have an ALLOCATABLE or POINTER attribute" }
+      class(t), intent(in) :: a, b
+      class(t), allocatable :: c
+      c = t(a%i + b%i)
+   end
+   elemental function g(a, b) &
+   result(c)                     ! { dg-error "shall not have an ALLOCATABLE or POINTER attribute" }
+      class(t), intent(in) :: a, b
+      class(t), pointer :: c
+      c => null ()
+   end
+   elemental function h(a, b) &  ! { dg-error "must have a scalar result" }
+   result(c)                     ! { dg-error "must be dummy, allocatable or pointer" }
+      class(t), intent(in) :: a, b
+      class(t) :: c(2)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/equiv_11.f90 b/gcc/testsuite/gfortran.dg/equiv_11.f90
new file mode 100644
index 00000000000..0f4a1ab5c32
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/equiv_11.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-fsecond-underscore" }
+! PR fortran/95106
+
+module m2345678901234567890123456789012345678901234567890123456789_123
+  implicit none
+  real :: a(4), u(3,2)
+  real :: b(4), v(4,2)
+  equivalence (a(1),u(1,1)), (b(1),v(1,1))
+end
+! { dg-final { scan-assembler {m2345678901234567890123456789012345678901234567890123456789_123.eq.0__} } }
+! { dg-final { scan-assembler {m2345678901234567890123456789012345678901234567890123456789_123.eq.1__} } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_28.f90 b/gcc/testsuite/gfortran.dg/finalize_28.f90
index 597413b2dd3..f0c9665252f 100644
--- a/gcc/testsuite/gfortran.dg/finalize_28.f90
+++ b/gcc/testsuite/gfortran.dg/finalize_28.f90
@@ -21,4 +21,4 @@ contains
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_33.f90 b/gcc/testsuite/gfortran.dg/finalize_33.f90
index 2205f9eed7f..3857e4485ee 100644
--- a/gcc/testsuite/gfortran.dg/finalize_33.f90
+++ b/gcc/testsuite/gfortran.dg/finalize_33.f90
@@ -116,4 +116,4 @@ contains
                                                ! (iii) mci_template
 end program main_ut
 ! { dg-final { scan-tree-dump-times "__builtin_malloc" 17 "original" } }
-! { dg-final { scan-tree-dump-times "__builtin_free" 19 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 20 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_34.f90 b/gcc/testsuite/gfortran.dg/finalize_34.f90
index e2f02a5c51c..8fb801d4235 100644
--- a/gcc/testsuite/gfortran.dg/finalize_34.f90
+++ b/gcc/testsuite/gfortran.dg/finalize_34.f90
@@ -22,4 +22,4 @@ program main
   use testmodule
   type(evtlist_type), dimension(10) :: a
 end program main
-! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
+! { dg-final  { scan-tree-dump-times "__builtin_free" 24 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_35.f90 b/gcc/testsuite/gfortran.dg/finalize_35.f90
new file mode 100644
index 00000000000..66435c43ecc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/finalize_35.f90
@@ -0,0 +1,48 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 94361 - this left open some memory leaks.  Original test case by
+! Antony Lewis.
+
+module debug
+  private
+
+  Type TypeWithFinal
+   contains
+     FINAL :: finalizer  !No leak if this line is commented
+  end type TypeWithFinal
+
+  Type Tester
+     real, dimension(:), allocatable :: Dat
+     Type(TypeWithFinal) :: X
+  end Type Tester
+
+  Type :: TestType2
+     Type(Tester) :: T
+  end type TestType2
+  public Leaker
+contains
+
+  subroutine Leaker
+    type(TestType2) :: Test
+
+    allocate(Test%T%Dat(1000))
+  end subroutine Leaker
+
+  subroutine finalizer(this)
+    Type(TypeWithFinal) :: this
+  end subroutine finalizer
+
+end module debug
+
+
+program run
+  use debug
+  implicit none
+  integer i
+
+  do i=1, 1000
+     call Leaker()
+  end do
+
+end program run
+! { dg-final  { scan-tree-dump-times "__builtin_free\\ \\(ptr2" 2 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_36.f90 b/gcc/testsuite/gfortran.dg/finalize_36.f90
new file mode 100644
index 00000000000..432f5472aeb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/finalize_36.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 94109
+! This used to leak memory.  Test case by Antony Lewis.
+    module debug
+    implicit none
+
+    Type Tester
+        real, dimension(:), allocatable :: Dat, Dat2
+    end Type
+
+    Type TestType2
+        Type(Tester) :: T
+    end type TestType2
+
+    contains
+
+    subroutine Leaker
+    class(TestType2), pointer :: ActiveState
+    Type(Tester) :: Temp
+
+    allocate(Temp%Dat2(10000))
+
+    allocate(TestType2::ActiveState)
+    ActiveState%T = Temp
+    deallocate(ActiveState)
+
+    end subroutine
+
+    end module
+
+
+    program run
+    use debug
+
+    call Leaker()
+
+    end program
+! { dg-final { scan-tree-dump-times "__builtin_free\\ \\(ptr2" 4 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_37.f90 b/gcc/testsuite/gfortran.dg/finalize_37.f90
new file mode 100644
index 00000000000..6d5be0247c9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/finalize_37.f90
@@ -0,0 +1,80 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/92587
+!
+
+module m
+  implicit none (type, external)
+  type t2
+  contains
+    final :: fini
+  end type
+  type t3
+    type(t2) :: a
+  end type
+  type, extends(t3) :: t4
+  end type
+  class(t4), allocatable :: y
+  class(t4), allocatable :: z
+  integer :: fini_cnt = 0
+contains
+  subroutine sub
+    y = z
+  end
+  subroutine fini(x)
+    type(t2) :: x
+    fini_cnt = fini_cnt + 1
+  end
+end
+
+module m2
+  use m
+  implicit none (type, external)
+  type, extends(t3) :: t5
+  end type
+  type, extends(t3) :: t6
+  contains
+    final :: fin2
+  end type
+  integer :: fin2_cnt = 0
+contains
+  subroutine bar(x, y, z)
+    class(t4), allocatable, intent(out) :: x
+    class(t5), allocatable, intent(out) :: y
+    class(t6), allocatable, intent(out) :: z
+  end
+  subroutine fin2 (x)
+    type(t6) :: x
+    fin2_cnt = fin2_cnt + 1
+  end
+end  
+
+  use m
+  use m2
+  implicit none (type, external)
+  class(t4), allocatable :: x2
+  class(t5), allocatable :: y2
+  class(t6), allocatable :: z2
+
+  if (fini_cnt /= 0 .or. fin2_cnt /= 0) stop 1
+  call bar (x2, y2, z2)
+  if (fini_cnt /= 0 .or. fin2_cnt /= 0) stop 2
+  if (allocated(x2) .or. allocated(y2) .or. allocated(z2)) stop 3
+
+  allocate(t4 :: x2)
+  allocate(t5 :: y2)
+  allocate(t6 :: z2)
+  call bar (x2, y2, z2)
+  if (fini_cnt /= 3 .or. fin2_cnt /= 1) stop 4
+  if (allocated(x2) .or. allocated(y2) .or. allocated(z2)) stop 5
+
+  allocate(t6 :: z2)
+  call bar (x2, y2, z2)
+  if (fini_cnt /= 4 .or. fin2_cnt /= 2) stop 6
+  if (allocated(x2) .or. allocated(y2) .or. allocated(z2)) stop 7
+end
+
+! { dg-final { scan-tree-dump "__final_m_T2 \\\(struct" "original" } }
+! { dg-final { scan-tree-dump "__final_m_T3 \\\(struct" "original" } }
+! { dg-final { scan-tree-dump "__final_m2_T6 \\\(struct" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/fmt_en.f90 b/gcc/testsuite/gfortran.dg/fmt_en.f90
index b3597e4a423..c8f61cbc369 100644
--- a/gcc/testsuite/gfortran.dg/fmt_en.f90
+++ b/gcc/testsuite/gfortran.dg/fmt_en.f90
@@ -10,7 +10,6 @@ use ISO_FORTRAN_ENV
     integer :: n_tst = 0, n_cnt = 0, n_skip = 0
     character(len=20) :: s, s1
 
-    open (unit = 10, file = 'fmt_en.res')
 !   Check that the default rounding mode is to nearest and to even on tie.
     do i=1,size(real_kinds)
       if (i == 1) then
@@ -149,8 +148,7 @@ use ISO_FORTRAN_ENV
 
     ! print *, n_tst, n_cnt, n_skip
     if (n_cnt /= 0) STOP 1
-    if (all(.not. l_skip)) write (10, *) "All kinds rounded to nearest"
-    close (10)
+    if (all(.not. l_skip)) print *, "All kinds rounded to nearest"
 
 contains
     subroutine checkfmt(fmt, x, cmp)
@@ -182,4 +180,4 @@ contains
         
     end subroutine
 end program
-! { dg-final { scan-file fmt_en.res "All kinds rounded to nearest" { xfail hppa*-*-hpux* } } }
+! { dg-output "All kinds rounded to nearest" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
diff --git a/gcc/testsuite/gfortran.dg/fmt_en_rd.f90 b/gcc/testsuite/gfortran.dg/fmt_en_rd.f90
new file mode 100644
index 00000000000..ea914e0901c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_en_rd.f90
@@ -0,0 +1,185 @@
+! { dg-do run }
+! PR60128 Invalid outputs with EN descriptors
+! Test case provided by Walt Brainerd.
+program pr60128
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20,kind=4) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= 4_'-9.5 9.5 10.  8.' .or. s1 /= 4_' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(en15.2)", -.44444,    4_"    -444.44E-03")
+
+! Test for the bug in comment 6.
+    call checkfmt("(rd,en15.0)", 1.0,        4_"         1.E+00")
+    call checkfmt("(rd,en15.0)", 1.00000012, 4_"         1.E+00")
+    call checkfmt("(rd,en15.0)", 0.99999994, 4_"       999.E-03")
+    call checkfmt("(rd,en15.0)", 10.0,       4_"        10.E+00")
+    call checkfmt("(rd,en15.0)", 10.0000010, 4_"        10.E+00")
+    call checkfmt("(rd,en15.0)", 9.99999905, 4_"         9.E+00")
+    call checkfmt("(ru,en15.0)", 100.0,      4_"       100.E+00")
+    call checkfmt("(rd,en15.0)", 100.000008, 4_"       100.E+00")
+    call checkfmt("(rd,en15.0)", 99.9999924, 4_"        99.E+00")
+    call checkfmt("(rd,en15.0)", 1000.0,     4_"         1.E+03")
+    call checkfmt("(rd,en15.0)", 1000.00006, 4_"         1.E+03")
+    call checkfmt("(rd,en15.0)", 999.999939, 4_"       999.E+00")
+    call checkfmt("(rd,en15.0)", 9.5,        4_"         9.E+00")
+    call checkfmt("(rd,en15.0)", 9.50000095, 4_"         9.E+00")
+    call checkfmt("(rd,en15.0)", 9.49999905, 4_"         9.E+00")
+    call checkfmt("(rd,en15.0)", 99.5,       4_"        99.E+00")
+    call checkfmt("(rd,en15.0)", 99.5000076, 4_"        99.E+00")
+    call checkfmt("(rd,en15.0)", 99.4999924, 4_"        99.E+00")
+    call checkfmt("(rd,en15.0)", 999.5,      4_"       999.E+00")
+    call checkfmt("(rd,en15.0)", 999.500061, 4_"       999.E+00")
+    call checkfmt("(rd,en15.0)", 999.499939, 4_"       999.E+00")
+    call checkfmt("(rd,en15.0)", 9500.0,     4_"         9.E+03")
+    call checkfmt("(rd,en15.0)", 9500.00098, 4_"         9.E+03")
+    call checkfmt("(rd,en15.0)", 9499.99902, 4_"         9.E+03")
+    call checkfmt("(rd,en15.1)", 9950.0,     4_"        9.9E+03")
+    call checkfmt("(rd,en15.2)", 9995.0,     4_"       9.99E+03")
+    call checkfmt("(rd,en15.3)", 9999.5,     4_"      9.999E+03")
+    call checkfmt("(rd,en15.1)", 9.5,        4_"        9.5E+00")
+    call checkfmt("(rd,en15.1)", 9.50000095, 4_"        9.5E+00")
+    call checkfmt("(rd,en15.1)", 9.49999905, 4_"        9.4E+00")
+    call checkfmt("(rd,en15.1)", 0.099951,   4_"       99.9E-03")
+    call checkfmt("(rd,en15.1)", 0.009951,   4_"        9.9E-03")
+    call checkfmt("(rd,en15.1)", 0.000999951,4_"      999.9E-06")
+
+    call checkfmt("(rd,en15.0)", -1.0,        4_"        -1.E+00")
+    call checkfmt("(rd,en15.0)", -1.00000012, 4_"        -2.E+00")
+    call checkfmt("(rd,en15.0)", -0.99999994, 4_"        -1.E+00")
+    call checkfmt("(rd,en15.0)", -10.0,       4_"       -10.E+00")
+    call checkfmt("(rd,en15.0)", -10.0000010, 4_"       -11.E+00")
+    call checkfmt("(rd,en15.0)", -9.99999905, 4_"       -10.E+00")
+    call checkfmt("(rd,en15.0)", -100.0,      4_"      -100.E+00")
+    call checkfmt("(rd,en15.0)", -100.000008, 4_"      -101.E+00")
+    call checkfmt("(rd,en15.0)", -99.9999924, 4_"      -100.E+00")
+    call checkfmt("(rd,en15.0)", -1000.0,     4_"        -1.E+03")
+    call checkfmt("(rd,en15.0)", -1000.00006, 4_"        -2.E+03")
+    call checkfmt("(rd,en15.0)", -999.999939, 4_"        -1.E+03")
+    call checkfmt("(rd,en15.0)", -9.5,        4_"       -10.E+00")
+    call checkfmt("(rd,en15.0)", -9.50000095, 4_"       -10.E+00")
+    call checkfmt("(rd,en15.0)", -9.49999905, 4_"       -10.E+00")
+    call checkfmt("(rd,en15.0)", -99.5,       4_"      -100.E+00")
+    call checkfmt("(rd,en15.0)", -99.5000076, 4_"      -100.E+00")
+    call checkfmt("(rd,en15.0)", -99.4999924, 4_"      -100.E+00")
+    call checkfmt("(rd,en15.0)", -999.5,      4_"        -1.E+03")
+    call checkfmt("(rd,en15.0)", -999.500061, 4_"        -1.E+03")
+    call checkfmt("(rd,en15.0)", -999.499939, 4_"        -1.E+03")
+    call checkfmt("(rd,en15.0)", -9500.0,     4_"       -10.E+03")
+    call checkfmt("(rd,en15.0)", -9500.00098, 4_"       -10.E+03")
+    call checkfmt("(rd,en15.0)", -9499.99902, 4_"       -10.E+03")
+    call checkfmt("(rd,en15.1)", -9950.0,     4_"      -10.0E+03")
+    call checkfmt("(rd,en15.2)", -9995.0,     4_"     -10.00E+03")
+    call checkfmt("(rd,en15.3)", -9999.5,     4_"    -10.000E+03")
+    call checkfmt("(rd,en15.1)", -9.5,        4_"       -9.5E+00")
+    call checkfmt("(rd,en15.1)", -9.50000095, 4_"       -9.6E+00")
+    call checkfmt("(rd,en15.1)", -9.49999905, 4_"       -9.5E+00")
+    call checkfmt("(rd,en15.1)", -0.099951,   4_"     -100.0E-03")
+    call checkfmt("(rd,en15.1)", -0.009951,   4_"      -10.0E-03")
+    call checkfmt("(rd,en15.1)", -0.000999951,4_"       -1.0E-03")
+
+    call checkfmt("(rd,en15.1)", 987350.,     4_"      987.3E+03")
+    call checkfmt("(rd,en15.2)", 98735.,      4_"      98.73E+03")
+    call checkfmt("(rd,en15.3)", 9873.5,      4_"      9.873E+03")
+    call checkfmt("(rd,en15.1)", 987650.,     4_"      987.6E+03")
+    call checkfmt("(rd,en15.2)", 98765.,      4_"      98.76E+03")
+    call checkfmt("(rd,en15.3)", 9876.5,      4_"      9.876E+03")
+    call checkfmt("(rd,en15.1)", 3.125E-02,   4_"       31.2E-03")
+    call checkfmt("(rd,en15.1)", 9.375E-02,   4_"       93.7E-03")
+    call checkfmt("(rd,en15.2)", 1.5625E-02,  4_"      15.62E-03")
+    call checkfmt("(rd,en15.2)", 4.6875E-02,  4_"      46.87E-03")
+    call checkfmt("(rd,en15.3)", 7.8125E-03,  4_"      7.812E-03")
+    call checkfmt("(rd,en15.3)", 2.34375E-02, 4_"     23.437E-03")
+    call checkfmt("(rd,en15.3)", 9.765625E-04,4_"    976.562E-06")
+    call checkfmt("(rd,en15.6)", 2.9296875E-03,4_"   2.929687E-03")
+
+    call checkfmt("(rd,en15.1)", -987350.,     4_"     -987.4E+03")
+    call checkfmt("(rd,en15.2)", -98735.,      4_"     -98.74E+03")
+    call checkfmt("(rd,en15.3)", -9873.5,      4_"     -9.874E+03")
+    call checkfmt("(rd,en15.1)", -987650.,     4_"     -987.7E+03")
+    call checkfmt("(rd,en15.2)", -98765.,      4_"     -98.77E+03")
+    call checkfmt("(rd,en15.3)", -9876.5,      4_"     -9.877E+03")
+    call checkfmt("(rd,en15.1)", -3.125E-02,   4_"      -31.3E-03")
+    call checkfmt("(rd,en15.1)", -9.375E-02,   4_"      -93.8E-03")
+    call checkfmt("(rd,en15.2)", -1.5625E-02,  4_"     -15.63E-03")
+    call checkfmt("(rd,en15.2)", -4.6875E-02,  4_"     -46.88E-03")
+    call checkfmt("(rd,en15.3)", -7.8125E-03,  4_"     -7.813E-03")
+    call checkfmt("(rd,en15.3)", -2.34375E-02, 4_"    -23.438E-03")
+    call checkfmt("(rd,en15.3)", -9.765625E-04,4_"   -976.563E-06")
+    call checkfmt("(rd,en15.6)", -2.9296875E-03,4_"  -2.929688E-03")
+
+    print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) stop n_cnt
+    if (all(.not. l_skip)) print *, "All kinds rounded down"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*, kind=4), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (l_skip(i)) cycle
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded down" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
+! { dg-final { cleanup-saved-temps } }
diff --git a/gcc/testsuite/gfortran.dg/fmt_en_rn.f90 b/gcc/testsuite/gfortran.dg/fmt_en_rn.f90
new file mode 100644
index 00000000000..b0ada5c672d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_en_rn.f90
@@ -0,0 +1,185 @@
+! { dg-do run }
+! PR60128 Invalid outputs with EN descriptors
+! Test case provided by Walt Brainerd.
+program pr60128
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20,kind=4) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= 4_'-9.5 9.5 10.  8.' .or. s1 /= 4_' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(en15.2)", -.44444,    4_"    -444.44E-03")
+
+! Test for the bug in comment 6.
+    call checkfmt("(rn,en15.0)", 1.0,        4_"         1.E+00")
+    call checkfmt("(rn,en15.0)", 1.00000012, 4_"         1.E+00")
+    call checkfmt("(rn,en15.0)", 0.99999994, 4_"         1.E+00")
+    call checkfmt("(rn,en15.0)", 10.0,       4_"        10.E+00")
+    call checkfmt("(rn,en15.0)", 10.0000010, 4_"        10.E+00")
+    call checkfmt("(rn,en15.0)", 9.99999905, 4_"        10.E+00")
+    call checkfmt("(rn,en15.0)", 100.0,      4_"       100.E+00")
+    call checkfmt("(rn,en15.0)", 100.000008, 4_"       100.E+00")
+    call checkfmt("(rn,en15.0)", 99.9999924, 4_"       100.E+00")
+    call checkfmt("(rn,en15.0)", 1000.0,     4_"         1.E+03")
+    call checkfmt("(rn,en15.0)", 1000.00006, 4_"         1.E+03")
+    call checkfmt("(rn,en15.0)", 999.999939, 4_"         1.E+03")
+    call checkfmt("(rn,en15.0)", 9.5,        4_"        10.E+00")
+    call checkfmt("(rn,en15.0)", 9.50000095, 4_"        10.E+00")
+    call checkfmt("(rn,en15.0)", 9.49999905, 4_"         9.E+00")
+    call checkfmt("(rn,en15.0)", 99.5,       4_"       100.E+00")
+    call checkfmt("(rn,en15.0)", 99.5000076, 4_"       100.E+00")
+    call checkfmt("(rn,en15.0)", 99.4999924, 4_"        99.E+00")
+    call checkfmt("(rn,en15.0)", 999.5,      4_"         1.E+03")
+    call checkfmt("(rn,en15.0)", 999.500061, 4_"         1.E+03")
+    call checkfmt("(rn,en15.0)", 999.499939, 4_"       999.E+00")
+    call checkfmt("(rn,en15.0)", 9500.0,     4_"        10.E+03")
+    call checkfmt("(rn,en15.0)", 9500.00098, 4_"        10.E+03")
+    call checkfmt("(rn,en15.0)", 9499.99902, 4_"         9.E+03")
+    call checkfmt("(rn,en15.1)", 9950.0,     4_"       10.0E+03")
+    call checkfmt("(rn,en15.2)", 9995.0,     4_"      10.00E+03")
+    call checkfmt("(rn,en15.3)", 9999.5,     4_"     10.000E+03")
+    call checkfmt("(rn,en15.1)", 9.5,        4_"        9.5E+00")
+    call checkfmt("(rn,en15.1)", 9.50000095, 4_"        9.5E+00")
+    call checkfmt("(rn,en15.1)", 9.49999905, 4_"        9.5E+00")
+    call checkfmt("(rn,en15.1)", 0.099951,   4_"      100.0E-03")
+    call checkfmt("(rn,en15.1)", 0.009951,   4_"       10.0E-03")
+    call checkfmt("(rn,en15.1)", 0.000999951,4_"        1.0E-03")
+
+    call checkfmt("(rn,en15.0)", -1.0,        4_"        -1.E+00")
+    call checkfmt("(rn,en15.0)", -1.00000012, 4_"        -1.E+00")
+    call checkfmt("(rn,en15.0)", -0.99999994, 4_"        -1.E+00")
+    call checkfmt("(rn,en15.0)", -10.0,       4_"       -10.E+00")
+    call checkfmt("(rn,en15.0)", -10.0000010, 4_"       -10.E+00")
+    call checkfmt("(rn,en15.0)", -9.99999905, 4_"       -10.E+00")
+    call checkfmt("(rn,en15.0)", -100.0,      4_"      -100.E+00")
+    call checkfmt("(rn,en15.0)", -100.000008, 4_"      -100.E+00")
+    call checkfmt("(rn,en15.0)", -99.9999924, 4_"      -100.E+00")
+    call checkfmt("(rn,en15.0)", -1000.0,     4_"        -1.E+03")
+    call checkfmt("(rn,en15.0)", -1000.00006, 4_"        -1.E+03")
+    call checkfmt("(rn,en15.0)", -999.999939, 4_"        -1.E+03")
+    call checkfmt("(rn,en15.0)", -9.5,        4_"       -10.E+00")
+    call checkfmt("(rn,en15.0)", -9.50000095, 4_"       -10.E+00")
+    call checkfmt("(rn,en15.0)", -9.49999905, 4_"        -9.E+00")
+    call checkfmt("(rn,en15.0)", -99.5,       4_"      -100.E+00")
+    call checkfmt("(rn,en15.0)", -99.5000076, 4_"      -100.E+00")
+    call checkfmt("(rn,en15.0)", -99.4999924, 4_"       -99.E+00")
+    call checkfmt("(rn,en15.0)", -999.5,      4_"        -1.E+03")
+    call checkfmt("(rn,en15.0)", -999.500061, 4_"        -1.E+03")
+    call checkfmt("(rn,en15.0)", -999.499939, 4_"      -999.E+00")
+    call checkfmt("(rn,en15.0)", -9500.0,     4_"       -10.E+03")
+    call checkfmt("(rn,en15.0)", -9500.00098, 4_"       -10.E+03")
+    call checkfmt("(rn,en15.0)", -9499.99902, 4_"        -9.E+03")
+    call checkfmt("(rn,en15.1)", -9950.0,     4_"      -10.0E+03")
+    call checkfmt("(rn,en15.2)", -9995.0,     4_"     -10.00E+03")
+    call checkfmt("(rn,en15.3)", -9999.5,     4_"    -10.000E+03")
+    call checkfmt("(rn,en15.1)", -9.5,        4_"       -9.5E+00")
+    call checkfmt("(rn,en15.1)", -9.50000095, 4_"       -9.5E+00")
+    call checkfmt("(rn,en15.1)", -9.49999905, 4_"       -9.5E+00")
+    call checkfmt("(rn,en15.1)", -0.099951,   4_"     -100.0E-03")
+    call checkfmt("(rn,en15.1)", -0.009951,   4_"      -10.0E-03")
+    call checkfmt("(rn,en15.1)", -0.000999951,4_"       -1.0E-03")
+
+    call checkfmt("(rn,en15.1)", 987350.,     4_"      987.4E+03")
+    call checkfmt("(rn,en15.2)", 98735.,      4_"      98.74E+03")
+    call checkfmt("(rn,en15.3)", 9873.5,      4_"      9.874E+03")
+    call checkfmt("(rn,en15.1)", 987650.,     4_"      987.6E+03")
+    call checkfmt("(rn,en15.2)", 98765.,      4_"      98.76E+03")
+    call checkfmt("(rn,en15.3)", 9876.5,      4_"      9.876E+03")
+    call checkfmt("(rn,en15.1)", 3.125E-02,   4_"       31.2E-03")
+    call checkfmt("(rn,en15.1)", 9.375E-02,   4_"       93.8E-03")
+    call checkfmt("(rn,en15.2)", 1.5625E-02,  4_"      15.62E-03")
+    call checkfmt("(rn,en15.2)", 4.6875E-02,  4_"      46.88E-03")
+    call checkfmt("(rn,en15.3)", 7.8125E-03,  4_"      7.812E-03")
+    call checkfmt("(rn,en15.3)", 2.34375E-02, 4_"     23.438E-03")
+    call checkfmt("(rn,en15.3)", 9.765625E-04,4_"    976.562E-06")
+    call checkfmt("(rn,en15.6)", 2.9296875E-03,4_"   2.929688E-03")
+
+    call checkfmt("(rn,en15.1)", -987350.,     4_"     -987.4E+03")
+    call checkfmt("(rn,en15.2)", -98735.,      4_"     -98.74E+03")
+    call checkfmt("(rn,en15.3)", -9873.5,      4_"     -9.874E+03")
+    call checkfmt("(rn,en15.1)", -987650.,     4_"     -987.6E+03")
+    call checkfmt("(rn,en15.2)", -98765.,      4_"     -98.76E+03")
+    call checkfmt("(rn,en15.3)", -9876.5,      4_"     -9.876E+03")
+    call checkfmt("(rn,en15.1)", -3.125E-02,   4_"      -31.2E-03")
+    call checkfmt("(rn,en15.1)", -9.375E-02,   4_"      -93.8E-03")
+    call checkfmt("(rn,en15.2)", -1.5625E-02,  4_"     -15.62E-03")
+    call checkfmt("(rn,en15.2)", -4.6875E-02,  4_"     -46.88E-03")
+    call checkfmt("(rn,en15.3)", -7.8125E-03,  4_"     -7.812E-03")
+    call checkfmt("(rn,en15.3)", -2.34375E-02, 4_"    -23.438E-03")
+    call checkfmt("(rn,en15.3)", -9.765625E-04,4_"   -976.562E-06")
+    call checkfmt("(rn,en15.6)", -2.9296875E-03,4_"  -2.929688E-03")
+
+    print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) stop n_cnt
+    if (all(.not. l_skip)) print *, "All kinds rounded to nearest"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*, kind=4), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (l_skip(i)) cycle
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded to nearest" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
+! { dg-final { cleanup-saved-temps } }
diff --git a/gcc/testsuite/gfortran.dg/fmt_en_ru.f90 b/gcc/testsuite/gfortran.dg/fmt_en_ru.f90
new file mode 100644
index 00000000000..7834e2880bd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_en_ru.f90
@@ -0,0 +1,185 @@
+! { dg-do run }
+! PR60128 Invalid outputs with EN descriptors
+! Test case provided by Walt Brainerd.
+program pr60128
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20,kind=4) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= 4_'-9.5 9.5 10.  8.' .or. s1 /= 4_' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(en15.2)", -.44444,    4_"    -444.44E-03")
+
+! Test for the bug in comment 6.
+    call checkfmt("(ru,en15.0)", 1.0,        4_"         1.E+00")
+    call checkfmt("(ru,en15.0)", 1.00000012, 4_"         2.E+00")
+    call checkfmt("(ru,en15.0)", 0.99999994, 4_"         1.E+00")
+    call checkfmt("(ru,en15.0)", 10.0,       4_"        10.E+00")
+    call checkfmt("(ru,en15.0)", 10.0000010, 4_"        11.E+00")
+    call checkfmt("(ru,en15.0)", 9.99999905, 4_"        10.E+00")
+    call checkfmt("(ru,en15.0)", 100.0,      4_"       100.E+00")
+    call checkfmt("(ru,en15.0)", 100.000008, 4_"       101.E+00")
+    call checkfmt("(ru,en15.0)", 99.9999924, 4_"       100.E+00")
+    call checkfmt("(ru,en15.0)", 1000.0,     4_"         1.E+03")
+    call checkfmt("(ru,en15.0)", 1000.00006, 4_"         2.E+03")
+    call checkfmt("(ru,en15.0)", 999.999939, 4_"         1.E+03")
+    call checkfmt("(ru,en15.0)", 9.5,        4_"        10.E+00")
+    call checkfmt("(ru,en15.0)", 9.50000095, 4_"        10.E+00")
+    call checkfmt("(ru,en15.0)", 9.49999905, 4_"        10.E+00")
+    call checkfmt("(ru,en15.0)", 99.5,       4_"       100.E+00")
+    call checkfmt("(ru,en15.0)", 99.5000076, 4_"       100.E+00")
+    call checkfmt("(ru,en15.0)", 99.4999924, 4_"       100.E+00")
+    call checkfmt("(ru,en15.0)", 999.5,      4_"         1.E+03")
+    call checkfmt("(ru,en15.0)", 999.500061, 4_"         1.E+03")
+    call checkfmt("(ru,en15.0)", 999.499939, 4_"         1.E+03")
+    call checkfmt("(ru,en15.0)", 9500.0,     4_"        10.E+03")
+    call checkfmt("(ru,en15.0)", 9500.00098, 4_"        10.E+03")
+    call checkfmt("(ru,en15.0)", 9499.99902, 4_"        10.E+03")
+    call checkfmt("(ru,en15.1)", 9950.0,     4_"       10.0E+03")
+    call checkfmt("(ru,en15.2)", 9995.0,     4_"      10.00E+03")
+    call checkfmt("(ru,en15.3)", 9999.5,     4_"     10.000E+03")
+    call checkfmt("(ru,en15.1)", 9.5,        4_"        9.5E+00")
+    call checkfmt("(ru,en15.1)", 9.50000095, 4_"        9.6E+00")
+    call checkfmt("(ru,en15.1)", 9.49999905, 4_"        9.5E+00")
+    call checkfmt("(ru,en15.1)", 0.099951,   4_"      100.0E-03")
+    call checkfmt("(ru,en15.1)", 0.009951,   4_"       10.0E-03")
+    call checkfmt("(ru,en15.1)", 0.000999951,4_"        1.0E-03")
+
+    call checkfmt("(ru,en15.0)", -1.0,        4_"        -1.E+00")
+    call checkfmt("(ru,en15.0)", -1.00000012, 4_"        -1.E+00")
+    call checkfmt("(ru,en15.0)", -0.99999994, 4_"      -999.E-03")
+    call checkfmt("(ru,en15.0)", -10.0,       4_"       -10.E+00")
+    call checkfmt("(ru,en15.0)", -10.0000010, 4_"       -10.E+00")
+    call checkfmt("(ru,en15.0)", -9.99999905, 4_"        -9.E+00")
+    call checkfmt("(ru,en15.0)", -100.0,      4_"      -100.E+00")
+    call checkfmt("(ru,en15.0)", -100.000008, 4_"      -100.E+00")
+    call checkfmt("(ru,en15.0)", -99.9999924, 4_"       -99.E+00")
+    call checkfmt("(ru,en15.0)", -1000.0,     4_"        -1.E+03")
+    call checkfmt("(ru,en15.0)", -1000.00006, 4_"        -1.E+03")
+    call checkfmt("(ru,en15.0)", -999.999939, 4_"      -999.E+00")
+    call checkfmt("(ru,en15.0)", -9.5,        4_"        -9.E+00")
+    call checkfmt("(ru,en15.0)", -9.50000095, 4_"        -9.E+00")
+    call checkfmt("(ru,en15.0)", -9.49999905, 4_"        -9.E+00")
+    call checkfmt("(ru,en15.0)", -99.5,       4_"       -99.E+00")
+    call checkfmt("(ru,en15.0)", -99.5000076, 4_"       -99.E+00")
+    call checkfmt("(ru,en15.0)", -99.4999924, 4_"       -99.E+00")
+    call checkfmt("(ru,en15.0)", -999.5,      4_"      -999.E+00")
+    call checkfmt("(ru,en15.0)", -999.500061, 4_"      -999.E+00")
+    call checkfmt("(ru,en15.0)", -999.499939, 4_"      -999.E+00")
+    call checkfmt("(ru,en15.0)", -9500.0,     4_"        -9.E+03")
+    call checkfmt("(ru,en15.0)", -9500.00098, 4_"        -9.E+03")
+    call checkfmt("(ru,en15.0)", -9499.99902, 4_"        -9.E+03")
+    call checkfmt("(ru,en15.1)", -9950.0,     4_"       -9.9E+03")
+    call checkfmt("(ru,en15.2)", -9995.0,     4_"      -9.99E+03")
+    call checkfmt("(ru,en15.3)", -9999.5,     4_"     -9.999E+03")
+    call checkfmt("(ru,en15.1)", -9.5,        4_"       -9.5E+00")
+    call checkfmt("(ru,en15.1)", -9.50000095, 4_"       -9.5E+00")
+    call checkfmt("(ru,en15.1)", -9.49999905, 4_"       -9.4E+00")
+    call checkfmt("(ru,en15.1)", -0.099951,   4_"      -99.9E-03")
+    call checkfmt("(ru,en15.1)", -0.009951,   4_"       -9.9E-03")
+    call checkfmt("(ru,en15.1)", -0.000999951,4_"     -999.9E-06")
+
+    call checkfmt("(ru,en15.1)", 987350.,     4_"      987.4E+03")
+    call checkfmt("(ru,en15.2)", 98735.,      4_"      98.74E+03")
+    call checkfmt("(ru,en15.3)", 9873.5,      4_"      9.874E+03")
+    call checkfmt("(ru,en15.1)", 987650.,     4_"      987.7E+03")
+    call checkfmt("(ru,en15.2)", 98765.,      4_"      98.77E+03")
+    call checkfmt("(ru,en15.3)", 9876.5,      4_"      9.877E+03")
+    call checkfmt("(ru,en15.1)", 3.125E-02,   4_"       31.3E-03")
+    call checkfmt("(ru,en15.1)", 9.375E-02,   4_"       93.8E-03")
+    call checkfmt("(ru,en15.2)", 1.5625E-02,  4_"      15.63E-03")
+    call checkfmt("(ru,en15.2)", 4.6875E-02,  4_"      46.88E-03")
+    call checkfmt("(ru,en15.3)", 7.8125E-03,  4_"      7.813E-03")
+    call checkfmt("(ru,en15.3)", 2.34375E-02, 4_"     23.438E-03")
+    call checkfmt("(ru,en15.3)", 9.765625E-04,4_"    976.563E-06")
+    call checkfmt("(ru,en15.6)", 2.9296875E-03,4_"   2.929688E-03")
+
+    call checkfmt("(ru,en15.1)", -987350.,     4_"     -987.3E+03")
+    call checkfmt("(ru,en15.2)", -98735.,      4_"     -98.73E+03")
+    call checkfmt("(ru,en15.3)", -9873.5,      4_"     -9.873E+03")
+    call checkfmt("(ru,en15.1)", -987650.,     4_"     -987.6E+03")
+    call checkfmt("(ru,en15.2)", -98765.,      4_"     -98.76E+03")
+    call checkfmt("(ru,en15.3)", -9876.5,      4_"     -9.876E+03")
+    call checkfmt("(ru,en15.1)", -3.125E-02,   4_"      -31.2E-03")
+    call checkfmt("(ru,en15.1)", -9.375E-02,   4_"      -93.7E-03")
+    call checkfmt("(ru,en15.2)", -1.5625E-02,  4_"     -15.62E-03")
+    call checkfmt("(ru,en15.2)", -4.6875E-02,  4_"     -46.87E-03")
+    call checkfmt("(ru,en15.3)", -7.8125E-03,  4_"     -7.812E-03")
+    call checkfmt("(ru,en15.3)", -2.34375E-02, 4_"    -23.437E-03")
+    call checkfmt("(ru,en15.3)", -9.765625E-04,4_"   -976.562E-06")
+    call checkfmt("(ru,en15.6)", -2.9296875E-03,4_"  -2.929687E-03")
+
+    print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) stop n_cnt
+    if (all(.not. l_skip)) print *, "All kinds rounded up"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*, kind=4), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (l_skip(i)) cycle
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded up" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
+! { dg-final { cleanup-saved-temps } }
diff --git a/gcc/testsuite/gfortran.dg/fmt_en_rz.f90 b/gcc/testsuite/gfortran.dg/fmt_en_rz.f90
new file mode 100644
index 00000000000..c07847cad6d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_en_rz.f90
@@ -0,0 +1,185 @@
+! { dg-do run }
+! PR60128 Invalid outputs with EN descriptors
+! Test case provided by Walt Brainerd.
+program pr60128
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20,kind=4) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= 4_'-9.5 9.5 10.  8.' .or. s1 /= 4_' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(en15.2)", -.44444,    4_"    -444.44E-03")
+
+! Test for the bug in comment 6.
+    call checkfmt("(rz,en15.0)", 1.0,        4_"         1.E+00")
+    call checkfmt("(rz,en15.0)", 1.00000012, 4_"         1.E+00")
+    call checkfmt("(rz,en15.0)", 0.99999994, 4_"       999.E-03")
+    call checkfmt("(rz,en15.0)", 10.0,       4_"        10.E+00")
+    call checkfmt("(rz,en15.0)", 10.0000010, 4_"        10.E+00")
+    call checkfmt("(rz,en15.0)", 9.99999905, 4_"         9.E+00")
+    call checkfmt("(rz,en15.0)", 100.0,      4_"       100.E+00")
+    call checkfmt("(rz,en15.0)", 100.000008, 4_"       100.E+00")
+    call checkfmt("(rz,en15.0)", 99.9999924, 4_"        99.E+00")
+    call checkfmt("(rz,en15.0)", 1000.0,     4_"         1.E+03")
+    call checkfmt("(rz,en15.0)", 1000.00006, 4_"         1.E+03")
+    call checkfmt("(rz,en15.0)", 999.999939, 4_"       999.E+00")
+    call checkfmt("(rz,en15.0)", 9.5,        4_"         9.E+00")
+    call checkfmt("(rz,en15.0)", 9.50000095, 4_"         9.E+00")
+    call checkfmt("(rz,en15.0)", 9.49999905, 4_"         9.E+00")
+    call checkfmt("(rz,en15.0)", 99.5,       4_"        99.E+00")
+    call checkfmt("(rz,en15.0)", 99.5000076, 4_"        99.E+00")
+    call checkfmt("(rz,en15.0)", 99.4999924, 4_"        99.E+00")
+    call checkfmt("(rz,en15.0)", 999.5,      4_"       999.E+00")
+    call checkfmt("(rz,en15.0)", 999.500061, 4_"       999.E+00")
+    call checkfmt("(rz,en15.0)", 999.499939, 4_"       999.E+00")
+    call checkfmt("(rz,en15.0)", 9500.0,     4_"         9.E+03")
+    call checkfmt("(rz,en15.0)", 9500.00098, 4_"         9.E+03")
+    call checkfmt("(rz,en15.0)", 9499.99902, 4_"         9.E+03")
+    call checkfmt("(rz,en15.1)", 9950.0,     4_"        9.9E+03")
+    call checkfmt("(rz,en15.2)", 9995.0,     4_"       9.99E+03")
+    call checkfmt("(rz,en15.3)", 9999.5,     4_"      9.999E+03")
+    call checkfmt("(rz,en15.1)", 9.5,        4_"        9.5E+00")
+    call checkfmt("(rz,en15.1)", 9.50000095, 4_"        9.5E+00")
+    call checkfmt("(rz,en15.1)", 9.49999905, 4_"        9.4E+00")
+    call checkfmt("(rz,en15.1)", 0.099951,   4_"       99.9E-03")
+    call checkfmt("(rz,en15.1)", 0.009951,   4_"        9.9E-03")
+    call checkfmt("(rz,en15.1)", 0.000999951,4_"      999.9E-06")
+
+    call checkfmt("(rz,en15.0)", -1.0,        4_"        -1.E+00")
+    call checkfmt("(rz,en15.0)", -1.00000012, 4_"        -1.E+00")
+    call checkfmt("(rz,en15.0)", -0.99999994, 4_"      -999.E-03")
+    call checkfmt("(rz,en15.0)", -10.0,       4_"       -10.E+00")
+    call checkfmt("(rz,en15.0)", -10.0000010, 4_"       -10.E+00")
+    call checkfmt("(rz,en15.0)", -9.99999905, 4_"        -9.E+00")
+    call checkfmt("(rz,en15.0)", -100.0,      4_"      -100.E+00")
+    call checkfmt("(rz,en15.0)", -100.000008, 4_"      -100.E+00")
+    call checkfmt("(rz,en15.0)", -99.9999924, 4_"       -99.E+00")
+    call checkfmt("(rz,en15.0)", -1000.0,     4_"        -1.E+03")
+    call checkfmt("(rz,en15.0)", -1000.00006, 4_"        -1.E+03")
+    call checkfmt("(rz,en15.0)", -999.999939, 4_"      -999.E+00")
+    call checkfmt("(rz,en15.0)", -9.5,        4_"        -9.E+00")
+    call checkfmt("(rz,en15.0)", -9.50000095, 4_"        -9.E+00")
+    call checkfmt("(rz,en15.0)", -9.49999905, 4_"        -9.E+00")
+    call checkfmt("(rz,en15.0)", -99.5,       4_"       -99.E+00")
+    call checkfmt("(rz,en15.0)", -99.5000076, 4_"       -99.E+00")
+    call checkfmt("(rz,en15.0)", -99.4999924, 4_"       -99.E+00")
+    call checkfmt("(rz,en15.0)", -999.5,      4_"      -999.E+00")
+    call checkfmt("(rz,en15.0)", -999.500061, 4_"      -999.E+00")
+    call checkfmt("(rz,en15.0)", -999.499939, 4_"      -999.E+00")
+    call checkfmt("(rz,en15.0)", -9500.0,     4_"        -9.E+03")
+    call checkfmt("(rz,en15.0)", -9500.00098, 4_"        -9.E+03")
+    call checkfmt("(rz,en15.0)", -9499.99902, 4_"        -9.E+03")
+    call checkfmt("(rz,en15.1)", -9950.0,     4_"       -9.9E+03")
+    call checkfmt("(rz,en15.2)", -9995.0,     4_"      -9.99E+03")
+    call checkfmt("(rz,en15.3)", -9999.5,     4_"     -9.999E+03")
+    call checkfmt("(rz,en15.1)", -9.5,        4_"       -9.5E+00")
+    call checkfmt("(rz,en15.1)", -9.50000095, 4_"       -9.5E+00")
+    call checkfmt("(rz,en15.1)", -9.49999905, 4_"       -9.4E+00")
+    call checkfmt("(rz,en15.1)", -0.099951,   4_"      -99.9E-03")
+    call checkfmt("(rz,en15.1)", -0.009951,   4_"       -9.9E-03")
+    call checkfmt("(rz,en15.1)", -0.000999951,4_"     -999.9E-06")
+
+    call checkfmt("(rz,en15.1)", 987350.,     4_"      987.3E+03")
+    call checkfmt("(rz,en15.2)", 98735.,      4_"      98.73E+03")
+    call checkfmt("(rz,en15.3)", 9873.5,      4_"      9.873E+03")
+    call checkfmt("(rz,en15.1)", 987650.,     4_"      987.6E+03")
+    call checkfmt("(rz,en15.2)", 98765.,      4_"      98.76E+03")
+    call checkfmt("(rz,en15.3)", 9876.5,      4_"      9.876E+03")
+    call checkfmt("(rz,en15.1)", 3.125E-02,   4_"       31.2E-03")
+    call checkfmt("(rz,en15.1)", 9.375E-02,   4_"       93.7E-03")
+    call checkfmt("(rz,en15.2)", 1.5625E-02,  4_"      15.62E-03")
+    call checkfmt("(rz,en15.2)", 4.6875E-02,  4_"      46.87E-03")
+    call checkfmt("(rz,en15.3)", 7.8125E-03,  4_"      7.812E-03")
+    call checkfmt("(rz,en15.3)", 2.34375E-02, 4_"     23.437E-03")
+    call checkfmt("(rz,en15.3)", 9.765625E-04,4_"    976.562E-06")
+    call checkfmt("(rz,en15.6)", 2.9296875E-03,4_"   2.929687E-03")
+
+    call checkfmt("(rz,en15.1)", -987350.,     4_"     -987.3E+03")
+    call checkfmt("(rz,en15.2)", -98735.,      4_"     -98.73E+03")
+    call checkfmt("(rz,en15.3)", -9873.5,      4_"     -9.873E+03")
+    call checkfmt("(rz,en15.1)", -987650.,     4_"     -987.6E+03")
+    call checkfmt("(rz,en15.2)", -98765.,      4_"     -98.76E+03")
+    call checkfmt("(rz,en15.3)", -9876.5,      4_"     -9.876E+03")
+    call checkfmt("(rz,en15.1)", -3.125E-02,   4_"      -31.2E-03")
+    call checkfmt("(rz,en15.1)", -9.375E-02,   4_"      -93.7E-03")
+    call checkfmt("(rz,en15.2)", -1.5625E-02,  4_"     -15.62E-03")
+    call checkfmt("(rz,en15.2)", -4.6875E-02,  4_"     -46.87E-03")
+    call checkfmt("(rz,en15.3)", -7.8125E-03,  4_"     -7.812E-03")
+    call checkfmt("(rz,en15.3)", -2.34375E-02, 4_"    -23.437E-03")
+    call checkfmt("(rz,en15.3)", -9.765625E-04,4_"   -976.562E-06")
+    call checkfmt("(rz,en15.6)", -2.9296875E-03,4_"  -2.929687E-03")
+
+    print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) stop n_cnt
+    if (all(.not. l_skip)) print *, "All kinds rounded to zero"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*, kind=4), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (l_skip(i)) cycle
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded to zero" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
+! { dg-final { cleanup-saved-temps } }
diff --git a/gcc/testsuite/gfortran.dg/forall_19.f90 b/gcc/testsuite/gfortran.dg/forall_19.f90
new file mode 100644
index 00000000000..ef05c97ab24
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/forall_19.f90
@@ -0,0 +1,32 @@
+! { dg-do run }
+! PR fortran/98307 - Dependency check fails when using "allocatable"
+
+program forall_deps
+  implicit none
+  type t
+    logical :: valid = .true.
+    integer :: s     = 0
+    integer, allocatable :: p(:)
+  end type
+  type(t) :: v(2)
+  integer :: i
+
+  allocate (v(1)%p(8))
+  allocate (v(2)%p(8))
+  v(1)%s    = 8
+  v(2)%s    = 6
+
+  v(1)%p(:) = [1, 2, 3, 4, 5, 6, 7, 8]
+  v(2)%p(:) = [13, 14, 15, 16, 17, 18, 19, 20]
+  forall (i=1:2)
+     v(i)%p(1:v(i)%s) = v(3-i)%p(1:v(i)%s)
+  end forall
+  if (any(v(2)%p(:) /= [1, 2, 3, 4, 5, 6, 19, 20])) stop 1
+
+  v(1)%p(:) = [1, 2, 3, 4, 5, 6, 7, 8]
+  v(2)%p(:) = [13, 14, 15, 16, 17, 18, 19, 20]
+  forall (i=1:2, v(i)%valid)
+     v(i)%p(1:v(i)%s) = v(3-i)%p(1:v(i)%s)
+  end forall
+  if (any(v(2)%p(:) /= [1, 2, 3, 4, 5, 6, 19, 20])) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr86470.f90 b/gcc/testsuite/gfortran.dg/gomp/pr86470.f90
new file mode 100644
index 00000000000..7e04437548c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr86470.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/86470 - ICE with OpenMP, class(*)
+
+program p
+  implicit none
+  class(*), allocatable :: val
+!$OMP PARALLEL private(val)
+  allocate(integer::val)
+  val = 1
+  deallocate(val)
+!$OMP END PARALLEL
+end
diff --git a/gcc/testsuite/gfortran.dg/graphite/vect-pr94043.f90 b/gcc/testsuite/gfortran.dg/graphite/vect-pr94043.f90
new file mode 100644
index 00000000000..744c0f3042e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/graphite/vect-pr94043.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-additional-options "-O3 -ftree-parallelize-loops=2 -fno-tree-dce" }
+
+! As PR94043, test it to be compiled successfully without ICE.
+
+program yw
+      integer :: hx(6, 6)
+      integer :: ps = 1, e2 = 1
+
+      do ps = 1, 6
+        do e2 = 1, 6
+            hx(e2, ps) = 0
+            if (ps >= 5 .and. e2 >= 5) then
+                hx(e2, ps) = hx(1, 1)
+            end if
+        end do
+      end do
+end program
diff --git a/gcc/testsuite/gfortran.dg/iall_masked.f90 b/gcc/testsuite/gfortran.dg/iall_masked.f90
new file mode 100644
index 00000000000..33cc4106a1b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/iall_masked.f90
@@ -0,0 +1,22 @@
+! { dg-do run }
+! PR fortran/96890 - Wrong answer with intrinsic IALL
+program p
+  implicit none
+  integer :: iarr1(0), iarr2(2,2), iarr3(2,2,2)
+  logical :: mask1(0), mask2(2,2), mask3(2,2,2)
+
+  if (     iall(iarr1,    mask1) /=          -1                 ) stop 1
+  if (     iall(iarr1, 1, mask1) /=          -1                 ) stop 2
+
+  iarr2 = reshape ([  1,      2,       3,      4      ], shape (iarr2))
+  mask2 = reshape ([ .true., .false., .true., .false. ], shape (mask2))
+
+  if (any (iall(iarr2, 2, mask2) /=          [1,-1])            ) stop 3
+
+  iarr3 = reshape ([  1,      2,       3,      4,     &
+                      5,      6,       7,      8      ], shape (iarr3))
+  mask3 = reshape ([ .true., .false., .true., .false.,&
+                     .true., .false., .true., .false. ], shape (iarr3))
+
+  if (any (iall(iarr3, 2, mask3) /= reshape ([1,-1,5,-1],[2,2]))) stop 4
+end
diff --git a/gcc/testsuite/gfortran.dg/implicit_pure_5.c b/gcc/testsuite/gfortran.dg/implicit_pure_5.c
new file mode 100644
index 00000000000..67a6d9ca45e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implicit_pure_5.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+extern int num_calls;
+int side_effect_c()
+{
+  num_calls ++;
+}
diff --git a/gcc/testsuite/gfortran.dg/implicit_pure_5.f90 b/gcc/testsuite/gfortran.dg/implicit_pure_5.f90
new file mode 100644
index 00000000000..7f1c887e3f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implicit_pure_5.f90
@@ -0,0 +1,63 @@
+! { dg-do run }
+! { dg-additional-sources implicit_pure_5.c }
+! PR fortran/96018 - a wrongly marked implicit_pure
+! function caused wrong code.
+module wrapper
+  use, intrinsic :: iso_c_binding, only : c_int
+  implicit none
+  integer(kind=c_int), bind(C) :: num_calls
+contains
+
+  integer function call_side_effect() result(ierr)
+    call side_effect(ierr)
+  end function call_side_effect
+
+  integer function inner_3d(array) result(ierr)
+    real, intent(in) :: array(:,:,:)
+    integer dimensions(3)
+    dimensions = shape(array)
+    ierr = call_side_effect()
+  end function inner_3d
+
+  integer function inner_4d(array) result(ierr)
+    real, intent(in) :: array(:,:,:,:)
+    integer dimensions(4)
+    dimensions = shape(array)
+    ierr = call_side_effect()
+  end function inner_4d
+
+  subroutine write_3d()
+    real :: array(1,1,1)
+    integer ierr
+    ierr = inner_3d(array)
+    ierr = call_side_effect()
+  end subroutine write_3d
+
+  subroutine write_4d()
+    real array(1,1,1,1)
+    integer ierr
+    ierr = inner_4d(array)
+    ierr = call_side_effect()
+  end subroutine write_4d
+
+  subroutine side_effect(ierr)
+    integer, intent(out) :: ierr        ! Error code
+    interface
+       integer(c_int) function side_effect_c() bind(C,name='side_effect_c')
+         use, intrinsic :: iso_c_binding, only: c_int
+       end function side_effect_c
+    end interface
+    ierr = side_effect_c()
+  end subroutine side_effect
+
+end module wrapper
+
+program self_contained
+  use wrapper
+  implicit none
+  call write_3d()
+  if (num_calls /= 2) stop 1
+  call write_4d()
+  if (num_calls /= 4) stop 2
+end program self_contained
+
diff --git a/gcc/testsuite/gfortran.dg/inquiry_type_ref_6.f90 b/gcc/testsuite/gfortran.dg/inquiry_type_ref_6.f90
new file mode 100644
index 00000000000..ffe09b088aa
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inquiry_type_ref_6.f90
@@ -0,0 +1,24 @@
+! { dg-do run }
+! { dg-options "-fcheck=all" }
+!
+! Test the fix for PR93581 and the implementation of note 9.7 of F2018.
+! The latter requires that the result of the LEN inquiry be a scalar
+! even for array expressions.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   complex, target :: z(2) = [(1.0, 2.0),(3.0, 4.0)]
+   character(:), allocatable, target :: c(:)
+   real, pointer :: r(:)
+   character(:), pointer :: s(:)
+
+   r => z%re
+   if (any (r .ne. real (z))) stop 1
+   r => z%im
+   if (any (r .ne. imag (z))) stop 2
+
+   allocate (c, source = ['abc','def'])
+   s(-2:-1) => c(1:2)
+   if (s%len .ne. len (c)) stop 3
+end
diff --git a/gcc/testsuite/gfortran.dg/intent_optimize_3.f90 b/gcc/testsuite/gfortran.dg/intent_optimize_3.f90
new file mode 100644
index 00000000000..6ecd722da76
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_optimize_3.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! { dg-options "-O2" }
+! PR99169 - Segfault passing allocatable scalar into intent(out) dummy argument
+
+program p
+  implicit none
+  integer, allocatable :: i
+  allocate (i)
+  call set (i)
+  if (i /= 5) stop 1
+contains
+  subroutine set (i)
+    integer, intent(out) :: i
+    i = 5
+  end subroutine set
+end program p
diff --git a/gcc/testsuite/gfortran.dg/matmul_20.f90 b/gcc/testsuite/gfortran.dg/matmul_20.f90
new file mode 100644
index 00000000000..7a211a4974d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/matmul_20.f90
@@ -0,0 +1,47 @@
+! { dg-do run }
+! PR97063 - Wrong result for vector (step size is negative) * matrix
+
+program p
+  implicit none
+  integer, parameter :: m = 3, k = 2*m, l = k-1, n = 4
+  integer :: i, j,  m1, m2, ms
+  integer :: ai(k), bi(k,n), ci(n), ci_ref(n), c1, c2
+  real    :: ar(k), br(k,n), cr(n), cr_ref(n)
+
+  ai(:)   = [(i,i=0,k-1)]
+  bi(:,:) = reshape ([(((5*i+j),i=0,k-1),j=0,n-1)],[k,n])
+
+  ! Parameters of subscript triplet
+  m1 = 1; m2 = l; ms =  2
+
+  ! Reference values for cross-checks: integer variant
+  c1 = dot_product (ai(m1:m2: ms), bi(m1:m2: ms,1))
+  c2 = dot_product (ai(m1:m2: ms), bi(m1:m2: ms,2))
+  ci_ref = matmul  (ai(m1:m2: ms), bi(m1:m2: ms,:))
+  ci     = matmul  (ai(m2:m1:-ms), bi(m2:m1:-ms,:))
+
+  if (ci_ref(1) /= c1 .or. ci_ref(2) /= c2) stop 1
+  if (any (ci   /= ci_ref)) stop 2
+
+  ! Real variant
+  ar = real (ai)
+  br = real (bi)
+  cr_ref = matmul  (ar(m1:m2: ms), br(m1:m2: ms,:))
+  cr     = matmul  (ar(m2:m1:-ms), br(m2:m1:-ms,:))
+
+  if (any (cr_ref /= real (ci_ref))) stop 3
+  if (any (cr     /=       cr_ref )) stop 4
+
+  ! Mixed variants
+  cr_ref = matmul  (ar(m1:m2: ms), bi(m1:m2: ms,:))
+  cr     = matmul  (ar(m2:m1:-ms), bi(m2:m1:-ms,:))
+
+  if (any (cr_ref /= real (ci_ref))) stop 5
+  if (any (cr     /=       cr_ref )) stop 6
+
+  cr_ref = matmul  (ai(m1:m2: ms), br(m1:m2: ms,:))
+  cr     = matmul  (ai(m2:m1:-ms), br(m2:m1:-ms,:))
+
+  if (any (cr_ref /= real (ci_ref))) stop 7
+  if (any (cr     /=       cr_ref )) stop 8
+end program
diff --git a/gcc/testsuite/gfortran.dg/matmul_21.f90 b/gcc/testsuite/gfortran.dg/matmul_21.f90
new file mode 100644
index 00000000000..505f4d555f8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/matmul_21.f90
@@ -0,0 +1,15 @@
+! { dg-do run }
+! PR libfortran/99218 - matmul on temporary array accesses invalid memory
+
+program p
+  implicit none
+  integer, parameter :: nState = 300000
+  integer, parameter :: nCon = 1
+  real,    parameter :: ZERO = 0.0
+  real :: G(nCon,nState) = ZERO
+  real :: H(nState,nCon) = ZERO
+  real :: lambda(nCon)   = ZERO
+  real :: f(nState)      = ZERO
+  f = matmul (transpose (G), lambda)
+  if (f(1) /= ZERO) stop 1
+end program
diff --git a/gcc/testsuite/gfortran.dg/module_procedure_3.f90 b/gcc/testsuite/gfortran.dg/module_procedure_3.f90
new file mode 100644
index 00000000000..50a83d9e5b1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/module_procedure_3.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+!
+! PR fortran/94348
+!
+! Contributed by Damian Rouson
+
+module foo_module
+  implicit none
+
+  interface
+     module function foo() result(bar)
+       implicit none
+       integer bar
+     end function
+  end interface
+
+contains
+  module procedure foo
+    bar = 5
+  end procedure
+end module
+
+program main
+  use foo_module
+  implicit none
+  if (foo() /= 5) stop 1
+end program main
diff --git a/gcc/testsuite/gfortran.dg/module_procedure_4.f90 b/gcc/testsuite/gfortran.dg/module_procedure_4.f90
new file mode 100644
index 00000000000..c30bbfe5d50
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/module_procedure_4.f90
@@ -0,0 +1,63 @@
+! { dg-do run }
+!
+! Test the fix for PR96320 in which the assumed shape of 'arg' in the
+! interface for 'bar' was mirrored by the 'arg' in the module procedure
+! incorrectly have deferred shape.
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+module foobar
+  type foo
+  contains
+    procedure, nopass :: bar1
+    procedure, nopass :: bar2
+    procedure, nopass :: bar3
+  end type
+
+  interface
+
+    module subroutine bar1(arg)
+      character(len=*) arg(:)
+    end subroutine
+
+    module subroutine bar2(arg)
+      character(len=*) arg(3:)
+    end subroutine
+
+    module subroutine bar3(arg)
+      character(len=*) arg(2)
+    end subroutine
+
+  end interface
+contains
+
+  module procedure bar1
+    if (lbound(arg, 1) .ne. 1) stop 1
+    if (arg(3) .ne. 'hijk') stop 2
+  end procedure
+
+! Make sure that the lower bound of an assumed shape array dummy,
+! if defined, is passed to the module procedure.
+
+  module procedure bar2
+    if (lbound(arg, 1) .ne. 3) stop 3
+    if (arg(3) .ne. 'abcd') stop 4
+  end procedure
+
+! This makes sure that an dummy with explicit shape has the upper
+! bound correctly set in the module procedure.
+
+  module procedure bar3
+    if (lbound(arg, 1) .ne. 1) stop 5
+    if (arg(3) .ne. 'hijk') stop 6       ! { dg-warning "is out of bounds" }
+  end procedure
+
+end module
+
+  use foobar
+  character(4) :: list(3) = ['abcd', 'efgh' , 'hijk']
+  type(foo) :: f
+  call f%bar1(list)
+  call f%bar2(list)
+  call f%bar3(list)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr39695_1.f90 b/gcc/testsuite/gfortran.dg/pr39695_1.f90
new file mode 100644
index 00000000000..4c4b3045f69
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr39695_1.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+!
+
+function f()
+  intrinsic :: sin
+  procedure(sin), pointer :: f ! { dg-error "Procedure pointer 'f'" }
+  f => sin
+end function f
diff --git a/gcc/testsuite/gfortran.dg/pr39695_2.f90 b/gcc/testsuite/gfortran.dg/pr39695_2.f90
new file mode 100644
index 00000000000..8534724959a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr39695_2.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+!
+
+function g()
+ interface
+    subroutine g()
+    end subroutine g
+  end interface
+  pointer g
+  real g   ! { dg-error "Symbol 'g' at .1. cannot have a type" }
+end function
+
diff --git a/gcc/testsuite/gfortran.dg/pr39695_3.f90 b/gcc/testsuite/gfortran.dg/pr39695_3.f90
new file mode 100644
index 00000000000..661e2540bb3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr39695_3.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+
+function g()
+ interface
+    subroutine g()   ! { dg-error "RESULT attribute in 'g'" }
+    end subroutine g
+  end interface
+  real g             ! { dg-error "Symbol 'g' at .1. cannot have a type" }
+end function
+
diff --git a/gcc/testsuite/gfortran.dg/pr39695_4.f90 b/gcc/testsuite/gfortran.dg/pr39695_4.f90
new file mode 100644
index 00000000000..ecb0a43929f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr39695_4.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+!
+
+function g()
+  implicit none
+  interface
+    function g()
+      integer g
+    end function g
+  end interface
+  pointer g
+  real g   ! { dg-error "Symbol 'g' at .1. already has basic type of INTEGER" }
+end function
+
diff --git a/gcc/testsuite/gfortran.dg/pr50392.f b/gcc/testsuite/gfortran.dg/pr50392.f
new file mode 100644
index 00000000000..2cb883e41a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr50392.f
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! 
+      function kf()
+      integer kf
+      assign 1 to kf ! { dg-warning "Deleted feature: ASSIGN statement at" }
+      kf = 2
+      goto kf ! { dg-warning "Deleted feature: Assigned GOTO statement at" }
+      kf = 1
+ 1    continue
+      kf = 0
+      end
+
diff --git a/gcc/testsuite/gfortran.dg/pr59107.f90 b/gcc/testsuite/gfortran.dg/pr59107.f90
new file mode 100644
index 00000000000..a84328f0851
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr59107.f90
@@ -0,0 +1,11 @@
+! { dg-compile }
+! { dg-options "-Wsurprising" }
+
+! There should be no surprising warnings
+
+program p
+  Integer :: nargs
+  intrinsic :: command_argument_count
+  nargs = command_argument_count()
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr71706.f90 b/gcc/testsuite/gfortran.dg/pr71706.f90
new file mode 100644
index 00000000000..860c1c8be80
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr71706.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -fcheck=all -fdefault-integer-8" }
+! PR fortran/71706 - ICE on using sync images with -fcheck=bounds
+
+program p
+  integer, volatile :: me = 1
+  sync images (me)
+  sync images (int (me, 2))
+  sync images (int (me, 8))
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88025.f90 b/gcc/testsuite/gfortran.dg/pr88025.f90
index 96172fae76a..c51390f1434 100644
--- a/gcc/testsuite/gfortran.dg/pr88025.f90
+++ b/gcc/testsuite/gfortran.dg/pr88025.f90
@@ -2,6 +2,6 @@
 ! PR fortran/88025
 program p
    type t
-      character(('')) :: c = 'c'    ! { dg-error "must be of INTEGER type" }
+      character(('')) :: c = 'c'  ! { dg-error "Scalar INTEGER expression expected" }
    end type
 end
diff --git a/gcc/testsuite/gfortran.dg/pr88379.f90 b/gcc/testsuite/gfortran.dg/pr88379.f90
new file mode 100644
index 00000000000..48a23af50c5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88379.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single" }
+! PR fortran/88379 - ICE with allocatable coarray, class and associate
+
+program p
+  type t
+  end type t
+  class(t), allocatable :: x[:]
+  associate (y => x)
+  end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/pr89574.f90 b/gcc/testsuite/gfortran.dg/pr89574.f90
new file mode 100644
index 00000000000..48dd0680a48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89574.f90
@@ -0,0 +1,29 @@
+! { dg-do compile }
+! PR fortran/89574 - ICE in conv_function_val, at fortran/trans-expr.c:3792
+
+module mod1
+contains
+  subroutine init
+  end subroutine
+end module
+
+module mod2
+contains
+  subroutine init
+  end subroutine
+end module
+
+module init
+  use mod1, only : test_init1 => init
+  use mod2, only : test_init2 => init
+  implicit none
+contains
+  subroutine sub
+    call test_init1
+    call test_init2
+    call init
+  contains
+    subroutine init
+    end subroutine
+  end subroutine
+end module
diff --git a/gcc/testsuite/gfortran.dg/pr91589.f90 b/gcc/testsuite/gfortran.dg/pr91589.f90
index d02cb64bfc2..375d895e0b7 100644
--- a/gcc/testsuite/gfortran.dg/pr91589.f90
+++ b/gcc/testsuite/gfortran.dg/pr91589.f90
@@ -10,6 +10,6 @@ program p
       integer :: a
    end type
    type(t) :: x = t(1)
-   call sub (x%a%a)   ! { dg-error "Syntax error in argument list" }
+   call sub (x%a%a)   ! { dg-error "is not an inquiry reference" }
 end
 
diff --git a/gcc/testsuite/gfortran.dg/pr91913.f90 b/gcc/testsuite/gfortran.dg/pr91913.f90
new file mode 100644
index 00000000000..7d5477ac0c3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91913.f90
@@ -0,0 +1,5 @@
+! PR target/91913
+! { dg-do compile }
+! { dg-options "-std=legacy -Ofast --param max-cse-insns=0 -fno-schedule-insns -fsanitize=null" }
+
+include 'string_ctor_1.f90'
diff --git a/gcc/testsuite/gfortran.dg/pr93337.f90 b/gcc/testsuite/gfortran.dg/pr93337.f90
new file mode 100644
index 00000000000..5cfb9297990
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93337.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/93337 - ICE in gfc_dt_upper_string, at fortran/module.c:441
+
+program p
+  type t
+     character(:), allocatable :: a
+  end type t
+  class(t) :: x ! { dg-error "must be dummy, allocatable or pointer" }
+  x = x         ! { dg-error "must not be polymorphic in intrinsic assignment" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93364.f90 b/gcc/testsuite/gfortran.dg/pr93364.f90
new file mode 100644
index 00000000000..61d7fa149a6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93364.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single" }
+!
+! PR fortran/93364 - check fix for ICE in gfc_set_array_spec
+
+type(t) function f()
+  codimension :: t[1,2,1,2,1,2,1,*]
+  dimension :: t(1,2,1,2,1,2,1,2)
+end
+
+! { dg-error "has not been declared" " " { target *-*-* } 6 }
+! { dg-error "is of type 't'" " " { target *-*-* } 6 }
+! { dg-error "rank \\+ corank of" " " { target *-*-* } 8 }
diff --git a/gcc/testsuite/gfortran.dg/pr93423.f90 b/gcc/testsuite/gfortran.dg/pr93423.f90
new file mode 100644
index 00000000000..fed5914daba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93423.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! PR fortran/93423 - ICE on invalid with argument list for module procedure
+
+module t
+  type :: b
+   contains
+     procedure :: p => bp
+  end type b
+  interface
+     module function bp(s)
+       class(b), intent(inout) :: s
+       integer, pointer :: bp
+     end function
+  end interface
+end module t
+
+submodule (t) ts
+contains
+  module procedure bp(s) ! { dg-error "must be in a generic module interface" }
+  end procedure bp       ! { dg-error "Expecting END SUBMODULE statement" }
+end submodule ts
diff --git a/gcc/testsuite/gfortran.dg/pr93484_1.f90 b/gcc/testsuite/gfortran.dg/pr93484_1.f90
new file mode 100644
index 00000000000..3b6dbc9ad79
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93484_1.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+!
+program p
+  implicit none
+  integer :: x(4) = [1,2,3,4]
+  print *, [real(x(k))] ! { dg-error "Symbol 'k' at .1. has no IMPLICIT type" } 
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93484_2.f90 b/gcc/testsuite/gfortran.dg/pr93484_2.f90
new file mode 100644
index 00000000000..4a7f4330ed9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93484_2.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+!
+program p
+  implicit none
+  integer, parameter :: x(4) = [1,2,3,4]
+  print *, [real(x(k))] ! { dg-error "Symbol 'k' at .1. has no IMPLICIT type" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93497.f90 b/gcc/testsuite/gfortran.dg/pr93497.f90
new file mode 100644
index 00000000000..612b41cd8ca
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93497.f90
@@ -0,0 +1,8 @@
+! { dg-do compile } 
+
+program p
+   print *, [character(((/1/))) :: 'a','b'] ! { dg-error "Scalar INTEGER expression expected" }
+   print *, [character(([1])) :: 'a','b']   ! { dg-error "Scalar INTEGER expression expected" }
+   print *, [character(1+[1]) :: 'a','b']   ! { dg-error "Scalar INTEGER expression expected" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93498_1.f90 b/gcc/testsuite/gfortran.dg/pr93498_1.f90
new file mode 100644
index 00000000000..0210cc7951e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93498_1.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+! Test case by  G. Steinmetz
+
+program p
+   character(len=1, kind=1) :: x(3) = ['a', 'b', 'c']
+   character(len=1, kind=4) :: y = 4_'b'
+   print *, findloc(x, y)     ! { dg-error " must be in type conformance" }
+   print *, findloc(x, y, 1)  ! { dg-error " must be in type conformance" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr93498_2.f90 b/gcc/testsuite/gfortran.dg/pr93498_2.f90
new file mode 100644
index 00000000000..ee9238ffa24
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93498_2.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+!
+! Test case by  G. Steinmetz
+
+program p
+   character(len=1, kind=4) :: x(3) = [4_'a', 4_'b', 4_'c']
+   character(len=1, kind=1) :: y = 'b'
+   print *, findloc(x, y)     ! { dg-error " must be in type conformance" }
+   print *, findloc(x, y, 1)  ! { dg-error " must be in type conformance" }
+end
+
+
diff --git a/gcc/testsuite/gfortran.dg/pr93685_1.f90 b/gcc/testsuite/gfortran.dg/pr93685_1.f90
new file mode 100644
index 00000000000..34d6e2cf355
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93685_1.f90
@@ -0,0 +1,20 @@
+! { dg-do run }
+! PR93685 - ICE in gfc_constructor_append_expr, at fortran/constructor.c:135
+
+program p
+  implicit none
+  type t
+     character, pointer :: a
+  end type t
+  type u
+     integer,   pointer :: i
+  end type u
+  type(t) :: x
+  type(u) :: y
+  character, target :: c = 'c'
+  integer  , target :: i = 10
+  data x%a /c/
+  data y%i /i/
+  if (x% a /= "c") stop 1
+  if (y% i /= 10)  stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93685_2.f90 b/gcc/testsuite/gfortran.dg/pr93685_2.f90
new file mode 100644
index 00000000000..a09ce7e5a2b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93685_2.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR93685 - ICE in gfc_constructor_append_expr, at fortran/constructor.c:135
+
+program p
+  implicit none
+  type t
+     character :: a
+  end type t
+  type u
+     integer   :: i
+  end type u
+  type(t) :: x
+  type(u) :: y
+  character, target :: c = 'c'
+  integer  , target :: i = 10
+  data x%a /c/  ! { dg-error "non-constant initialization expression" }
+  data y%i /i/  ! { dg-error "non-constant initialization expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93686_1.f90 b/gcc/testsuite/gfortran.dg/pr93686_1.f90
new file mode 100644
index 00000000000..0e7560a5c17
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93686_1.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/93686
+
+program p
+   type t
+      integer :: a
+   end type
+   type(t), pointer :: x
+   data x /t(2)/ ! { dg-error "part-ref with pointer attribute near ... is not rightmost part-ref of data-stmt-object" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93686_2.f90 b/gcc/testsuite/gfortran.dg/pr93686_2.f90
new file mode 100644
index 00000000000..aac4d9138ee
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93686_2.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/93686
+
+program p
+   type t
+      integer :: a = 1
+   end type
+   type(t), pointer :: x
+   data x /t(2)/ ! { dg-error "part-ref with pointer attribute near ... is not rightmost part-ref of data-stmt-object" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93686_3.f90 b/gcc/testsuite/gfortran.dg/pr93686_3.f90
new file mode 100644
index 00000000000..5b570407f8f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93686_3.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/93686
+
+program p
+   type t
+   end type
+   type(t), pointer :: x
+   data x /t()/ ! { dg-error "part-ref with pointer attribute near ... is not rightmost part-ref of data-stmt-object" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93686_4.f90 b/gcc/testsuite/gfortran.dg/pr93686_4.f90
new file mode 100644
index 00000000000..ff3ae764ab7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr93686_4.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/93686
+
+type t
+end type
+type(t), pointer :: x
+data x / ! { dg-error "part-ref with pointer attribute near ... is not rightmost part-ref of data-stmt-object" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr93714_1.f90 b/gcc/testsuite/gfortran.dg/pr93714_1.f90
index 40f4a4bf89f..e55812c76de 100644
--- a/gcc/testsuite/gfortran.dg/pr93714_1.f90
+++ b/gcc/testsuite/gfortran.dg/pr93714_1.f90
@@ -7,5 +7,5 @@ program test
    character, pointer :: b => a
 end program
 
-! { dg-error "must be of INTEGER type" " " { target *-*-* } 6 }
-! { dg-error "does not have the TARGET attribute" " " { target *-*-* } 7 }
+! { dg-error "Scalar INTEGER expression expected" " " { target *-*-* } 6 }
+! { dg-error "Different types in pointer assignment" " " { target *-*-* } 7 }
diff --git a/gcc/testsuite/gfortran.dg/pr93714_2.f90 b/gcc/testsuite/gfortran.dg/pr93714_2.f90
index 86658f28859..23d53508f1f 100644
--- a/gcc/testsuite/gfortran.dg/pr93714_2.f90
+++ b/gcc/testsuite/gfortran.dg/pr93714_2.f90
@@ -7,5 +7,5 @@ program test
    character(:), pointer :: b => a
 end program
 
-! { dg-error "must be of INTEGER type" " " { target *-*-* } 6 }
-! { dg-error "does not have the TARGET attribute" " " { target *-*-* } 7 }
+! { dg-error "Scalar INTEGER expression expected" " " { target *-*-* } 6 }
+! { dg-error "Different types in pointer assignment" " " { target *-*-* } 7 }
diff --git a/gcc/testsuite/gfortran.dg/pr94030_1.f90 b/gcc/testsuite/gfortran.dg/pr94030_1.f90
new file mode 100644
index 00000000000..e63d3cc8da4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr94030_1.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+
+subroutine f(n)
+  integer :: n
+  integer :: arr(n)
+  integer :: i
+  equivalence (i, arr(1))
+end
+
+! { dg-error "Array 'arr' at .1. with non-constant bounds cannot be an EQUIVALENCE object" " " { target *-*-* } 8 }
diff --git a/gcc/testsuite/gfortran.dg/pr94030_2.f90 b/gcc/testsuite/gfortran.dg/pr94030_2.f90
new file mode 100644
index 00000000000..84bfdeaa819
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr94030_2.f90
@@ -0,0 +1,33 @@
+! { dg-do compile }
+!
+! Provided by Steve Kargl.
+
+subroutine foo(n,m)
+  integer, intent(in) :: n, m
+  integer a(n)
+  real b(n)
+  equivalence(a,b)
+  if (m /= 2) then
+      a = 1
+      print *, a(1)
+  else
+      b = 42.
+      print *, b(1)
+   end if
+end subroutine 
+
+subroutine bar(m)
+  integer, intent(in) :: m
+  integer x(8)
+  real y(8)
+  equivalence(x,y)
+  if (m /= 2) then
+      x = 1
+      print *, x(1)
+  else
+      y = 42.
+      print *, y(1)
+   end if
+end subroutine 
+
+! { dg-error "Array '.' at .1. with non-constant bounds cannot be an EQUIVALENCE object" " " { target *-*-* } 9 }
diff --git a/gcc/testsuite/gfortran.dg/pr94329.f90 b/gcc/testsuite/gfortran.dg/pr94329.f90
new file mode 100644
index 00000000000..9efcf4b6524
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr94329.f90
@@ -0,0 +1,12 @@
+! PR tree-optimization/94329
+! { dg-do compile }
+! { dg-options "-O1 -fno-tree-loop-optimize -fwrapv -fcompare-debug" }
+
+subroutine pr94329 (s, t)
+  real :: s, t(:,:)
+  do i = 1,3
+    do j = 1,3
+      s = t(i,j)
+    end do
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/pr94397.F90 b/gcc/testsuite/gfortran.dg/pr94397.F90
new file mode 100644
index 00000000000..fda10c1a88b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr94397.F90
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+
+module m
+  implicit none
+contains
+  function is_real8(a)
+    class(*) :: a
+    logical :: is_real8
+    is_real8 = .false.
+    select type(a)
+      type is(real(kind(1.0_8)))
+        is_real8 = .true. 
+    end select
+  end function is_real8
+end module m
+
+program test
+  use m
+
+  if (is_real8(1.0_4)) stop 1
+  if (.not. is_real8(1.0_8)) stop 2
+#ifdef __GFC_REAL_16__
+  if (is_real8(1.0_16)) stop 3
+#endif
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr95091.f90 b/gcc/testsuite/gfortran.dg/pr95091.f90
new file mode 100644
index 00000000000..1c48dca2f4a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95091.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options "-fsecond-underscore" }
+! PR fortran/95091 - ICE in gfc_hash_value
+
+module m2345678901234567890123456789012345678901234567890123456789_123
+  type t2345678901234567890123456789012345678901234567890123456789_123
+  end type t2345678901234567890123456789012345678901234567890123456789_123
+  interface
+     module subroutine s2345678901234567890123456789012345678901234567890123456789_123 &
+          (x2345678901234567890123456789012345678901234567890123456789_123)
+    end
+  end interface
+end
+submodule(m2345678901234567890123456789012345678901234567890123456789_123) &
+     n2345678901234567890123456789012345678901234567890123456789_123
+  type, extends(t2345678901234567890123456789012345678901234567890123456789_123) :: &
+    u2345678901234567890123456789012345678901234567890123456789_123
+  end type
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95104.f90 b/gcc/testsuite/gfortran.dg/pr95104.f90
new file mode 100644
index 00000000000..20bdd910f46
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95104.f90
@@ -0,0 +1,8 @@
+! { dg-do run }
+! PR libfortran/95104 - Segfault on a legal WAIT statement
+
+program test
+  wait (10, iostat=ios)
+  if (ios /= 0) stop 1
+  close (10)
+end program test
diff --git a/gcc/testsuite/gfortran.dg/pr95342.f90 b/gcc/testsuite/gfortran.dg/pr95342.f90
new file mode 100644
index 00000000000..41c987d3bbb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95342.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! PR fortran/95342 - ICE in gfc_match_subroutine, at fortran/decl.c:7913
+
+module m1
+  interface
+     module subroutine s()
+     end
+     subroutine s() bind(c) ! { dg-error "EXTERNAL attribute conflicts" }
+     end                    ! { dg-error "END INTERFACE" }
+  end interface
+end
+
+module m2
+  interface
+     module function f()
+     end
+     function f() bind(c)
+     end                    ! { dg-error "Duplicate EXTERNAL attribute" }
+  end interface
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95373_1.f90 b/gcc/testsuite/gfortran.dg/pr95373_1.f90
new file mode 100644
index 00000000000..59a9e7a81e0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95373_1.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+! PR fortran/95373 - ICE in build_reference_type, at tree.c:7942
+
+subroutine s (x)
+  complex, parameter :: z = 3
+  real(z% kind)      :: x       ! { dg-error "Fortran 2003: KIND part_ref" }
+  type t
+     real    :: kind
+     logical :: re
+  end type t
+  type(t) :: b
+  print *, b% kind, b% re
+  print *, z% re                ! { dg-error "Fortran 2008: RE or IM part_ref" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95373_2.f90 b/gcc/testsuite/gfortran.dg/pr95373_2.f90
new file mode 100644
index 00000000000..b0f3da0a20d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95373_2.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-std=f2003" }
+! PR fortran/95373 - ICE in build_reference_type, at tree.c:7942
+
+subroutine s (x)
+  complex, parameter :: z = 3
+  real(z% kind)      :: x
+  type t
+     real    :: kind
+     logical :: re
+  end type t
+  type(t) :: b
+  print *, b% kind, b% re
+  print *, z% re                ! { dg-error "Fortran 2008: RE or IM part_ref" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95500.f90 b/gcc/testsuite/gfortran.dg/pr95500.f90
new file mode 100644
index 00000000000..e9eb7c65c86
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95500.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! PR fortran/95500 - ICE compiling extra interface on intrinsic
+
+program test_intrinsic
+  implicit none
+  intrinsic :: alog
+  intrinsic :: dlog
+  real (4), parameter :: one = 1
+
+  interface ln
+     procedure :: alog, dlog
+  end interface ln
+
+  write (*,*) 'ln  1', ln (one)
+end program test_intrinsic
diff --git a/gcc/testsuite/gfortran.dg/pr95503.f90 b/gcc/testsuite/gfortran.dg/pr95503.f90
new file mode 100644
index 00000000000..4a202b405c4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95503.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/95503 - ICE in gfc_is_simply_contiguous
+
+program p
+  complex, target :: a
+  real, pointer, contiguous :: b => a%re ! { dg-error "not an array pointer" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95585.f90 b/gcc/testsuite/gfortran.dg/pr95585.f90
new file mode 100644
index 00000000000..b0e6cdc5bea
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95585.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+
+program test
+  integer, parameter :: a(2) = reshape([1, 2], a) ! { dg-error "before its definition" }
+end program
+
diff --git a/gcc/testsuite/gfortran.dg/pr95587.f90 b/gcc/testsuite/gfortran.dg/pr95587.f90
new file mode 100644
index 00000000000..a543fb92a18
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95587.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/95587 - ICE in gfc_target_encode_expr, at fortran/target-memory.c:362
+
+program p
+  type t
+  end type t
+  class(*), allocatable :: x, y
+  class(t), allocatable :: u, v
+  class(t),    pointer  :: c, d
+  equivalence (x, y) ! { dg-error "conflicts with ALLOCATABLE" }
+  equivalence (u, v) ! { dg-error "conflicts with ALLOCATABLE" }
+  equivalence (c, d) ! { dg-error "conflicts with POINTER" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95611.f90 b/gcc/testsuite/gfortran.dg/pr95611.f90
new file mode 100644
index 00000000000..b7a54514ca3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95611.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/95611 - ICE in access_attr_decl, at fortran/decl.c:9075
+
+module m
+  public operator (.a.)
+  public operator (.a.) ! { dg-error "has already been specified" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95612.f90 b/gcc/testsuite/gfortran.dg/pr95612.f90
new file mode 100644
index 00000000000..b3cac8c1d81
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95612.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+
+program p
+   integer, pointer :: y(:) => shape(1)   ! { dg-error "Zero-sized array detected at .1. where an entity with the TARGET attribute is expected" }
+   integer, pointer :: z(:) => shape([1]) ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute at .1." }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95708.f90 b/gcc/testsuite/gfortran.dg/pr95708.f90
new file mode 100644
index 00000000000..32bd324ce15
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95708.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+!
+
+program test
+  procedure(team_num) :: g ! { dg-error "must be explicit" }
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr95709.f90 b/gcc/testsuite/gfortran.dg/pr95709.f90
new file mode 100644
index 00000000000..04f2da81988
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95709.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR fortran/95709 - ICE in gfc_resolve_code, at fortran/resolve.c:11807
+
+program p
+  integer, parameter :: j    = 1
+  integer            :: k(1) = 1
+  goto j           ! { dg-error "requires a scalar INTEGER variable" }
+  goto k(1)        ! { dg-error "requires a scalar INTEGER variable" }
+  goto k%kind, (1) ! { dg-error "requires a scalar INTEGER variable" }
+1 continue
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95829.f90 b/gcc/testsuite/gfortran.dg/pr95829.f90
new file mode 100644
index 00000000000..081d647c7c0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95829.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+!
+! Declaration of b used to be a bogus failure.
+
+subroutine s (a, b, c, d, e, f, g)
+  type(*) :: a
+  type(* ) :: b
+  type( *) :: c
+  type( * ) :: d
+  type(*  ) :: e
+  type(  *) :: f
+  type(  *  ) :: g
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95880.f90 b/gcc/testsuite/gfortran.dg/pr95880.f90
new file mode 100644
index 00000000000..b7a573cba05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95880.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/95880 - ICE in gfc_add_type, at fortran/symbol.c:2030 
+
+module m
+end
+block data
+   use m
+   integer m    ! { dg-error "cannot have a type" }
+end block data
diff --git a/gcc/testsuite/gfortran.dg/pr95881.f90 b/gcc/testsuite/gfortran.dg/pr95881.f90
new file mode 100644
index 00000000000..9f171764948
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95881.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+! PR fortran/95881 - ICE in resolve_symbol, at fortran/resolve.c:15175
+
+program p
+  type t
+     real, allocatable :: a[:]
+  end type t
+  class(t) :: x     ! { dg-error "must be dummy, allocatable or pointer" }
+  allocate (x%a[*])
+end
diff --git a/gcc/testsuite/gfortran.dg/pr95882_1.f90 b/gcc/testsuite/gfortran.dg/pr95882_1.f90
new file mode 100644
index 00000000000..c254bddf494
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95882_1.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+
+module m
+   type t
+      character(((0)/0)) :: c  ! { dg-error "Division by zero" }
+   end type
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95882_2.f90 b/gcc/testsuite/gfortran.dg/pr95882_2.f90
new file mode 100644
index 00000000000..d308f0c3181
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95882_2.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+
+module m
+   character(0/(0)) :: c = '123456789'  ! { dg-error "Division by zero" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95882_3.f90 b/gcc/testsuite/gfortran.dg/pr95882_3.f90
new file mode 100644
index 00000000000..bd849135480
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95882_3.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+
+subroutine s(c)
+   character(((0)/0)) :: c  ! { dg-error "Division by zero" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95882_4.f90 b/gcc/testsuite/gfortran.dg/pr95882_4.f90
new file mode 100644
index 00000000000..52892d32b8b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95882_4.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+
+program p
+   character(((0)/0)) :: c  ! { dg-error "Division by zero" }
+   common /x/ c
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr95882_5.f90 b/gcc/testsuite/gfortran.dg/pr95882_5.f90
new file mode 100644
index 00000000000..dcdf5304052
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr95882_5.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+
+program p
+   character(0/(0)) :: c = '123456789'  ! { dg-error "Division by zero" }
+   common c
+end
diff --git a/gcc/testsuite/gfortran.dg/pr96325.f90 b/gcc/testsuite/gfortran.dg/pr96325.f90
new file mode 100644
index 00000000000..62f4cfbf3b2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr96325.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Test the fix for PR96325 in which the typebound procedure reference
+! 'foo' was applied to an intrinsic type component without generating
+! an error. The result of the expression was the value of the arg..
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+   implicit none
+
+   type t2
+      integer r1
+   end type
+
+   type(t2) :: t
+   integer :: a
+
+   a = t%r1%foo(1)     { dg-error "is not an inquiry reference" }
+   if (a == 42) stop
+
+   end
diff --git a/gcc/testsuite/gfortran.dg/pr96486.f90 b/gcc/testsuite/gfortran.dg/pr96486.f90
new file mode 100644
index 00000000000..fdc7025d61c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr96486.f90
@@ -0,0 +1,9 @@
+! { dg-do run }
+
+program test
+  implicit none
+  character(0) :: value
+  integer :: l, stat
+  call get_environment_variable("HOME",value,length=l,status=stat)
+  if (stat.ne.-1) stop 1
+end program test
diff --git a/gcc/testsuite/gfortran.dg/pr97272.f90 b/gcc/testsuite/gfortran.dg/pr97272.f90
new file mode 100644
index 00000000000..e81903860ea
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr97272.f90
@@ -0,0 +1,19 @@
+! { dg-do run }
+! PR fortran/97272 - Wrong answer from MAXLOC with character arg
+
+program test
+  implicit none
+  integer :: i, j, k, l = 10
+  character, allocatable :: a(:)
+  allocate (a(l))
+  a(:) = 'a'
+  l = l - 1
+  a(l) = 'b'
+  i = maxloc (a, dim=1)
+  j = maxloc (a, dim=1, kind=2)
+  k = maxloc (a, dim=1, kind=8, back=.true.)
+! print *, 'i = ', i, 'a(i) = ', a(i)
+! print *, 'j = ', j, 'a(j) = ', a(j)
+! print *, 'k = ', k, 'a(k) = ', a(k)
+  if (i /= l .or. j /= l .or. k /= l) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr98017.f90 b/gcc/testsuite/gfortran.dg/pr98017.f90
new file mode 100644
index 00000000000..ab60407bf1d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr98017.f90
@@ -0,0 +1,14 @@
+! { dg-do run }
+! PR98017 - [8/9/10/11 Regression] Suspected regression using PACK
+
+program p
+  implicit none
+  character(*), parameter :: s(1) = ['abc()']
+  character(*), parameter :: t(*) = s(:)(:1)
+  if (len (pack (s, s(:)(:1)  == 'a')) /= len (s)) stop 1
+  if (any (pack (s, s(:)(:1)  == 'a')  /=      s)) stop 2
+  if (len (pack (s,         t == 'a')) /= len (s)) stop 3
+  if (any (pack (s,         t == 'a')  /=      s)) stop 4
+  if (len (pack (s(:)(1:5), t == 'a')) /= len (s)) stop 5
+  if (any (pack (s(:)(1:5), t == 'a')  /=      s)) stop 6
+end
diff --git a/gcc/testsuite/gfortran.dg/pr99060.f90 b/gcc/testsuite/gfortran.dg/pr99060.f90
new file mode 100644
index 00000000000..fdf3b1a724e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr99060.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! Test the fix for PR99060 in which the expression caused an ICE after the error.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   real :: a
+   print *, a%kind%n ! { dg-error "not an inquiry reference" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr99545.f90 b/gcc/testsuite/gfortran.dg/pr99545.f90
new file mode 100644
index 00000000000..1b5ed5da29b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr99545.f90
@@ -0,0 +1,40 @@
+! { dg-do compile }
+! { dg-options "-fcheck=mem" }
+!
+! Test the fix for PR99545, in which the allocate statements caused an ICE.
+!
+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>
+!
+module commands
+  implicit none
+  private
+
+  type, abstract :: range_t
+     integer :: step_mode = 0
+     integer :: n_step = 0
+  end type range_t
+
+  type, extends (range_t) :: range_int_t
+     integer :: i_step = 0
+  end type range_int_t
+
+  type, extends (range_t) :: range_real_t
+     real :: lr_step = 0
+end type range_real_t
+
+  type :: cmd_scan_t
+     private
+     class(range_t), dimension(:), allocatable :: range
+   contains
+     procedure :: compile => cmd_scan_compile
+  end type cmd_scan_t
+
+contains
+
+  subroutine cmd_scan_compile (cmd)
+    class(cmd_scan_t), intent(inout) :: cmd
+    allocate (range_int_t :: cmd%range (3))
+    allocate (range_real_t :: cmd%range (3))
+  end subroutine cmd_scan_compile
+
+end module commands
diff --git a/gcc/testsuite/gfortran.dg/recursive_check_16.f90 b/gcc/testsuite/gfortran.dg/recursive_check_16.f90
new file mode 100644
index 00000000000..d8e9d69ea7b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/recursive_check_16.f90
@@ -0,0 +1,25 @@
+! { dg-do  run }
+! ! { dg-options "-fcheck=recursion" }
+! PR 95743 - this used cause a runtime error.
+! Test case by Antoine Lemoine
+
+program test_recursive_call
+   implicit none
+
+   type t_tree_node
+      type(t_tree_node), dimension(:), allocatable :: child
+   end type
+
+   type t_tree
+      type(t_tree_node), allocatable :: root
+   end type
+
+   type(t_tree), allocatable :: tree
+
+   allocate(tree)
+   allocate(tree%root)
+   allocate(tree%root%child(1))
+   ! If the line below is removed, the code works fine.
+   allocate(tree%root%child(1)%child(1))
+   deallocate(tree)
+end program
diff --git a/gcc/testsuite/gfortran.dg/transpose_5.f90 b/gcc/testsuite/gfortran.dg/transpose_5.f90
new file mode 100644
index 00000000000..ed4b643acbf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/transpose_5.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-O2" }
+! PR fortran/99840 - ICE in gfc_simplify_matmul, at fortran/simplify.c:4777
+program p
+  integer, parameter :: x(0,0) = 0
+  integer :: y(0,0)
+  y = matmul (x, transpose(x))
+end
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_32.f03 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_32.f03
new file mode 100644
index 00000000000..23d0540526d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_32.f03
@@ -0,0 +1,59 @@
+! { dg-do run }
+!
+! Test the fix of the test case referenced in comment 17 of PR83118.
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  implicit none
+  type Wrapper
+    class(*), allocatable :: elements(:)
+  end type
+  type Mytype
+    real(4) :: r = 42.0
+  end type
+
+  call driver
+contains
+  subroutine driver
+    class(*), allocatable :: obj
+    type(Wrapper) w
+    integer(4) :: expected4(2) = [42_4, 43_4]
+    integer(8) :: expected8(3) = [42_8, 43_8, 44_8]
+
+    w = new_wrapper (expected4)
+    obj = w
+    call test (obj, 0)
+    obj =  new_wrapper (expected8) ! Used to generate a linker error
+    call test (obj, 10)
+    obj = new_wrapper ([mytype (99.0)])
+    call test (obj, 100)
+    obj = Mytype (42.0) ! Used to generate a linker error
+    call test (obj, 1000)
+  end subroutine
+  function new_wrapper(array) result (res)
+    class(*) :: array(:)
+    type(Wrapper) :: res
+    res%elements = array ! Used to runtime segfault
+  end function
+  subroutine test (arg, idx)
+    class(*) :: arg
+    integer :: idx
+    select type (arg)
+      type is (wrapper)
+        select type (z => arg%elements)
+          type is (integer(4))
+            if (any (z .ne. [42_4, 43_4])) stop 1 + idx
+          type is (integer(8))
+            if (any (z .ne. [42_8, 43_8, 44_8])) stop 1 + idx
+          type is (Mytype)
+            if (abs (z(1)%r - 99.0) .ge. 1e-6) stop 1 + idx
+        class default
+          stop 2 + idx
+        end select
+      type is (Mytype)
+        if (abs (arg%r - 42.0) .ge. 1e-6) stop 1 + idx
+      class default
+        stop 3 + idx
+    end select
+  end subroutine
+end
diff --git a/gcc/testsuite/gfortran.dg/use_rename_10.f90 b/gcc/testsuite/gfortran.dg/use_rename_10.f90
new file mode 100644
index 00000000000..736d319c5a9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/use_rename_10.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+!
+! PR fortran/92736
+!
+! Contributed by Chinoune Mehdi
+!
+module m1
+  implicit none
+  integer, parameter :: i = 10
+end module m1
+
+module m2
+  use m1, only : i
+  implicit none
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end module m2
+
+submodule(m2) s1
+  use m1, only : i
+  implicit none
+contains
+  module subroutine sb1
+    print *,"hello", i
+  end subroutine sb1
+end submodule s1
diff --git a/gcc/testsuite/gfortran.dg/use_rename_11.f90 b/gcc/testsuite/gfortran.dg/use_rename_11.f90
new file mode 100644
index 00000000000..b713ae01d36
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/use_rename_11.f90
@@ -0,0 +1,79 @@
+! { dg-do compile }
+!
+! PR fortran/92736
+!
+module m
+  integer :: i, j
+end module m
+
+module m2
+  integer :: i, k
+end module m2
+
+module mod
+  use m, only: i
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end
+
+! Error: use 'i' both for m's 'i' and 'j'
+submodule(mod) sub     ! { dg-error "Symbol 'i' at .1. conflicts with the rename symbol" }
+  use m1, only: i => j ! { dg-error "Symbol 'i' at .1. conflicts with the rename symbol" }
+end
+
+module mod2
+  use m, only: i
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end
+
+! Error: use 'i' both for m's 'i' and m2's 'k'
+submodule(mod2) sub2   ! { dg-error "Symbol 'i' at .1. conflicts with the rename symbol" }
+  use m2, only: i => k ! { dg-error "Symbol 'i' at .1. conflicts with the rename symbol" }
+end
+
+
+module mod3
+  use m, only: i
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end
+
+! Error: use 'i' both for m's 'i' and m2's 'i'
+submodule(mod3) sub3  ! { dg-error "Symbol 'i' at .1. conflicts with the symbol" }
+  use m2, only: i     ! { dg-error "Symbol 'i' at .1. conflicts with the symbol" }
+end
+
+
+module mod4
+  use m, only: mm => i, i
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end
+
+! OK
+submodule(mod4) sub4
+  use m, only: i
+  use m, only: mm => i
+end
+
+module mod5
+  use m, only: mm => i
+  interface
+    module subroutine sb1()
+    end subroutine sb1
+  end interface
+end
+
+! mm from both m2 and m
+submodule(mod5) sub5    ! { dg-error "Symbol 'mm' at .1. conflicts with the rename symbol" }
+  use m2, only: mm => i ! { dg-error "Symbol 'mm' at .1. conflicts with the rename symbol" }
+end
diff --git a/gcc/testsuite/gfortran.dg/value_8.f90 b/gcc/testsuite/gfortran.dg/value_8.f90
new file mode 100644
index 00000000000..8273fe88b60
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/value_8.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! PR97491 - Wrong restriction for VALUE arguments of pure procedures
+
+pure function foo (x) result (ret)
+  integer        :: ret
+  integer, value :: x
+  x = x / 2
+  ret = x
+end function foo
+
+elemental function foo1 (x)
+  integer        :: foo1
+  integer, value :: x
+  x = x / 2
+  foo1 = x
+end function foo1
diff --git a/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_6.f90 b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_6.f90
new file mode 100644
index 00000000000..72f6d5c0857
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_6.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-Wall" }
+! PR 94270 - this used to give a bogus warning.
+! Test case by Ignacio Fernández Galván.
+subroutine foo()
+external bar
+call meh(bar)
+call foo_internal()
+contains
+  subroutine foo_internal()
+    call meh(bar)
+  end subroutine foo_internal
+end subroutine foo
diff --git a/gcc/testsuite/gnat.dg/bias2.adb b/gcc/testsuite/gnat.dg/bias2.adb
new file mode 100644
index 00000000000..a32e9a337ad
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/bias2.adb
@@ -0,0 +1,33 @@
+-- { dg-do run }
+
+procedure Bias2 is
+
+  type Biased_T is range 1 .. 2 ** 6;
+  for Biased_T'Size use 6;  --  { dg-warning "biased representation" }
+  X, Y : Biased_T;
+
+begin
+  X := 1;
+  Y := 1;
+  if X + Y /= 2 then
+    raise Program_Error;
+  end if;
+
+  X := 2;
+  Y := 1;
+  if X - Y /= 1 then
+    raise Program_Error;
+  end if;
+
+  X := 2;
+  Y := 3;
+  if X * Y /= 6 then
+    raise Program_Error;
+  end if;
+
+  X := 24;
+  Y := 3;
+  if X / Y /= 8 then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/discr59.adb b/gcc/testsuite/gnat.dg/discr59.adb
new file mode 100644
index 00000000000..59e1b5fc290
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr59.adb
@@ -0,0 +1,24 @@
+-- { dg-do run }
+
+with Discr59_Pkg1; use Discr59_Pkg1;
+
+procedure Discr59 is
+
+   function At_Response_Decode return At_Response_Type is
+      Fill : At_Response_Type (Alert, 1);
+   begin
+      return Fill;
+   end;
+
+   function Decode return Rec is
+      Make : constant At_Response_Type := At_Response_Decode;
+      Fill : Rec (At_Response, Make.Kind, Make.Units);
+   begin
+      return Fill;
+   end;
+
+   R : constant Rec := Decode;
+
+begin
+   null;
+end;
diff --git a/gcc/testsuite/gnat.dg/discr59_pkg1.ads b/gcc/testsuite/gnat.dg/discr59_pkg1.ads
new file mode 100644
index 00000000000..455250b33e9
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr59_pkg1.ads
@@ -0,0 +1,35 @@
+with Discr59_Pkg2;
+
+package Discr59_Pkg1 is
+
+   subtype Index_Type is Natural range 1 .. 300;
+
+   type Code_Type is (Global_Query, Status_Query, Alert);
+
+   type Id_Type is (None, At_Command, At_Response);
+
+   package My_G is new Discr59_Pkg2 (21);
+
+   type Arr is array (Index_Type range <>) of My_G.Token_Type;
+
+   type Unit_List_Type (Last : Natural) is record
+      A : Arr (1 .. Last);
+   end record;
+
+   type At_Response_Type (Kind : Code_Type; Units : Natural) is record
+      case Kind is
+         when Global_Query => Global_Query : Unit_List_Type (Units);
+         when Status_Query => null;
+         when Alert        => Alert : Unit_List_Type (Units);
+      end case;
+   end record;
+
+   type Rec (Kind : Id_Type; Code : Code_Type; Units : Natural) is record
+      case Kind is
+         when None        => null;
+         when At_Command  => null;
+         when At_Response => At_Response : At_Response_Type (Code, Units);
+      end case;
+   end record;
+
+end Discr59_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/discr59_pkg2.ads b/gcc/testsuite/gnat.dg/discr59_pkg2.ads
new file mode 100644
index 00000000000..01ed5090ebd
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr59_pkg2.ads
@@ -0,0 +1,15 @@
+generic
+
+   Max_Length : Positive;
+
+package Discr59_Pkg2 is
+
+   type Token_Base_Type (Most : Natural) is record
+      Text : String (1 .. Most) := (others => ' ');
+      Last : Natural            := 0;
+      Used : Natural            := 0;
+   end record;
+
+   type Token_Type is new Token_Base_Type (Max_Length);
+
+end Discr59_Pkg2;
diff --git a/gcc/testsuite/gnat.dg/modular6.adb b/gcc/testsuite/gnat.dg/modular6.adb
new file mode 100644
index 00000000000..f0f1c80c62f
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/modular6.adb
@@ -0,0 +1,15 @@
+-- { dg-do compile }
+
+with Ada.Text_IO; use Ada.Text_IO;
+
+procedure Modular6 is
+   Max : Integer := 0;
+   
+   type Modulus is mod 3;
+begin
+   Max := 30;
+   
+   for N in 1 .. Max loop
+      Put_Line("N: " & Integer'Image(N) & " Modulus:    " & Integer'Image(Modulus'Modulus) & " Mod:" & Modulus'Image(Modulus'Mod(N)));
+   end loop;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt89.adb b/gcc/testsuite/gnat.dg/opt89.adb
new file mode 100644
index 00000000000..37520086616
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt89.adb
@@ -0,0 +1,18 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+procedure Opt89 is
+
+  type Rec is record
+    I : Integer := 3;
+  end record;
+
+  subtype Index is Natural range 0..0;
+
+  type Arr is array (Index range <>) of Rec;
+
+  X : Arr (0 .. -1);
+
+begin
+  null;
+end;
diff --git a/gcc/testsuite/gnat.dg/specs/discr7.ads b/gcc/testsuite/gnat.dg/specs/discr7.ads
new file mode 100644
index 00000000000..ca35ced2e7a
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/specs/discr7.ads
@@ -0,0 +1,14 @@
+-- { dg-do compile }
+
+package Discr7 is
+
+  type Enum is (One, Two, Three);
+  for Enum use (One => 1, Two => 2, Three => 3);
+
+  type Arr is array (Integer range <>, Enum range <>) of Boolean;
+
+  type Rec (D : Integer) is record
+    A: Arr (1 .. D, Enum'Range);
+  end record;
+
+end Discr7;
diff --git a/gcc/testsuite/gnat.dg/thunk2.adb b/gcc/testsuite/gnat.dg/thunk2.adb
new file mode 100644
index 00000000000..96ed883bfab
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/thunk2.adb
@@ -0,0 +1,11 @@
+-- { dg-do compile }
+-- { dg-options "-O2" }
+
+package body Thunk2 is
+
+  overriding function Element (Self : Ext; Name : String) return Ext is
+  begin
+    return Self;
+  end;
+
+end Thunk2;
diff --git a/gcc/testsuite/gnat.dg/thunk2.ads b/gcc/testsuite/gnat.dg/thunk2.ads
new file mode 100644
index 00000000000..05dc45bc74b
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/thunk2.ads
@@ -0,0 +1,12 @@
+with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
+with Thunk2_Pkg; use Thunk2_Pkg;
+
+package Thunk2 is
+
+  type Ext is new Root and I with record
+    S : Unbounded_String;
+  end record;
+
+  overriding function Element (Self : Ext; Name : String) return Ext;
+
+end Thunk2;
diff --git a/gcc/testsuite/gnat.dg/thunk2_pkg.ads b/gcc/testsuite/gnat.dg/thunk2_pkg.ads
new file mode 100644
index 00000000000..75799892ed8
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/thunk2_pkg.ads
@@ -0,0 +1,11 @@
+package Thunk2_Pkg is
+
+  type Root is tagged record
+    A : Integer;
+  end record;
+
+  type I is interface;
+
+  function Element (Self : I; Name : String) return I is abstract;
+
+end Thunk2_Pkg;
diff --git a/gcc/testsuite/go.test/test/fixedbugs/issue4085b.go b/gcc/testsuite/go.test/test/fixedbugs/issue4085b.go
index 6bf315fcc2f..6304ce073aa 100644
--- a/gcc/testsuite/go.test/test/fixedbugs/issue4085b.go
+++ b/gcc/testsuite/go.test/test/fixedbugs/issue4085b.go
@@ -21,9 +21,11 @@ func main() {
 	shouldPanic("cap out of range", func() { _ = make(T, 0, int64(n)) })
 	var t *byte
 	if unsafe.Sizeof(t) == 8 {
-		var n2 int64 = 1 << 50
+		// Test mem > maxAlloc
+		var n2 int64 = 1 << 59
 		shouldPanic("len out of range", func() { _ = make(T, int(n2)) })
 		shouldPanic("cap out of range", func() { _ = make(T, 0, int(n2)) })
+		// Test elem.size*cap overflow
 		n2 = 1<<63 - 1
 		shouldPanic("len out of range", func() { _ = make(T, int(n2)) })
 		shouldPanic("cap out of range", func() { _ = make(T, 0, int(n2)) })
diff --git a/gcc/testsuite/lib/gcc-dg.exp b/gcc/testsuite/lib/gcc-dg.exp
index c56e8e80ae0..b756f7c80f9 100644
--- a/gcc/testsuite/lib/gcc-dg.exp
+++ b/gcc/testsuite/lib/gcc-dg.exp
@@ -470,7 +470,10 @@ proc dg-set-target-env-var { args } {
 	error "dg-set-target-env-var: need two arguments"
 	return
     }
-    lappend set_target_env_var [list [lindex $args 1] [lindex $args 2]]
+    set var [lindex $args 1]
+    set value [lindex $args 2]
+    verbose "dg-set-target-env-var $var $value" 2
+    lappend set_target_env_var [list $var $value]
 }
 
 proc set-target-env-var { } {
@@ -511,6 +514,7 @@ proc dg-set-compiler-env-var { args } {
     }
     set var [lindex $args 1]
     set value [lindex $args 2]
+    verbose "dg-set-compiler-env-var $var $value" 2
     if [info exists ::env($var)] {
       lappend saved_compiler_env_var [list $var 1 $::env($var)]
     } else {
@@ -1221,7 +1225,7 @@ proc dg-optimized { args } {
     # Make this variable available here and to the saved proc.
     upvar dg-messages dg-messages
 
-    process-message saved-dg-error "optimized: " "$args"
+    process-message saved-dg-warning "optimized:" "$args"
 }
 
 # Handle output from -fopt-info for MSG_MISSED_OPTIMIZATION:
@@ -1231,7 +1235,7 @@ proc dg-missed { args } {
     # Make this variable available here and to the saved proc.
     upvar dg-messages dg-messages
 
-    process-message saved-dg-error "missed: " "$args"
+    process-message saved-dg-warning "missed:" "$args"
 }
 
 # Check the existence of a gdb in the path, and return true if there
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index ea9a50ccb27..32e825cdd4a 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -4414,6 +4414,27 @@ proc check_effective_target_aarch64_bti_hw { } {
     } "-O2" ]
 }
 
+# Return 1 if the target supports executing the armv8.3-a FJCVTZS
+# instruction.
+proc check_effective_target_aarch64_fjcvtzs_hw { } {
+    if { ![istarget aarch64*-*-*] } {
+	return 0
+    }
+    return [check_runtime aarch64_fjcvtzs_hw_available {
+	int
+	main (void)
+	{
+	  double in = 25.1;
+	  int out;
+	  asm volatile ("fjcvtzs %w0, %d1"
+			: "=r" (out)
+			: "w" (in)
+			: /* No clobbers.  */);
+	  return out != 25;
+	}
+    } "-march=armv8.3-a" ]
+}
+
 # Return 1 if GCC was configured with --enable-standard-branch-protection
 proc check_effective_target_default_branch_protection { } {
     return [check_configured_with "enable-standard-branch-protection"]
@@ -8579,7 +8600,8 @@ proc check_effective_target_aarch64_tiny { } {
 # Create functions to check that the AArch64 assembler supports the
 # various architecture extensions via the .arch_extension pseudo-op.
 
-foreach { aarch64_ext } { "fp" "simd" "crypto" "crc" "lse" "dotprod" "sve"} {
+foreach { aarch64_ext } { "fp" "simd" "crypto" "crc" "lse" "dotprod" "sve"
+			  "sb"} {
     eval [string map [list FUNC $aarch64_ext] {
 	proc check_effective_target_aarch64_asm_FUNC_ok { } {
 	  if { [istarget aarch64*-*-*] } {
@@ -9400,3 +9422,25 @@ proc check_effective_target_mfentry { } {
 	        void foo (void) { }
     } "-mfentry"]
 }
+
+# Return 1 if we're able to assemble movdiri and movdir64b
+
+proc check_effective_target_movdir { } {
+    return [check_no_compiler_messages movdir object {
+	void
+	foo (unsigned int *d, unsigned int s)
+	{
+	  __builtin_ia32_directstoreu_u32 (d, s);
+	}
+	void
+	bar (void *d, const void *s)
+	{
+	  __builtin_ia32_movdir64b (d, s);
+	}
+    } "-mmovdiri -mmovdir64b" ]
+}
+
+# Return 1 if GCC was configured with --with-tune=cortex-a76
+proc check_effective_target_tune_cortex_a76 { } {
+    return [check_configured_with "with-tune=cortex-a76"]
+}
diff --git a/gcc/testsuite/substr_10.f90 b/gcc/testsuite/substr_10.f90
new file mode 100644
index 00000000000..918ca8af162
--- /dev/null
+++ b/gcc/testsuite/substr_10.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR93340 - test error handling of substring simplification
+
+subroutine p
+  integer,parameter :: k = len ('a'(:0))
+  integer,parameter :: m = len ('a'(0:)) ! { dg-error "Substring start index" }
+  call foo ('bcd'(-8:-9))
+  call foo ('bcd'(-9:-8)) ! { dg-error "Substring start index" }
+  call foo ('bcd'(:12))   ! { dg-error "Substring end index" }
+  call foo ('bcd'(-12:))  ! { dg-error "Substring start index" }
+end
diff --git a/gcc/testsuite/substr_9.f90 b/gcc/testsuite/substr_9.f90
new file mode 100644
index 00000000000..73152d6627f
--- /dev/null
+++ b/gcc/testsuite/substr_9.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+! { dg-options "-std=gnu -fdump-tree-original" }
+! PR93340 - issues with substrings in initializers
+
+program p
+  implicit none
+  integer, parameter :: m = 1
+  character b(2) /'a', 'b'   (1:1)/
+  character c(2) /'a', 'bc'  (1:1)/
+  character d(2) /'a', 'bxyz'(m:m)/
+  character e(2)
+  character f(2)
+  data e /'a', 'bxyz'( :1)/
+  data f /'a', 'xyzb'(4:4)/
+  character :: g(2) = [ 'a', 'b' (1:1) ]
+  character :: h(2) = [ 'a', 'bc'(1:1) ]
+  character :: k(2) = [ 'a', 'bc'(m:1) ]
+  if (b(2) /= "b") stop 1
+  if (c(2) /= "b") stop 2
+  if (d(2) /= "b") stop 3
+  if (e(2) /= "b") stop 4
+  if (f(2) /= "b") stop 5
+  if (g(2) /= "b") stop 6
+  if (h(2) /= "b") stop 7
+  if (k(2) /= "b") stop 8
+end
+
+! { dg-final { scan-tree-dump-times "xyz" 0 "original" } }
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index 0c4ae81aa05..e5dfd17ded9 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -1726,6 +1726,7 @@ group_case_labels_stmt (gswitch *stmt)
   int old_size = gimple_switch_num_labels (stmt);
   int i, next_index, new_size;
   basic_block default_bb = NULL;
+  hash_set<tree> *removed_labels = NULL;
 
   default_bb = gimple_switch_default_bb (cfun, stmt);
 
@@ -1742,8 +1743,11 @@ group_case_labels_stmt (gswitch *stmt)
       base_bb = label_to_block (cfun, CASE_LABEL (base_case));
 
       /* Discard cases that have the same destination as the default case or
-	 whose destiniation blocks have already been removed as unreachable.  */
-      if (base_bb == NULL || base_bb == default_bb)
+	 whose destination blocks have already been removed as unreachable.  */
+      if (base_bb == NULL
+	  || base_bb == default_bb
+	  || (removed_labels
+	      && removed_labels->contains (CASE_LABEL (base_case))))
 	{
 	  i++;
 	  continue;
@@ -1766,10 +1770,13 @@ group_case_labels_stmt (gswitch *stmt)
 	  /* Merge the cases if they jump to the same place,
 	     and their ranges are consecutive.  */
 	  if (merge_bb == base_bb
+	      && (removed_labels == NULL
+		  || !removed_labels->contains (CASE_LABEL (merge_case)))
 	      && wi::to_wide (CASE_LOW (merge_case)) == bhp1)
 	    {
-	      base_high = CASE_HIGH (merge_case) ?
-		  CASE_HIGH (merge_case) : CASE_LOW (merge_case);
+	      base_high
+		= (CASE_HIGH (merge_case)
+		   ? CASE_HIGH (merge_case) : CASE_LOW (merge_case));
 	      CASE_HIGH (base_case) = base_high;
 	      next_index++;
 	    }
@@ -1790,7 +1797,29 @@ group_case_labels_stmt (gswitch *stmt)
 	{
 	  edge base_edge = find_edge (gimple_bb (stmt), base_bb);
 	  if (base_edge != NULL)
-	    remove_edge_and_dominated_blocks (base_edge);
+	    {
+	      for (gimple_stmt_iterator gsi = gsi_start_bb (base_bb);
+		   !gsi_end_p (gsi); gsi_next (&gsi))
+		if (glabel *stmt = dyn_cast <glabel *> (gsi_stmt (gsi)))
+		  {
+		    if (FORCED_LABEL (gimple_label_label (stmt))
+			|| DECL_NONLOCAL (gimple_label_label (stmt)))
+		      {
+			/* Forced/non-local labels aren't going to be removed,
+			   but they will be moved to some neighbouring basic
+			   block. If some later case label refers to one of
+			   those labels, we should throw that case away rather
+			   than keeping it around and refering to some random
+			   other basic block without an edge to it.  */
+			if (removed_labels == NULL)
+			  removed_labels = new hash_set<tree>;
+			removed_labels->add (gimple_label_label (stmt));
+		      }
+		  }
+		else
+		  break;
+	      remove_edge_and_dominated_blocks (base_edge);
+	    }
 	  i = next_index;
 	  continue;
 	}
@@ -1807,6 +1836,7 @@ group_case_labels_stmt (gswitch *stmt)
   if (new_size < old_size)
     gimple_switch_set_num_labels (stmt, new_size);
 
+  delete removed_labels;
   return new_size < old_size;
 }
 
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index d00c1bd31e6..8aa4e39b5b9 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -141,7 +141,7 @@ tree_fold_divides_p (const_tree a, const_tree b)
 /* Returns true iff A divides B.  */
 
 static inline bool
-int_divides_p (int a, int b)
+int_divides_p (lambda_int a, lambda_int b)
 {
   return ((b % a) == 0);
 }
@@ -3567,10 +3567,10 @@ lambda_matrix_right_hermite (lambda_matrix A, int m, int n,
 
 		  a = S[i-1][j];
 		  b = S[i][j];
-		  sigma = (a * b < 0) ? -1: 1;
-		  a = abs_hwi (a);
-		  b = abs_hwi (b);
-		  factor = sigma * (a / b);
+		  sigma = ((a < 0) ^ (b < 0)) ? -1: 1;
+		  unsigned HOST_WIDE_INT abs_a = absu_hwi (a);
+		  unsigned HOST_WIDE_INT abs_b = absu_hwi (b);
+		  factor = sigma * (lambda_int)(abs_a / abs_b);
 
 		  lambda_matrix_row_add (S, n, i, i-1, -factor);
 		  std::swap (S[i], S[i-1]);
@@ -3596,7 +3596,7 @@ analyze_subscript_affine_affine (tree chrec_a,
 				 tree *last_conflicts)
 {
   unsigned nb_vars_a, nb_vars_b, dim;
-  HOST_WIDE_INT gamma, gcd_alpha_beta;
+  lambda_int gamma, gcd_alpha_beta;
   lambda_matrix A, U, S;
   struct obstack scratch_obstack;
 
@@ -4369,17 +4369,19 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,
   return true;
 }
 
-/* Return true when the DDR contains only constant access functions.  */
+/* Return true when the DDR contains only invariant access functions wrto. loop
+   number LNUM.  */
 
 static bool
-constant_access_functions (const struct data_dependence_relation *ddr)
+invariant_access_functions (const struct data_dependence_relation *ddr,
+			    int lnum)
 {
   unsigned i;
   subscript *sub;
 
   FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)
-    if (!evolution_function_is_constant_p (SUB_ACCESS_FN (sub, 0))
-	|| !evolution_function_is_constant_p (SUB_ACCESS_FN (sub, 1)))
+    if (!evolution_function_is_invariant_p (SUB_ACCESS_FN (sub, 0), lnum)
+	|| !evolution_function_is_invariant_p (SUB_ACCESS_FN (sub, 1), lnum))
       return false;
 
   return true;
@@ -4578,7 +4580,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,
       dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));
       save_dist_v (ddr, dist_v);
 
-      if (constant_access_functions (ddr))
+      if (invariant_access_functions (ddr, loop_nest->num))
 	add_distance_for_zero_overlaps (ddr);
 
       if (DDR_NB_LOOPS (ddr) > 1)
diff --git a/gcc/tree-emutls.c b/gcc/tree-emutls.c
index 6fc8370f42c..b34ef40aa03 100644
--- a/gcc/tree-emutls.c
+++ b/gcc/tree-emutls.c
@@ -242,16 +242,18 @@ get_emutls_init_templ_addr (tree decl)
   DECL_PRESERVE_P (to) = DECL_PRESERVE_P (decl);
 
   DECL_WEAK (to) = DECL_WEAK (decl);
-  if (DECL_ONE_ONLY (decl))
+  if (DECL_ONE_ONLY (decl) || DECL_WEAK (decl))
     {
       TREE_STATIC (to) = TREE_STATIC (decl);
       TREE_PUBLIC (to) = TREE_PUBLIC (decl);
       DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);
-      make_decl_one_only (to, DECL_ASSEMBLER_NAME (to));
     }
   else
     TREE_STATIC (to) = 1;
 
+  if (DECL_ONE_ONLY (decl))
+    make_decl_one_only (to, DECL_ASSEMBLER_NAME (to));
+
   DECL_VISIBILITY_SPECIFIED (to) = DECL_VISIBILITY_SPECIFIED (decl);
   DECL_INITIAL (to) = DECL_INITIAL (decl);
   DECL_INITIAL (decl) = NULL;
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
index 2780a4b243f..56c0905093e 100644
--- a/gcc/tree-if-conv.c
+++ b/gcc/tree-if-conv.c
@@ -1139,6 +1139,11 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)
   if (EDGE_COUNT (bb->succs) > 2)
     return false;
 
+  gimple *last = last_stmt (bb);
+  if (gcall *call = safe_dyn_cast <gcall *> (last))
+    if (gimple_call_ctrl_altering_p (call))
+      return false;
+
   if (exit_bb)
     {
       if (bb != loop->latch)
@@ -2913,9 +2918,12 @@ ifcvt_local_dce (basic_block bb)
   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
     {
       stmt = gsi_stmt (gsi);
-      if (gimple_store_p (stmt)
-	  || gimple_assign_load_p (stmt)
-	  || is_gimple_debug (stmt))
+      if (is_gimple_debug (stmt))
+	{
+	  gimple_set_plf (stmt, GF_PLF_2, true);
+	  continue;
+	}
+      if (gimple_store_p (stmt) || gimple_assign_load_p (stmt))
 	{
 	  gimple_set_plf (stmt, GF_PLF_2, true);
 	  worklist.safe_push (stmt);
@@ -2936,7 +2944,7 @@ ifcvt_local_dce (basic_block bb)
 	  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)
 	    {
 	      stmt1 = USE_STMT (use_p);
-	      if (gimple_bb (stmt1) != bb)
+	      if (!is_gimple_debug (stmt1) && gimple_bb (stmt1) != bb)
 		{
 		  gimple_set_plf (stmt, GF_PLF_2, true);
 		  worklist.safe_push (stmt);
@@ -2959,21 +2967,22 @@ ifcvt_local_dce (basic_block bb)
 	  if (TREE_CODE (use) != SSA_NAME)
 	    continue;
 	  stmt1 = SSA_NAME_DEF_STMT (use);
-	  if (gimple_bb (stmt1) != bb
-	      || gimple_plf (stmt1, GF_PLF_2))
+	  if (gimple_bb (stmt1) != bb || gimple_plf (stmt1, GF_PLF_2))
 	    continue;
 	  gimple_set_plf (stmt1, GF_PLF_2, true);
 	  worklist.safe_push (stmt1);
 	}
     }
   /* Delete dead statements.  */
-  gsi = gsi_start_bb (bb);
+  gsi = gsi_last_bb (bb);
   while (!gsi_end_p (gsi))
     {
+      gimple_stmt_iterator gsiprev = gsi;
+      gsi_prev (&gsiprev);
       stmt = gsi_stmt (gsi);
       if (gimple_plf (stmt, GF_PLF_2))
 	{
-	  gsi_next (&gsi);
+	  gsi = gsiprev;
 	  continue;
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2983,6 +2992,7 @@ ifcvt_local_dce (basic_block bb)
 	}
       gsi_remove (&gsi, true);
       release_defs (stmt);
+      gsi = gsiprev;
     }
 }
 
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index d115fcb1a5b..878f1631a17 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -543,8 +543,9 @@ remap_type_1 (tree type, copy_body_data *id)
 	  /* For array bounds where we have decided not to copy over the bounds
 	     variable which isn't used in OpenMP/OpenACC region, change them to
 	     an uninitialized VAR_DECL temporary.  */
-	  if (TYPE_MAX_VALUE (TYPE_DOMAIN (new_tree)) == error_mark_node
-	      && id->adjust_array_error_bounds
+	  if (id->adjust_array_error_bounds
+	      && TYPE_DOMAIN (new_tree)
+	      && TYPE_MAX_VALUE (TYPE_DOMAIN (new_tree)) == error_mark_node
 	      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)
 	    {
 	      tree v = create_tmp_var (TREE_TYPE (TYPE_DOMAIN (new_tree)));
@@ -3213,10 +3214,10 @@ insert_init_stmt (copy_body_data *id, basic_block bb, gimple *init_stmt)
 	  gimple_assign_set_rhs1 (init_stmt, rhs);
 	}
       gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);
-      gimple_regimplify_operands (init_stmt, &si);
-
       if (!is_gimple_debug (init_stmt))
 	{
+	  gimple_regimplify_operands (init_stmt, &si);
+
 	  tree def = gimple_assign_lhs (init_stmt);
 	  insert_init_debug_bind (id, bb, def, def, init_stmt);
 	}
@@ -5698,6 +5699,7 @@ copy_decl_to_var (tree decl, copy_body_data *id)
   TREE_READONLY (copy) = TREE_READONLY (decl);
   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);
   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);
+  DECL_BY_REFERENCE (copy) = DECL_BY_REFERENCE (decl);
 
   return copy_decl_for_dup_finish (id, decl, copy);
 }
diff --git a/gcc/tree-loop-distribution.c b/gcc/tree-loop-distribution.c
index 8959f52a67b..15a74544a07 100644
--- a/gcc/tree-loop-distribution.c
+++ b/gcc/tree-loop-distribution.c
@@ -1004,7 +1004,7 @@ generate_memset_builtin (struct loop *loop, partition *partition)
   nb_bytes = rewrite_to_non_trapping_overflow (builtin->size);
   nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,
 				       false, GSI_CONTINUE_LINKING);
-  mem = builtin->dst_base;
+  mem = rewrite_to_non_trapping_overflow (builtin->dst_base);
   mem = force_gimple_operand_gsi (&gsi, mem, true, NULL_TREE,
 				  false, GSI_CONTINUE_LINKING);
 
@@ -1056,8 +1056,8 @@ generate_memcpy_builtin (struct loop *loop, partition *partition)
   nb_bytes = rewrite_to_non_trapping_overflow (builtin->size);
   nb_bytes = force_gimple_operand_gsi (&gsi, nb_bytes, true, NULL_TREE,
 				       false, GSI_CONTINUE_LINKING);
-  dest = builtin->dst_base;
-  src = builtin->src_base;
+  dest = rewrite_to_non_trapping_overflow (builtin->dst_base);
+  src = rewrite_to_non_trapping_overflow (builtin->src_base);
   if (partition->kind == PKIND_MEMCPY
       || ! ptr_derefs_may_alias_p (dest, src))
     kind = BUILT_IN_MEMCPY;
@@ -1949,7 +1949,8 @@ pg_add_dependence_edges (struct graph *rdg, int dir,
 		this_dir = -this_dir;
 
 	      /* Known dependences can still be unordered througout the
-		 iteration space, see gcc.dg/tree-ssa/ldist-16.c.  */
+		 iteration space, see gcc.dg/tree-ssa/ldist-16.c and
+		 gcc.dg/tree-ssa/pr94969.c.  */
 	      if (DDR_NUM_DIST_VECTS (ddr) != 1)
 		this_dir = 2;
 	      /* If the overlap is exact preserve stmt order.  */
@@ -2013,6 +2014,8 @@ struct pg_edge_callback_data
   bitmap sccs_to_merge;
   /* Array constains component information for all vertices.  */
   int *vertices_component;
+  /* Array constains postorder information for all vertices.  */
+  int *vertices_post;
   /* Vector to record all data dependence relations which are needed
      to break strong connected components by runtime alias checks.  */
   vec<ddr_p> *alias_ddrs;
@@ -2275,7 +2278,7 @@ break_alias_scc_partitions (struct graph *rdg,
 			    vec<struct partition *> *partitions,
 			    vec<ddr_p> *alias_ddrs)
 {
-  int i, j, k, num_sccs, num_sccs_no_alias;
+  int i, j, k, num_sccs, num_sccs_no_alias = 0;
   /* Build partition dependence graph.  */
   graph *pg = build_partition_graph (rdg, partitions, false);
 
@@ -2326,6 +2329,7 @@ break_alias_scc_partitions (struct graph *rdg,
       cbdata.sccs_to_merge = sccs_to_merge;
       cbdata.alias_ddrs = alias_ddrs;
       cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);
+      cbdata.vertices_post = XNEWVEC (int, pg->n_vertices);
       /* Record the component information which will be corrupted by next
 	 graph scc finding call.  */
       for (i = 0; i < pg->n_vertices; ++i)
@@ -2334,6 +2338,11 @@ break_alias_scc_partitions (struct graph *rdg,
       /* Collect data dependences for runtime alias checks to break SCCs.  */
       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)
 	{
+	  /* Record the postorder information which will be corrupted by next
+	     graph SCC finding call.  */
+	  for (i = 0; i < pg->n_vertices; ++i)
+	    cbdata.vertices_post[i] = pg->vertices[i].post;
+
 	  /* Run SCC finding algorithm again, with alias dependence edges
 	     skipped.  This is to topologically sort partitions according to
 	     compilation time known dependence.  Note the topological order
@@ -2364,14 +2373,6 @@ break_alias_scc_partitions (struct graph *rdg,
 	      if (cbdata.vertices_component[k] != i)
 		continue;
 
-	      /* Update postorder number so that merged reduction partition is
-		 sorted after other partitions.  */
-	      if (!partition_reduction_p (first)
-		  && partition_reduction_p (partition))
-		{
-		  gcc_assert (pg->vertices[k].post < pg->vertices[j].post);
-		  pg->vertices[j].post = pg->vertices[k].post;
-		}
 	      partition_merge_into (NULL, first, partition, FUSE_SAME_SCC);
 	      (*partitions)[k] = NULL;
 	      partition_free (partition);
@@ -2382,6 +2383,29 @@ break_alias_scc_partitions (struct graph *rdg,
 	      first->type = PTYPE_SEQUENTIAL;
 	    }
 	}
+      /* Restore the postorder information if it's corrupted in finding SCC
+	 with alias dependence edges skipped.  If reduction partition's SCC is
+	 broken by runtime alias checks, we force a negative post order to it
+	 making sure it will be scheduled in the last.  */
+      if (num_sccs_no_alias > 0)
+	{
+	  j = -1;
+	  for (i = 0; i < pg->n_vertices; ++i)
+	    {
+	      pg->vertices[i].post = cbdata.vertices_post[i];
+	      struct pg_vdata *data = (struct pg_vdata *)pg->vertices[i].data;
+	      if (data->partition && partition_reduction_p (data->partition))
+		{
+		  gcc_assert (j == -1);
+		  j = i;
+		}
+	    }
+	  if (j >= 0)
+	    pg->vertices[j].post = -1;
+	}
+
+      free (cbdata.vertices_component);
+      free (cbdata.vertices_post);
     }
 
   sort_partitions_by_post_order (pg, partitions);
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index 3fe23cc2b22..dc0cfe27142 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -1178,7 +1178,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 {
   struct nesting_info *const info = (struct nesting_info *) wi->info;
   bool need_chain = false, need_stmts = false;
-  tree clause, decl;
+  tree clause, decl, *pdecl;
   int dummy;
   bitmap new_suppress;
 
@@ -1187,6 +1187,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 
   for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))
     {
+      pdecl = NULL;
       switch (OMP_CLAUSE_CODE (clause))
 	{
 	case OMP_CLAUSE_REDUCTION:
@@ -1194,6 +1195,15 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	case OMP_CLAUSE_TASK_REDUCTION:
 	  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))
 	    need_stmts = true;
+	  if (TREE_CODE (OMP_CLAUSE_DECL (clause)) == MEM_REF)
+	    {
+	      pdecl = &TREE_OPERAND (OMP_CLAUSE_DECL (clause), 0);
+	      if (TREE_CODE (*pdecl) == POINTER_PLUS_EXPR)
+		pdecl = &TREE_OPERAND (*pdecl, 0);
+	      if (TREE_CODE (*pdecl) == INDIRECT_REF
+		  || TREE_CODE (*pdecl) == ADDR_EXPR)
+		pdecl = &TREE_OPERAND (*pdecl, 0);
+	    }
 	  goto do_decl_clause;
 
 	case OMP_CLAUSE_LASTPRIVATE:
@@ -1219,7 +1229,9 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	case OMP_CLAUSE_USE_DEVICE_PTR:
 	case OMP_CLAUSE_IS_DEVICE_PTR:
 	do_decl_clause:
-	  decl = OMP_CLAUSE_DECL (clause);
+	  if (pdecl == NULL)
+	    pdecl = &OMP_CLAUSE_DECL (clause);
+	  decl = *pdecl;
 	  if (VAR_P (decl)
 	      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
 	    break;
@@ -1228,7 +1240,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	      if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_SHARED)
 		OMP_CLAUSE_SHARED_READONLY (clause) = 0;
 	      bitmap_set_bit (new_suppress, DECL_UID (decl));
-	      OMP_CLAUSE_DECL (clause) = get_nonlocal_debug_decl (info, decl);
+	      *pdecl = get_nonlocal_debug_decl (info, decl);
 	      if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE_PRIVATE)
 		need_chain = true;
 	    }
@@ -1396,12 +1408,22 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))
 		DECL_CONTEXT (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))
 		  = info->context;
+	      tree save_local_var_chain = info->new_local_var_chain;
+	      info->new_local_var_chain = NULL;
+	      gimple_seq *seq = &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause);
 	      walk_body (convert_nonlocal_reference_stmt,
-			 convert_nonlocal_reference_op, info,
-			 &OMP_CLAUSE_REDUCTION_GIMPLE_INIT (clause));
+			 convert_nonlocal_reference_op, info, seq);
+	      if (info->new_local_var_chain)
+		declare_vars (info->new_local_var_chain,
+			      gimple_seq_first_stmt (*seq), false);
+	      info->new_local_var_chain = NULL;
+	      seq = &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause);
 	      walk_body (convert_nonlocal_reference_stmt,
-			 convert_nonlocal_reference_op, info,
-			 &OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (clause));
+			 convert_nonlocal_reference_op, info, seq);
+	      if (info->new_local_var_chain)
+		declare_vars (info->new_local_var_chain,
+			      gimple_seq_first_stmt (*seq), false);
+	      info->new_local_var_chain = save_local_var_chain;
 	      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))
 		= old_context;
 	      if (OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clause))
@@ -1411,15 +1433,31 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	  break;
 
 	case OMP_CLAUSE_LASTPRIVATE:
-	  walk_body (convert_nonlocal_reference_stmt,
-		     convert_nonlocal_reference_op, info,
-		     &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause));
+	  {
+	    tree save_local_var_chain = info->new_local_var_chain;
+	    info->new_local_var_chain = NULL;
+	    gimple_seq *seq = &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause);
+	    walk_body (convert_nonlocal_reference_stmt,
+		       convert_nonlocal_reference_op, info, seq);
+	    if (info->new_local_var_chain)
+	      declare_vars (info->new_local_var_chain,
+			    gimple_seq_first_stmt (*seq), false);
+	    info->new_local_var_chain = save_local_var_chain;
+	  }
 	  break;
 
 	case OMP_CLAUSE_LINEAR:
-	  walk_body (convert_nonlocal_reference_stmt,
-		     convert_nonlocal_reference_op, info,
-		     &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause));
+	  {
+	    tree save_local_var_chain = info->new_local_var_chain;
+	    info->new_local_var_chain = NULL;
+	    gimple_seq *seq = &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause);
+	    walk_body (convert_nonlocal_reference_stmt,
+		       convert_nonlocal_reference_op, info, seq);
+	    if (info->new_local_var_chain)
+	      declare_vars (info->new_local_var_chain,
+			    gimple_seq_first_stmt (*seq), false);
+	    info->new_local_var_chain = save_local_var_chain;
+	  }
 	  break;
 
 	default:
@@ -1894,7 +1932,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 {
   struct nesting_info *const info = (struct nesting_info *) wi->info;
   bool need_frame = false, need_stmts = false;
-  tree clause, decl;
+  tree clause, decl, *pdecl;
   int dummy;
   bitmap new_suppress;
 
@@ -1903,6 +1941,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 
   for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))
     {
+      pdecl = NULL;
       switch (OMP_CLAUSE_CODE (clause))
 	{
 	case OMP_CLAUSE_REDUCTION:
@@ -1910,6 +1949,15 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	case OMP_CLAUSE_TASK_REDUCTION:
 	  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))
 	    need_stmts = true;
+	  if (TREE_CODE (OMP_CLAUSE_DECL (clause)) == MEM_REF)
+	    {
+	      pdecl = &TREE_OPERAND (OMP_CLAUSE_DECL (clause), 0);
+	      if (TREE_CODE (*pdecl) == POINTER_PLUS_EXPR)
+		pdecl = &TREE_OPERAND (*pdecl, 0);
+	      if (TREE_CODE (*pdecl) == INDIRECT_REF
+		  || TREE_CODE (*pdecl) == ADDR_EXPR)
+		pdecl = &TREE_OPERAND (*pdecl, 0);
+	    }
 	  goto do_decl_clause;
 
 	case OMP_CLAUSE_LASTPRIVATE:
@@ -1935,7 +1983,9 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	case OMP_CLAUSE_USE_DEVICE_PTR:
 	case OMP_CLAUSE_IS_DEVICE_PTR:
 	do_decl_clause:
-	  decl = OMP_CLAUSE_DECL (clause);
+	  if (pdecl == NULL)
+	    pdecl = &OMP_CLAUSE_DECL (clause);
+	  decl = *pdecl;
 	  if (VAR_P (decl)
 	      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
 	    break;
@@ -1948,8 +1998,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 		  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_SHARED)
 		    OMP_CLAUSE_SHARED_READONLY (clause) = 0;
 		  bitmap_set_bit (new_suppress, DECL_UID (decl));
-		  OMP_CLAUSE_DECL (clause)
-		    = get_local_debug_decl (info, decl, field);
+		  *pdecl = get_local_debug_decl (info, decl, field);
 		  need_frame = true;
 		}
 	    }
diff --git a/gcc/tree-object-size.c b/gcc/tree-object-size.c
index 25c5ced57b7..6450cae371d 100644
--- a/gcc/tree-object-size.c
+++ b/gcc/tree-object-size.c
@@ -1369,7 +1369,10 @@ pass_object_sizes::execute (function *fun)
 	    }
 
 	  /* Propagate into all uses and fold those stmts.  */
-	  replace_uses_by (lhs, result);
+	  if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))
+	    replace_uses_by (lhs, result);
+	  else
+	    replace_call_with_value (&i, result);
 	}
     }
 
diff --git a/gcc/tree-pretty-print.c b/gcc/tree-pretty-print.c
index ae0a6c12072..2190635b432 100644
--- a/gcc/tree-pretty-print.c
+++ b/gcc/tree-pretty-print.c
@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Local functions, macros and variables.  */
 static const char *op_symbol (const_tree);
-static void pretty_print_string (pretty_printer *, const char*, unsigned);
 static void newline_and_indent (pretty_printer *, int);
 static void maybe_init_pretty_print (FILE *);
 static void print_struct_decl (pretty_printer *, const_tree, int, dump_flags_t);
@@ -2944,10 +2943,11 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,
 	 libstdc++-prettyprinters/shared_ptr.cc with and without -g,
 	 for example, at occurrences of OBJ_TYPE_REF.  */
       if (!(flags & (TDF_SLIM | TDF_COMPARE_DEBUG))
-	  && virtual_method_call_p (node))
+	  && virtual_method_call_p (node, true))
 	{
 	  pp_string (pp, "(");
-	  dump_generic_node (pp, obj_type_ref_class (node), spc, flags, false);
+	  dump_generic_node (pp, obj_type_ref_class (node, true),
+			     spc, flags, false);
 	  pp_string (pp, ")");
 	}
       dump_generic_node (pp, OBJ_TYPE_REF_OBJECT (node), spc, flags, false);
@@ -4021,8 +4021,8 @@ print_call_name (pretty_printer *pp, tree node, dump_flags_t flags)
 /* Print the first N characters in the array STR, replacing non-printable
    characters (including embedded nuls) with unambiguous escape sequences.  */
 
-static void
-pretty_print_string (pretty_printer *pp, const char *str, unsigned n)
+void
+pretty_print_string (pretty_printer *pp, const char *str, size_t n)
 {
   if (str == NULL)
     return;
diff --git a/gcc/tree-pretty-print.h b/gcc/tree-pretty-print.h
index 9f593289666..41697e77994 100644
--- a/gcc/tree-pretty-print.h
+++ b/gcc/tree-pretty-print.h
@@ -47,6 +47,7 @@ extern void print_declaration (pretty_printer *, tree, int, dump_flags_t);
 extern int op_code_prio (enum tree_code);
 extern int op_prio (const_tree);
 extern const char *op_symbol_code (enum tree_code);
+extern void pretty_print_string (pretty_printer *, const char *, size_t);
 extern void print_call_name (pretty_printer *, tree, dump_flags_t);
 extern void percent_K_format (text_info *, location_t, tree);
 extern void pp_tree_identifier (pretty_printer *, tree);
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index fd51a3d0323..909b4fef9a8 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -291,6 +291,9 @@ static object_allocator<assign_link> assign_link_pool ("SRA links");
 /* Base (tree) -> Vector (vec<access_p> *) map.  */
 static hash_map<tree, auto_vec<access_p> > *base_access_vec;
 
+/* Hash to limit creation of artificial accesses */
+static hash_map<tree, unsigned> *propagation_budget;
+
 /* Candidate hash table helpers.  */
 
 struct uid_decl_hasher : nofree_ptr_hash <tree_node>
@@ -2326,7 +2329,7 @@ create_access_replacement (struct access *access, tree reg_type = NULL_TREE)
 	  print_generic_expr (dump_file, access->base);
 	  fprintf (dump_file, " offset: %u, size: %u: ",
 		   (unsigned) access->offset, (unsigned) access->size);
-	  print_generic_expr (dump_file, repl);
+	  print_generic_expr (dump_file, repl, TDF_UID);
 	  fprintf (dump_file, "\n");
 	}
     }
@@ -2670,6 +2673,45 @@ subtree_mark_written_and_enqueue (struct access *access)
     subtree_mark_written_and_enqueue (child);
 }
 
+/* If there is still budget to create a propagation access for DECL, return
+   true and decrement the budget.  Otherwise return false.  */
+
+static bool
+budget_for_propagation_access (tree decl)
+{
+  unsigned b, *p = propagation_budget->get (decl);
+  if (p)
+    b = *p;
+  else
+    b = PARAM_SRA_MAX_PROPAGATIONS;
+
+  if (b == 0)
+    return false;
+  b--;
+
+  if (b == 0 && dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fprintf (dump_file, "The propagation budget of ");
+      print_generic_expr (dump_file, decl);
+      fprintf (dump_file, " (UID: %u) has been exhausted.\n", DECL_UID (decl));
+    }
+  propagation_budget->put (decl, b);
+  return true;
+}
+
+/* Return true if ACC or any of its subaccesses has grp_child set.  */
+
+static bool
+access_or_its_child_written (struct access *acc)
+{
+  if (acc->grp_write)
+    return true;
+  for (struct access *sub = acc->first_child; sub; sub = sub->next_sibling)
+    if (access_or_its_child_written (sub))
+      return true;
+  return false;
+}
+
 /* Propagate subaccesses and grp_write flags of RACC across an assignment link
    to LACC.  Enqueue sub-accesses as necessary so that the write flag is
    propagated transitively.  Return true if anything changed.  Additionally, if
@@ -2770,9 +2812,10 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)
 	  continue;
 	}
 
-      if (rchild->grp_unscalarizable_region)
+      if (rchild->grp_unscalarizable_region
+	  || !budget_for_propagation_access (lacc->base))
 	{
-	  if (rchild->grp_write && !lacc->grp_write)
+	  if (!lacc->grp_write && access_or_its_child_written (rchild))
 	    {
 	      ret = true;
 	      subtree_mark_written_and_enqueue (lacc);
@@ -2800,6 +2843,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)
 static void
 propagate_all_subaccesses (void)
 {
+  propagation_budget = new hash_map<tree, unsigned>;
   while (work_queue_head)
     {
       struct access *racc = pop_access_from_work_queue ();
@@ -2838,6 +2882,7 @@ propagate_all_subaccesses (void)
 	    while (lacc);
 	}
     }
+  delete propagation_budget;
 }
 
 /* Go through all accesses collected throughout the (intraprocedural) analysis
@@ -3155,6 +3200,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)
   location_t loc;
   struct access *access;
   tree type, bfr, orig_expr;
+  bool partial_cplx_access = false;
 
   if (TREE_CODE (*expr) == BIT_FIELD_REF)
     {
@@ -3165,7 +3211,10 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)
     bfr = NULL_TREE;
 
   if (TREE_CODE (*expr) == REALPART_EXPR || TREE_CODE (*expr) == IMAGPART_EXPR)
-    expr = &TREE_OPERAND (*expr, 0);
+    {
+      expr = &TREE_OPERAND (*expr, 0);
+      partial_cplx_access = true;
+    }
   access = get_access_for_expr (*expr);
   if (!access)
     return false;
@@ -3193,13 +3242,32 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)
          be accessed as a different type too, potentially creating a need for
          type conversion (see PR42196) and when scalarized unions are involved
          in assembler statements (see PR42398).  */
-      if (!useless_type_conversion_p (type, access->type))
+      if (!bfr && !useless_type_conversion_p (type, access->type))
 	{
 	  tree ref;
 
 	  ref = build_ref_for_model (loc, orig_expr, 0, access, gsi, false);
 
-	  if (write)
+	  if (partial_cplx_access)
+	    {
+	    /* VIEW_CONVERT_EXPRs in partial complex access are always fine in
+	       the case of a write because in such case the replacement cannot
+	       be a gimple register.  In the case of a load, we have to
+	       differentiate in between a register an non-register
+	       replacement.  */
+	      tree t = build1 (VIEW_CONVERT_EXPR, type, repl);
+	      gcc_checking_assert (!write || access->grp_partial_lhs);
+	      if (!access->grp_partial_lhs)
+		{
+		  tree tmp = make_ssa_name (type);
+		  gassign *stmt = gimple_build_assign (tmp, t);
+		  /* This is always a read. */
+		  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);
+		  t = tmp;
+		}
+	      *expr = t;
+	    }
+	  else if (write)
 	    {
 	      gassign *stmt;
 
diff --git a/gcc/tree-ssa-dse.c b/gcc/tree-ssa-dse.c
index efe5b31cc0a..26376ecf8de 100644
--- a/gcc/tree-ssa-dse.c
+++ b/gcc/tree-ssa-dse.c
@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "params.h"
 #include "alias.h"
 #include "tree-ssa-loop.h"
+#include "gimplify.h"
 
 /* This file implements dead store elimination.
 
@@ -394,29 +395,38 @@ decrement_count (gimple *stmt, int decrement)
   gcc_assert (TREE_CODE (*countp) == INTEGER_CST);
   *countp = wide_int_to_tree (TREE_TYPE (*countp), (TREE_INT_CST_LOW (*countp)
 						    - decrement));
-
 }
 
 static void
 increment_start_addr (gimple *stmt, tree *where, int increment)
 {
+  if (tree lhs = gimple_call_lhs (stmt))
+    if (where == gimple_call_arg_ptr (stmt, 0))
+      {
+	gassign *newop = gimple_build_assign (lhs, unshare_expr (*where));
+	gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
+	gsi_insert_after (&gsi, newop, GSI_SAME_STMT);
+	gimple_call_set_lhs (stmt, NULL_TREE);
+	update_stmt (stmt);
+      }
+
   if (TREE_CODE (*where) == SSA_NAME)
     {
       tree tem = make_ssa_name (TREE_TYPE (*where));
       gassign *newop
-        = gimple_build_assign (tem, POINTER_PLUS_EXPR, *where,
+	= gimple_build_assign (tem, POINTER_PLUS_EXPR, *where,
 			       build_int_cst (sizetype, increment));
       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
       gsi_insert_before (&gsi, newop, GSI_SAME_STMT);
       *where = tem;
-      update_stmt (gsi_stmt (gsi));
+      update_stmt (stmt);
       return;
     }
 
   *where = build_fold_addr_expr (fold_build2 (MEM_REF, char_type_node,
-                                             *where,
-                                             build_int_cst (ptr_type_node,
-                                                            increment)));
+					      *where,
+					      build_int_cst (ptr_type_node,
+							     increment)));
 }
 
 /* STMT is builtin call that writes bytes in bitmap ORIG, some bytes are dead
diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
index bbfa1bc6fae..ca5443b79b3 100644
--- a/gcc/tree-ssa-forwprop.c
+++ b/gcc/tree-ssa-forwprop.c
@@ -2357,7 +2357,8 @@ pass_forwprop::execute (function *fun)
 		    continue;
 		  if (!is_gimple_assign (use_stmt)
 		      || (gimple_assign_rhs_code (use_stmt) != REALPART_EXPR
-			  && gimple_assign_rhs_code (use_stmt) != IMAGPART_EXPR))
+			  && gimple_assign_rhs_code (use_stmt) != IMAGPART_EXPR)
+		      || TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) != lhs)
 		    {
 		      rewrite = false;
 		      break;
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
index 01423dee883..ecfa569259c 100644
--- a/gcc/tree-ssa-loop-ivopts.c
+++ b/gcc/tree-ssa-loop-ivopts.c
@@ -109,6 +109,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "builtins.h"
 #include "tree-vectorizer.h"
 
+/* For lang_hooks.types.type_for_mode.  */
+#include "langhooks.h"
+
 /* FIXME: Expressions are expanded to RTL in this pass to determine the
    cost of different addressing modes.  This should be moved to a TBD
    interface between the GIMPLE and RTL worlds.  */
@@ -3490,8 +3493,21 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)
 {
   poly_uint64 offset;
   tree base;
-  tree basetype;
   struct iv *iv = use->iv;
+  tree basetype = TREE_TYPE (iv->base);
+
+  /* Don't add candidate for iv_use with non integer, pointer or non-mode
+     precision types, instead, add candidate for the corresponding scev in
+     unsigned type with the same precision.  See PR93674 for more info.  */
+  if ((TREE_CODE (basetype) != INTEGER_TYPE && !POINTER_TYPE_P (basetype))
+      || !type_has_mode_precision_p (basetype))
+    {
+      basetype = lang_hooks.types.type_for_mode (TYPE_MODE (basetype),
+						 TYPE_UNSIGNED (basetype));
+      add_candidate (data, fold_convert (basetype, iv->base),
+		     fold_convert (basetype, iv->step), false, NULL);
+      return;
+    }
 
   add_candidate (data, iv->base, iv->step, false, use);
 
diff --git a/gcc/tree-ssa-loop-niter.c b/gcc/tree-ssa-loop-niter.c
index 470b6a295be..200344b42dd 100644
--- a/gcc/tree-ssa-loop-niter.c
+++ b/gcc/tree-ssa-loop-niter.c
@@ -2382,6 +2382,11 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,
   affine_iv iv0, iv1;
   bool safe;
 
+  /* The condition at a fake exit (if it exists) does not control its
+     execution.  */
+  if (exit->flags & EDGE_FAKE)
+    return false;
+
   /* Nothing to analyze if the loop is known to be infinite.  */
   if (loop_constraint_set_p (loop, LOOP_C_INFINITE))
     return false;
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
index 19b37b43b8e..47227dc16dc 100644
--- a/gcc/tree-ssa-phiopt.c
+++ b/gcc/tree-ssa-phiopt.c
@@ -1040,7 +1040,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,
   gimple *cond;
   edge true_edge, false_edge;
   enum tree_code code;
-  bool emtpy_or_with_defined_p = true;
+  bool empty_or_with_defined_p = true;
 
   /* If the type says honor signed zeros we cannot do this
      optimization.  */
@@ -1059,7 +1059,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,
 	{
 	  if (gimple_code (stmt) != GIMPLE_PREDICT
 	      && gimple_code (stmt) != GIMPLE_NOP)
-	    emtpy_or_with_defined_p = false;
+	    empty_or_with_defined_p = false;
 	  continue;
 	}
       /* Now try to adjust arg0 or arg1 according to the computation
@@ -1069,7 +1069,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,
 	     && jump_function_from_stmt (&arg0, stmt))
 	    || (lhs == arg1
 		&& jump_function_from_stmt (&arg1, stmt)))
-	emtpy_or_with_defined_p = false;
+	empty_or_with_defined_p = false;
     }
 
   cond = last_stmt (cond_bb);
@@ -1121,7 +1121,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,
       /* If the middle basic block was empty or is defining the
 	 PHI arguments and this is a single phi where the args are different
 	 for the edges e0 and e1 then we can remove the middle basic block. */
-      if (emtpy_or_with_defined_p
+      if (empty_or_with_defined_p
 	  && single_non_singleton_phi_for_edges (phi_nodes (gimple_bb (phi)),
 						 e0, e1) == phi)
 	{
@@ -1239,7 +1239,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,
       && profile_status_for_fn (cfun) != PROFILE_ABSENT
       && EDGE_PRED (middle_bb, 0)->probability < profile_probability::even ()
       /* If assign is cheap, there is no point avoiding it.  */
-      && estimate_num_insns (bb_seq (middle_bb), &eni_time_weights)
+      && estimate_num_insns_seq (bb_seq (middle_bb), &eni_time_weights)
 	 >= 3 * estimate_num_insns (cond, &eni_time_weights))
     return 0;
 
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 8bd17b82368..7b171bc4e8f 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -2810,7 +2810,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,
 	      unsigned HOST_WIDE_INT hmisalign
 		= args.length () == 3 ? tree_to_uhwi (args[2]) : 0;
 	      if ((halign & (halign - 1)) == 0
-		  && (hmisalign & ~(halign - 1)) == 0)
+		  && (hmisalign & ~(halign - 1)) == 0
+		  && (unsigned int)halign != 0)
 		set_ptr_info_alignment (get_ptr_info (forcedname),
 					halign, hmisalign);
 	    }
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 6794fbde29e..4bc691d5797 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -4492,7 +4492,7 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
    recursive invocations.  */
 
 static tree
-rewrite_expr_tree (gimple *stmt, unsigned int opindex,
+rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 		   vec<operand_entry *> ops, bool changed, bool next_changed)
 {
   tree rhs1 = gimple_assign_rhs1 (stmt);
@@ -4539,7 +4539,7 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,
 		= find_insert_point (stmt, oe1->op, oe2->op);
 	      lhs = make_ssa_name (TREE_TYPE (lhs));
 	      stmt
-		= gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),
+		= gimple_build_assign (lhs, rhs_code,
 				       oe1->op, oe2->op);
 	      gimple_set_uid (stmt, uid);
 	      gimple_set_visited (stmt, true);
@@ -4583,7 +4583,7 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,
   /* Recurse on the LHS of the binary operator, which is guaranteed to
      be the non-leaf side.  */
   tree new_rhs1
-    = rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops,
+    = rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), rhs_code, opindex + 1, ops,
 			 changed || oe->op != rhs2 || next_changed,
 			 false);
 
@@ -4609,7 +4609,7 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,
 	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op);
 
 	  lhs = make_ssa_name (TREE_TYPE (lhs));
-	  stmt = gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),
+	  stmt = gimple_build_assign (lhs, rhs_code,
 				      new_rhs1, oe->op);
 	  gimple_set_uid (stmt, uid);
 	  gimple_set_visited (stmt, true);
@@ -5162,13 +5162,20 @@ linearize_expr_tree (vec<operand_entry *> *ops, gimple *stmt,
 
       if (!binrhsisreassoc)
 	{
-	  if (!try_special_add_to_ops (ops, rhscode, binrhs, binrhsdef))
+	  bool swap = false;
+	  if (try_special_add_to_ops (ops, rhscode, binrhs, binrhsdef))
+	    /* If we add ops for the rhs we expect to be able to recurse
+	       to it via the lhs during expression rewrite so swap
+	       operands.  */
+	    swap = true;
+	  else
 	    add_to_ops_vec (ops, binrhs);
 
 	  if (!try_special_add_to_ops (ops, rhscode, binlhs, binlhsdef))
 	    add_to_ops_vec (ops, binlhs);
 
-	  return;
+	  if (!swap)
+	    return;
 	}
 
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -5187,6 +5194,8 @@ linearize_expr_tree (vec<operand_entry *> *ops, gimple *stmt,
 	  fprintf (dump_file, " is now ");
 	  print_gimple_stmt (dump_file, stmt, 0);
 	}
+      if (!binrhsisreassoc)
+	return;
 
       /* We want to make it so the lhs is always the reassociative op,
 	 so swap.  */
@@ -5872,8 +5881,11 @@ reassociate_bb (basic_block bb)
   if (stmt && !gimple_visited_p (stmt))
     cfg_cleanup_needed |= maybe_optimize_range_tests (stmt);
 
-  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))
+  bool do_prev = false;
+  for (gsi = gsi_last_bb (bb);
+       !gsi_end_p (gsi); do_prev ? gsi_prev (&gsi) : (void) 0)
     {
+      do_prev = true;
       stmt = gsi_stmt (gsi);
 
       if (is_gimple_assign (stmt)
@@ -5899,15 +5911,12 @@ reassociate_bb (basic_block bb)
 		  release_defs (stmt);
 		  /* We might end up removing the last stmt above which
 		     places the iterator to the end of the sequence.
-		     Reset it to the last stmt in this case which might
-		     be the end of the sequence as well if we removed
-		     the last statement of the sequence.  In which case
-		     we need to bail out.  */
+		     Reset it to the last stmt in this case and make sure
+		     we don't do gsi_prev in that case.  */
 		  if (gsi_end_p (gsi))
 		    {
 		      gsi = gsi_last_bb (bb);
-		      if (gsi_end_p (gsi))
-			break;
+		      do_prev = false;
 		    }
 		}
 	      continue;
@@ -6051,7 +6060,7 @@ reassociate_bb (basic_block bb)
                       if (len >= 3)
                         swap_ops_for_binary_stmt (ops, len - 3, stmt);
 
-		      new_lhs = rewrite_expr_tree (stmt, 0, ops,
+		      new_lhs = rewrite_expr_tree (stmt, rhs_code, 0, ops,
 						   powi_result != NULL
 						   || negate_result,
 						   len != orig_len);
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 32f45c95cdf..57e0e613a62 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -535,7 +535,8 @@ vn_get_stmt_kind (gimple *stmt)
 		     || code == IMAGPART_EXPR
 		     || code == VIEW_CONVERT_EXPR
 		     || code == BIT_FIELD_REF)
-		    && TREE_CODE (TREE_OPERAND (rhs1, 0)) == SSA_NAME)
+		    && (TREE_CODE (TREE_OPERAND (rhs1, 0)) == SSA_NAME
+			|| is_gimple_min_invariant (TREE_OPERAND (rhs1, 0))))
 		  return VN_NARY;
 
 		/* Fallthrough.  */
@@ -3731,6 +3732,8 @@ set_ssa_val_to (tree from, tree to)
   vn_ssa_aux_t from_info = VN_INFO (from);
   tree currval = from_info->valnum; // SSA_VAL (from)
   poly_int64 toff, coff;
+  bool curr_undefined = false;
+  bool curr_invariant = false;
 
   /* The only thing we allow as value numbers are ssa_names
      and invariants.  So assert that here.  We don't allow VN_TOP
@@ -3773,9 +3776,9 @@ set_ssa_val_to (tree from, tree to)
 	    }
 	  return false;
 	}
-      bool curr_invariant = is_gimple_min_invariant (currval);
-      bool curr_undefined = (TREE_CODE (currval) == SSA_NAME
-			     && ssa_undefined_value_p (currval, false));
+      curr_invariant = is_gimple_min_invariant (currval);
+      curr_undefined = (TREE_CODE (currval) == SSA_NAME
+			&& ssa_undefined_value_p (currval, false));
       if (currval != VN_TOP
 	  && !curr_invariant
 	  && !curr_undefined
@@ -3830,9 +3833,8 @@ set_and_exit:
       && !operand_equal_p (currval, to, 0)
       /* Different undefined SSA names are not actually different.  See
          PR82320 for a testcase were we'd otherwise not terminate iteration.  */
-      && !(TREE_CODE (currval) == SSA_NAME
+      && !(curr_undefined
 	   && TREE_CODE (to) == SSA_NAME
-	   && ssa_undefined_value_p (currval, false)
 	   && ssa_undefined_value_p (to, false))
       /* ???  For addresses involving volatile objects or types operand_equal_p
          does not reliably detect ADDR_EXPRs as equal.  We know we are only
@@ -3844,6 +3846,22 @@ set_and_exit:
 	       == get_addr_base_and_unit_offset (TREE_OPERAND (to, 0), &toff))
 	   && known_eq (coff, toff)))
     {
+      if (to != from
+	  && currval != VN_TOP
+	  && !curr_undefined
+	  /* We do not want to allow lattice transitions from one value
+	     to another since that may lead to not terminating iteration
+	     (see PR95049).  Since there's no convenient way to check
+	     for the allowed transition of VAL -> PHI (loop entry value,
+	     same on two PHIs, to same PHI result) we restrict the check
+	     to invariants.  */
+	  && curr_invariant
+	  && is_gimple_min_invariant (to))
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, " forced VARYING");
+	  to = from;
+	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file, " (changed)\n");
       from_info->valnum = to;
@@ -4124,13 +4142,22 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)
   if (result
       && !useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (op)))
     {
-      /* We will be setting the value number of lhs to the value number
-	 of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).
-	 So first simplify and lookup this expression to see if it
-	 is already available.  */
-      gimple_match_op res_op (gimple_match_cond::UNCOND,
-			      VIEW_CONVERT_EXPR, TREE_TYPE (op), result);
-      result = vn_nary_build_or_lookup (&res_op);
+      /* Avoid the type punning in case the result mode has padding where
+	 the op we lookup has not.  */
+      if (maybe_lt (GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (result))),
+		    GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (op)))))
+	result = NULL_TREE;
+      else
+	{
+	  /* We will be setting the value number of lhs to the value number
+	     of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).
+	     So first simplify and lookup this expression to see if it
+	     is already available.  */
+	  gimple_match_op res_op (gimple_match_cond::UNCOND,
+				  VIEW_CONVERT_EXPR, TREE_TYPE (op), result);
+	  result = vn_nary_build_or_lookup (&res_op);
+	}
+
       /* When building the conversion fails avoid inserting the reference
          again.  */
       if (!result)
@@ -4293,6 +4320,8 @@ visit_phi (gimple *phi, bool *inserted, bool backedges_varying_p)
       {
 	tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);
 
+	if (def == PHI_RESULT (phi))
+	  continue;
 	++n_executable;
 	if (TREE_CODE (def) == SSA_NAME)
 	  {
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 0ea0b461d2b..4396bcd8f20 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -7937,7 +7937,8 @@ refered_from_nonlocal_fn (struct cgraph_node *node, void *data)
 {
   bool *nonlocal_p = (bool *)data;
   *nonlocal_p |= (node->used_from_other_partition
-		  || node->externally_visible
+		  || DECL_EXTERNAL (node->decl)
+		  || TREE_PUBLIC (node->decl)
 		  || node->force_output
 		  || lookup_attribute ("noipa", DECL_ATTRIBUTES (node->decl)));
   return false;
@@ -7949,7 +7950,8 @@ refered_from_nonlocal_var (struct varpool_node *node, void *data)
 {
   bool *nonlocal_p = (bool *)data;
   *nonlocal_p |= (node->used_from_other_partition
-		  || node->externally_visible
+		  || DECL_EXTERNAL (node->decl)
+		  || TREE_PUBLIC (node->decl)
 		  || node->force_output);
   return false;
 }
@@ -7998,7 +8000,8 @@ ipa_pta_execute (void)
 	 For local functions we see all callers and thus do not need initial
 	 constraints for parameters.  */
       bool nonlocal_p = (node->used_from_other_partition
-			 || node->externally_visible
+			 || DECL_EXTERNAL (node->decl)
+			 || TREE_PUBLIC (node->decl)
 			 || node->force_output
 			 || lookup_attribute ("noipa",
 					      DECL_ATTRIBUTES (node->decl)));
@@ -8038,8 +8041,9 @@ ipa_pta_execute (void)
 
       /* For the purpose of IPA PTA unit-local globals are not
          escape points.  */
-      bool nonlocal_p = (var->used_from_other_partition
-			 || var->externally_visible
+      bool nonlocal_p = (DECL_EXTERNAL (var->decl)
+			 || TREE_PUBLIC (var->decl)
+			 || var->used_from_other_partition
 			 || var->force_output);
       var->call_for_symbol_and_aliases (refered_from_nonlocal_var,
 					&nonlocal_p, true);
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
index 255575f1198..4f42817f7de 100644
--- a/gcc/tree-tailcall.c
+++ b/gcc/tree-tailcall.c
@@ -327,7 +327,8 @@ process_assignment (gassign *stmt,
 	   && (non_ass_var = independent_of_stmt_p (op1, stmt, call,
 						    to_move)))
     ;
-  else if (op1 == *ass_var
+  else if (*ass_var
+	   && op1 == *ass_var
 	   && (non_ass_var = independent_of_stmt_p (op0, stmt, call,
 						    to_move)))
     ;
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index 17a4fc8e279..f2e1766432b 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -1045,7 +1045,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)
   if (tree_int_cst_sgn (drb->step) < 0)
     /* PLUS because STEP is negative.  */
     misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)
-		     * TREE_INT_CST_LOW (drb->step));
+		     * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));
 
   unsigned int const_misalignment;
   if (!known_misalignment (misalignment, vect_align_c, &const_misalignment))
diff --git a/gcc/tree-vect-generic.c b/gcc/tree-vect-generic.c
index ad1ea4e7b97..1f255fa70c2 100644
--- a/gcc/tree-vect-generic.c
+++ b/gcc/tree-vect-generic.c
@@ -478,6 +478,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,
 {
   bool use_pow2 = true;
   bool has_vector_shift = true;
+  bool use_abs_op1 = false;
   int mode = -1, this_mode;
   int pre_shift = -1, post_shift;
   unsigned int nunits = nunits_for_known_piecewise_op (type);
@@ -618,8 +619,11 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,
 
 	  /* n rem d = n rem -d */
 	  if (code == TRUNC_MOD_EXPR && d < 0)
-	    d = abs_d;
-	  else if (abs_d == HOST_WIDE_INT_1U << (prec - 1))
+	    {
+	      d = abs_d;
+	      use_abs_op1 = true;
+	    }
+	  if (abs_d == HOST_WIDE_INT_1U << (prec - 1))
 	    {
 	      /* This case is not handled correctly below.  */
 	      mode = -2;
@@ -899,6 +903,23 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,
   if (op == unknown_optab
       || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)
     return NULL_TREE;
+  if (use_abs_op1)
+    {
+      tree_vector_builder elts;
+      if (!elts.new_unary_operation (type, op1, false))
+	return NULL_TREE;
+      unsigned int count = elts.encoded_nelts ();
+      for (unsigned int i = 0; i < count; ++i)
+	{
+	  tree elem1 = VECTOR_CST_ELT (op1, i);
+
+	  tree elt = const_unop (ABS_EXPR, TREE_TYPE (elem1), elem1);
+	  if (elt == NULL_TREE)
+	    return NULL_TREE;
+	  elts.quick_push (elt);
+	}
+      op1 = elts.build ();
+    }
   tem = gimplify_build2 (gsi, MULT_EXPR, type, cur_op, op1);
   op = optab_for_tree_code (MINUS_EXPR, type, optab_default);
   if (op == unknown_optab
@@ -1670,6 +1691,12 @@ expand_vector_conversion (gimple_stmt_iterator *gsi)
   gimple *stmt = gsi_stmt (*gsi);
   gimple *g;
   tree lhs = gimple_call_lhs (stmt);
+  if (lhs == NULL_TREE)
+    {
+      g = gimple_build_nop ();
+      gsi_replace (gsi, g, false);
+      return;
+    }
   tree arg = gimple_call_arg (stmt, 0);
   tree decl = NULL_TREE;
   tree ret_type = TREE_TYPE (lhs);
diff --git a/gcc/tree-vect-loop-manip.c b/gcc/tree-vect-loop-manip.c
index b3fae5ba4da..030effcd79d 100644
--- a/gcc/tree-vect-loop-manip.c
+++ b/gcc/tree-vect-loop-manip.c
@@ -1065,6 +1065,10 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,
 
   add_phi_args_after_copy (new_bbs, scalar_loop->num_nodes + 1, NULL);
 
+  /* Skip new preheader since it's deleted if copy loop is added at entry.  */
+  for (unsigned i = (at_exit ? 0 : 1); i < scalar_loop->num_nodes + 1; i++)
+    rename_variables_in_bb (new_bbs[i], duplicate_outer_loop);
+
   if (scalar_loop != loop)
     {
       /* If we copied from SCALAR_LOOP rather than LOOP, SSA_NAMEs from
@@ -1142,10 +1146,6 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,
 			       loop_preheader_edge (new_loop)->src);
     }
 
-  /* Skip new preheader since it's deleted if copy loop is added at entry.  */
-  for (unsigned i = (at_exit ? 0 : 1); i < scalar_loop->num_nodes + 1; i++)
-    rename_variables_in_bb (new_bbs[i], duplicate_outer_loop);
-
   if (scalar_loop != loop)
     {
       /* Update new_loop->header PHIs, so that on the preheader
@@ -1986,13 +1986,29 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,
       niters_vector = force_gimple_operand (niters_vector, &stmts, true, var);
       gsi_insert_seq_on_edge_immediate (pe, stmts);
       /* Peeling algorithm guarantees that vector loop bound is at least ONE,
-	 we set range information to make niters analyzer's life easier.  */
+	 we set range information to make niters analyzer's life easier.
+	 Note the number of latch iteration value can be TYPE_MAX_VALUE so
+	 we have to represent the vector niter TYPE_MAX_VALUE + 1 >> log_vf.  */
       if (stmts != NULL && log_vf)
-	set_range_info (niters_vector, VR_RANGE,
-			wi::to_wide (build_int_cst (type, 1)),
-			wi::to_wide (fold_build2 (RSHIFT_EXPR, type,
-						  TYPE_MAX_VALUE (type),
-						  log_vf)));
+	{
+	  if (niters_no_overflow)
+	    set_range_info (niters_vector, VR_RANGE,
+			    wi::one (TYPE_PRECISION (type)),
+			    wi::rshift (wi::max_value (TYPE_PRECISION (type),
+						       TYPE_SIGN (type)),
+					exact_log2 (const_vf),
+					TYPE_SIGN (type)));
+	  /* For VF == 1 the vector IV might also overflow so we cannot
+	     assert a minimum value of 1.  */
+	  else if (const_vf > 1)
+	    set_range_info (niters_vector, VR_RANGE,
+			    wi::one (TYPE_PRECISION (type)),
+			    wi::rshift (wi::max_value (TYPE_PRECISION (type),
+						       TYPE_SIGN (type))
+					- (const_vf - 1),
+					exact_log2 (const_vf), TYPE_SIGN (type))
+			    + 1);
+	}
     }
   *niters_vector_ptr = niters_vector;
   *step_vector_ptr = step_vector;
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 0308b26b808..ed6586753c5 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -7942,6 +7942,25 @@ vectorizable_live_operation (stmt_vec_info stmt_info,
       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);
     }
 
+  /* Ensure the VEC_LHS for lane extraction stmts satisfy loop-closed PHI
+     requirement, insert one phi node for it.  It looks like:
+	 loop;
+       BB:
+	 # lhs' = PHI <lhs>
+     ==>
+	 loop;
+       BB:
+	 # vec_lhs' = PHI <vec_lhs>
+	 new_tree = lane_extract <vec_lhs', ...>;
+	 lhs' = new_tree;  */
+
+  basic_block exit_bb = single_exit (loop)->dest;
+  gcc_assert (single_pred_p (exit_bb));
+
+  tree vec_lhs_phi = copy_ssa_name (vec_lhs);
+  gimple *phi = create_phi_node (vec_lhs_phi, exit_bb);
+  SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, vec_lhs);
+
   gimple_seq stmts = NULL;
   tree new_tree;
   if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))
@@ -7954,10 +7973,10 @@ vectorizable_live_operation (stmt_vec_info stmt_info,
 	 the loop mask for the final iteration.  */
       gcc_assert (ncopies == 1 && !slp_node);
       tree scalar_type = TREE_TYPE (STMT_VINFO_VECTYPE (stmt_info));
-      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo),
-				      1, vectype, 0);
-      tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST,
-				      scalar_type, mask, vec_lhs);
+      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo), 1,
+				      vectype, 0);
+      tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST, scalar_type,
+				      mask, vec_lhs_phi);
 
       /* Convert the extracted vector element to the required scalar type.  */
       new_tree = gimple_convert (&stmts, lhs_type, scalar_res);
@@ -7967,13 +7986,32 @@ vectorizable_live_operation (stmt_vec_info stmt_info,
       tree bftype = TREE_TYPE (vectype);
       if (VECTOR_BOOLEAN_TYPE_P (vectype))
 	bftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);
-      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs, bitsize, bitstart);
+      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs_phi, bitsize, bitstart);
       new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),
 				       &stmts, true, NULL_TREE);
     }
 
   if (stmts)
-    gsi_insert_seq_on_edge_immediate (single_exit (loop), stmts);
+    {
+      gimple_stmt_iterator exit_gsi = gsi_after_labels (exit_bb);
+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);
+
+      /* Remove existing phi from lhs and create one copy from new_tree.  */
+      tree lhs_phi = NULL_TREE;
+      gimple_stmt_iterator gsi;
+      for (gsi = gsi_start_phis (exit_bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gimple *phi = gsi_stmt (gsi);
+	  if ((gimple_phi_arg_def (phi, 0) == lhs))
+	    {
+	      remove_phi_node (&gsi, false);
+	      lhs_phi = gimple_phi_result (phi);
+	      gimple *copy = gimple_build_assign (lhs_phi, new_tree);
+	      gsi_insert_before (&exit_gsi, copy, GSI_SAME_STMT);
+	      break;
+	    }
+	}
+    }
 
   /* Replace use of lhs with newly computed result.  If the use stmt is a
      single arg PHI, just replace all uses of PHI result.  It's necessary
diff --git a/gcc/tree-vect-patterns.c b/gcc/tree-vect-patterns.c
index badf4e7104e..167e1150e70 100644
--- a/gcc/tree-vect-patterns.c
+++ b/gcc/tree-vect-patterns.c
@@ -1657,6 +1657,7 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)
   /* Apply the minimum efficient precision we just calculated.  */
   if (new_precision < min_precision)
     new_precision = min_precision;
+  new_precision = vect_element_precision (new_precision);
   if (new_precision >= TYPE_PRECISION (type))
     return NULL;
 
@@ -2093,7 +2094,6 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
       append_pattern_def_seq (stmt_vinfo, def_stmt);
     }
   stype = TREE_TYPE (def);
-  scalar_int_mode smode = SCALAR_INT_TYPE_MODE (stype);
 
   if (TREE_CODE (def) == INTEGER_CST)
     {
@@ -2122,7 +2122,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
 	append_pattern_def_seq (stmt_vinfo, def_stmt, vecstype);
 
       def2 = vect_recog_temp_ssa_var (stype, NULL);
-      tree mask = build_int_cst (stype, GET_MODE_PRECISION (smode) - 1);
+      tree mask = build_int_cst (stype, GET_MODE_PRECISION (mode) - 1);
       def_stmt = gimple_build_assign (def2, BIT_AND_EXPR,
 				      gimple_assign_lhs (def_stmt), mask);
       if (ext_def)
@@ -2969,8 +2969,8 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
 	  d = abs_d;
 	  oprnd1 = build_int_cst (itype, abs_d);
 	}
-      else if (HOST_BITS_PER_WIDE_INT >= prec
-	       && abs_d == HOST_WIDE_INT_1U << (prec - 1))
+      if (HOST_BITS_PER_WIDE_INT >= prec
+	  && abs_d == HOST_WIDE_INT_1U << (prec - 1))
 	/* This case is not handled correctly below.  */
 	return NULL;
 
@@ -3710,14 +3710,18 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)
 
   var = gimple_assign_rhs1 (last_stmt);
   lhs = gimple_assign_lhs (last_stmt);
+  rhs_code = gimple_assign_rhs_code (last_stmt);
+
+  if (rhs_code == VIEW_CONVERT_EXPR)
+    var = TREE_OPERAND (var, 0);
 
   if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (var)))
     return NULL;
 
   hash_set<gimple *> bool_stmts;
 
-  rhs_code = gimple_assign_rhs_code (last_stmt);
-  if (CONVERT_EXPR_CODE_P (rhs_code))
+  if (CONVERT_EXPR_CODE_P (rhs_code)
+      || rhs_code == VIEW_CONVERT_EXPR)
     {
       if (! INTEGRAL_TYPE_P (TREE_TYPE (lhs))
 	  || TYPE_PRECISION (TREE_TYPE (lhs)) == 1)
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 507f81b0a0e..ffbba3441de 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -2355,25 +2355,23 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,
 	  /* First cope with the degenerate case of a single-element
 	     vector.  */
 	  if (known_eq (TYPE_VECTOR_SUBPARTS (vectype), 1U))
-	    *memory_access_type = VMAT_CONTIGUOUS;
+	    ;
 
 	  /* Otherwise try using LOAD/STORE_LANES.  */
-	  if (*memory_access_type == VMAT_ELEMENTWISE
-	      && (vls_type == VLS_LOAD
-		  ? vect_load_lanes_supported (vectype, group_size, masked_p)
-		  : vect_store_lanes_supported (vectype, group_size,
-						masked_p)))
+	  else if (vls_type == VLS_LOAD
+		   ? vect_load_lanes_supported (vectype, group_size, masked_p)
+		   : vect_store_lanes_supported (vectype, group_size,
+						 masked_p))
 	    {
 	      *memory_access_type = VMAT_LOAD_STORE_LANES;
 	      overrun_p = would_overrun_p;
 	    }
 
 	  /* If that fails, try using permuting loads.  */
-	  if (*memory_access_type == VMAT_ELEMENTWISE
-	      && (vls_type == VLS_LOAD
-		  ? vect_grouped_load_supported (vectype, single_element_p,
-						 group_size)
-		  : vect_grouped_store_supported (vectype, group_size)))
+	  else if (vls_type == VLS_LOAD
+		   ? vect_grouped_load_supported (vectype, single_element_p,
+						  group_size)
+		   : vect_grouped_store_supported (vectype, group_size))
 	    {
 	      *memory_access_type = VMAT_CONTIGUOUS_PERMUTE;
 	      overrun_p = would_overrun_p;
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index 2140101d7d2..324673b780c 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -3019,8 +3019,14 @@ register_edge_assert_for_2 (tree name, edge e,
 	      && ((TYPE_PRECISION (TREE_TYPE (name))
 		   > TYPE_PRECISION (TREE_TYPE (rhs1)))
 		  || (get_range_info (rhs1, &rmin, &rmax) == VR_RANGE
-		      && wi::fits_to_tree_p (rmin, TREE_TYPE (name))
-		      && wi::fits_to_tree_p (rmax, TREE_TYPE (name)))))
+		      && wi::fits_to_tree_p
+			   (widest_int::from (rmin,
+					      TYPE_SIGN (TREE_TYPE (rhs1))),
+			    TREE_TYPE (name))
+		      && wi::fits_to_tree_p
+			   (widest_int::from (rmax,
+					      TYPE_SIGN (TREE_TYPE (rhs1))),
+			    TREE_TYPE (name)))))
 	    add_assert_info (asserts, rhs1, rhs1,
 		 	     comp_code, fold_convert (TREE_TYPE (rhs1), val));
 	}
diff --git a/gcc/tree.c b/gcc/tree.c
index 32e94e48132..be311754393 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -11683,6 +11683,7 @@ build_call_expr_internal_loc_array (location_t loc, internal_fn ifn,
     CALL_EXPR_ARG (t, i) = args[i];
   SET_EXPR_LOCATION (t, loc);
   CALL_EXPR_IFN (t) = ifn;
+  process_call_operands (t);
   return t;
 }
 
@@ -12188,7 +12189,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
     case INTEGER_CST:
     case REAL_CST:
     case FIXED_CST:
-    case VECTOR_CST:
     case STRING_CST:
     case BLOCK:
     case PLACEHOLDER_EXPR:
@@ -12219,6 +12219,18 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	WALK_SUBTREE_TAIL (TREE_VEC_ELT (*tp, 0));
       }
 
+    case VECTOR_CST:
+      {
+	unsigned len = vector_cst_encoded_nelts (*tp);
+	if (len == 0)
+	  break;
+	/* Walk all elements but the first.  */
+	while (--len)
+	  WALK_SUBTREE (VECTOR_CST_ENCODED_ELT (*tp, len));
+	/* Now walk the first one as a tail call.  */
+	WALK_SUBTREE_TAIL (VECTOR_CST_ENCODED_ELT (*tp, 0));
+      }
+
     case COMPLEX_CST:
       WALK_SUBTREE (TREE_REALPART (*tp));
       WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));
@@ -12995,10 +13007,11 @@ lhd_gcc_personality (void)
    OBJ_TYPE_REF representing an virtual call of C++ method.
    (As opposed to OBJ_TYPE_REF representing objc calls
    through a cast where middle-end devirtualization machinery
-   can't apply.) */
+   can't apply.)  FOR_DUMP_P is true when being called from
+   the dump routines.  */
 
 bool
-virtual_method_call_p (const_tree target)
+virtual_method_call_p (const_tree target, bool for_dump_p)
 {
   if (TREE_CODE (target) != OBJ_TYPE_REF)
     return false;
@@ -13011,7 +13024,7 @@ virtual_method_call_p (const_tree target)
   /* If we do not have BINFO associated, it means that type was built
      without devirtualization enabled.  Do not consider this a virtual
      call.  */
-  if (!TYPE_BINFO (obj_type_ref_class (target)))
+  if (!TYPE_BINFO (obj_type_ref_class (target, for_dump_p)))
     return false;
   return true;
 }
diff --git a/gcc/tree.h b/gcc/tree.h
index 2f8e37bb356..8d25916ff9d 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -5043,8 +5043,8 @@ extern location_t *block_nonartificial_location (tree);
 extern location_t tree_nonartificial_location (tree);
 extern tree block_ultimate_origin (const_tree);
 extern tree get_binfo_at_offset (tree, poly_int64, tree);
-extern bool virtual_method_call_p (const_tree);
-extern tree obj_type_ref_class (const_tree ref);
+extern bool virtual_method_call_p (const_tree, bool = false);
+extern tree obj_type_ref_class (const_tree ref, bool = false);
 extern bool types_same_for_odr (const_tree type1, const_tree type2);
 extern bool contains_bitfld_component_ref_p (const_tree);
 extern bool block_may_fallthru (const_tree);
diff --git a/gcc/ubsan.c b/gcc/ubsan.c
index d2696302bd0..5d4af79177c 100644
--- a/gcc/ubsan.c
+++ b/gcc/ubsan.c
@@ -229,6 +229,7 @@ ubsan_get_type_descriptor_type (void)
   TYPE_FIELDS (ret) = fields[0];
   TYPE_NAME (ret) = type_decl;
   TYPE_STUB_DECL (ret) = type_decl;
+  TYPE_ARTIFICIAL (ret) = 1;
   layout_type (ret);
   ubsan_type_descriptor_type = ret;
   return ret;
@@ -277,6 +278,7 @@ ubsan_get_source_location_type (void)
   TYPE_FIELDS (ret) = fields[0];
   TYPE_NAME (ret) = type_decl;
   TYPE_STUB_DECL (ret) = type_decl;
+  TYPE_ARTIFICIAL (ret) = 1;
   layout_type (ret);
   ubsan_source_location_type = ret;
   return ret;
@@ -593,6 +595,7 @@ ubsan_create_data (const char *name, int loccnt, const location_t *ploc, ...)
   TYPE_FIELDS (ret) = fields[0];
   TYPE_NAME (ret) = type_decl;
   TYPE_STUB_DECL (ret) = type_decl;
+  TYPE_ARTIFICIAL (ret) = 1;
   layout_type (ret);
 
   /* Now, fill in the type.  */
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index 5013956cf86..b8ce4bd82ce 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -363,7 +363,10 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)
       /* When user uses an unsigned type with a big value, constant converted
 	 to gcov_type (a signed type) can be negative.  */
       gcov_type value = hist->hvalue.counters[i];
-      if (hist->type == HIST_TYPE_SINGLE_VALUE && i == 0)
+      if ((hist->type == HIST_TYPE_SINGLE_VALUE && i == 0)
+	  || hist->type == HIST_TYPE_IOR)
+	/* Note that the IOR counter tracks pointer values and these can have
+	   sign bit set.  */
 	;
       else
 	gcc_assert (value >= 0);
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 8f006dcff67..8d87e28cc7c 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -5136,6 +5136,26 @@ struct oc_local_state {
 static void
 output_constructor_array_range (oc_local_state *local)
 {
+  /* Perform the index calculation in modulo arithmetic but
+     sign-extend the result because Ada has negative DECL_FIELD_OFFSETs
+     but we are using an unsigned sizetype.  */
+  unsigned prec = TYPE_PRECISION (sizetype);
+  offset_int idx = wi::sext (wi::to_offset (TREE_OPERAND (local->index, 0))
+			     - wi::to_offset (local->min_index), prec);
+  tree valtype = TREE_TYPE (local->val);
+  HOST_WIDE_INT fieldpos
+    = (idx * wi::to_offset (TYPE_SIZE_UNIT (valtype))).to_short_addr ();
+
+  /* Advance to offset of this element.  */
+  if (fieldpos > local->total_bytes)
+    {
+      assemble_zeros (fieldpos - local->total_bytes);
+      local->total_bytes = fieldpos;
+    }
+  else
+    /* Must not go backwards.  */
+    gcc_assert (fieldpos == local->total_bytes);
+
   unsigned HOST_WIDE_INT fieldsize
     = int_size_in_bytes (TREE_TYPE (local->type));
 
diff --git a/gcc/wide-int.h b/gcc/wide-int.h
index 25ea0545439..77aa01f2c98 100644
--- a/gcc/wide-int.h
+++ b/gcc/wide-int.h
@@ -3032,8 +3032,7 @@ wi::lshift (const T1 &x, const T2 &y)
       if (STATIC_CONSTANT_P (xi.precision > HOST_BITS_PER_WIDE_INT)
 	  ? (STATIC_CONSTANT_P (shift < HOST_BITS_PER_WIDE_INT - 1)
 	     && xi.len == 1
-	     && xi.val[0] <= (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT)
-					      HOST_WIDE_INT_MAX >> shift))
+	     && IN_RANGE (xi.val[0], 0, HOST_WIDE_INT_MAX >> shift))
 	  : precision <= HOST_BITS_PER_WIDE_INT)
 	{
 	  val[0] = xi.ulow () << shift;
diff --git a/include/ChangeLog b/include/ChangeLog
index 1811056c182..e8e301dd8e7 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,13 @@
+2020-04-20  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-04-17  Martin Liska  <mliska@suse.cz>
+		    Jonathan Yong <10walls@gmail.com>
+
+	PR gcov-profile/94570
+	* filenames.h (defined): Do not define HAVE_DOS_BASED_FILE_SYSTEM
+	for CYGWIN.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/include/filenames.h b/include/filenames.h
index 1bcfddb87ac..790a27db873 100644
--- a/include/filenames.h
+++ b/include/filenames.h
@@ -32,7 +32,8 @@ Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
 extern "C" {
 #endif
 
-#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)
+#if defined(__MSDOS__) || (defined(_WIN32) && ! defined(__CYGWIN__)) || \
+    defined(__OS2__)
 #  ifndef HAVE_DOS_BASED_FILE_SYSTEM
 #    define HAVE_DOS_BASED_FILE_SYSTEM 1
 #  endif
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
index 5c0aa2db0c8..93ba72ae5ef 100644
--- a/libatomic/ChangeLog
+++ b/libatomic/ChangeLog
@@ -1,3 +1,8 @@
+2020-04-19  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/x86/fenv.c (__atomic_feraiseexcept) [__SSE_MATH__]:
+	Remove unneeded assignments to volatile memory.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libatomic/config/x86/fenv.c b/libatomic/config/x86/fenv.c
index 9b8a3bd9308..b4c7edc249e 100644
--- a/libatomic/config/x86/fenv.c
+++ b/libatomic/config/x86/fenv.c
@@ -57,9 +57,7 @@ __atomic_feraiseexcept (int excepts)
     {
       float f = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%0, %d0|%d0, %0}" : "+x" (f));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdiv\t{%y0, %0|%0, %y0}" : "+t" (f));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -77,9 +75,7 @@ __atomic_feraiseexcept (int excepts)
     {
       float f = 1.0f, g = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -105,9 +101,7 @@ __atomic_feraiseexcept (int excepts)
     {
       float f = 1.0f, g = 3.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index a5c30516ff8..df85a37b13a 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,156 @@
+2021-01-13  Samuel Thibault  <samuel.thibault@gnu.org>
+
+	Backported from master:
+	2021-01-13  Samuel Thibault  <samuel.thibault@gnu.org>
+
+	* config/i386/gnu-unwind.h (x86_gnu_fallback_frame_state): Add the
+	posix siginfo case to struct handler_args. Detect between legacy
+	and siginfo from the second parameter, which is a small sigcode in
+	the legacy case, and a pointer in the siginfo case.
+
+2020-08-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/96402
+	* config/aarch64/lse.S (__aarch64_cas16_acq_rel): Use x2, x3 instead
+	of x(tmp0), x(tmp1) in STXP arguments.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94891
+	* config/aarch64/aarch64-unwind.h (MD_POST_EXTRACT_ROOT_ADDR): Remove.
+	(MD_POST_FROB_EH_HANDLER_ADDR): Remove.
+	(MD_POST_EXTRACT_FRAME_ADDR): Rename to ...
+	(MD_DEMANGLE_RETURN_ADDR): This.
+	(aarch64_post_extract_frame_addr): Rename to ...
+	(aarch64_demangle_return_addr): This.
+	(aarch64_post_frob_eh_handler_addr): Remove.
+	* unwind-dw2.c (uw_update_context): Demangle return address.
+	(uw_frob_return_addr): Remove.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-09  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/96001
+	* config/aarch64/lse.S: Add BTI marking and related definitions,
+	and add BTI c to function entries.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-09  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/lse.S: Add stack note.
+
+2020-06-17  Samuel Thibault  <samuel.thibault@gnu.org>
+
+	Backported from master:
+	2020-06-17  Samuel Thibault  <samuel.thibault@gnu.org>
+
+	* config.host (md_unwind_header) <i[34567]86-*-gnu*>: Set to
+	'i386/gnu-unwind.h'
+	* config/i386/gnu-unwind.h: New file.
+
+2020-05-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/lse-init.c (init_have_lse_atomics): Use __getauxval
+	instead of getauxval.
+	(AT_HWCAP): Define.
+	(HWCAP_ATOMICS): Define.
+	Guard detection on __gnu_linux__.
+
+2020-05-29  Dong JianQiang  <dongjianqiang2@huawei.com>
+
+	PR gcov-profile/95332
+	* libgcov-util.c (read_gcda_file): Call gcov_magic.
+	* libgcov.h (gcov_magic): Disable GCC poison.
+
+2020-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/91695
+	* config/i386/cpuinfo.c (get_available_features): Fix VPCLMULQDQ
+	check.
+
+2020-05-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from master
+	2020-05-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/95220
+	* config/i386/cpuinfo.c (get_available_features): Fix
+	FEATURE_GFNI check.
+
+2020-05-14  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline.
+	2020-04-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR target/94514
+	* config/aarch64/aarch64-unwind.h (aarch64_frob_update_context):
+	Update context->flags accroding to the frame state.
+
+2020-04-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline.
+	2020-04-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/93053
+	* configure.ac (LIBGCC_CHECK_AS_LSE): Add HAVE_AS_LSE checking.
+	* config/aarch64/lse.S: Include auto-target.h, if HAVE_AS_LSE
+	is not defined, use just .arch armv8-a.
+	(B, M, N, OPN): Define.
+	(COMMENT): New .macro.
+	(CAS, CASP, SWP, LDOP): Use .inst directive if HAVE_AS_LSE is not
+	defined.  Otherwise, move the operands right after the glue? and
+	comment out operands where the macros are used.
+	* configure: Regenerated.
+	* config.in: Regenerated.
+
+2020-04-19  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sfp-exceptions.c (__sfp_handle_exceptions) [__SSE_MATH__]:
+	Remove unneeded assignments to volatile memory.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-25  Richard Henderson  <richard.henderson@linaro.org>
+
+	PR target/91833
+	* config/aarch64/lse-init.c: Include auto-target.h.  Disable
+	initialization if !HAVE_SYS_AUXV_H.
+	* configure.ac (AC_CHECK_HEADERS): Add sys/auxv.h.
+	* config.in, configure: Rebuild.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-25  Richard Henderson  <richard.henderson@linaro.org>
+
+	PR target/91834
+	* config/aarch64/lse.S (LDNM): Ensure STXR output does not
+	overlap the inputs.
+
+2020-04-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-19  Richard Henderson  <richard.henderson@linaro.org>
+
+	* config/aarch64/lse-init.c: New file.
+	* config/aarch64/lse.S: New file.
+	* config/aarch64/t-lse: New file.
+	* config.host: Add t-lse to all aarch64 tuples.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index 0f15fda3612..bdbf77a3e62 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -347,23 +347,27 @@ aarch64*-*-elf | aarch64*-*-rtems*)
 	extra_parts="$extra_parts crtbegin.o crtend.o crti.o crtn.o"
 	extra_parts="$extra_parts crtfastmath.o"
 	tmake_file="${tmake_file} ${cpu_type}/t-aarch64"
+	tmake_file="${tmake_file} ${cpu_type}/t-lse t-slibgcc-libgcc"
 	tmake_file="${tmake_file} ${cpu_type}/t-softfp t-softfp t-crtfm"
 	md_unwind_header=aarch64/aarch64-unwind.h
 	;;
 aarch64*-*-freebsd*)
 	extra_parts="$extra_parts crtfastmath.o"
 	tmake_file="${tmake_file} ${cpu_type}/t-aarch64"
+	tmake_file="${tmake_file} ${cpu_type}/t-lse t-slibgcc-libgcc"
 	tmake_file="${tmake_file} ${cpu_type}/t-softfp t-softfp t-crtfm"
 	md_unwind_header=aarch64/freebsd-unwind.h
 	;;
 aarch64*-*-fuchsia*)
 	tmake_file="${tmake_file} ${cpu_type}/t-aarch64"
+	tmake_file="${tmake_file} ${cpu_type}/t-lse t-slibgcc-libgcc"
 	tmake_file="${tmake_file} ${cpu_type}/t-softfp t-softfp"
 	;;
 aarch64*-*-linux*)
 	extra_parts="$extra_parts crtfastmath.o"
 	md_unwind_header=aarch64/linux-unwind.h
 	tmake_file="${tmake_file} ${cpu_type}/t-aarch64"
+	tmake_file="${tmake_file} ${cpu_type}/t-lse t-slibgcc-libgcc"
 	tmake_file="${tmake_file} ${cpu_type}/t-softfp t-softfp t-crtfm"
 	;;
 alpha*-*-linux*)
@@ -675,11 +679,17 @@ i[34567]86-*-linux*)
 	tm_file="${tm_file} i386/elf-lib.h"
 	md_unwind_header=i386/linux-unwind.h
 	;;
-i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)
+i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-kopensolaris*-gnu)
 	extra_parts="$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o"
 	tmake_file="${tmake_file} i386/t-crtpc t-crtfm i386/t-crtstuff t-dfprules"
 	tm_file="${tm_file} i386/elf-lib.h"
 	;;
+i[34567]86-*-gnu*)
+	extra_parts="$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o"
+	tmake_file="${tmake_file} i386/t-crtpc t-crtfm i386/t-crtstuff t-dfprules"
+	tm_file="${tm_file} i386/elf-lib.h"
+	md_unwind_header=i386/gnu-unwind.h
+	;;
 x86_64-*-linux*)
 	extra_parts="$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o"
 	tmake_file="${tmake_file} i386/t-crtpc t-crtfm i386/t-crtstuff t-dfprules"
diff --git a/libgcc/config.in b/libgcc/config.in
index d634af9d949..5be5321d258 100644
--- a/libgcc/config.in
+++ b/libgcc/config.in
@@ -10,6 +10,9 @@
    */
 #undef HAVE_AS_CFI_SECTIONS
 
+/* Define to 1 if the assembler supports LSE. */
+#undef HAVE_AS_LSE
+
 /* Define to 1 if the target assembler supports thread-local storage. */
 #undef HAVE_CC_TLS
 
@@ -43,6 +46,9 @@
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
+/* Define to 1 if you have the <sys/auxv.h> header file. */
+#undef HAVE_SYS_AUXV_H
+
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
@@ -82,6 +88,11 @@
 /* Define to 1 if the target use emutls for thread-local storage. */
 #undef USE_EMUTLS
 
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
 /* Number of bits in a file offset, on hosts where this is settable. */
 #undef _FILE_OFFSET_BITS
 
diff --git a/libgcc/config/aarch64/aarch64-unwind.h b/libgcc/config/aarch64/aarch64-unwind.h
index 223ac9157f1..687687e5d1f 100644
--- a/libgcc/config/aarch64/aarch64-unwind.h
+++ b/libgcc/config/aarch64/aarch64-unwind.h
@@ -27,22 +27,20 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #define DWARF_REGNUM_AARCH64_RA_STATE 34
 
-#define MD_POST_EXTRACT_ROOT_ADDR(addr)  __builtin_aarch64_xpaclri (addr)
-#define MD_POST_EXTRACT_FRAME_ADDR(context, fs, addr) \
-  aarch64_post_extract_frame_addr (context, fs, addr)
-#define MD_POST_FROB_EH_HANDLER_ADDR(current, target, addr) \
-  aarch64_post_frob_eh_handler_addr (current, target, addr)
+#define MD_DEMANGLE_RETURN_ADDR(context, fs, addr) \
+  aarch64_demangle_return_addr (context, fs, addr)
 #define MD_FROB_UPDATE_CONTEXT(context, fs) \
   aarch64_frob_update_context (context, fs)
 
-/* Do AArch64 private extraction on ADDR based on context info CONTEXT and
-   unwind frame info FS.  If ADDR is signed, we do address authentication on it
-   using CFA of current frame.  */
+/* Do AArch64 private extraction on ADDR_WORD based on context info CONTEXT and
+   unwind frame info FS.  If ADDR_WORD is signed, we do address authentication
+   on it using CFA of current frame.  */
 
 static inline void *
-aarch64_post_extract_frame_addr (struct _Unwind_Context *context,
-				 _Unwind_FrameState *fs, void *addr)
+aarch64_demangle_return_addr (struct _Unwind_Context *context,
+			      _Unwind_FrameState *fs, _Unwind_Word addr_word)
 {
+  void *addr = (void *)addr_word;
   if (fs->regs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset & 0x1)
     {
       _Unwind_Word salt = (_Unwind_Word) context->cfa;
@@ -52,23 +50,6 @@ aarch64_post_extract_frame_addr (struct _Unwind_Context *context,
     return addr;
 }
 
-/* Do AArch64 private frob on exception handler's address HANDLER_ADDR before
-   installing it into current context CURRENT.  TARGET is currently not used.
-   We need to sign exception handler's address if CURRENT itself is signed.  */
-
-static inline void *
-aarch64_post_frob_eh_handler_addr (struct _Unwind_Context *current,
-				   struct _Unwind_Context *target
-				   ATTRIBUTE_UNUSED,
-				   void *handler_addr)
-{
-  if (current->flags & RA_A_SIGNED_BIT)
-    return __builtin_aarch64_pacia1716 (handler_addr,
-					(_Unwind_Word) current->cfa);
-  else
-    return handler_addr;
-}
-
 /* Do AArch64 private initialization on CONTEXT based on frame info FS.  Mark
    CONTEXT as return address signed if bit 0 of DWARF_REGNUM_AARCH64_RA_STATE is
    set.  */
@@ -80,6 +61,8 @@ aarch64_frob_update_context (struct _Unwind_Context *context,
   if (fs->regs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset & 0x1)
     /* The flag is used for re-authenticating EH handler's address.  */
     context->flags |= RA_A_SIGNED_BIT;
+  else
+    context->flags &= ~RA_A_SIGNED_BIT;
 
   return;
 }
diff --git a/libgcc/config/aarch64/lse-init.c b/libgcc/config/aarch64/lse-init.c
new file mode 100644
index 00000000000..2f2921349e7
--- /dev/null
+++ b/libgcc/config/aarch64/lse-init.c
@@ -0,0 +1,48 @@
+/* Out-of-line LSE atomics for AArch64 architecture, Init.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   Contributed by Linaro Ltd.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include "auto-target.h"
+
+/* Define the symbol gating the LSE implementations.  */
+_Bool __aarch64_have_lse_atomics
+  __attribute__((visibility("hidden"), nocommon));
+
+/* Gate availability of __getauxval on glibc.  All AArch64-supporting glibc
+   versions support it.  */
+#ifdef __gnu_linux__
+
+# define AT_HWCAP	16
+# define HWCAP_ATOMICS	(1 << 8)
+
+unsigned long int __getauxval (unsigned long int);
+
+static void __attribute__((constructor))
+init_have_lse_atomics (void)
+{
+  unsigned long hwcap = __getauxval (AT_HWCAP);
+  __aarch64_have_lse_atomics = (hwcap & HWCAP_ATOMICS) != 0;
+}
+
+#endif /* __gnu_linux__  */
diff --git a/libgcc/config/aarch64/lse.S b/libgcc/config/aarch64/lse.S
new file mode 100644
index 00000000000..e3ae5191103
--- /dev/null
+++ b/libgcc/config/aarch64/lse.S
@@ -0,0 +1,306 @@
+/* Out-of-line LSE atomics for AArch64 architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   Contributed by Linaro Ltd.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/*
+ * The problem that we are trying to solve is operating system deployment
+ * of ARMv8.1-Atomics, also known as Large System Exensions (LSE).
+ *
+ * There are a number of potential solutions for this problem which have
+ * been proposed and rejected for various reasons.  To recap:
+ *
+ * (1) Multiple builds.  The dynamic linker will examine /lib64/atomics/
+ * if HWCAP_ATOMICS is set, allowing entire libraries to be overwritten.
+ * However, not all Linux distributions are happy with multiple builds,
+ * and anyway it has no effect on main applications.
+ *
+ * (2) IFUNC.  We could put these functions into libgcc_s.so, and have
+ * a single copy of each function for all DSOs.  However, ARM is concerned
+ * that the branch-to-indirect-branch that is implied by using a PLT,
+ * as required by IFUNC, is too much overhead for smaller cpus.
+ *
+ * (3) Statically predicted direct branches.  This is the approach that
+ * is taken here.  These functions are linked into every DSO that uses them.
+ * All of the symbols are hidden, so that the functions are called via a
+ * direct branch.  The choice of LSE vs non-LSE is done via one byte load
+ * followed by a well-predicted direct branch.  The functions are compiled
+ * separately to minimize code size.
+ */
+
+#include "auto-target.h"
+
+/* Tell the assembler to accept LSE instructions.  */
+#ifdef HAVE_AS_LSE
+	.arch armv8-a+lse
+#else
+	.arch armv8-a
+#endif
+
+/* Declare the symbol gating the LSE implementations.  */
+	.hidden	__aarch64_have_lse_atomics
+
+/* Turn size and memory model defines into mnemonic fragments.  */
+#if SIZE == 1
+# define S     b
+# define UXT   uxtb
+# define B     0x00000000
+#elif SIZE == 2
+# define S     h
+# define UXT   uxth
+# define B     0x40000000
+#elif SIZE == 4 || SIZE == 8 || SIZE == 16
+# define S
+# define UXT   mov
+# if SIZE == 4
+#  define B    0x80000000
+# elif SIZE == 8
+#  define B    0xc0000000
+# endif
+#else
+# error
+#endif
+
+#if MODEL == 1
+# define SUFF  _relax
+# define A
+# define L
+# define M     0x000000
+# define N     0x000000
+#elif MODEL == 2
+# define SUFF  _acq
+# define A     a
+# define L
+# define M     0x400000
+# define N     0x800000
+#elif MODEL == 3
+# define SUFF  _rel
+# define A
+# define L     l
+# define M     0x008000
+# define N     0x400000
+#elif MODEL == 4
+# define SUFF  _acq_rel
+# define A     a
+# define L     l
+# define M     0x408000
+# define N     0xc00000
+#else
+# error
+#endif
+
+/* Concatenate symbols.  */
+#define glue2_(A, B)		A ## B
+#define glue2(A, B)		glue2_(A, B)
+#define glue3_(A, B, C)		A ## B ## C
+#define glue3(A, B, C)		glue3_(A, B, C)
+#define glue4_(A, B, C, D)	A ## B ## C ## D
+#define glue4(A, B, C, D)	glue4_(A, B, C, D)
+
+/* Select the size of a register, given a regno.  */
+#define x(N)			glue2(x, N)
+#define w(N)			glue2(w, N)
+#if SIZE < 8
+# define s(N)			w(N)
+#else
+# define s(N)			x(N)
+#endif
+
+#define NAME(BASE)		glue4(__aarch64_, BASE, SIZE, SUFF)
+#define LDXR			glue4(ld, A, xr, S)
+#define STXR			glue4(st, L, xr, S)
+
+/* Temporary registers used.  Other than these, only the return value
+   register (x0) and the flags are modified.  */
+#define tmp0	16
+#define tmp1	17
+#define tmp2	15
+
+#define BTI_C	hint	34
+
+/* Start and end a function.  */
+.macro	STARTFN name
+	.text
+	.balign	16
+	.globl	\name
+	.hidden	\name
+	.type	\name, %function
+	.cfi_startproc
+\name:
+	BTI_C
+.endm
+
+.macro	ENDFN name
+	.cfi_endproc
+	.size	\name, . - \name
+.endm
+
+/* Branch to LABEL if LSE is disabled.  */
+.macro	JUMP_IF_NOT_LSE label
+	adrp	x(tmp0), __aarch64_have_lse_atomics
+	ldrb	w(tmp0), [x(tmp0), :lo12:__aarch64_have_lse_atomics]
+	cbz	w(tmp0), \label
+.endm
+
+#ifdef L_cas
+
+STARTFN	NAME(cas)
+	JUMP_IF_NOT_LSE	8f
+
+#if SIZE < 16
+#ifdef HAVE_AS_LSE
+# define CAS	glue4(cas, A, L, S)	s(0), s(1), [x2]
+#else
+# define CAS	.inst 0x08a07c41 + B + M
+#endif
+
+	CAS		/* s(0), s(1), [x2] */
+	ret
+
+8:	UXT		s(tmp0), s(0)
+0:	LDXR		s(0), [x2]
+	cmp		s(0), s(tmp0)
+	bne		1f
+	STXR		w(tmp1), s(1), [x2]
+	cbnz		w(tmp1), 0b
+1:	ret
+
+#else
+#define LDXP	glue3(ld, A, xp)
+#define STXP	glue3(st, L, xp)
+#ifdef HAVE_AS_LSE
+# define CASP	glue3(casp, A, L)	x0, x1, x2, x3, [x4]
+#else
+# define CASP	.inst 0x48207c82 + M
+#endif
+
+	CASP		/* x0, x1, x2, x3, [x4] */
+	ret
+
+8:	mov		x(tmp0), x0
+	mov		x(tmp1), x1
+0:	LDXP		x0, x1, [x4]
+	cmp		x0, x(tmp0)
+	ccmp		x1, x(tmp1), #0, eq
+	bne		1f
+	STXP		w(tmp2), x2, x3, [x4]
+	cbnz		w(tmp2), 0b
+1:	ret
+
+#endif
+
+ENDFN	NAME(cas)
+#endif
+
+#ifdef L_swp
+#ifdef HAVE_AS_LSE
+# define SWP	glue4(swp, A, L, S)	s(0), s(0), [x1]
+#else
+# define SWP	.inst 0x38208020 + B + N
+#endif
+
+STARTFN	NAME(swp)
+	JUMP_IF_NOT_LSE	8f
+
+	SWP		/* s(0), s(0), [x1] */
+	ret
+
+8:	mov		s(tmp0), s(0)
+0:	LDXR		s(0), [x1]
+	STXR		w(tmp1), s(tmp0), [x1]
+	cbnz		w(tmp1), 0b
+	ret
+
+ENDFN	NAME(swp)
+#endif
+
+#if defined(L_ldadd) || defined(L_ldclr) \
+    || defined(L_ldeor) || defined(L_ldset)
+
+#ifdef L_ldadd
+#define LDNM	ldadd
+#define OP	add
+#define OPN	0x0000
+#elif defined(L_ldclr)
+#define LDNM	ldclr
+#define OP	bic
+#define OPN	0x1000
+#elif defined(L_ldeor)
+#define LDNM	ldeor
+#define OP	eor
+#define OPN	0x2000
+#elif defined(L_ldset)
+#define LDNM	ldset
+#define OP	orr
+#define OPN	0x3000
+#else
+#error
+#endif
+#ifdef HAVE_AS_LSE
+# define LDOP	glue4(LDNM, A, L, S)	s(0), s(0), [x1]
+#else
+# define LDOP	.inst 0x38200020 + OPN + B + N
+#endif
+
+STARTFN	NAME(LDNM)
+	JUMP_IF_NOT_LSE	8f
+
+	LDOP		/* s(0), s(0), [x1] */
+	ret
+
+8:	mov		s(tmp0), s(0)
+0:	LDXR		s(0), [x1]
+	OP		s(tmp1), s(0), s(tmp0)
+	STXR		w(tmp2), s(tmp1), [x1]
+	cbnz		w(tmp2), 0b
+	ret
+
+ENDFN	NAME(LDNM)
+#endif
+
+/* GNU_PROPERTY_AARCH64_* macros from elf.h for use in asm code.  */
+#define FEATURE_1_AND 0xc0000000
+#define FEATURE_1_BTI 1
+#define FEATURE_1_PAC 2
+
+/* Add a NT_GNU_PROPERTY_TYPE_0 note.  */
+#define GNU_PROPERTY(type, value)	\
+  .section .note.gnu.property, "a";	\
+  .p2align 3;				\
+  .word 4;				\
+  .word 16;				\
+  .word 5;				\
+  .asciz "GNU";				\
+  .word type;				\
+  .word 4;				\
+  .word value;				\
+  .word 0;
+
+#if defined(__linux__) || defined(__FreeBSD__)
+.section .note.GNU-stack, "", %progbits
+
+/* Add GNU property note if built with branch protection.  */
+# ifdef __ARM_FEATURE_BTI_DEFAULT
+GNU_PROPERTY (FEATURE_1_AND, FEATURE_1_BTI)
+# endif
+#endif
diff --git a/libgcc/config/aarch64/t-lse b/libgcc/config/aarch64/t-lse
new file mode 100644
index 00000000000..fe3868dacbf
--- /dev/null
+++ b/libgcc/config/aarch64/t-lse
@@ -0,0 +1,44 @@
+# Out-of-line LSE atomics for AArch64 architecture.
+# Copyright (C) 2019 Free Software Foundation, Inc.
+# Contributed by Linaro Ltd.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Compare-and-swap has 5 sizes and 4 memory models.
+S0 := $(foreach s, 1 2 4 8 16, $(addsuffix _$(s), cas))
+O0 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S0)))
+
+# Swap, Load-and-operate have 4 sizes and 4 memory models
+S1 := $(foreach s, 1 2 4 8, $(addsuffix _$(s), swp ldadd ldclr ldeor ldset))
+O1 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S1)))
+
+LSE_OBJS := $(O0) $(O1)
+
+libgcc-objects += $(LSE_OBJS) lse-init$(objext)
+
+empty      =
+space      = $(empty) $(empty)
+PAT_SPLIT  = $(subst _,$(space),$(*F))
+PAT_BASE   = $(word 1,$(PAT_SPLIT))
+PAT_N      = $(word 2,$(PAT_SPLIT))
+PAT_M      = $(word 3,$(PAT_SPLIT))
+
+lse-init$(objext): $(srcdir)/config/aarch64/lse-init.c
+	$(gcc_compile) -c $<
+
+$(LSE_OBJS): $(srcdir)/config/aarch64/lse.S
+	$(gcc_compile) -DL_$(PAT_BASE) -DSIZE=$(PAT_N) -DMODEL=$(PAT_M) -c $<
diff --git a/libgcc/config/i386/cpuinfo.c b/libgcc/config/i386/cpuinfo.c
index d6cb2de6265..6a33d2e0d52 100644
--- a/libgcc/config/i386/cpuinfo.c
+++ b/libgcc/config/i386/cpuinfo.c
@@ -346,9 +346,13 @@ get_available_features (unsigned int ecx, unsigned int edx,
 	{
 	  if (ebx & bit_AVX2)
 	    set_feature (FEATURE_AVX2);
+	  if (ecx & bit_VPCLMULQDQ)
+	    set_feature (FEATURE_VPCLMULQDQ);
 	}
       if (ebx & bit_BMI2)
 	set_feature (FEATURE_BMI2);
+      if (ecx & bit_GFNI)
+	set_feature (FEATURE_GFNI);
       if (avx512_usable)
 	{
 	  if (ebx & bit_AVX512F)
@@ -371,10 +375,6 @@ get_available_features (unsigned int ecx, unsigned int edx,
 	    set_feature (FEATURE_AVX512VBMI);
 	  if (ecx & bit_AVX512VBMI2)
 	    set_feature (FEATURE_AVX512VBMI2);
-	  if (ecx & bit_GFNI)
-	    set_feature (FEATURE_GFNI);
-	  if (ecx & bit_VPCLMULQDQ)
-	    set_feature (FEATURE_VPCLMULQDQ);
 	  if (ecx & bit_AVX512VNNI)
 	    set_feature (FEATURE_AVX512VNNI);
 	  if (ecx & bit_AVX512BITALG)
diff --git a/libgcc/config/i386/gnu-unwind.h b/libgcc/config/i386/gnu-unwind.h
new file mode 100644
index 00000000000..f83411e3de4
--- /dev/null
+++ b/libgcc/config/i386/gnu-unwind.h
@@ -0,0 +1,141 @@
+/* DWARF2 EH unwinding support for GNU Hurd: x86.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   Contributed by Samuel Thibault <samuel.thibault@gnu.org>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#ifndef inhibit_libc
+
+#include <signal.h>
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_gnu_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_gnu_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  struct handler_args {
+    int signo;
+    union
+      {
+	struct
+	  {
+	    long int sigcode;
+	    struct sigcontext *scp;
+	  } legacy;
+	struct
+	  {
+	    siginfo_t *siginfop;
+	    ucontext_t *uctxp;
+	  } posix;
+      };
+  } *handler_args;
+  long int sigcode;
+  unsigned long usp;
+
+/*
+ * i386 sigtramp frame we are looking for follows.
+ * (see glibc/sysdeps/mach/hurd/i386/trampoline.c assembly)
+ *
+ * rpc_wait_trampoline:
+ *   0:	b8 e7 ff ff ff       	mov    $-25,%eax       mach_msg_trap
+ *   5:	9a 00 00 00 00 07 00 	lcall  $7,$0
+ *  12:	89 01                	movl   %eax, (%ecx)
+ *  14:	89 dc                	movl   %ebx, %esp      switch to signal stack
+ *
+ * trampoline:
+ *  16:	ff d2                	call   *%edx           call the handler function
+ * RA HERE
+ *  18:	83 c4 0c             	addl   $12, %esp       pop its args
+ *  21:	c3                   	ret                    return to sigreturn
+ *
+ * firewall:
+ *  22:	f4                   	hlt
+ */
+
+  if (!(   *(unsigned int   *)(context->ra     ) == 0xc30cc483
+        && *(unsigned char  *)(context->ra +  4) ==       0xf4
+
+        && *(unsigned int   *)(context->ra -  4) == 0xd2ffdc89
+        && *(unsigned int   *)(context->ra -  8) == 0x01890007
+        && *(unsigned int   *)(context->ra - 12) == 0x00000000
+        && *(unsigned int   *)(context->ra - 16) == 0x9affffff
+        && *(unsigned short *)(context->ra - 18) ==     0xe7b8))
+    return _URC_END_OF_STACK;
+
+  handler_args = context->cfa;
+  sigcode = handler_args->legacy.sigcode;
+  if (sigcode >= -16 && sigcode < 4096)
+    {
+      /* This cannot be a SIGINFO pointer, assume legacy.  */
+      struct sigcontext *scp = handler_args->legacy.scp;
+      usp = scp->sc_uesp;
+
+      fs->regs.reg[0].loc.offset = (unsigned long)&scp->sc_eax - usp;
+      fs->regs.reg[1].loc.offset = (unsigned long)&scp->sc_ecx - usp;
+      fs->regs.reg[2].loc.offset = (unsigned long)&scp->sc_edx - usp;
+      fs->regs.reg[3].loc.offset = (unsigned long)&scp->sc_ebx - usp;
+      fs->regs.reg[5].loc.offset = (unsigned long)&scp->sc_ebp - usp;
+      fs->regs.reg[6].loc.offset = (unsigned long)&scp->sc_esi - usp;
+      fs->regs.reg[7].loc.offset = (unsigned long)&scp->sc_edi - usp;
+      fs->regs.reg[8].loc.offset = (unsigned long)&scp->sc_eip - usp;
+    }
+  else
+    {
+      /* This is not a valid sigcode, assume SIGINFO.  */
+      ucontext_t *uctxp = handler_args->posix.uctxp;
+      gregset_t *gregset = &uctxp->uc_mcontext.gregs;
+      usp = (*gregset)[REG_UESP];
+
+      fs->regs.reg[0].loc.offset = (unsigned long)&(*gregset)[REG_EAX] - usp;
+      fs->regs.reg[1].loc.offset = (unsigned long)&(*gregset)[REG_ECX] - usp;
+      fs->regs.reg[2].loc.offset = (unsigned long)&(*gregset)[REG_EDX] - usp;
+      fs->regs.reg[3].loc.offset = (unsigned long)&(*gregset)[REG_EBX] - usp;
+      fs->regs.reg[5].loc.offset = (unsigned long)&(*gregset)[REG_EBP] - usp;
+      fs->regs.reg[6].loc.offset = (unsigned long)&(*gregset)[REG_ESI] - usp;
+      fs->regs.reg[7].loc.offset = (unsigned long)&(*gregset)[REG_EDI] - usp;
+      fs->regs.reg[8].loc.offset = (unsigned long)&(*gregset)[REG_EIP] - usp;
+    }
+
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = usp - (unsigned long) context->cfa;
+
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+
+  return _URC_NO_REASON;
+}
+
+#endif /* ifndef inhibit_libc */
diff --git a/libgcc/config/i386/sfp-exceptions.c b/libgcc/config/i386/sfp-exceptions.c
index a6c56392acd..de4a2e06102 100644
--- a/libgcc/config/i386/sfp-exceptions.c
+++ b/libgcc/config/i386/sfp-exceptions.c
@@ -48,9 +48,7 @@ __sfp_handle_exceptions (int _fex)
     {
       float f = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%0, %d0|%d0, %0}" : "+x" (f));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdiv\t{%y0, %0|%0, %y0}" : "+t" (f));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -68,9 +66,7 @@ __sfp_handle_exceptions (int _fex)
     {
       float f = 1.0f, g = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -96,9 +92,7 @@ __sfp_handle_exceptions (int _fex)
     {
       float f = 1.0f, g = 3.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       asm volatile ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       asm volatile ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
diff --git a/libgcc/configure b/libgcc/configure
old mode 100644
new mode 100755
index 36dbbc1f699..8ceec1d047f
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -674,6 +674,7 @@ infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -763,6 +764,7 @@ datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1015,6 +1017,15 @@ do
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1152,7 +1163,7 @@ fi
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1305,6 +1316,7 @@ Fine tuning of the installation directories:
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
@@ -4170,7 +4182,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -4216,7 +4228,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -4240,7 +4252,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -4285,7 +4297,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -4309,7 +4321,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -4421,7 +4433,7 @@ as_fn_arith $ac_cv_sizeof_long_double \* 8 && long_double_type_size=$as_val
 
 for ac_header in inttypes.h stdint.h stdlib.h ftw.h \
 	unistd.h sys/stat.h sys/types.h \
-	string.h strings.h memory.h
+	string.h strings.h memory.h sys/auxv.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_preproc "$LINENO" "$ac_header" "$as_ac_Header"
@@ -5472,6 +5484,46 @@ $as_echo "#define HAVE_AS_AVX 1" >>confdefs.h
   ;;
 esac
 
+
+
+case "${target}" in
+aarch64*-*-*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if the assembler supports LSE" >&5
+$as_echo_n "checking if the assembler supports LSE... " >&6; }
+if ${libgcc_cv_as_lse+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+			asm(".arch armv8-a+lse\n\tcas w0, w1, [x2]");
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  libgcc_cv_as_lse=yes
+else
+  libgcc_cv_as_lse=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_as_lse" >&5
+$as_echo "$libgcc_cv_as_lse" >&6; }
+  if test x$libgcc_cv_as_lse = xyes; then
+
+$as_echo "#define HAVE_AS_LSE 1" >>confdefs.h
+
+  fi
+  ;;
+esac
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for init priority support" >&5
 $as_echo_n "checking for init priority support... " >&6; }
 if ${libgcc_cv_init_priority+:} false; then :
diff --git a/libgcc/configure.ac b/libgcc/configure.ac
index 8e96cafdf8b..61356d0721d 100644
--- a/libgcc/configure.ac
+++ b/libgcc/configure.ac
@@ -207,7 +207,7 @@ AC_SUBST(long_double_type_size)
 
 AC_CHECK_HEADERS(inttypes.h stdint.h stdlib.h ftw.h \
 	unistd.h sys/stat.h sys/types.h \
-	string.h strings.h memory.h)
+	string.h strings.h memory.h sys/auxv.h)
 AC_HEADER_STDC
 
 # Check for decimal float support.
@@ -564,6 +564,25 @@ i[[34567]]86-*-* | x86_64-*-*)
 esac])
 LIBGCC_CHECK_AS_AVX
 
+dnl Check if as supports LSE instructions.
+AC_DEFUN([LIBGCC_CHECK_AS_LSE], [
+case "${target}" in
+aarch64*-*-*)
+  AC_CACHE_CHECK([if the assembler supports LSE], libgcc_cv_as_lse, [
+    AC_TRY_COMPILE([],
+changequote(,)dnl
+			asm(".arch armv8-a+lse\n\tcas w0, w1, [x2]");
+changequote([,])dnl
+		       ,
+		   [libgcc_cv_as_lse=yes], [libgcc_cv_as_lse=no])
+  ])
+  if test x$libgcc_cv_as_lse = xyes; then
+    AC_DEFINE(HAVE_AS_LSE, 1, [Define to 1 if the assembler supports LSE.])
+  fi
+  ;;
+esac])
+LIBGCC_CHECK_AS_LSE
+
 dnl Check if as supports RTM instructions.
 AC_CACHE_CHECK(for init priority support, libgcc_cv_init_priority, [
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM(,
diff --git a/libgcc/libgcov-util.c b/libgcc/libgcov-util.c
index ae0dd017204..13332e12077 100644
--- a/libgcc/libgcov-util.c
+++ b/libgcc/libgcov-util.c
@@ -261,7 +261,7 @@ read_gcda_file (const char *filename)
 {
   unsigned tags[4];
   unsigned depth = 0;
-  unsigned magic, version;
+  unsigned version;
   struct gcov_info *obj_info;
   int i;
 
@@ -276,8 +276,7 @@ read_gcda_file (const char *filename)
     }
 
   /* Read magic.  */
-  magic = gcov_read_unsigned ();
-  if (magic != GCOV_DATA_MAGIC)
+  if (!gcov_magic (gcov_read_unsigned (), GCOV_DATA_MAGIC))
     {
       fnotice (stderr, "%s:not a gcov data file\n", filename);
       gcov_close ();
diff --git a/libgcc/libgcov.h b/libgcc/libgcov.h
index 993db8fb057..03c0257dd00 100644
--- a/libgcc/libgcov.h
+++ b/libgcc/libgcov.h
@@ -149,7 +149,7 @@ extern struct gcov_info *gcov_list;
 
 /* Poison these, so they don't accidentally slip in.  */
 #pragma GCC poison gcov_write_string gcov_write_tag gcov_write_length
-#pragma GCC poison gcov_time gcov_magic
+#pragma GCC poison gcov_time
 
 #ifdef HAVE_GAS_HIDDEN
 #define ATTRIBUTE_HIDDEN  __attribute__ ((__visibility__ ("hidden")))
diff --git a/libgcc/unwind-dw2.c b/libgcc/unwind-dw2.c
index e6130af2fb5..8c21ab8a121 100644
--- a/libgcc/unwind-dw2.c
+++ b/libgcc/unwind-dw2.c
@@ -1532,11 +1532,14 @@ uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
     {
       /* Compute the return address now, since the return address column
 	 can change from frame to frame.  */
-      context->ra = __builtin_extract_return_addr
-	(_Unwind_GetPtr (context, fs->retaddr_column));
-#ifdef MD_POST_EXTRACT_FRAME_ADDR
-      context->ra = MD_POST_EXTRACT_FRAME_ADDR (context, fs, context->ra);
+      void *ret_addr;
+#ifdef MD_DEMANGLE_RETURN_ADDR
+      _Unwind_Word ra = _Unwind_GetGR (context, fs->retaddr_column);
+      ret_addr = MD_DEMANGLE_RETURN_ADDR (context, fs, ra);
+#else
+      ret_addr = _Unwind_GetPtr (context, fs->retaddr_column);
 #endif
+      context->ra = __builtin_extract_return_addr (ret_addr);
     }
 }
 
@@ -1571,9 +1574,6 @@ uw_init_context_1 (struct _Unwind_Context *context,
 		   void *outer_cfa, void *outer_ra)
 {
   void *ra = __builtin_extract_return_addr (__builtin_return_address (0));
-#ifdef MD_POST_EXTRACT_ROOT_ADDR
-  ra = MD_POST_EXTRACT_ROOT_ADDR (ra);
-#endif
   _Unwind_FrameState fs;
   _Unwind_SpTmp sp_slot;
   _Unwind_Reason_Code code;
@@ -1610,9 +1610,6 @@ uw_init_context_1 (struct _Unwind_Context *context,
      initialization context, then we can't see it in the given
      call frame data.  So have the initialization context tell us.  */
   context->ra = __builtin_extract_return_addr (outer_ra);
-#ifdef MD_POST_EXTRACT_ROOT_ADDR
-  context->ra = MD_POST_EXTRACT_ROOT_ADDR (context->ra);
-#endif
 }
 
 static void _Unwind_DebugHook (void *, void *)
@@ -1635,21 +1632,6 @@ _Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),
 #endif
 }
 
-/* Frob exception handler's address kept in TARGET before installing into
-   CURRENT context.  */
-
-static inline void *
-uw_frob_return_addr (struct _Unwind_Context *current
-		     __attribute__ ((__unused__)),
-		     struct _Unwind_Context *target)
-{
-  void *ret_addr = __builtin_frob_return_addr (target->ra);
-#ifdef MD_POST_FROB_EH_HANDLER_ADDR
-  ret_addr = MD_POST_FROB_EH_HANDLER_ADDR (current, target, ret_addr);
-#endif
-  return ret_addr;
-}
-
 /* Install TARGET into CURRENT so that we can return to it.  This is a
    macro because __builtin_eh_return must be invoked in the context of
    our caller.  FRAMES is a number of frames to be unwind.
@@ -1661,7 +1643,7 @@ uw_frob_return_addr (struct _Unwind_Context *current
   do									\
     {									\
       long offset = uw_install_context_1 ((CURRENT), (TARGET));		\
-      void *handler = uw_frob_return_addr ((CURRENT), (TARGET));	\
+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	\
       _Unwind_DebugHook ((TARGET)->cfa, handler);			\
       _Unwind_Frames_Extra (FRAMES);					\
       __builtin_eh_return (offset, handler);				\
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 01aa551b914..bc22134382c 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,138 @@
+2021-03-07  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/99218
+	* m4/matmul_internal.m4: Invoke tuned matmul only for rank(b)>1.
+	* generated/matmul_c10.c: Regenerated.
+	* generated/matmul_c16.c: Likewise.
+	* generated/matmul_c4.c: Likewise.
+	* generated/matmul_c8.c: Likewise.
+	* generated/matmul_i1.c: Likewise.
+	* generated/matmul_i16.c: Likewise.
+	* generated/matmul_i2.c: Likewise.
+	* generated/matmul_i4.c: Likewise.
+	* generated/matmul_i8.c: Likewise.
+	* generated/matmul_r10.c: Likewise.
+	* generated/matmul_r16.c: Likewise.
+	* generated/matmul_r4.c: Likewise.
+	* generated/matmul_r8.c: Likewise.
+	* generated/matmulavx128_c10.c: Likewise.
+	* generated/matmulavx128_c16.c: Likewise.
+	* generated/matmulavx128_c4.c: Likewise.
+	* generated/matmulavx128_c8.c: Likewise.
+	* generated/matmulavx128_i1.c: Likewise.
+	* generated/matmulavx128_i16.c: Likewise.
+	* generated/matmulavx128_i2.c: Likewise.
+	* generated/matmulavx128_i4.c: Likewise.
+	* generated/matmulavx128_i8.c: Likewise.
+	* generated/matmulavx128_r10.c: Likewise.
+	* generated/matmulavx128_r16.c: Likewise.
+	* generated/matmulavx128_r4.c: Likewise.
+	* generated/matmulavx128_r8.c: Likewise.
+
+2020-12-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2020-11-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* intrinsics/execute_command_line.c (environ): Use
+	_NSGetEnviron to get the environment pointer on Darwin.
+
+2020-10-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-10-18  Harald Anlauf  <anlauf@gmx.de>
+
+	* m4/matmul_internal.m4: Move check for rank-1 times rank-2 before
+	checks on strides for rank-2 times rank-2.
+	* generated/matmul_c10.c: Regenerated.
+	* generated/matmul_c16.c: Likewise.
+	* generated/matmul_c4.c: Likewise.
+	* generated/matmul_c8.c: Likewise.
+	* generated/matmul_i1.c: Likewise.
+	* generated/matmul_i16.c: Likewise.
+	* generated/matmul_i2.c: Likewise.
+	* generated/matmul_i4.c: Likewise.
+	* generated/matmul_i8.c: Likewise.
+	* generated/matmul_r10.c: Likewise.
+	* generated/matmul_r16.c: Likewise.
+	* generated/matmul_r4.c: Likewise.
+	* generated/matmul_r8.c: Likewise.
+	* generated/matmulavx128_c10.c: Likewise.
+	* generated/matmulavx128_c16.c: Likewise.
+	* generated/matmulavx128_c4.c: Likewise.
+	* generated/matmulavx128_c8.c: Likewise.
+	* generated/matmulavx128_i1.c: Likewise.
+	* generated/matmulavx128_i16.c: Likewise.
+	* generated/matmulavx128_i2.c: Likewise.
+	* generated/matmulavx128_i4.c: Likewise.
+	* generated/matmulavx128_i8.c: Likewise.
+	* generated/matmulavx128_r10.c: Likewise.
+	* generated/matmulavx128_r16.c: Likewise.
+	* generated/matmulavx128_r4.c: Likewise.
+	* generated/matmulavx128_r8.c: Likewise.
+
+2020-09-09  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2020-09-03  Harald Anlauf  <anlauf@gmx.de>
+
+	* m4/iall.m4: Initial value for result should be -1.
+	* generated/iall_i1.c (miall_i1): Generated.
+	* generated/iall_i16.c (miall_i16): Likewise.
+	* generated/iall_i2.c (miall_i2): Likewise.
+	* generated/iall_i4.c (miall_i4): Likewise.
+	* generated/iall_i8.c (miall_i8): Likewise.
+
+2020-08-24  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	Backported from master:
+	2020-08-24  Mark Eggleston  <markeggleston@gcc.gnu.org>
+
+	PR fortran/96486
+	* intrinsics/env.c: If value_len is > 0 blank the string.
+	Copy the result only if its length is > 0.
+
+2020-07-25  Dominique d'Humieres  <dhumieres.dominique@free.fr>
+
+	Backported from master:
+	2020-07-24  Dominique d'Humieres  <dhumieres.dominique@free.fr>
+
+	PR fortran/93592
+	* io/write_float.def (build_float_string): Do not reset
+	  nbefore for FMT_F and FMT_EN.
+
+2020-05-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR libfortran/95104
+	* io/unit.c (unlock_unit): Guard by check for NULL pointer.
+
+2020-05-27  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl   <kargl@gcc.gnu.org>
+
+	PR libfortran/95104
+	* io/transfer.c (st_wait_async): Do not dereference NULL pointer.
+
+2020-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/95191
+	* io/async.c (async_wait_id): Generate error if ID is higher
+	than the highest current ID.
+	* runtime/error.c (translate_error): Handle LIBERROR_BAD_WAIT_ID.
+
+2020-05-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/95119
+	* io/close.c (close_status): Add CLOSE_INVALID.
+	(st_close): Return early on invalid STATUS parameter.
+
+2020-04-19  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/fpu-387.h (local_feraiseexcept) [__SSE_MATH__]:
+	Remove unneeded assignments to volatile memory.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libgfortran/config/fpu-387.h b/libgfortran/config/fpu-387.h
index a2f4281d0c5..bf4d78586c9 100644
--- a/libgfortran/config/fpu-387.h
+++ b/libgfortran/config/fpu-387.h
@@ -103,9 +103,7 @@ local_feraiseexcept (int excepts)
     {
       float f = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       __asm__ __volatile__ ("%vdivss\t{%0, %d0|%d0, %0}" : "+x" (f));
-      r = f; /* Needed to trigger exception.   */
 #else
       __asm__ __volatile__ ("fdiv\t{%y0, %0|%0, %y0}" : "+t" (f));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -123,9 +121,7 @@ local_feraiseexcept (int excepts)
     {
       float f = 1.0f, g = 0.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       __asm__ __volatile__ ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       __asm__ __volatile__ ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
@@ -151,9 +147,7 @@ local_feraiseexcept (int excepts)
     {
       float f = 1.0f, g = 3.0f;
 #ifdef __SSE_MATH__
-      volatile float r __attribute__ ((unused));
       __asm__ __volatile__ ("%vdivss\t{%1, %d0|%d0, %1}" : "+x" (f) : "xm" (g));
-      r = f; /* Needed to trigger exception.   */
 #else
       __asm__ __volatile__ ("fdivs\t%1" : "+t" (f) : "m" (g));
       /* No need for fwait, exception is triggered by emitted fstp.  */
diff --git a/libgfortran/generated/iall_i1.c b/libgfortran/generated/iall_i1.c
index 3e848ff6787..23f55822812 100644
--- a/libgfortran/generated/iall_i1.c
+++ b/libgfortran/generated/iall_i1.c
@@ -345,7 +345,7 @@ miall_i1 (gfc_array_i1 * const restrict retarray,
       msrc = mbase;
       {
 
-  result = 0;
+  result = (GFC_INTEGER_1) -1;
 	for (n = 0; n < len; n++, src += delta, msrc += mdelta)
 	  {
 
diff --git a/libgfortran/generated/iall_i16.c b/libgfortran/generated/iall_i16.c
index 29a056eecab..c90c5e6c40e 100644
--- a/libgfortran/generated/iall_i16.c
+++ b/libgfortran/generated/iall_i16.c
@@ -345,7 +345,7 @@ miall_i16 (gfc_array_i16 * const restrict retarray,
       msrc = mbase;
       {
 
-  result = 0;
+  result = (GFC_INTEGER_16) -1;
 	for (n = 0; n < len; n++, src += delta, msrc += mdelta)
 	  {
 
diff --git a/libgfortran/generated/iall_i2.c b/libgfortran/generated/iall_i2.c
index 6a6c9936d71..a2fd671e3be 100644
--- a/libgfortran/generated/iall_i2.c
+++ b/libgfortran/generated/iall_i2.c
@@ -345,7 +345,7 @@ miall_i2 (gfc_array_i2 * const restrict retarray,
       msrc = mbase;
       {
 
-  result = 0;
+  result = (GFC_INTEGER_2) -1;
 	for (n = 0; n < len; n++, src += delta, msrc += mdelta)
 	  {
 
diff --git a/libgfortran/generated/iall_i4.c b/libgfortran/generated/iall_i4.c
index cdba6c8c762..03f9ef9cbf2 100644
--- a/libgfortran/generated/iall_i4.c
+++ b/libgfortran/generated/iall_i4.c
@@ -345,7 +345,7 @@ miall_i4 (gfc_array_i4 * const restrict retarray,
       msrc = mbase;
       {
 
-  result = 0;
+  result = (GFC_INTEGER_4) -1;
 	for (n = 0; n < len; n++, src += delta, msrc += mdelta)
 	  {
 
diff --git a/libgfortran/generated/iall_i8.c b/libgfortran/generated/iall_i8.c
index 5cd7353013d..3b9cc9197b6 100644
--- a/libgfortran/generated/iall_i8.c
+++ b/libgfortran/generated/iall_i8.c
@@ -345,7 +345,7 @@ miall_i8 (gfc_array_i8 * const restrict retarray,
       msrc = mbase;
       {
 
-  result = 0;
+  result = (GFC_INTEGER_8) -1;
 	for (n = 0; n < len; n++, src += delta, msrc += mdelta)
 	  {
 
diff --git a/libgfortran/generated/matmul_c10.c b/libgfortran/generated/matmul_c10.c
index bd2763f4b31..790c4558fd5 100644
--- a/libgfortran/generated/matmul_c10.c
+++ b/libgfortran/generated/matmul_c10.c
@@ -276,7 +276,8 @@ matmul_c10_avx (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_c10_avx (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_c10_avx (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_c10_avx2 (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_c10_avx2 (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_c10_avx2 (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_c10_avx512f (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_c10_avx512f (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_c10_avx512f (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_c10_vanilla (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_c10_vanilla (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_c10_vanilla (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_c16.c b/libgfortran/generated/matmul_c16.c
index 98acaa70a67..d1c25badaa3 100644
--- a/libgfortran/generated/matmul_c16.c
+++ b/libgfortran/generated/matmul_c16.c
@@ -276,7 +276,8 @@ matmul_c16_avx (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_c16_avx (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_c16_avx (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_c16_avx2 (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_c16_avx2 (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_c16_avx2 (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_c16_avx512f (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_c16_avx512f (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_c16_avx512f (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_c16_vanilla (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_c16_vanilla (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_c16_vanilla (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_c4.c b/libgfortran/generated/matmul_c4.c
index f88d09cb365..3ebe78c397a 100644
--- a/libgfortran/generated/matmul_c4.c
+++ b/libgfortran/generated/matmul_c4.c
@@ -276,7 +276,8 @@ matmul_c4_avx (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_c4_avx (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_c4_avx (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_c4_avx2 (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_c4_avx2 (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_c4_avx2 (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_c4_avx512f (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_c4_avx512f (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_c4_avx512f (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_c4_vanilla (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_c4_vanilla (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_c4_vanilla (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_c8.c b/libgfortran/generated/matmul_c8.c
index 3c9cf1c6ead..a9a880d9afd 100644
--- a/libgfortran/generated/matmul_c8.c
+++ b/libgfortran/generated/matmul_c8.c
@@ -276,7 +276,8 @@ matmul_c8_avx (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_c8_avx (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_c8_avx (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_c8_avx2 (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_c8_avx2 (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_c8_avx2 (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_c8_avx512f (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_c8_avx512f (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_c8_avx512f (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_c8_vanilla (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_c8_vanilla (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_c8_vanilla (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_i1.c b/libgfortran/generated/matmul_i1.c
index e3f40c7baa9..3ea57260a89 100644
--- a/libgfortran/generated/matmul_i1.c
+++ b/libgfortran/generated/matmul_i1.c
@@ -276,7 +276,8 @@ matmul_i1_avx (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_i1_avx (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_i1_avx (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_i1_avx2 (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_i1_avx2 (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_i1_avx2 (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_i1_avx512f (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_i1_avx512f (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_i1_avx512f (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_i1_vanilla (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_i1_vanilla (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_i1_vanilla (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_i16.c b/libgfortran/generated/matmul_i16.c
index 3189a018452..a72ca391e2a 100644
--- a/libgfortran/generated/matmul_i16.c
+++ b/libgfortran/generated/matmul_i16.c
@@ -276,7 +276,8 @@ matmul_i16_avx (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_i16_avx (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_i16_avx (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_i16_avx2 (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_i16_avx2 (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_i16_avx2 (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_i16_avx512f (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_i16_avx512f (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_i16_avx512f (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_i16_vanilla (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_i16_vanilla (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_i16_vanilla (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_i2.c b/libgfortran/generated/matmul_i2.c
index e480b9092ca..cd3b6805f69 100644
--- a/libgfortran/generated/matmul_i2.c
+++ b/libgfortran/generated/matmul_i2.c
@@ -276,7 +276,8 @@ matmul_i2_avx (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_i2_avx (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_i2_avx (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_i2_avx2 (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_i2_avx2 (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_i2_avx2 (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_i2_avx512f (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_i2_avx512f (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_i2_avx512f (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_i2_vanilla (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_i2_vanilla (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_i2_vanilla (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_i4.c b/libgfortran/generated/matmul_i4.c
index ab532be7fb3..5f9e8b0e6c8 100644
--- a/libgfortran/generated/matmul_i4.c
+++ b/libgfortran/generated/matmul_i4.c
@@ -276,7 +276,8 @@ matmul_i4_avx (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_i4_avx (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_i4_avx (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_i4_avx2 (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_i4_avx2 (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_i4_avx2 (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_i4_avx512f (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_i4_avx512f (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_i4_avx512f (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_i4_vanilla (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_i4_vanilla (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_i4_vanilla (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_i8.c b/libgfortran/generated/matmul_i8.c
index 78d5af209e3..7e8c912e65f 100644
--- a/libgfortran/generated/matmul_i8.c
+++ b/libgfortran/generated/matmul_i8.c
@@ -276,7 +276,8 @@ matmul_i8_avx (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_i8_avx (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_i8_avx (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_i8_avx2 (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_i8_avx2 (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_i8_avx2 (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_i8_avx512f (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_i8_avx512f (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_i8_avx512f (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_i8_vanilla (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_i8_vanilla (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_i8_vanilla (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_r10.c b/libgfortran/generated/matmul_r10.c
index 8304a97f1c5..fc0a101815b 100644
--- a/libgfortran/generated/matmul_r10.c
+++ b/libgfortran/generated/matmul_r10.c
@@ -276,7 +276,8 @@ matmul_r10_avx (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_r10_avx (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_r10_avx (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_r10_avx2 (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_r10_avx2 (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_r10_avx2 (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_r10_avx512f (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_r10_avx512f (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_r10_avx512f (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_r10_vanilla (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_r10_vanilla (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_r10_vanilla (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_r16.c b/libgfortran/generated/matmul_r16.c
index 48730af542c..bae53888b4b 100644
--- a/libgfortran/generated/matmul_r16.c
+++ b/libgfortran/generated/matmul_r16.c
@@ -276,7 +276,8 @@ matmul_r16_avx (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_r16_avx (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_r16_avx (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_r16_avx2 (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_r16_avx2 (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_r16_avx2 (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_r16_avx512f (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_r16_avx512f (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_r16_avx512f (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_r16_vanilla (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_r16_vanilla (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_r16_vanilla (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_r4.c b/libgfortran/generated/matmul_r4.c
index 17f7cea6821..60cb81501af 100644
--- a/libgfortran/generated/matmul_r4.c
+++ b/libgfortran/generated/matmul_r4.c
@@ -276,7 +276,8 @@ matmul_r4_avx (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_r4_avx (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_r4_avx (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_r4_avx2 (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_r4_avx2 (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_r4_avx2 (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_r4_avx512f (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_r4_avx512f (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_r4_avx512f (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_r4_vanilla (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_r4_vanilla (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_r4_vanilla (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmul_r8.c b/libgfortran/generated/matmul_r8.c
index 70adc4e8417..53744003ad6 100644
--- a/libgfortran/generated/matmul_r8.c
+++ b/libgfortran/generated/matmul_r8.c
@@ -276,7 +276,8 @@ matmul_r8_avx (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -590,20 +591,6 @@ matmul_r8_avx (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -618,6 +605,20 @@ matmul_r8_avx (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
@@ -844,7 +845,8 @@ matmul_r8_avx2 (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1158,20 +1160,6 @@ matmul_r8_avx2 (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -1186,6 +1174,20 @@ matmul_r8_avx2 (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
@@ -1412,7 +1414,8 @@ matmul_r8_avx512f (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1726,20 +1729,6 @@ matmul_r8_avx512f (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -1754,6 +1743,20 @@ matmul_r8_avx512f (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
@@ -1994,7 +1997,8 @@ matmul_r8_vanilla (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2308,20 +2312,6 @@ matmul_r8_vanilla (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -2336,6 +2326,20 @@ matmul_r8_vanilla (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
@@ -2636,7 +2640,8 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -2950,20 +2955,6 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -2978,6 +2969,20 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_c10.c b/libgfortran/generated/matmulavx128_c10.c
index 58520e19282..e9fea30003d 100644
--- a/libgfortran/generated/matmulavx128_c10.c
+++ b/libgfortran/generated/matmulavx128_c10.c
@@ -241,7 +241,8 @@ matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_c10_avx128_fma3 (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_10 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_c10_avx128_fma4 (gfc_array_c10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_10 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_c16.c b/libgfortran/generated/matmulavx128_c16.c
index 0ec72450d1b..fc5de9a9b65 100644
--- a/libgfortran/generated/matmulavx128_c16.c
+++ b/libgfortran/generated/matmulavx128_c16.c
@@ -241,7 +241,8 @@ matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_c16_avx128_fma3 (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_16 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_c16_avx128_fma4 (gfc_array_c16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_c4.c b/libgfortran/generated/matmulavx128_c4.c
index cd97bf3e375..677651724ab 100644
--- a/libgfortran/generated/matmulavx128_c4.c
+++ b/libgfortran/generated/matmulavx128_c4.c
@@ -241,7 +241,8 @@ matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_c4_avx128_fma3 (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_4 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_c4_avx128_fma4 (gfc_array_c4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_c8.c b/libgfortran/generated/matmulavx128_c8.c
index 8d770c02251..80b231d9390 100644
--- a/libgfortran/generated/matmulavx128_c8.c
+++ b/libgfortran/generated/matmulavx128_c8.c
@@ -241,7 +241,8 @@ matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_c8_avx128_fma3 (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_COMPLEX_8 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_c8_avx128_fma4 (gfc_array_c8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_COMPLEX_8 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_i1.c b/libgfortran/generated/matmulavx128_i1.c
index 16d5ec2781b..91e4376e040 100644
--- a/libgfortran/generated/matmulavx128_i1.c
+++ b/libgfortran/generated/matmulavx128_i1.c
@@ -241,7 +241,8 @@ matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_i1_avx128_fma3 (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_1 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_i1_avx128_fma4 (gfc_array_i1 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_1 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_i16.c b/libgfortran/generated/matmulavx128_i16.c
index 26c2a75b905..2b45788cb3d 100644
--- a/libgfortran/generated/matmulavx128_i16.c
+++ b/libgfortran/generated/matmulavx128_i16.c
@@ -241,7 +241,8 @@ matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_i16_avx128_fma3 (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_16 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_i16_avx128_fma4 (gfc_array_i16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_i2.c b/libgfortran/generated/matmulavx128_i2.c
index 13e5fd46275..3937abbeb37 100644
--- a/libgfortran/generated/matmulavx128_i2.c
+++ b/libgfortran/generated/matmulavx128_i2.c
@@ -241,7 +241,8 @@ matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_i2_avx128_fma3 (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_2 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_i2_avx128_fma4 (gfc_array_i2 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_2 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_i4.c b/libgfortran/generated/matmulavx128_i4.c
index 1e8a3253b8e..ad248757b6e 100644
--- a/libgfortran/generated/matmulavx128_i4.c
+++ b/libgfortran/generated/matmulavx128_i4.c
@@ -241,7 +241,8 @@ matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_i4_avx128_fma3 (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_4 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_i4_avx128_fma4 (gfc_array_i4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_i8.c b/libgfortran/generated/matmulavx128_i8.c
index 2b6256f821b..55c841878e4 100644
--- a/libgfortran/generated/matmulavx128_i8.c
+++ b/libgfortran/generated/matmulavx128_i8.c
@@ -241,7 +241,8 @@ matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_i8_avx128_fma3 (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_INTEGER_8 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_i8_avx128_fma4 (gfc_array_i8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_INTEGER_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_INTEGER_8 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_r10.c b/libgfortran/generated/matmulavx128_r10.c
index d1c12a0f0c9..96483136c51 100644
--- a/libgfortran/generated/matmulavx128_r10.c
+++ b/libgfortran/generated/matmulavx128_r10.c
@@ -241,7 +241,8 @@ matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_r10_avx128_fma3 (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_10 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_r10_avx128_fma4 (gfc_array_r10 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_10)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_10 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_r16.c b/libgfortran/generated/matmulavx128_r16.c
index 750f79d4e6f..b5e279ba539 100644
--- a/libgfortran/generated/matmulavx128_r16.c
+++ b/libgfortran/generated/matmulavx128_r16.c
@@ -241,7 +241,8 @@ matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_r16_avx128_fma3 (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_16 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_r16_avx128_fma4 (gfc_array_r16 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_16)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_16 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_r4.c b/libgfortran/generated/matmulavx128_r4.c
index a3af0c5bfb3..87e589f1205 100644
--- a/libgfortran/generated/matmulavx128_r4.c
+++ b/libgfortran/generated/matmulavx128_r4.c
@@ -241,7 +241,8 @@ matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_r4_avx128_fma3 (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_4 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_r4_avx128_fma4 (gfc_array_r4 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_4)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_4 *restrict abase_x;
diff --git a/libgfortran/generated/matmulavx128_r8.c b/libgfortran/generated/matmulavx128_r8.c
index 42eba2116a4..cd0e6c2e56b 100644
--- a/libgfortran/generated/matmulavx128_r8.c
+++ b/libgfortran/generated/matmulavx128_r8.c
@@ -241,7 +241,8 @@ matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -555,20 +556,6 @@ matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -583,6 +570,20 @@ matmul_r8_avx128_fma3 (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
@@ -810,7 +811,8 @@ matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray,
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -1124,20 +1126,6 @@ matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray,
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const GFC_REAL_8 *restrict bbase_y;
@@ -1152,6 +1140,20 @@ matmul_r8_avx128_fma4 (gfc_array_r8 * const restrict retarray,
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = (GFC_REAL_8)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const GFC_REAL_8 *restrict abase_x;
diff --git a/libgfortran/intrinsics/env.c b/libgfortran/intrinsics/env.c
index d62116d5e5b..00b1662443e 100644
--- a/libgfortran/intrinsics/env.c
+++ b/libgfortran/intrinsics/env.c
@@ -110,10 +110,7 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,
 
   if (value != NULL)
     { 
-      if (value_len < 1)
-	runtime_error ("Zero-length string passed as value to "
-		       "get_environment_variable.");
-      else
+      if (value_len > 0)
 	memset (value, ' ', value_len); /* Blank the string.  */
     }
 
@@ -138,7 +135,7 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,
 	      memcpy (value, res, value_len);
 	      stat = GFC_VALUE_TOO_SHORT;
 	    }
-	  else
+	  else if (res_len > 0)
 	    memcpy (value, res, res_len);
 	}
     }
diff --git a/libgfortran/intrinsics/execute_command_line.c b/libgfortran/intrinsics/execute_command_line.c
index 1a471632172..7d8b6c5fe99 100644
--- a/libgfortran/intrinsics/execute_command_line.c
+++ b/libgfortran/intrinsics/execute_command_line.c
@@ -34,7 +34,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif
 #ifdef HAVE_POSIX_SPAWN
 #include <spawn.h>
+# ifdef __APPLE__
+#  include <crt_externs.h>
+#  define environ (*_NSGetEnviron ())
+# else
 extern char **environ;
+# endif
 #endif
 #if defined(HAVE_POSIX_SPAWN) || defined(HAVE_FORK)
 #include <signal.h>
diff --git a/libgfortran/io/async.c b/libgfortran/io/async.c
index 28b84f6613a..5af919bd71c 100644
--- a/libgfortran/io/async.c
+++ b/libgfortran/io/async.c
@@ -424,6 +424,13 @@ async_wait_id (st_parameter_common *cmp, async_unit *au, int i)
     }
 
   LOCK (&au->lock);
+  if (i > au->id.high)
+    {
+      generate_error_common (cmp, LIBERROR_BAD_WAIT_ID, NULL);
+      UNLOCK (&au->lock);
+      return true;
+    }
+
   NOTE ("Waiting for id %d", i);
   if (au->id.waiting < i)
     au->id.waiting = i;
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
index 1e075ea9608..b5c855b7fb3 100644
--- a/libgfortran/io/close.c
+++ b/libgfortran/io/close.c
@@ -31,7 +31,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif
 
 typedef enum
-{ CLOSE_DELETE, CLOSE_KEEP, CLOSE_UNSPECIFIED }
+{ CLOSE_INVALID = - 1, CLOSE_DELETE, CLOSE_KEEP, CLOSE_UNSPECIFIED }
 close_status;
 
 static const st_option status_opt[] = {
@@ -61,6 +61,12 @@ st_close (st_parameter_close *clp)
     find_option (&clp->common, clp->status, clp->status_len,
 		 status_opt, "Bad STATUS parameter in CLOSE statement");
 
+  if (status == CLOSE_INVALID)
+    {
+      library_end ();
+      return;
+    }
+
   u = find_unit (clp->common.unit);
 
   if (ASYNC_IO && u && u->au)
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 28e403fedf2..38c2d87b34f 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -4473,7 +4473,7 @@ void
 st_wait_async (st_parameter_wait *wtp)
 {
   gfc_unit *u = find_unit (wtp->common.unit);
-  if (ASYNC_IO && u->au)
+  if (ASYNC_IO && u && u->au)
     {
       if (wtp->common.flags & IOPARM_WAIT_HAS_ID)
 	async_wait_id (&(wtp->common), u->au, *wtp->id);
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index 87e01fe0442..377a8fe1b6a 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -767,9 +767,12 @@ close_unit_1 (gfc_unit *u, int locked)
 void
 unlock_unit (gfc_unit *u)
 {
-  NOTE ("unlock_unit = %d", u->unit_number);
-  UNLOCK (&u->lock);
-  NOTE ("unlock_unit done");
+  if (u)
+    {
+      NOTE ("unlock_unit = %d", u->unit_number);
+      UNLOCK (&u->lock);
+      NOTE ("unlock_unit done");
+    }
 }
 
 /* close_unit()-- Close a unit.  The stream is closed, and any memory
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index c63db4e77ef..9db748898c4 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -389,7 +389,8 @@ build_float_string (st_parameter_dt *dtp, const fnode *f, char *buffer,
   updown:
 
   rchar = '0';
-  if (ft != FMT_F && w > 0 && d == 0 && p == 0)
+  /* Do not reset nbefore for FMT_F and FMT_EN.  */
+  if (ft != FMT_F && ft !=FMT_EN && w > 0 && d == 0 && p == 0)
     nbefore = 1;
   /* Scan for trailing zeros to see if we really need to round it.  */
   for(i = nbefore + nafter; i < ndigits; i++)
diff --git a/libgfortran/m4/iall.m4 b/libgfortran/m4/iall.m4
index 41c8c268586..7de1ceb4925 100644
--- a/libgfortran/m4/iall.m4
+++ b/libgfortran/m4/iall.m4
@@ -35,7 +35,7 @@ ARRAY_FUNCTION(0,
 `  result &= *src;')
 
 MASKED_ARRAY_FUNCTION(0,
-`  result = 0;',
+`  result = ('rtype_name`) -1;',
 `  if (*msrc)
     result &= *src;')
 
diff --git a/libgfortran/m4/matmul_internal.m4 b/libgfortran/m4/matmul_internal.m4
index 32a1e01e12f..0e96207a0fc 100644
--- a/libgfortran/m4/matmul_internal.m4
+++ b/libgfortran/m4/matmul_internal.m4
@@ -192,7 +192,8 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl
 	}
     }
 
-  if (rxstride == 1 && axstride == 1 && bxstride == 1)
+  if (rxstride == 1 && axstride == 1 && bxstride == 1
+      && GFC_DESCRIPTOR_RANK (b) != 1)
     {
       /* This block of code implements a tuned matmul, derived from
          Superscalar GEMM-based level 3 BLAS,  Beta version 0.1
@@ -506,20 +507,6 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl
 	    }
 	}
     }
-  else if (axstride < aystride)
-    {
-      for (y = 0; y < ycount; y++)
-	for (x = 0; x < xcount; x++)
-	  dest[x*rxstride + y*rystride] = ('rtype_name`)0;
-
-      for (y = 0; y < ycount; y++)
-	for (n = 0; n < count; n++)
-	  for (x = 0; x < xcount; x++)
-	    /* dest[x,y] += a[x,n] * b[n,y] */
-	    dest[x*rxstride + y*rystride] +=
-					abase[x*axstride + n*aystride] *
-					bbase[n*bxstride + y*bystride];
-    }
   else if (GFC_DESCRIPTOR_RANK (a) == 1)
     {
       const 'rtype_name` *restrict bbase_y;
@@ -534,6 +521,20 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl
 	  dest[y*rxstride] = s;
 	}
     }
+  else if (axstride < aystride)
+    {
+      for (y = 0; y < ycount; y++)
+	for (x = 0; x < xcount; x++)
+	  dest[x*rxstride + y*rystride] = ('rtype_name`)0;
+
+      for (y = 0; y < ycount; y++)
+	for (n = 0; n < count; n++)
+	  for (x = 0; x < xcount; x++)
+	    /* dest[x,y] += a[x,n] * b[n,y] */
+	    dest[x*rxstride + y*rystride] +=
+					abase[x*axstride + n*aystride] *
+					bbase[n*bxstride + y*bystride];
+    }
   else
     {
       const 'rtype_name` *restrict abase_x;
diff --git a/libgfortran/runtime/error.c b/libgfortran/runtime/error.c
index 0335a165edc..1dea2f0e5f8 100644
--- a/libgfortran/runtime/error.c
+++ b/libgfortran/runtime/error.c
@@ -616,6 +616,10 @@ translate_error (int code)
       p = "Inquire statement identifies an internal file";
       break;
 
+    case LIBERROR_BAD_WAIT_ID:
+      p = "Bad ID in WAIT statement";
+      break;
+
     default:
       p = "Unknown error code";
       break;
diff --git a/libgo/runtime/proc.c b/libgo/runtime/proc.c
index 1569b5bb898..bb4c56dceb2 100644
--- a/libgo/runtime/proc.c
+++ b/libgo/runtime/proc.c
@@ -804,8 +804,8 @@ runtime_malg(bool allocatestack, bool signalstack, byte** ret_stack, uintptr* re
 		if(signalstack) {
 			stacksize = 32 * 1024; // OS X wants >= 8K, GNU/Linux >= 2K
 #ifdef SIGSTKSZ
-			if(stacksize < SIGSTKSZ)
-				stacksize = SIGSTKSZ;
+			if(stacksize < (uintptr)(SIGSTKSZ))
+				stacksize = (uintptr)(SIGSTKSZ);
 #endif
 		}
 
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index 0156d5f7bc9..1fe858426f9 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,225 @@
+2021-03-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-03-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* plugin/plugin-hsa.c (init_enviroment_variables): Don't prepend
+	the 'HSA_RUNTIME_LIB' path to 'libhsa-runtime64.so'.
+	* plugin/configfrag.ac (HSA_RUNTIME_LIB): Clean up.
+	* config.h.in: Regenerate.
+	* configure: Likewise.
+
+2021-01-14  Kwok Cheung Yeung  <kcy@codesourcery.com>
+
+	Backported from master:
+	2019-09-30  Kwok Cheung Yeung  <kcy@codesourcery.com>
+
+	* libgomp_g.h: Include stdint.h instead of gstdint.h.
+
+2021-01-14  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2021-01-14  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/65099
+	* plugin/configfrag.ac (PLUGIN_NVPTX): Restrict to supported
+	configurations.
+	* configure: Regenerate.
+	* plugin/plugin-nvptx.c (nvptx_get_num_devices): Remove 64-bit
+	check.
+
+2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-25  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/libgomp.oacc-c++/cache-1.C: New.
+	* testsuite/libgomp.oacc-c-c++-common/cache-1.c: Update.
+
+2020-11-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR target/85486
+	* testsuite/libgomp.oacc-c-c++-common/pr85486-2.c: Simplify and enhance.
+	* testsuite/libgomp.oacc-c-c++-common/pr85486-3.c: Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/pr85486.c: Likewise.
+
+2020-11-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2020-11-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/80219
+	PR testsuite/85303
+	* testsuite/lib/libgomp.exp (libgomp_init): Set
+	'gcc_warning_prefix', 'gcc_error_prefix'.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-08  Jakub Jelinek  <jakub@redhat.com>
+		    Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/93553
+	* testsuite/libgomp.fortran/pr93553.f90: New test.
+
+2020-09-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2020-08-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/96459
+	* testsuite/libgomp.c/teams-3.c: New test.
+	* testsuite/libgomp.c-c++-common/for-2.h (OMPTEAMS): Define to nothing
+	if not defined yet.
+	(N(test)): Use it before all N(f*) calls.
+	* testsuite/libgomp.c-c++-common/for-14.c (DO_PRAGMA, OMPTEAMS): Define.
+	(main): Don't call all test_* functions from within
+	#pragma omp teams reduction(|:err), call them directly.
+
+2020-06-04  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* testsuite/libgomp.oacc-fortran/error_stop-1.f: Initialize before
+	the checkpoint.
+	* testsuite/libgomp.oacc-fortran/error_stop-2.f: Likewise.
+	* testsuite/libgomp.oacc-fortran/error_stop-3.f: Likewise.
+	* testsuite/libgomp.oacc-fortran/stop-1.f: Likewise.
+	* testsuite/libgomp.oacc-fortran/stop-2.f: Likewise.
+	* testsuite/libgomp.oacc-fortran/stop-3.f: Likewise.
+
+2020-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/95191
+	* testsuite/libgomp.fortran/async_io_9.f90: New test.
+
+2020-05-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/95119
+	* testsuite/libgomp.fortran/close_errors_1.f90: New test.
+
+2020-04-13  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/92843
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-1-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-1.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-2-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-2.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-3-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-3.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-4-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-4.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-5-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-5.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-6-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-6.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-7-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-7.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-8-lib.c:
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8-lib.c:
+	... this.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-8.c::
+	Rename to...
+	* testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8.c:
+	... this.
+
+2020-04-10  Julian Brown  <julian@codesourcery.com>
+	    Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR libgomp/92843
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-1-lib.c:
+	New file.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-1.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-2-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-2.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-3-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-3.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-4-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-4.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-5-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-5.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-6-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-6.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-7-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-7.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-8-lib.c:
+	Likewise.
+	* testsuite/libgomp.oacc-c-c++-common/static-dynamic-lifetimes-8.c:
+	Likewise.
+
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/93931
+	* testsuite/libgomp.c++/pr93931.C: New test.
+
+2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/93566
+	* testsuite/libgomp.c/pr93566.c: New test.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libgomp/config.h.in b/libgomp/config.h.in
index 73f1b12805e..714020db03a 100644
--- a/libgomp/config.h.in
+++ b/libgomp/config.h.in
@@ -130,9 +130,6 @@
 /* Define to 1 if you have the `__secure_getenv' function. */
 #undef HAVE___SECURE_GETENV
 
-/* Define path to HSA runtime. */
-#undef HSA_RUNTIME_LIB
-
 /* Define to 1 if GNU symbol versioning is used for libgomp. */
 #undef LIBGOMP_GNU_SYMBOL_VERSIONING
 
diff --git a/libgomp/configure b/libgomp/configure
index b4bc4f43628..6f19f8c5822 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -15641,21 +15641,30 @@ if test x"$enable_offload_targets" != x; then
 	tgt_plugin=intelmic
 	;;
       nvptx*)
-	tgt_plugin=nvptx
-	PLUGIN_NVPTX=$tgt
-	if test "x$CUDA_DRIVER_LIB" != xno \
-	   && test "x$CUDA_DRIVER_LIB" != xno; then
-	  PLUGIN_NVPTX_CPPFLAGS=$CUDA_DRIVER_CPPFLAGS
-	  PLUGIN_NVPTX_LDFLAGS=$CUDA_DRIVER_LDFLAGS
-	  PLUGIN_NVPTX_LIBS='-lcuda'
-
-	  PLUGIN_NVPTX_save_CPPFLAGS=$CPPFLAGS
-	  CPPFLAGS="$PLUGIN_NVPTX_CPPFLAGS $CPPFLAGS"
-	  PLUGIN_NVPTX_save_LDFLAGS=$LDFLAGS
-	  LDFLAGS="$PLUGIN_NVPTX_LDFLAGS $LDFLAGS"
-	  PLUGIN_NVPTX_save_LIBS=$LIBS
-	  LIBS="$PLUGIN_NVPTX_LIBS $LIBS"
-	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+	case "${target}" in
+	  aarch64*-*-* | powerpc64le-*-* | x86_64-*-*)
+	    case " ${CC} ${CFLAGS} " in
+	      *" -m32 "* | *" -mx32 "*)
+		# PR libgomp/65099: Currently, we only support offloading in
+		# 64-bit configurations.
+		PLUGIN_NVPTX=0
+		;;
+	      *)
+		tgt_plugin=nvptx
+		PLUGIN_NVPTX=$tgt
+		if test "x$CUDA_DRIVER_LIB" != xno \
+		   && test "x$CUDA_DRIVER_LIB" != xno; then
+		  PLUGIN_NVPTX_CPPFLAGS=$CUDA_DRIVER_CPPFLAGS
+		  PLUGIN_NVPTX_LDFLAGS=$CUDA_DRIVER_LDFLAGS
+		  PLUGIN_NVPTX_LIBS='-lcuda'
+
+		  PLUGIN_NVPTX_save_CPPFLAGS=$CPPFLAGS
+		  CPPFLAGS="$PLUGIN_NVPTX_CPPFLAGS $CPPFLAGS"
+		  PLUGIN_NVPTX_save_LDFLAGS=$LDFLAGS
+		  LDFLAGS="$PLUGIN_NVPTX_LDFLAGS $LDFLAGS"
+		  PLUGIN_NVPTX_save_LIBS=$LIBS
+		  LIBS="$PLUGIN_NVPTX_LIBS $LIBS"
+		  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "cuda.h"
 int
@@ -15671,25 +15680,33 @@ if ac_fn_c_try_link "$LINENO"; then :
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-	  CPPFLAGS=$PLUGIN_NVPTX_save_CPPFLAGS
-	  LDFLAGS=$PLUGIN_NVPTX_save_LDFLAGS
-	  LIBS=$PLUGIN_NVPTX_save_LIBS
-	fi
-	case $PLUGIN_NVPTX in
-	  nvptx*)
-	    if (test "x$CUDA_DRIVER_INCLUDE" = x \
-		|| test "x$CUDA_DRIVER_INCLUDE" = xno) \
-	       && (test "x$CUDA_DRIVER_LIB" = x \
-		   || test "x$CUDA_DRIVER_LIB" = xno); then
-	      PLUGIN_NVPTX=1
-	      PLUGIN_NVPTX_CPPFLAGS='-I$(srcdir)/plugin/cuda'
-	      PLUGIN_NVPTX_LIBS='-ldl'
-	      PLUGIN_NVPTX_DYNAMIC=1
-	    else
-	      PLUGIN_NVPTX=0
-	      as_fn_error $? "CUDA driver package required for nvptx support" "$LINENO" 5
-	    fi
-	  ;;
+		  CPPFLAGS=$PLUGIN_NVPTX_save_CPPFLAGS
+		  LDFLAGS=$PLUGIN_NVPTX_save_LDFLAGS
+		  LIBS=$PLUGIN_NVPTX_save_LIBS
+		fi
+		case $PLUGIN_NVPTX in
+		  nvptx*)
+		    if (test "x$CUDA_DRIVER_INCLUDE" = x \
+			|| test "x$CUDA_DRIVER_INCLUDE" = xno) \
+		       && (test "x$CUDA_DRIVER_LIB" = x \
+			   || test "x$CUDA_DRIVER_LIB" = xno); then
+		      PLUGIN_NVPTX=1
+		      PLUGIN_NVPTX_CPPFLAGS='-I$(srcdir)/plugin/cuda'
+		      PLUGIN_NVPTX_LIBS='-ldl'
+		      PLUGIN_NVPTX_DYNAMIC=1
+		    else
+		      PLUGIN_NVPTX=0
+		      as_fn_error $? "CUDA driver package required for nvptx support" "$LINENO" 5
+		    fi
+		    ;;
+		esac
+		;;
+	    esac
+	    ;;
+	  *-*-*)
+	    # Target architecture not supported.
+	    PLUGIN_NVPTX=0
+	    ;;
 	esac
 	;;
       hsa*)
@@ -15796,16 +15813,6 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
-if test "$HSA_RUNTIME_LIB" != ""; then
-  HSA_RUNTIME_LIB="$HSA_RUNTIME_LIB/"
-fi
-
-
-cat >>confdefs.h <<_ACEOF
-#define HSA_RUNTIME_LIB "$HSA_RUNTIME_LIB"
-_ACEOF
-
-
 
 # Check for functions needed.
 for ac_func in getloadavg clock_gettime strtoull
diff --git a/libgomp/libgomp_g.h b/libgomp/libgomp_g.h
index 32a9d8aade9..dfb55fb66dc 100644
--- a/libgomp/libgomp_g.h
+++ b/libgomp/libgomp_g.h
@@ -31,7 +31,7 @@
 
 #include <stdbool.h>
 #include <stddef.h>
-#include "gstdint.h"
+#include <stdint.h>
 
 /* barrier.c */
 
diff --git a/libgomp/plugin/configfrag.ac b/libgomp/plugin/configfrag.ac
index 9718ac752e2..1f52901d4be 100644
--- a/libgomp/plugin/configfrag.ac
+++ b/libgomp/plugin/configfrag.ac
@@ -158,44 +158,61 @@ if test x"$enable_offload_targets" != x; then
 	tgt_plugin=intelmic
 	;;
       nvptx*)
-	tgt_plugin=nvptx
-	PLUGIN_NVPTX=$tgt
-	if test "x$CUDA_DRIVER_LIB" != xno \
-	   && test "x$CUDA_DRIVER_LIB" != xno; then
-	  PLUGIN_NVPTX_CPPFLAGS=$CUDA_DRIVER_CPPFLAGS
-	  PLUGIN_NVPTX_LDFLAGS=$CUDA_DRIVER_LDFLAGS
-	  PLUGIN_NVPTX_LIBS='-lcuda'
+	case "${target}" in
+	  aarch64*-*-* | powerpc64le-*-* | x86_64-*-*)
+	    case " ${CC} ${CFLAGS} " in
+	      *" -m32 "* | *" -mx32 "*)
+		# PR libgomp/65099: Currently, we only support offloading in
+		# 64-bit configurations.
+		PLUGIN_NVPTX=0
+		;;
+	      *)
+		tgt_plugin=nvptx
+		PLUGIN_NVPTX=$tgt
+		if test "x$CUDA_DRIVER_LIB" != xno \
+		   && test "x$CUDA_DRIVER_LIB" != xno; then
+		  PLUGIN_NVPTX_CPPFLAGS=$CUDA_DRIVER_CPPFLAGS
+		  PLUGIN_NVPTX_LDFLAGS=$CUDA_DRIVER_LDFLAGS
+		  PLUGIN_NVPTX_LIBS='-lcuda'
 
-	  PLUGIN_NVPTX_save_CPPFLAGS=$CPPFLAGS
-	  CPPFLAGS="$PLUGIN_NVPTX_CPPFLAGS $CPPFLAGS"
-	  PLUGIN_NVPTX_save_LDFLAGS=$LDFLAGS
-	  LDFLAGS="$PLUGIN_NVPTX_LDFLAGS $LDFLAGS"
-	  PLUGIN_NVPTX_save_LIBS=$LIBS
-	  LIBS="$PLUGIN_NVPTX_LIBS $LIBS"
-	  AC_LINK_IFELSE(
-	    [AC_LANG_PROGRAM(
-	      [#include "cuda.h"],
-		[CUresult r = cuCtxPushCurrent (NULL);])],
-	    [PLUGIN_NVPTX=1])
-	  CPPFLAGS=$PLUGIN_NVPTX_save_CPPFLAGS
-	  LDFLAGS=$PLUGIN_NVPTX_save_LDFLAGS
-	  LIBS=$PLUGIN_NVPTX_save_LIBS
-	fi
-	case $PLUGIN_NVPTX in
-	  nvptx*)
-	    if (test "x$CUDA_DRIVER_INCLUDE" = x \
-		|| test "x$CUDA_DRIVER_INCLUDE" = xno) \
-	       && (test "x$CUDA_DRIVER_LIB" = x \
-		   || test "x$CUDA_DRIVER_LIB" = xno); then
-	      PLUGIN_NVPTX=1
-	      PLUGIN_NVPTX_CPPFLAGS='-I$(srcdir)/plugin/cuda'
-	      PLUGIN_NVPTX_LIBS='-ldl'
-	      PLUGIN_NVPTX_DYNAMIC=1
-	    else
-	      PLUGIN_NVPTX=0
-	      AC_MSG_ERROR([CUDA driver package required for nvptx support])
-	    fi
-	  ;;
+		  PLUGIN_NVPTX_save_CPPFLAGS=$CPPFLAGS
+		  CPPFLAGS="$PLUGIN_NVPTX_CPPFLAGS $CPPFLAGS"
+		  PLUGIN_NVPTX_save_LDFLAGS=$LDFLAGS
+		  LDFLAGS="$PLUGIN_NVPTX_LDFLAGS $LDFLAGS"
+		  PLUGIN_NVPTX_save_LIBS=$LIBS
+		  LIBS="$PLUGIN_NVPTX_LIBS $LIBS"
+		  AC_LINK_IFELSE(
+		    [AC_LANG_PROGRAM(
+		      [#include "cuda.h"],
+			[CUresult r = cuCtxPushCurrent (NULL);])],
+		    [PLUGIN_NVPTX=1])
+		  CPPFLAGS=$PLUGIN_NVPTX_save_CPPFLAGS
+		  LDFLAGS=$PLUGIN_NVPTX_save_LDFLAGS
+		  LIBS=$PLUGIN_NVPTX_save_LIBS
+		fi
+		case $PLUGIN_NVPTX in
+		  nvptx*)
+		    if (test "x$CUDA_DRIVER_INCLUDE" = x \
+			|| test "x$CUDA_DRIVER_INCLUDE" = xno) \
+		       && (test "x$CUDA_DRIVER_LIB" = x \
+			   || test "x$CUDA_DRIVER_LIB" = xno); then
+		      PLUGIN_NVPTX=1
+		      PLUGIN_NVPTX_CPPFLAGS='-I$(srcdir)/plugin/cuda'
+		      PLUGIN_NVPTX_LIBS='-ldl'
+		      PLUGIN_NVPTX_DYNAMIC=1
+		    else
+		      PLUGIN_NVPTX=0
+		      AC_MSG_ERROR([CUDA driver package required for nvptx support])
+		    fi
+		    ;;
+		esac
+		;;
+	    esac
+	    ;;
+	  *-*-*)
+	    # Target architecture not supported.
+	    PLUGIN_NVPTX=0
+	    ;;
 	esac
 	;;
       hsa*)
@@ -275,10 +292,3 @@ AC_DEFINE_UNQUOTED([PLUGIN_NVPTX_DYNAMIC], [$PLUGIN_NVPTX_DYNAMIC],
 AM_CONDITIONAL([PLUGIN_HSA], [test $PLUGIN_HSA = 1])
 AC_DEFINE_UNQUOTED([PLUGIN_HSA], [$PLUGIN_HSA],
   [Define to 1 if the HSA plugin is built, 0 if not.])
-
-if test "$HSA_RUNTIME_LIB" != ""; then
-  HSA_RUNTIME_LIB="$HSA_RUNTIME_LIB/"
-fi
-
-AC_DEFINE_UNQUOTED([HSA_RUNTIME_LIB], ["$HSA_RUNTIME_LIB"],
-  [Define path to HSA runtime.])
diff --git a/libgomp/plugin/plugin-hsa.c b/libgomp/plugin/plugin-hsa.c
index e0bc87c9552..fbb3609c811 100644
--- a/libgomp/plugin/plugin-hsa.c
+++ b/libgomp/plugin/plugin-hsa.c
@@ -244,7 +244,7 @@ init_enviroment_variables (void)
 
   hsa_runtime_lib = secure_getenv ("HSA_RUNTIME_LIB");
   if (hsa_runtime_lib == NULL)
-    hsa_runtime_lib = HSA_RUNTIME_LIB "libhsa-runtime64.so";
+    hsa_runtime_lib = "libhsa-runtime64.so";
 
   support_cpu_devices = secure_getenv ("HSA_SUPPORT_CPU_DEVICES");
 }
diff --git a/libgomp/plugin/plugin-nvptx.c b/libgomp/plugin/plugin-nvptx.c
index 387e7cc6dd3..eaa8a956573 100644
--- a/libgomp/plugin/plugin-nvptx.c
+++ b/libgomp/plugin/plugin-nvptx.c
@@ -876,15 +876,6 @@ nvptx_get_num_devices (void)
 {
   int n;
 
-  /* PR libgomp/65099: Currently, we only support offloading in 64-bit
-     configurations.  */
-  if (sizeof (void *) != 8)
-    {
-      GOMP_PLUGIN_debug (0, "Disabling nvptx offloading;"
-			 " only 64-bit configurations are supported\n");
-      return 0;
-    }
-
   /* This function will be called before the plugin has been initialized in
      order to enumerate available devices, but CUDA API routines can't be used
      until cuInit has been called.  Just call it now (but don't yet do any
diff --git a/libgomp/testsuite/lib/libgomp.exp b/libgomp/testsuite/lib/libgomp.exp
index 14d9b5f1305..bee273df3b0 100644
--- a/libgomp/testsuite/lib/libgomp.exp
+++ b/libgomp/testsuite/lib/libgomp.exp
@@ -229,6 +229,12 @@ proc libgomp_init { args } {
     if { $offload_additional_options != "" } {
 	lappend ALWAYS_CFLAGS "additional_flags=${offload_additional_options}"
     }
+
+    # Tell warning from error diagnostics.  This fits for C, C++, and Fortran.
+    global gcc_warning_prefix
+    set gcc_warning_prefix "\[Ww\]arning:"
+    global gcc_error_prefix
+    set gcc_error_prefix "(\[Ff\]atal )?\[Ee\]rror:"
 }
 
 #
diff --git a/libgomp/testsuite/libgomp.c++/pr93931.C b/libgomp/testsuite/libgomp.c++/pr93931.C
new file mode 100644
index 00000000000..4d4232ef340
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/pr93931.C
@@ -0,0 +1,120 @@
+// PR c++/93931
+// { dg-do run }
+// { dg-options "-O2 -std=c++14" }
+
+extern "C" void abort ();
+
+void
+sink (int &x)
+{
+  int *volatile p;
+  p = &x;
+  (*p)++;
+}
+
+int
+foo ()
+{
+  int r = 0;
+  [&r] () {
+#pragma omp parallel for reduction(+ : r)
+    for (int i = 0; i < 1024; ++i)
+      r += i;
+  } ();
+  return r;
+}
+
+int
+bar ()
+{
+  int l = 0;
+  [&l] () {
+#pragma omp parallel for lastprivate (l)
+    for (int i = 0; i < 1024; ++i)
+      l = i;
+  } ();
+  return l;
+}
+
+void
+baz ()
+{
+  int f = 18;
+  [&f] () {
+#pragma omp parallel for firstprivate (f)
+    for (int i = 0; i < 1024; ++i)
+      {
+	sink (f);
+	f += 3;
+	sink (f);
+	if (f != 23)
+	  abort ();
+	sink (f);
+	f -= 7;
+	sink (f);
+      }
+  } ();
+  if (f != 18)
+    abort ();
+}
+
+int
+qux ()
+{
+  int r = 0;
+  [&] () {
+#pragma omp parallel for reduction(+ : r)
+    for (int i = 0; i < 1024; ++i)
+      r += i;
+  } ();
+  return r;
+}
+
+int
+corge ()
+{
+  int l = 0;
+  [&] () {
+#pragma omp parallel for lastprivate (l)
+    for (int i = 0; i < 1024; ++i)
+      l = i;
+  } ();
+  return l;
+}
+
+void
+garply ()
+{
+  int f = 18;
+  [&] () {
+#pragma omp parallel for firstprivate (f)
+    for (int i = 0; i < 1024; ++i)
+      {
+	sink (f);
+	f += 3;
+	sink (f);
+	if (f != 23)
+	  abort ();
+	sink (f);
+	f -= 7;
+	sink (f);
+      }
+  } ();
+  if (f != 18)
+    abort ();
+}
+
+int
+main ()
+{
+  if (foo () != 1024 * 1023 / 2)
+    abort ();
+  if (bar () != 1023)
+    abort ();
+  baz ();
+  if (qux () != 1024 * 1023 / 2)
+    abort ();
+  if (corge () != 1023)
+    abort ();
+  garply ();
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/for-14.c b/libgomp/testsuite/libgomp.c-c++-common/for-14.c
index 56440ab740f..d2e3be82b09 100644
--- a/libgomp/testsuite/libgomp.c-c++-common/for-14.c
+++ b/libgomp/testsuite/libgomp.c-c++-common/for-14.c
@@ -6,6 +6,8 @@ extern
 #endif
 void abort ();
 
+#define DO_PRAGMA(x) _Pragma (#x)
+#define OMPTEAMS DO_PRAGMA (omp teams)
 #define M(x, y, z) O(x, y, z)
 #define O(x, y, z) x ## _ ## y ## _ ## z
 
@@ -77,33 +79,30 @@ int
 main ()
 {
   int err = 0;
-  #pragma omp teams reduction(|:err)
-    {
-      err |= test_d_normal ();
-      err |= test_d_ds128_normal ();
-      err |= test_ds_normal ();
-      err |= test_ds_ds128_normal ();
-      err |= test_dpf_static ();
-      err |= test_dpf_static32 ();
-      err |= test_dpf_auto ();
-      err |= test_dpf_guided32 ();
-      err |= test_dpf_runtime ();
-      err |= test_dpf_ds128_static ();
-      err |= test_dpf_ds128_static32 ();
-      err |= test_dpf_ds128_auto ();
-      err |= test_dpf_ds128_guided32 ();
-      err |= test_dpf_ds128_runtime ();
-      err |= test_dpfs_static ();
-      err |= test_dpfs_static32 ();
-      err |= test_dpfs_auto ();
-      err |= test_dpfs_guided32 ();
-      err |= test_dpfs_runtime ();
-      err |= test_dpfs_ds128_static ();
-      err |= test_dpfs_ds128_static32 ();
-      err |= test_dpfs_ds128_auto ();
-      err |= test_dpfs_ds128_guided32 ();
-      err |= test_dpfs_ds128_runtime ();
-    }
+  err |= test_d_normal ();
+  err |= test_d_ds128_normal ();
+  err |= test_ds_normal ();
+  err |= test_ds_ds128_normal ();
+  err |= test_dpf_static ();
+  err |= test_dpf_static32 ();
+  err |= test_dpf_auto ();
+  err |= test_dpf_guided32 ();
+  err |= test_dpf_runtime ();
+  err |= test_dpf_ds128_static ();
+  err |= test_dpf_ds128_static32 ();
+  err |= test_dpf_ds128_auto ();
+  err |= test_dpf_ds128_guided32 ();
+  err |= test_dpf_ds128_runtime ();
+  err |= test_dpfs_static ();
+  err |= test_dpfs_static32 ();
+  err |= test_dpfs_auto ();
+  err |= test_dpfs_guided32 ();
+  err |= test_dpfs_runtime ();
+  err |= test_dpfs_ds128_static ();
+  err |= test_dpfs_ds128_static32 ();
+  err |= test_dpfs_ds128_auto ();
+  err |= test_dpfs_ds128_guided32 ();
+  err |= test_dpfs_ds128_runtime ();
   if (err)
     abort ();
   return 0;
diff --git a/libgomp/testsuite/libgomp.c-c++-common/for-2.h b/libgomp/testsuite/libgomp.c-c++-common/for-2.h
index 91a604a6c25..f637fd3d760 100644
--- a/libgomp/testsuite/libgomp.c-c++-common/for-2.h
+++ b/libgomp/testsuite/libgomp.c-c++-common/for-2.h
@@ -14,6 +14,9 @@ noreturn (void)
 #ifndef OMPTGT
 #define OMPTGT
 #endif
+#ifndef OMPTEAMS
+#define OMPTEAMS
+#endif
 #ifndef OMPTO
 #define OMPTO(v) do {} while (0)
 #endif
@@ -214,31 +217,37 @@ N(test) (void)
   for (i = 0; i < 1500; i++)
     a[i] = i - 25;
   OMPTO (a);
+  OMPTEAMS
   N(f0) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 23)
       return 1;
+  OMPTEAMS
   N(f1) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 25)
       return 1;
+  OMPTEAMS
   N(f2) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 29)
       return 1;
+  OMPTEAMS
   N(f3) (1500LL - 1 - 23 - 48, -1LL + 25 - 48, 1LL);
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 22)
       return 1;
+  OMPTEAMS
   N(f3) (1500LL - 1 - 23 - 48, 1500LL - 1, 7LL);
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 22)
       return 1;
+  OMPTEAMS
   N(f4) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
@@ -249,6 +258,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	b[i][j][k] = i - 2.5 + 1.5 * j - 1.5 * k;
   OMPTO (b);
+  OMPTEAMS
   N(f5) (0, 10, 0, 15, 0, 10, 1, 1, 1);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -256,6 +266,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f5) (0, 10, 30, 15, 0, 10, 4, 5, 6);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -263,6 +274,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f6) (9, -1, 29, 0, 9, -1, -1, -2, -1);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -270,6 +282,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i - 4.5 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f7) ();
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -277,6 +290,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f8) ();	  
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -284,9 +298,13 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f9) ();
+  OMPTEAMS
   N(f10) ();
+  OMPTEAMS
   N(f11) (10);
+  OMPTEAMS
   N(f12) (12);
   OMPFROM (a);
   OMPFROM (b);
@@ -298,7 +316,9 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f13) ();
+  OMPTEAMS
   N(f14) ();
   OMPFROM (a);
   OMPFROM (b);
@@ -507,26 +527,31 @@ N(test) (void)
   for (i = 0; i < 1500; i++)
     a[i] = i - 25;
   OMPTO (a);
+  OMPTEAMS
   N(f20) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 23)
       return 1;
+  OMPTEAMS
   N(f21) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 25)
       return 1;
+  OMPTEAMS
   N(f22) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 29)
       return 1;
+  OMPTEAMS
   N(f23) (1500LL - 1 - 23 - 48, -1LL + 25 - 48);
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
     if (a[i] != i - 22)
       return 1;
+  OMPTEAMS
   N(f24) ();
   OMPFROM (a);
   for (i = 0; i < 1500; i++)
@@ -537,6 +562,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	b[i][j][k] = i - 2.5 + 1.5 * j - 1.5 * k;
   OMPTO (b);
+  OMPTEAMS
   N(f25) (0, 10, 0, 15, 0, 10, 1);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -544,6 +570,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f25) (0, 10, 30, 15, 0, 10, 5);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -551,6 +578,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f26) (9, -1, 29, 0, 9, -1, -2);
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -558,6 +586,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i - 4.5 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f27) ();
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -565,6 +594,7 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f28) ();
   OMPFROM (b);
   for (i = 0; i < 10; i++)
@@ -572,9 +602,13 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f29) ();
+  OMPTEAMS
   N(f30) ();
+  OMPTEAMS
   N(f31) (20);
+  OMPTEAMS
   N(f32) (12);
   OMPFROM (a);
   OMPFROM (b);
@@ -586,7 +620,9 @@ N(test) (void)
       for (k = 0; k < 10; k++)
 	if (b[i][j][k] != i + 1.0 + 1.5 * j - 1.5 * k)
 	  return 1;
+  OMPTEAMS
   N(f33) ();
+  OMPTEAMS
   N(f34) ();
   OMPFROM (a);
   OMPFROM (b);
diff --git a/libgomp/testsuite/libgomp.c/pr93566.c b/libgomp/testsuite/libgomp.c/pr93566.c
new file mode 100644
index 00000000000..3334bd571f6
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr93566.c
@@ -0,0 +1,113 @@
+/* PR middle-end/93566 */
+/* { dg-additional-options "-std=c99" } */
+
+extern void abort (void);
+
+void
+foo (int *x)
+{
+  void nest (void) {
+    #pragma omp parallel for reduction(+:x[:10])
+    for (int i = 0; i < 1024; i++)
+      for (int j = 0; j < 10; j++)
+	x[j] += j * i;
+  }
+  nest ();
+  for (int i = 0; i < 10; i++)
+    if (x[i] != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+void
+bar (void)
+{
+  int x[10] = {};
+  void nest (void) {
+    #pragma omp parallel for reduction(+:x[:10])
+    for (int i = 0; i < 1024; i++)
+      for (int j = 0; j < 10; j++)
+	x[j] += j * i;
+  }
+  nest ();
+  for (int i = 0; i < 10; i++)
+    if (x[i] != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+void
+baz (void)
+{
+  int x[10] = {};
+  void nest (void) {
+    #pragma omp parallel for reduction(+:x[2:5])
+    for (int i = 0; i < 1024; i++)
+      for (int j = 2; j < 7; j++)
+	x[j] += j * i;
+  }
+  nest ();
+  for (int i = 2; i < 7; i++)
+    if (x[i] != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+void
+qux (int *x)
+{
+  void nest (void) { x++; }
+  nest ();
+  #pragma omp parallel for reduction(+:x[:9])
+  for (int i = 0; i < 1024; i++)
+    for (int j = 0; j < 9; j++)
+      x[j] += j * i;
+  nest ();
+  for (int i = 0; i < 9; i++)
+    if (x[i - 1] != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+void
+quux (void)
+{
+  int x[10];
+  void nest (void) { for (int i = 0; i < 10; i++) x[i] = 0; }
+  int nest2 (int i) { return x[i]; }
+  nest ();
+  #pragma omp parallel for reduction(+:x[:7])
+  for (int i = 0; i < 1024; i++)
+    for (int j = 0; j < 7; j++)
+      x[j] += j * i;
+  for (int i = 0; i < 7; i++)
+    if (nest2 (i) != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+void
+corge (void)
+{
+  int x[10];
+  void nest (void) { for (int i = 0; i < 10; i++) x[i] = 0; }
+  int nest2 (int i) { return x[i]; }
+  nest ();
+  #pragma omp parallel for reduction(+:x[2:4])
+  for (int i = 0; i < 1024; i++)
+    for (int j = 2; j < 6; j++)
+      x[j] += j * i;
+  for (int i = 2; i < 6; i++)
+    if (nest2 (i) != 1023 * 1024 / 2 * i)
+      abort ();
+}
+
+int
+main ()
+{
+  int a[10] = {};
+  foo (a);
+  bar ();
+  baz ();
+  for (int i = 0; i < 10; i++)
+    a[i] = 0;
+  qux (a);
+  quux ();
+  corge ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/teams-3.c b/libgomp/testsuite/libgomp.c/teams-3.c
new file mode 100644
index 00000000000..34a9aa00ff7
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/teams-3.c
@@ -0,0 +1,20 @@
+/* PR middle-end/96459 */
+
+#include <stdlib.h>
+
+int
+main ()
+{
+  int niters = 0, i, j, k;
+  #pragma omp teams reduction(+:niters)
+  {
+    #pragma omp distribute collapse(3)
+    for (i = 0; i < 3; i++)
+      for (j = 0; j < 8; j += 2)
+	for (k = 0; k < 25; k += 3)
+	  niters++;
+  }
+  if (niters != 108)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.fortran/async_io_9.f90 b/libgomp/testsuite/libgomp.fortran/async_io_9.f90
new file mode 100644
index 00000000000..2dc111c3967
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/async_io_9.f90
@@ -0,0 +1,20 @@
+! { dg-do run }
+! PR 95191 - this used to hang.
+! Original test case by Bill Long.
+program test
+  real a(10000)
+  integer my_id
+  integer bad_id
+  integer :: iostat
+  character (len=100) :: iomsg
+  data my_id /1/
+  data bad_id /2/
+  a = 1.
+  open (unit=10, file='test.dat', form='unformatted', &
+       &                asynchronous='yes')
+  write (unit=10, asynchronous='yes', id=my_id) a
+  iomsg = ""
+  wait (unit=10, id=bad_id, iostat=iostat, iomsg=iomsg)
+  if (iostat == 0 .or. iomsg /= "Bad ID in WAIT statement") stop 1
+  close (unit=10, status='delete')
+end program test
diff --git a/libgomp/testsuite/libgomp.fortran/close_errors_1.f90 b/libgomp/testsuite/libgomp.fortran/close_errors_1.f90
new file mode 100644
index 00000000000..6edb7da4116
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/close_errors_1.f90
@@ -0,0 +1,19 @@
+! { dg-do run }
+! PR 95115 - this used to hang with -pthread.  Original test case by
+! Bill Long.
+
+program test
+  character(len=16) my_status
+  character(len=1000) :: iomsg
+  open (unit=10, file='test.dat')
+  print *,42
+  write (10, *) 'weird'
+  rewind (10)
+  read (10, *) my_status
+  close (10)
+  open (unit=10, file='test.dat')
+  close (unit=10, status=my_status, iostat=ios, iomsg=iomsg)
+  if (ios == 0) stop 1
+  if (iomsg /= "Bad STATUS parameter in CLOSE statement") stop 2
+  close (10, status='delete')
+end program test
diff --git a/libgomp/testsuite/libgomp.fortran/pr93553.f90 b/libgomp/testsuite/libgomp.fortran/pr93553.f90
new file mode 100644
index 00000000000..5d6f10febed
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/pr93553.f90
@@ -0,0 +1,21 @@
+program p
+   implicit none
+   integer :: x(8) = 0
+   call sub(x)
+end
+subroutine sub(x)
+   implicit none
+   integer i
+   integer :: x(8)
+   integer :: c(8) = [(11*i, i=1,8)]
+   call s
+   if (any (x /= c)) stop 1
+contains
+   subroutine s
+      integer :: i
+      !$omp parallel do reduction(+:x)
+      do i = 1, 8
+         x(i) = c(i)
+      end do
+   end
+end
diff --git a/libgomp/testsuite/libgomp.oacc-c++/cache-1.C b/libgomp/testsuite/libgomp.oacc-c++/cache-1.C
new file mode 100644
index 00000000000..fcb1f84eef9
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c++/cache-1.C
@@ -0,0 +1,13 @@
+/* OpenACC 'cache' directive.  */
+
+/* See also corresponding C/C++ variant '../libgomp.oacc-c-c++-common/cache-1.c'.  */
+
+#include "../../../gcc/testsuite/g++.dg/goacc/cache-1.C"
+
+int
+main (int argc, char *argv[])
+{
+  test<0> ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
index 16aaed5df70..c0dddb3c4f3 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c
@@ -1,3 +1,13 @@
-/* OpenACC cache directive.  */
+/* OpenACC 'cache' directive.  */
+
+/* See also corresponding C++ variant '../libgomp.oacc-c++/cache-1.C'.  */
 
 #include "../../../gcc/testsuite/c-c++-common/goacc/cache-1.c"
+
+int
+main (int argc, char *argv[])
+{
+  test ();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-2.c
index f6ca263166d..d45326488cd 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-2.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-2.c
@@ -1,52 +1,11 @@
 /* { dg-do run { target openacc_nvidia_accel_selected } } */
+/* { dg-additional-options "-DVECTOR_LENGTH=" } */
 /* { dg-additional-options "-fopenacc-dim=::128" } */
 
-/* Minimized from ref-1.C.  */
+/* { dg-additional-options "-foffload=-fdump-tree-oaccdevlow" } */
+/* { dg-set-target-env-var "GOMP_DEBUG" "1" } */
 
-#include <stdio.h>
+#include "pr85486.c"
 
-#pragma acc routine vector
-void __attribute__((noinline, noclone))
-Vector (int *ptr, int n, const int inc)
-{
-  #pragma acc loop vector
-  for (unsigned ix = 0; ix < n; ix++)
-    ptr[ix] += inc;
-}
-
-int
-main (void)
-{
-  const int n = 32, m=32;
-
-  int ary[m][n];
-  unsigned ix,  iy;
-
-  for (ix = m; ix--;)
-    for (iy = n; iy--;)
-      ary[ix][iy] = (1 << 16) + (ix << 8) + iy;
-
-  int err = 0;
-
-#pragma acc parallel copy (ary)
-  {
-    Vector (&ary[0][0], m * n, (1 << 24) - (1 << 16));
-  }
-
-  for (ix = m; ix--;)
-    for (iy = n; iy--;)
-      if (ary[ix][iy] != ((1 << 24) + (ix << 8) + iy))
-	{
-	  printf ("ary[%u][%u] = %x expected %x\n",
-		  ix, iy, ary[ix][iy], ((1 << 24) + (ix << 8) + iy));
-	  err++;
-	}
-
-  if (err)
-    {
-      printf ("%d failed\n", err);
-      return 1;
-    }
-
-  return 0;
-}
+/* { dg-final { scan-offload-tree-dump "__attribute__\\(\\(oacc function \\(1, 1, 32\\)" "oaccdevlow" } } */
+/* { dg-output "nvptx_exec: kernel main\\\$_omp_fn\\\$0: launch gangs=1, workers=1, vectors=32" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-3.c
index a959b90c29a..33480a4ae68 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-3.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486-3.c
@@ -1,54 +1,11 @@
 /* { dg-do run { target openacc_nvidia_accel_selected } } */
+/* { dg-additional-options "-DVECTOR_LENGTH=" } */
 /* { dg-set-target-env-var "GOMP_OPENACC_DIM" "::128" } */
 
-/* Minimized from ref-1.C.  */
+/* { dg-additional-options "-foffload=-fdump-tree-oaccdevlow" } */
+/* { dg-set-target-env-var "GOMP_DEBUG" "1" } */
 
-#include <stdio.h>
+#include "pr85486.c"
 
-#pragma acc routine vector
-void __attribute__((noinline, noclone))
-Vector (int *ptr, int n, const int inc)
-{
-  #pragma acc loop vector
-  for (unsigned ix = 0; ix < n; ix++)
-    ptr[ix] += inc;
-}
-
-int
-main (void)
-{
-  const int n = 32, m=32;
-
-  int ary[m][n];
-  unsigned ix,  iy;
-
-  for (ix = m; ix--;)
-    for (iy = n; iy--;)
-      ary[ix][iy] = (1 << 16) + (ix << 8) + iy;
-
-  int err = 0;
-
-#pragma acc parallel copy (ary)
-  {
-    Vector (&ary[0][0], m * n, (1 << 24) - (1 << 16));
-  }
-
-  for (ix = m; ix--;)
-    for (iy = n; iy--;)
-      if (ary[ix][iy] != ((1 << 24) + (ix << 8) + iy))
-	{
-	  printf ("ary[%u][%u] = %x expected %x\n",
-		  ix, iy, ary[ix][iy], ((1 << 24) + (ix << 8) + iy));
-	  err++;
-	}
-
-  if (err)
-    {
-      printf ("%d failed\n", err);
-      return 1;
-    }
-
-  return 0;
-}
-
-/* { dg-prune-output "using vector_length \\(32\\), ignoring runtime setting" } */
+/* { dg-final { scan-offload-tree-dump "__attribute__\\(\\(oacc function \\(1, 1, 32\\)" "oaccdevlow" } } */
+/* { dg-output "nvptx_exec: kernel main\\\$_omp_fn\\\$0: launch gangs=1, workers=1, vectors=32" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486.c
index 99c08059d37..0d98b82f993 100644
--- a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486.c
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr85486.c
@@ -1,4 +1,8 @@
 /* { dg-do run { target openacc_nvidia_accel_selected } } */
+/* { dg-additional-options "-DVECTOR_LENGTH=vector_length(128)" } */
+
+/* { dg-additional-options "-foffload=-fdump-tree-oaccdevlow" } */
+/* { dg-set-target-env-var "GOMP_DEBUG" "1" } */
 
 /* Minimized from ref-1.C.  */
 
@@ -27,7 +31,7 @@ main (void)
 
   int err = 0;
 
-#pragma acc parallel copy (ary) vector_length (128) /* { dg-warning "using vector_length \\(32\\) due to call to vector-partitionable routine, ignoring 128" } */
+#pragma acc parallel copy (ary) VECTOR_LENGTH /* { dg-warning "using vector_length \\(32\\) due to call to vector-partitionable routine, ignoring 128" } */
   {
     Vector (&ary[0][0], m * n, (1 << 24) - (1 << 16));
   }
@@ -49,3 +53,6 @@ main (void)
 
   return 0;
 }
+
+/* { dg-final { scan-offload-tree-dump "__attribute__\\(\\(oacc function \\(1, 1, 32\\)" "oaccdevlow" } } */
+/* { dg-output "nvptx_exec: kernel main\\\$_omp_fn\\\$0: launch gangs=1, workers=1, vectors=32" } */
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1-lib.c
new file mode 100644
index 00000000000..8fa87777f1a
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-1.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1.c
new file mode 100644
index 00000000000..0d6b4159ad0
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-1.c
@@ -0,0 +1,161 @@
+/* Test transitioning of data lifetimes between structured and dynamic.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+void
+f1 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+  }
+
+  assert (acc_is_present (block1, SIZE));
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+  assert (acc_is_present (block1, SIZE));
+  acc_copyout (block1, SIZE);
+  assert (acc_is_present (block1, SIZE));
+  acc_copyout (block1, SIZE);
+  assert (!acc_is_present (block1, SIZE));
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (acc_is_present (block1, SIZE));
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (acc_is_present (block1, SIZE));
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (!acc_is_present (block1, SIZE));
+#endif
+
+  free (block1);
+}
+
+void
+f2 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+    /* This should stay present until the end of the structured data
+       lifetime.  */
+    assert (acc_is_present (block1, SIZE));
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f3 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+    acc_copyin (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+    assert (acc_is_present (block1, SIZE));
+  }
+
+  assert (acc_is_present (block1, SIZE));
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f4 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+  char *block3 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])
+  {
+  /* The first copyin of block2 is the enclosing data region.  This
+     "enter data" should make it live beyond the end of this region.
+     This works, though the on-target copies of block1, block2 and block3
+     will stay allocated until block2 is unmapped because they are bound
+     together in a single target_mem_desc.  */
+#ifdef OPENACC_API
+    acc_copyin (block2, SIZE);
+#else
+#pragma acc enter data copyin(block2[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+
+#ifdef OPENACC_API
+  acc_copyout (block2, SIZE);
+#else
+#pragma acc exit data copyout(block2[0:SIZE])
+#endif
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+  free (block3);
+}
+
+int
+main (int argc, char *argv[])
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2-lib.c
new file mode 100644
index 00000000000..365df8d7f7d
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-2.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2.c
new file mode 100644
index 00000000000..726942c76fd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-2.c
@@ -0,0 +1,166 @@
+/* Test nested dynamic/structured data mappings.  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+void
+f1 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f2 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+  }
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f3 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+    acc_copyin (block1, SIZE);
+    acc_copyout (block1, SIZE);
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f4 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+    {
+#ifdef OPENACC_API
+      acc_copyin (block1, SIZE);
+      acc_copyout (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+    }
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+void
+f5 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+#pragma acc data copy(block1[0:SIZE])
+    {
+    }
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+
+  assert (!acc_is_present (block1, SIZE));
+
+  free (block1);
+}
+
+int
+main (int argc, char *argv[])
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3-lib.c
new file mode 100644
index 00000000000..469b35b76f1
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-3.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3.c
new file mode 100644
index 00000000000..c13f3c56584
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-3.c
@@ -0,0 +1,183 @@
+/* Test nested dynamic/structured data mappings (multiple blocks on data
+   regions).  */
+
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+void
+f1 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+}
+
+void
+f2 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+  }
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+}
+
+void
+f3 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+    acc_copyin (block2, SIZE);
+    acc_copyout (block2, SIZE);
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc enter data copyin(block2[0:SIZE])
+#pragma acc exit data copyout(block2[0:SIZE])
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+}
+
+void
+f4 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+    {
+#ifdef OPENACC_API
+      acc_copyin (block2, SIZE);
+      acc_copyout (block2, SIZE);
+#else
+#pragma acc enter data copyin(block2[0:SIZE])
+#pragma acc exit data copyout(block2[0:SIZE])
+#endif
+    }
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+}
+
+void
+f5 (void)
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyin (block2, SIZE);
+#else
+#pragma acc enter data copyin(block2[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+    {
+    }
+#ifdef OPENACC_API
+    acc_copyout (block2, SIZE);
+#else
+#pragma acc exit data copyout(block2[0:SIZE])
+#endif
+  }
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+}
+
+int
+main (int argc, char *argv[])
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4-lib.c
new file mode 100644
index 00000000000..8e88b97b2ce
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-4.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c
new file mode 100644
index 00000000000..e9a6510ace8
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-4.c
@@ -0,0 +1,64 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+int
+main (int argc, char *argv[])
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+  char *block3 = (char *) malloc (SIZE);
+
+  /* Doing this twice ensures that we have a non-zero virtual refcount.  Make
+     sure that works too.  */
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])
+  {
+  /* The first copyin of block2 is the enclosing data region.  This
+     "enter data" should make it live beyond the end of this region.  */
+#ifdef OPENACC_API
+    acc_copyin (block2, SIZE);
+#else
+#pragma acc enter data copyin(block2[0:SIZE])
+#endif
+  }
+
+  assert (acc_is_present (block1, SIZE));
+  assert (acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+  assert (acc_is_present (block1, SIZE));
+  acc_copyout (block1, SIZE);
+  assert (!acc_is_present (block1, SIZE));
+
+  acc_copyout (block2, SIZE);
+  assert (!acc_is_present (block2, SIZE));
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (acc_is_present (block1, SIZE));
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (!acc_is_present (block1, SIZE));
+
+#pragma acc exit data copyout(block2[0:SIZE])
+  assert (!acc_is_present (block2, SIZE));
+#endif
+
+  free (block1);
+  free (block2);
+  free (block3);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5-lib.c
new file mode 100644
index 00000000000..59ef5626bd0
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-5.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5.c
new file mode 100644
index 00000000000..9807076d3f4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-5.c
@@ -0,0 +1,56 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+int
+main (int argc, char *argv[])
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+  char *block3 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])
+  {
+  /* The first copyin of block2 is the enclosing data region.  This
+     "enter data" should make it live beyond the end of this region.  */
+#ifdef OPENACC_API
+    acc_copyin (block2, SIZE);
+#else
+#pragma acc enter data copyin(block2[0:SIZE])
+#endif
+  }
+
+  assert (acc_is_present (block1, SIZE));
+  assert (acc_is_present (block2, SIZE));
+  assert (!acc_is_present (block3, SIZE));
+
+#ifdef OPENACC_API
+  acc_copyout (block1, SIZE);
+  assert (!acc_is_present (block1, SIZE));
+
+  acc_copyout (block2, SIZE);
+  assert (!acc_is_present (block2, SIZE));
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+  assert (!acc_is_present (block1, SIZE));
+
+#pragma acc exit data copyout(block2[0:SIZE])
+  assert (!acc_is_present (block2, SIZE));
+#endif
+
+  free (block1);
+  free (block2);
+  free (block3);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6-lib.c
new file mode 100644
index 00000000000..0401f73966f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-6.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6.c
new file mode 100644
index 00000000000..9250b4af3ed
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-6.c
@@ -0,0 +1,43 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+int
+main (int argc, char *argv[])
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+  acc_copyin (block2, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE], block2[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+    acc_copyout (block2, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE], block2[0:SIZE])
+#endif
+    /* These should stay present until the end of the structured data
+       lifetime.  */
+    assert (acc_is_present (block1, SIZE));
+    assert (acc_is_present (block2, SIZE));
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7-lib.c
new file mode 100644
index 00000000000..07caefbd082
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-7.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7.c
new file mode 100644
index 00000000000..52e8d4c9959
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-7.c
@@ -0,0 +1,44 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+int
+main (int argc, char *argv[])
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+/* We can't attach the dynamic data mapping's (block1) target_mem_desc to the
+   enclosing structured data region here, because that region maps block2
+   also.  */
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#endif
+    /* These should stay present until the end of the structured data
+       lifetime.  */
+    assert (acc_is_present (block1, SIZE));
+    assert (acc_is_present (block2, SIZE));
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8-lib.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8-lib.c
new file mode 100644
index 00000000000..1c2479ad96f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8-lib.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+/* { dg-additional-options "-DOPENACC_API" } */
+#include "structured-dynamic-lifetimes-8.c"
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8.c
new file mode 100644
index 00000000000..919ee02b725
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/structured-dynamic-lifetimes-8.c
@@ -0,0 +1,47 @@
+/* { dg-skip-if "" { *-*-* } { "-DACC_MEM_SHARED=1" } } */
+
+#include <openacc.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#define SIZE 1024
+
+int
+main (int argc, char *argv[])
+{
+  char *block1 = (char *) malloc (SIZE);
+  char *block2 = (char *) malloc (SIZE);
+
+#ifdef OPENACC_API
+  acc_copyin (block1, SIZE);
+#else
+#pragma acc enter data copyin(block1[0:SIZE])
+#endif
+
+#pragma acc data copy(block1[0:SIZE], block2[0:SIZE])
+  {
+#ifdef OPENACC_API
+    acc_copyout (block1, SIZE);
+    acc_copyin (block2, SIZE);
+#else
+#pragma acc exit data copyout(block1[0:SIZE])
+#pragma acc enter data copyin(block2[0:SIZE])
+#endif
+    assert (acc_is_present (block1, SIZE));
+    assert (acc_is_present (block2, SIZE));
+  }
+
+  assert (!acc_is_present (block1, SIZE));
+  assert (acc_is_present (block2, SIZE));
+#ifdef OPENACC_API
+  acc_copyout (block2, SIZE);
+#else
+#pragma acc exit data copyout(block2[0:SIZE])
+#endif
+  assert (!acc_is_present (block2, SIZE));
+
+  free (block1);
+  free (block2);
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
index 4965e674c27..a995d955fc2 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-1.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       ERROR STOP
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
index 7103fdb5d8e..426c15abcdf 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-2.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       ERROR STOP 35
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
index 9c217f14ea1..bef01e6d505 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/error_stop-3.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       ERROR STOP "SiGN"
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/stop-1.f b/libgomp/testsuite/libgomp.oacc-fortran/stop-1.f
index af267fc08d1..2c00d2e5bf8 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/stop-1.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/stop-1.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       STOP
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/stop-2.f b/libgomp/testsuite/libgomp.oacc-fortran/stop-2.f
index 13c06845c08..adade54557c 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/stop-2.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/stop-2.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       STOP 35
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/stop-3.f b/libgomp/testsuite/libgomp.oacc-fortran/stop-3.f
index 3bd7446571d..157e369d4e7 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/stop-3.f
+++ b/libgomp/testsuite/libgomp.oacc-fortran/stop-3.f
@@ -3,6 +3,10 @@
       PROGRAM MAIN
       IMPLICIT NONE
 
+! Initialize before the checkpoint, in case this produces any output.
+!$ACC PARALLEL
+!$ACC END PARALLEL
+
       PRINT *, "CheCKpOInT"
 !$ACC PARALLEL
       STOP "SiGN"
diff --git a/libiberty/simple-object-elf.c b/libiberty/simple-object-elf.c
index 3d49f339631..a5cf6043dc3 100644
--- a/libiberty/simple-object-elf.c
+++ b/libiberty/simple-object-elf.c
@@ -1446,6 +1446,11 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,
 		       && st_shndx < shnum
 		       && pfnret[st_shndx - 1] == -1)
 		discard = 1;
+	      /* We also need to remove global UNDEFs which can
+		 cause link fails later.  */
+	      else if (st_shndx == SHN_UNDEF
+		       && ELF_ST_BIND (*st_info) == STB_GLOBAL)
+		discard = 1;
 
 	      if (discard)
 		{
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index 703db28ee23..d8203bfb37a 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,18 @@
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-09  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/sjlj.S: Add BTI marking and related definitions,
+	and add BTI c to function entries.
+
+2020-07-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backported from master:
+	2020-07-09  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* config/aarch64/sjlj.S: Add stack note if __FreeBSD__ is defined.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libitm/config/aarch64/sjlj.S b/libitm/config/aarch64/sjlj.S
index c704d1b0898..367806b68fd 100644
--- a/libitm/config/aarch64/sjlj.S
+++ b/libitm/config/aarch64/sjlj.S
@@ -24,6 +24,8 @@
 
 #include "asmcfi.h"
 
+#define BTI_C	hint	34
+
 	.text
 	.align	2
 	.global	_ITM_beginTransaction
@@ -31,6 +33,7 @@
 
 _ITM_beginTransaction:
 	cfi_startproc
+	BTI_C
 	mov	x1, sp
 	stp	x29, x30, [sp, -11*16]!
 	cfi_adjust_cfa_offset(11*16)
@@ -70,6 +73,7 @@ GTM_longjmp:
 	/* The first parameter becomes the return value (x0).
 	   The third parameter is ignored for now.  */
 	cfi_startproc
+	BTI_C
 	ldp	x19, x20, [x1, 1*16]
 	ldp	x21, x22, [x1, 2*16]
 	ldp	x23, x24, [x1, 3*16]
@@ -87,6 +91,29 @@ GTM_longjmp:
 	cfi_endproc
 	.size	GTM_longjmp, . - GTM_longjmp
 
-#ifdef __linux__
+/* GNU_PROPERTY_AARCH64_* macros from elf.h for use in asm code.  */
+#define FEATURE_1_AND 0xc0000000
+#define FEATURE_1_BTI 1
+#define FEATURE_1_PAC 2
+
+/* Add a NT_GNU_PROPERTY_TYPE_0 note.  */
+#define GNU_PROPERTY(type, value)	\
+  .section .note.gnu.property, "a";	\
+  .p2align 3;				\
+  .word 4;				\
+  .word 16;				\
+  .word 5;				\
+  .asciz "GNU";				\
+  .word type;				\
+  .word 4;				\
+  .word value;				\
+  .word 0;
+
+#if defined(__linux__) || defined(__FreeBSD__)
 .section .note.GNU-stack, "", %progbits
+
+/* Add GNU property note if built with branch protection.  */
+# ifdef __ARM_FEATURE_BTI_DEFAULT
+GNU_PROPERTY (FEATURE_1_AND, FEATURE_1_BTI)
+# endif
 #endif
diff --git a/libobjc/ChangeLog b/libobjc/ChangeLog
index 9003252bebd..56ed2d3323d 100644
--- a/libobjc/ChangeLog
+++ b/libobjc/ChangeLog
@@ -1,3 +1,11 @@
+2020-12-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2020-10-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* encoding.c (_darwin_rs6000_special_round_type_align):
+	Use DFMode in the emulation of the special round type.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libobjc/encoding.c b/libobjc/encoding.c
index ef34fc84707..cb8058292e8 100644
--- a/libobjc/encoding.c
+++ b/libobjc/encoding.c
@@ -146,7 +146,6 @@ static int __attribute__ ((__unused__)) not_target_flags = 0;
 #  undef TARGET_ALIGN_NATURAL
 #  define TARGET_ALIGN_NATURAL 1
 # endif
-
 /* On Darwin32, we need to recurse until we find the starting stuct type.  */
 static int 
 _darwin_rs6000_special_round_type_align (const char *struc, int comp, int spec)
@@ -163,7 +162,7 @@ _darwin_rs6000_special_round_type_align (const char *struc, int comp, int spec)
       case UNION_TYPE:
 	return MAX (MAX (comp, spec), objc_alignof_type (_stp) * __CHAR_BIT__);
 	break;
-      case E_DFmode:
+      case DFmode:
       case _C_LNG_LNG:
       case _C_ULNG_LNG:
 	return MAX (MAX (comp, spec), 64);
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 569a3c91ab2..bdb8a46ab55 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,40 @@
+2021-01-24  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-01-23  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/98806
+	* libdruntime/gcc/sections/elf_shared.d (MIPS_Any): Declare version
+	for MIPS32 and MIPS64.
+	(getDependencies): Adjust dlpi_addr on MIPS_Any.
+
+2020-10-15  Maciej W. Rozycki  <macro@linux-mips.org>
+
+	Backported from master:
+	2020-10-12  Maciej W. Rozycki  <macro@linux-mips.org>
+
+	* libdruntime/config/mips/switchcontext.S [__mips_hard_float]:
+	Use L.D and S.D generic assembly instructions rather than LDC1
+	and SDC1 MIPS II hardware instructions.
+
+2020-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90719
+	* libdruntime/core/sys/posix/sys/stat.d (Solaris): Move st_pad3 from
+	struct stat64_t to stat32_t.
+
+2020-04-27  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90718
+	* libdruntime/core/sys/posix/netdb.d (Solaris): Include _ai_pad member
+	in struct addrinfo only when targeting SPARC64.
+
+2020-04-27  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90719
+	* libdruntime/core/sys/posix/sys/stat.d (Solaris): Remove st_pad3 from
+	struct stat32_t.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libphobos/libdruntime/config/mips/switchcontext.S b/libphobos/libdruntime/config/mips/switchcontext.S
index 7604ba1ebbd..43080b06b91 100644
--- a/libphobos/libdruntime/config/mips/switchcontext.S
+++ b/libphobos/libdruntime/config/mips/switchcontext.S
@@ -47,12 +47,12 @@ fiber_switchContext:
 #ifdef __mips_hard_float
 #define ALIGN8(val) (val + (-val & 7))
 #define BELOW (ALIGN8(6 * 8 + 4))
-    sdc1 $f20, (0 * 8 - BELOW)($sp)
-    sdc1 $f22, (1 * 8 - BELOW)($sp)
-    sdc1 $f24, (2 * 8 - BELOW)($sp)
-    sdc1 $f26, (3 * 8 - BELOW)($sp)
-    sdc1 $f28, (4 * 8 - BELOW)($sp)
-    sdc1 $f30, (5 * 8 - BELOW)($sp)
+    s.d $f20, (0 * 8 - BELOW)($sp)
+    s.d $f22, (1 * 8 - BELOW)($sp)
+    s.d $f24, (2 * 8 - BELOW)($sp)
+    s.d $f26, (3 * 8 - BELOW)($sp)
+    s.d $f28, (4 * 8 - BELOW)($sp)
+    s.d $f30, (5 * 8 - BELOW)($sp)
 #endif
     sw $ra, -4($sp)
 
@@ -72,12 +72,12 @@ fiber_switchContext:
     move $sp, $a1
 
 #ifdef __mips_hard_float
-    ldc1 $f20, (0 * 8 - BELOW)($sp)
-    ldc1 $f22, (1 * 8 - BELOW)($sp)
-    ldc1 $f24, (2 * 8 - BELOW)($sp)
-    ldc1 $f26, (3 * 8 - BELOW)($sp)
-    ldc1 $f28, (4 * 8 - BELOW)($sp)
-    ldc1 $f30, (5 * 8 - BELOW)($sp)
+    l.d $f20, (0 * 8 - BELOW)($sp)
+    l.d $f22, (1 * 8 - BELOW)($sp)
+    l.d $f24, (2 * 8 - BELOW)($sp)
+    l.d $f26, (3 * 8 - BELOW)($sp)
+    l.d $f28, (4 * 8 - BELOW)($sp)
+    l.d $f30, (5 * 8 - BELOW)($sp)
 #endif
     lw $ra, -4($sp)
 
diff --git a/libphobos/libdruntime/core/sys/posix/netdb.d b/libphobos/libdruntime/core/sys/posix/netdb.d
index 327387f68ea..f1251839b16 100644
--- a/libphobos/libdruntime/core/sys/posix/netdb.d
+++ b/libphobos/libdruntime/core/sys/posix/netdb.d
@@ -743,9 +743,7 @@ else version (Solaris)
         int ai_socktype;
         int ai_protocol;
 
-        version (SPARC)
-            int _ai_pad;
-        else version (SPARC64)
+        version (SPARC64)
             int _ai_pad;
 
         socklen_t ai_addrlen;
diff --git a/libphobos/libdruntime/core/sys/posix/sys/stat.d b/libphobos/libdruntime/core/sys/posix/sys/stat.d
index 76e4460550d..f394823767d 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/stat.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/stat.d
@@ -1348,7 +1348,6 @@ else version (Solaris)
             dev_t st_rdev;
             c_long[2] st_pad2;
             off64_t st_size;
-            c_long st_pad3;
             union
             {
                 timestruc_t st_atim;
diff --git a/libphobos/libdruntime/gcc/sections/elf_shared.d b/libphobos/libdruntime/gcc/sections/elf_shared.d
index 7f9036bf505..5fac3bf360f 100644
--- a/libphobos/libdruntime/gcc/sections/elf_shared.d
+++ b/libphobos/libdruntime/gcc/sections/elf_shared.d
@@ -22,6 +22,8 @@
 
 module gcc.sections.elf_shared;
 
+version (MIPS32)  version = MIPS_Any;
+version (MIPS64)  version = MIPS_Any;
 version (RISCV32) version = RISCV_Any;
 version (RISCV64) version = RISCV_Any;
 version (S390)    version = IBMZ_Any;
@@ -763,6 +765,8 @@ version (Shared)
                     // in glibc: #define DL_RO_DYN_SECTION 1
                     version (RISCV_Any)
                         strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate
+                    else version (MIPS_Any)
+                        strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate
                     else
                         strtab = cast(const(char)*)dyn.d_un.d_ptr;
                 }
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index 07a4952bc66..21709b8cc65 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,8 @@
+2020-08-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* sanitizer_common/sanitizer_linux.cc: Cherry-pick llvm-project
+	revision f0e9b76c3500496f8f3ea7abe6f4bf801e3b41e7.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libsanitizer/sanitizer_common/sanitizer_linux.cc b/libsanitizer/sanitizer_common/sanitizer_linux.cc
index dc1e9849679..b798de7a820 100644
--- a/libsanitizer/sanitizer_common/sanitizer_linux.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_linux.cc
@@ -1938,13 +1938,13 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {
 # ifndef REG_EBP
 #  define REG_EBP  6 // REG_FP
 # endif
-# ifndef REG_ESP
-#  define REG_ESP 17 // REG_SP
+# ifndef REG_UESP
+#  define REG_UESP 17 // REG_SP
 # endif
 # endif
   *pc = ucontext->uc_mcontext.gregs[REG_EIP];
   *bp = ucontext->uc_mcontext.gregs[REG_EBP];
-  *sp = ucontext->uc_mcontext.gregs[REG_ESP];
+  *sp = ucontext->uc_mcontext.gregs[REG_UESP];
 # endif
 #elif defined(__powerpc__) || defined(__powerpc64__)
   ucontext_t *ucontext = (ucontext_t*)context;
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 45847172291..801ddd8403d 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,1007 @@
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR bootstrap/99983
+	* include/bits/hashtable.h (_Hashtable): Fix noexcept-specifier
+	on definition to match the one on the declaration.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99985
+	* include/bits/hashtable.h (_Hashtable::_S_nothrow_move()): Fix
+	to be a valid constexpr function in C++11.
+	* testsuite/23_containers/unordered_set/cons/99985.cc: New test.
+
+2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_fwd.h: Fix doxygen group command.
+	* include/bits/regex.h: Likewise.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/bits/unique_lock.h: Likewise.
+	* include/std/chrono: Likewise.
+	* include/std/thread: Likewise.
+	* include/tr1/complex: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/alloc_traits.h: Use markdown for code font.
+	* include/bits/basic_string.h: Fix @param names.
+	* include/bits/regex.h: Fix duplicate @retval names, and rename.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp: Add
+	group open to match existing group close.
+	* include/ext/pb_ds/priority_queue.hpp: Add blank line before group
+	open.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h: Fix doxygen group commands.
+	* include/bits/regex_constants.h: Likewise.
+	* include/tr1/random.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/atomic_base.h: Fix doxygen group close.
+	* include/bits/basic_ios.h: Likewise.
+	* include/bits/forward_list.h: Likewise.
+	* include/bits/fs_dir.h: Likewise.
+	* include/bits/fs_ops.h: Likewise.
+	* include/bits/fs_path.h: Likewise.
+	* include/bits/functional_hash.h: Likewise.
+	* include/bits/gslice.h: Likewise.
+	* include/bits/gslice_array.h: Likewise.
+	* include/bits/hashtable_policy.h: Likewise.
+	* include/bits/indirect_array.h: Likewise.
+	* include/bits/locale_classes.h: Likewise.
+	* include/bits/locale_facets.h: Likewise.
+	* include/bits/locale_facets_nonio.h: Likewise.
+	* include/bits/mask_array.h: Likewise.
+	* include/bits/refwrap.h: Likewise.
+	* include/bits/regex.h: Likewise.
+	* include/bits/regex_automaton.h: Likewise.
+	* include/bits/regex_compiler.h: Likewise.
+	* include/bits/regex_constants.h: Likewise.
+	* include/bits/regex_error.h: Likewise.
+	* include/bits/regex_executor.h: Likewise.
+	* include/bits/regex_scanner.h: Likewise.
+	* include/bits/shared_ptr.h: Likewise.
+	* include/bits/shared_ptr_atomic.h: Likewise.
+	* include/bits/slice_array.h: Likewise.
+	* include/bits/specfun.h: Likewise.
+	* include/bits/std_function.h: Likewise.
+	* include/bits/std_mutex.h: Likewise.
+	* include/bits/stl_deque.h: Likewise.
+	* include/bits/stl_iterator.h: Likewise.
+	* include/bits/stl_iterator_base_types.h: Likewise.
+	* include/bits/stl_map.h: Likewise.
+	* include/bits/stl_multimap.h: Likewise.
+	* include/bits/stl_multiset.h: Likewise.
+	* include/bits/stl_numeric.h: Likewise.
+	* include/bits/stl_set.h: Likewise.
+	* include/bits/stream_iterator.h: Likewise.
+	* include/bits/streambuf_iterator.h: Likewise.
+	* include/bits/unique_ptr.h: Likewise.
+	* include/bits/unordered_map.h: Likewise.
+	* include/bits/unordered_set.h: Likewise.
+	* include/decimal/decimal: Likewise.
+	* include/experimental/any: Likewise.
+	* include/experimental/array: Likewise.
+	* include/experimental/bits/fs_dir.h: Likewise.
+	* include/experimental/bits/fs_fwd.h: Likewise.
+	* include/experimental/bits/fs_ops.h: Likewise.
+	* include/experimental/bits/fs_path.h: Likewise.
+	* include/experimental/buffer: Likewise.
+	* include/experimental/internet: Likewise.
+	* include/experimental/optional: Likewise.
+	* include/experimental/propagate_const: Likewise.
+	* include/experimental/socket: Likewise.
+	* include/ext/pb_ds/assoc_container.hpp: Likewise.
+	* include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp:
+	Likewise.
+	* include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp: Likewise.
+	* include/ext/pb_ds/detail/types_traits.hpp: Likewise.
+	* include/ext/pb_ds/exception.hpp: Likewise.
+	* include/ext/pb_ds/priority_queue.hpp: Likewise.
+	* include/ext/pb_ds/tag_and_trait.hpp: Likewise.
+	* include/ext/random: Likewise.
+	* include/std/any: Likewise.
+	* include/std/atomic: Likewise.
+	* include/std/bitset: Likewise.
+	* include/std/complex: Likewise.
+	* include/std/condition_variable: Likewise.
+	* include/std/fstream: Likewise.
+	* include/std/future: Likewise.
+	* include/std/istream: Likewise.
+	* include/std/iostream: Likewise.
+	* include/std/mutex: Likewise.
+	* include/std/numeric: Likewise.
+	* include/std/ostream: Likewise.
+	* include/std/ratio: Likewise.
+	* include/std/shared_mutex: Likewise.
+	* include/std/stdexcept: Likewise.
+	* include/std/streambuf: Likewise.
+	* include/std/valarray: Likewise.
+	* include/std/variant: Likewise.
+	* include/tr1/cmath: Likewise.
+	* include/tr1/regex: Likewise.
+	* include/tr2/dynamic_bitset: Likewise.
+	* libsupc++/atomic_lockfree_defines.h: Likewise.
+	* libsupc++/exception: Likewise.
+	* libsupc++/exception.h: Likewise.
+	* libsupc++/exception_ptr.h: Likewise.
+	* libsupc++/nested_exception.h: Likewise.
+
+2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/string_view: Adjust Doxygen @file comment.
+
+2021-04-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-29  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/hashtable.h
+	(_Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a, true_type)):
+	Add noexcept qualification.
+	(_Hashtable(_Hashtable&&)): Fix noexcept qualification.
+	(_Hashtable(_Hashtable&&, const allocator_type&)): Add noexcept
+	qualification.
+	* include/bits/unordered_map.h
+	(unordered_map(unordered_map&&, const allocator_type&)): Add noexcept
+	qualification.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/bits/unordered_set.h
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_map
+	(unordered_map(unordered_map&&, const allocator_type&)): Likewise.
+	(unordered_multimap(unordered_multimap&&, const allocator_type&)):
+	Likewise.
+	* include/debug/unordered_set
+	(unordered_set(unordered_set&&, const allocator_type&)): Likewise.
+	(unordered_multiset(unordered_multiset&&, const allocator_type&)):
+	Likewise.
+	* testsuite/23_containers/unordered_map/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_map/modifiers/move_assign.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/allocator/default_init.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc:
+	New test.
+	* testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc:
+	New test.
+
+2021-04-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2020-07-08  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/96029
+	* include/bits/stl_tree.h (_Rb_tree_impl(_Rb_tree_impl&&)): Add noexcept
+	qualification based only on _Compare one.
+	* testsuite/23_containers/map/cons/noexcept_move_construct.cc: Add
+	static asserts.
+	* testsuite/23_containers/multimap/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/multiset/cons/noexcept_move_construct.cc:
+	Likewise.
+	* testsuite/23_containers/set/cons/noexcept_move_construct.cc: Likewise.
+
+2021-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/98605
+	* include/std/mutex (call_once): Use NOLINT to suppress clang
+	analyzer warnings.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/configure.xml: Correct name of option.
+	* doc/html/*: Regenerate.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-12-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (StdExpPathPrinter): Store the
+	name of the type and pass it to the iterator.
+	(StdPathPrinter): Likewise.
+	* testsuite/libstdc++-prettyprinters/filesystem-ts.cc: New test.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96083
+	* include/ext/throw_allocator.h: Use __has_builtin to check for
+	__builtin_sprintf support, and use std::sprintf if necessary.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-12-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65480
+	PR libstdc++/68735
+	* python/libstdcxx/v6/printers.py (function_pointer_to_name):
+	New helper function to get the name of a function from its
+	address.
+	(StdExpAnyPrinter.__init__): Use it.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (UniquePointerPrinter.__init__):
+	Use gdb.Type.strip_typedefs().
+	* testsuite/libstdc++-prettyprinters/compat.cc: Use a typedef in
+	the emulated old type.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2019-05-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (UniquePointerPrinter.__init__): Do
+	not assume field called _M_head_impl is the first tuple element.
+	* testsuite/libstdc++-prettyprinters/compat.cc: Make tuple
+	implementation more accurate.
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Check unique_ptr with
+	empty pointer type and non-empty deleter.
+
+2021-01-11  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2019-12-20  François Dumont  <fdumont@gcc.gnu.org>
+
+	* python/libstdcxx/v6/printers.py (lookup_node_type): Remove redundant
+	call to lookup_node_type.
+	* testsuite/libstdc++-prettyprinters/80276.cc: Define
+	_GLIBCXX_USE_CXX11_ABI to 0.
+	* testsuite/libstdc++-prettyprinters/91997.cc: Use regexp-test to check
+	'a' content.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2019-11-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91997
+	* python/libstdcxx/v6/printers.py (find_type): Fail more gracefully
+	if we run out of base classes to look at.
+	(llokup_templ_spec, lookup_node_type): New utilities to find node
+	types for node-based containers.
+	(StdListPrinter.children, NodeIteratorPrinter.__init__)
+	(NodeIteratorPrinter.to_string, StdSlistPrinter.children)
+	(StdSlistIteratorPrinter.to_string, StdRbtreeIteratorPrinter.__init__)
+	(StdMapPrinter.children, StdSetPrinter.children)
+	(StdForwardListPrinter.children): Use lookup_node_type instead of
+	find_type.
+	(StdListIteratorPrinter.__init__, StdFwdListIteratorPrinter.__init__):
+	Pass name of node type to NodeIteratorPrinter constructor.
+	(Tr1HashtableIterator.__init__): Rename argument.
+	(StdHashtableIterator.__init__): Likewise. Use lookup_templ_spec
+	instead of find_type.
+	* testsuite/libstdc++-prettyprinters/59161.cc: Remove workaround for
+	_Node typedef not being present in debuginfo.
+	* testsuite/libstdc++-prettyprinters/91997.cc: New test.
+
+2021-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/experimental/filesystem/filesystem_error/cons.cc:
+	Remove -std=gnu++17 option.
+
+2020-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/98001
+	* testsuite/ext/stdio_filebuf/char/79820.cc: Do not pass invalid
+	FILE* to constructor.
+
+2020-11-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94936
+	* src/c++17/memory_resource.cc (synchronized_pool_resource::_TPools):
+	Add comment about single-threaded behaviour.
+	(synchronized_pool_resource::_TPools::move_nonempty_chunks()): Hoist
+	class member access out of loop.
+	(synchronized_pool_resource::synchronized_pool_resource())
+	(synchronized_pool_resource::~synchronized_pool_resource())
+	(synchronized_pool_resource::release()): Check __gthread_active_p
+	before creating and/or deleting the thread-specific data key.
+	(synchronized_pool_resource::_M_thread_specific_pools()): Adjust
+	assertions.
+	(synchronized_pool_resource::do_allocate(size_t, size_t)): Add fast
+	path for single-threaded case.
+	(synchronized_pool_resource::do_deallocate(void*, size_t, size_t)):
+	Likewise. Return if unable to find a pool that owns the allocation.
+	* testsuite/20_util/synchronized_pool_resource/allocate_single.cc:
+	New test.
+	* testsuite/20_util/synchronized_pool_resource/cons_single.cc: New
+	test.
+	* testsuite/20_util/synchronized_pool_resource/release_single.cc: New
+	test.
+
+2020-11-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-11-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97798
+	* include/ext/numeric_traits.h (__glibcxx_signed)
+	(__glibcxx_digits, __glibcxx_min, __glibcxx_max): Remove
+	macros.
+	(__is_integer_nonstrict::__width): Define new constant.
+	(__numeric_traits_integer): Define constants in terms of each
+	other and __is_integer_nonstrict::__width, rather than the
+	removed macros.
+	(_GLIBCXX_INT_N_TRAITS): Macro to define explicit
+	specializations for non-standard integer types.
+
+2020-11-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2020-09-22  Patrick Palka  <ppalka@redhat.com>
+
+	* include/bits/stl_algo.h (__sample): Exit early when the
+	input range is empty.
+	* testsuite/25_algorithms/sample/3.cc: New test.
+
+2020-11-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97731
+	* src/filesystem/dir.cc (recursive_directory_iterator): Call the
+	right overload of _Dir::advance.
+	* testsuite/experimental/filesystem/iterators/97731.cc: New test.
+
+2020-10-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97132
+	* include/std/memory (assume_aligned): Do not use
+	__builtin_assume_aligned during constant evaluation.
+	* testsuite/20_util/assume_aligned/1.cc: Improve test.
+	* testsuite/20_util/assume_aligned/97132.cc: New test.
+
+2020-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-10-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h (seed_seq(initializer_list<T>)): Rename
+	parameter to use reserved name.
+	* testsuite/17_intro/names.cc: Check "il".
+
+2020-09-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97167
+	* src/c++17/fs_path.cc (path::_Parser::root_path()): Check
+	for empty string before inspecting the first character.
+	* testsuite/27_io/filesystem/path/append/source.cc: Append
+	empty string_view to path.
+
+2020-09-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96803
+	* include/std/tuple
+	(_Tuple_impl(allocator_arg_t, Alloc, const _Tuple_impl<U...>&)):
+	Use correct value category in __use_alloc call.
+	* testsuite/20_util/tuple/cons/96803.cc: Check with constructors
+	that require correct value category to be used.
+
+2020-09-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96803
+	* include/std/tuple
+	(_Tuple_impl(allocator_arg_t, Alloc, const _Tuple_impl<U...>&)):
+	Replace parameter pack with a type parameter and a pack and pass
+	the first type to __use_alloc.
+	* testsuite/20_util/tuple/cons/96803.cc: New test.
+
+2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92978
+	* include/std/numeric (__abs_integral): Replace with ...
+	(__detail::__absu): New function template that returns an
+	unsigned type, guaranteeing it can represent the most
+	negative signed value.
+	(__detail::__gcd, __detail::__lcm): Require arguments to
+	be unsigned and therefore already non-negative.
+	(gcd, lcm): Convert arguments to absolute value as unsigned
+	type before calling __detail::__gcd or __detail::__lcm.
+	* include/experimental/numeric (gcd, lcm): Likewise.
+	* testsuite/26_numerics/gcd/gcd_neg.cc: Adjust expected
+	errors.
+	* testsuite/26_numerics/lcm/lcm_neg.cc: Likewise.
+	* testsuite/26_numerics/gcd/92978.cc: New test.
+	* testsuite/26_numerics/lcm/92978.cc: New test.
+	* testsuite/experimental/numeric/92978.cc: New test.
+
+2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94681
+	* src/c++17/fs_ops.cc (read_symlink): Use posix::lstat instead
+	of calling ::lstat directly.
+	* src/filesystem/ops.cc (read_symlink): Likewise.
+
+2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94681
+	* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Do not depend on
+	$enable_libstdcxx_filesystem_ts.
+	* configure: Regenerate.
+
+2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/97101
+	* include/std/functional (bind_front): Fix order of parameters
+	in is_nothrow_constructible_v specialization.
+	* testsuite/20_util/function_objects/bind_front/97101.cc: New test.
+
+2020-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-09-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94160
+	* src/c++17/memory_resource.cc (munge_options): Round
+	max_blocks_per_chunk to a multiple of four.
+	(__pool_resource::_M_alloc_pools()): Simplify slightly.
+	* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:
+	Check that valid pointers are returned when small values are
+	used for max_blocks_per_chunk.
+
+2020-09-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94033
+	* include/std/type_traits (__is_nt_default_constructible_atom): Remove.
+	(__is_nt_default_constructible_impl): Remove.
+	(__is_nothrow_default_constructible_impl): Remove.
+	(__is_nt_constructible_impl): Add bool template parameter. Adjust
+	partial specializations.
+	(__is_nothrow_constructible_impl): Replace class template with alias
+	template.
+	(is_nothrow_default_constructible): Derive from alias template
+	__is_nothrow_constructible_impl instead of
+	__is_nothrow_default_constructible_impl.
+	* testsuite/20_util/is_nothrow_constructible/94003.cc: New test.
+	* testsuite/20_util/is_nothrow_default_constructible/96999.cc: New file.
+
+2020-09-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-04-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89510
+	* include/bits/alloc_traits.h (allocator_traits::_S_construct)
+	(allocator_traits::_S_destroy)
+	(allocator_traits<allocator<T>>::construct): Use traits in
+	noexcept-specifiers.
+	* include/bits/allocator.h (allocator<void>::construct)
+	(allocator<void>::destroy): Likewise.
+	* include/ext/malloc_allocator.h (malloc_allocator::construct)
+	(malloc_allocator::destroy): Likewise.
+	* include/ext/new_allocator.h (new_allocator::construct)
+	(new_allocator::destroy): Likewise.
+	* testsuite/20_util/allocator/89510.cc: New test.
+	* testsuite/ext/malloc_allocator/89510.cc: New test.
+	* testsuite/ext/new_allocator/89510.cc: New test.
+
+2020-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/71960
+	* include/experimental/string_view (basic_string_view):
+	Enable debug assertions.
+	* include/std/string_view (basic_string_view):
+	Likewise.
+
+2020-08-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96766
+	* include/std/variant (_Variant_storage): Replace implicit
+	conversions from size_t to __index_type with explicit casts.
+
+2020-08-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/c++config (_GLIBCXX_DEPRECATED_SUGGEST): New
+	macro for "use 'foo' instead" message in deprecated warnings.
+	* include/bits/ios_base.h (io_state, open_mode, seek_dir)
+	(streampos, streamoff): Use _GLIBCXX_DEPRECATED_SUGGEST.
+	* include/std/streambuf (stossc): Replace C++11 attribute
+	with _GLIBCXX_DEPRECATED_SUGGEST.
+	* testsuite/27_io/types/1.cc: Check for deprecated warnings.
+	Also check for io_state, open_mode and seek_dir typedefs.
+
+2020-08-11  Andrea Corallo  <andrea.corallo@arm.com>
+
+	Backported from master:
+	2020-04-02  Andrea Corallo  <andrea.corallo@arm.com>
+
+	* testsuite/experimental/net/execution_context/use_service.cc:
+	Require pthread and gthreads.
+
+2020-08-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89760
+	* testsuite/experimental/net/execution_context/make_service.cc:
+	Add dg-require-gthreads.
+	* testsuite/experimental/net/executor/1.cc: Likewise.
+	* testsuite/experimental/net/headers.cc: Likewise.
+	* testsuite/experimental/net/internet/address/v4/comparisons.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/address/v4/cons.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/address/v4/creation.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/address/v4/members.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/resolver/base.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/resolver/ops/lookup.cc:
+	Likewise.
+	* testsuite/experimental/net/internet/resolver/ops/reverse.cc:
+	Likewise.
+	* testsuite/experimental/net/timer/waitable/cons.cc: Likewise.
+	* testsuite/experimental/net/timer/waitable/dest.cc: Likewise.
+	* testsuite/experimental/net/timer/waitable/ops.cc: Likewise.
+
+2020-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95749
+	* src/filesystem/ops-common.h [_GLIBCXX_FILESYSTEM_IS_WINDOWS]
+	(stat_type): Change to __stat64.
+	(stat): Use _wstat64.
+
+2020-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-03-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93245
+	* include/experimental/bits/fs_path.h (path::generic_string<C,T,A>()):
+	Return the generic format path, not the native one.
+	* testsuite/experimental/filesystem/path/generic/generic_string.cc:
+	Improve test coverage.
+
+2020-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-03-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94242
+	* include/bits/fs_path.h (path::_S_str_convert): Replace first
+	parameter with basic_string_view so that strings with different
+	allocators can be accepted.
+	(path::generic_string<C,T,A>()): Use basic_string object that uses the
+	right allocator type.
+	* testsuite/27_io/filesystem/path/generic/94242.cc: New test.
+	* testsuite/27_io/filesystem/path/generic/generic_string.cc: Improve
+	test coverage.
+
+2020-08-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-08-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96484
+	* src/c++17/fs_ops.cc (fs::read_symlink): Return an error
+	immediately for non-symlinks.
+	* src/filesystem/ops.cc (fs::read_symlink): Likewise.
+
+2020-07-02  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backported from master:
+	2020-07-02  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR libstdc++/91807
+	* include/std/variant
+	(_Copy_assign_base::operator=(const _Copy_assign_base&):
+	Do the move-assignment from a temporary so that the temporary
+	is constructed with an explicit index.
+	* testsuite/20_util/variant/91807.cc: New.
+
+2020-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94627
+	* include/bits/regex.h (operator==, operator!=): Remove noexcept
+	equality comparisons for match_results.
+	* testsuite/28_regex/match_results/94627.cc: New test.
+
+2020-06-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2020-06-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/charconv (__from_chars_binary): Ignore leading zeros.
+	* testsuite/20_util/from_chars/1.cc: Check "0x1" for all bases,
+	not just 10 and 16.
+	* testsuite/20_util/from_chars/3.cc: New test.
+
+2020-05-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94906
+	* src/c++17/memory_resource.cc
+	(monotonic_buffer_resource::_Chunk::release): Use size_t for shift
+	operands.
+
+2020-05-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/abi/post/sparc64-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/sparc64-linux-gnu/32/baseline_symbols.txt: Likewise.
+
+2020-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/abi/post/i386-solaris2.10/baseline_symbols.txt: Regenerate.
+	* config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt:
+	Likewise.
+	* config/abi/post/i386-solaris2.11/baseline_symbols.txt: Likewise.
+	* config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt:
+	Likewise.
+	* config/abi/post/sparc-solaris2.10/baseline_symbols.txt: Likewise.
+	* config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt:
+	Likewise.
+	* config/abi/post/sparc-solaris2.11/baseline_symbols.txt: Likewise.
+	* config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt:
+	Likewise.
+
+2020-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/abi.xml (abi.versioning.history): Document library
+	versions for GCC 9.[123] and 10.1 releases.
+	* doc/html/*: Regenerate.
+
+2020-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt: Update.
+	* config/abi/post/i386-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/i486-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/aarch64-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/s390x-linux-gnu/baseline_symbols.txt: Update.
+	* config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt: Update.
+
+2020-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Use working link for SGI STL FAQ.
+	* doc/html/*: Regenerate.
+
+2020-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94203
+	* include/experimental/executor (executor::executor(Executor)): Call
+	make_shared directly instead of _M_create. Create _Tgt1 object.
+	(executor::executor(allocator_arg_t, const ProtoAlloc&, Executor)):
+	Call allocate_shared directly instead of _M_create. Create _Tgt2
+	object.
+	(executor::target_type): Add cast needed for new _Tgt interface.
+	(executor::target): Define when RTTI is disabled. Use _Tgt::_M_func.
+	(executor::_Tgt): Define the same interface whether RTTI is enabled or
+	not.
+	(executor::_Tgt::target_type, executor::_Tgt::target): Do not use
+	std::type_info in the interface.
+	(executor::_Tgt::_M_func): Add data member.
+	(executor::_TgtImpl): Replace with _Tgt1 and _Tgt2 class templates.
+	(executor::_Tgt1::_S_func): Define function to access target without
+	depending on RTTI.
+	(executor::_M_create): Remove.
+	(operator==, operator!=): Simplify comparisons for executor.
+	* include/experimental/socket (is_error_code_enum<socket_errc>):
+	Define specialization before use.
+
+	Backport from mainline
+	2020-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/executor (service_already_exists): Make default
+	constructor public (LWG 3414).
+	* testsuite/experimental/net/execution_context/make_service.cc: Check
+	the service_already_exists can be default constructed.
+
+2020-04-23  Thomas Rodgers  <rodgert@appliantology.com>
+
+	Backport from mainline
+	2020-04-23  Thomas Rodgers  <rodgert@appliantology.com>
+	* include/experimental/net/executor (system_context): Mark
+	system_context::system_context() = delete.
+	* testsuite/experimental/net/executor/1.cc: Add new
+	test to check system_context is not default constructible.
+
+2020-04-23  Thomas Rodgers  <trodgers@redhat.com>
+
+	Backport from mainline
+	2020-04-20  Thomas Rodgers  <trodgers@redhat.com>
+	* testsuite/lib/libstdc++.exp: Add additional_flags=
+	-DTBB_SUPRESS_DEPRECATED_MESSAGES=1 to suppress warnings when
+	compiling with a newer Thread Building Blocks.
+
+2020-04-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/execution (__cpp_lib_execution): Define to indicate
+	support for P0024R2 and P1001R2.
+	* include/std/version (__cpp_lib_execution): Define.
+	* testsuite/25_algorithms/pstl/feature_test.cc: Only test macro
+	defined by <algorithm>, move other tests to new tests ...
+	* testsuite/25_algorithms/pstl/feature_test-2.cc: New test.
+	* testsuite/25_algorithms/pstl/feature_test-3.cc: New test.
+	* testsuite/25_algorithms/pstl/feature_test-4.cc: New test.
+	* testsuite/25_algorithms/pstl/feature_test-5.cc: New test.
+
+	* include/bits/stl_iterator.h (__cpp_lib_array_constexpr): Update
+	value to indicate P0858R0 support.
+	* include/std/string_view (__cpp_lib_string_view): Likewise.
+	* include/std/version (__cpp_lib_array_constexpr)
+	(__cpp_lib_string_view): Likewise.
+	* testsuite/23_containers/array/element_access/constexpr_c++17.cc:
+	New test.
+	* testsuite/23_containers/array/requirements/constexpr_iter.cc: Test
+	in C++17 mode and check feature test macro.
+
+	Backport from mainline
+	2020-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ptr_traits.h (__cpp_lib_constexpr_memory): Define to
+	indicate P1006R1 support.
+	(__cpp_lib_to_address): Define to indicate P0653R2 support.
+	* include/std/memory (__cpp_lib_assume_aligned): Define to indicate
+	P1007R3 support.
+	* include/std/memory_resource (__cpp_lib_polymorphic_allocator):
+	Define to indicate P0339R6 support.
+	* include/std/string_view (__cpp_lib_starts_ends_with): Define to
+	indicate P0457R2 support.
+	* include/std/type_traits (__cpp_lib_is_nothrow_convertible): Define
+	to indicate P0758R1 support.
+	(__cpp_lib_remove_cvref): Define to indicate P0550R2 support.
+	(__cpp_lib_type_identity): Define to indicate P0887R1 support.
+	* include/std/version (__cpp_lib_is_nothrow_convertible)
+	(__cpp_lib_remove_cvref, __cpp_lib_type_identity)
+	(__cpp_lib_assume_aligned, __cpp_lib_constexpr_memory)
+	(__cpp_lib_polymorphic_allocator, __cpp_lib_starts_ends_with)
+	(__cpp_lib_to_address): Define.
+	* testsuite/20_util/to_address/1_neg.cc: Adjust dg-error line number.
+
+	* include/bits/stl_map.h (__cpp_lib_map_insertion): Add comment to
+	non-standard macro.
+	* include/bits/unordered_map.h (__cpp_lib_unordered_map_insertion):
+	Likewise.
+	* include/std/version (__cpp_lib_map_insertion)
+	(__cpp_lib_unordered_map_insertion): Likewise.
+
+	* include/std/bit (__cpp_lib_int_pow2): Define to indicate P0556R3
+	support.
+	* include/std/version (__cpp_lib_int_pow2): Likewise.
+
+	Backport from mainline
+	2019-12-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/complex (__cpp_lib_constexpr_complex): Define.
+	* include/std/version (__cpp_lib_constexpr_complex): Likewise.
+	* testsuite/26_numerics/complex/1.cc: New test.
+	* testsuite/26_numerics/complex/2.cc: New test.
+
+	Backport from mainline
+	2019-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/version [!_GLIBCXX_HOSTED]: Do not define feature test
+	macros for features that are only present in hosted builds.
+
+	Backport from mainline
+	2019-10-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/bit (__cpp_lib_bitops): Define.
+	* include/std/version (__cpp_lib_bitops): Define.
+	* testsuite/26_numerics/bit/header.cc: New test.
+	* testsuite/26_numerics/bit/header-2.cc: New test.
+
+	Backport from mainline
+	2020-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/type_traits (__cpp_lib_unwrap_ref): Define (LWG 3348).
+	* include/std/version (__cpp_lib_unwrap_ref): Likewise.
+	* testsuite/20_util/unwrap_reference/1.cc: Check macro.
+	* testsuite/20_util/unwrap_reference/3.cc: New test.
+
+2020-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/Makefile.am (xml_sources_manual): Add missing XML files.
+	* doc/Makefile.in: Regenerate.
+	* doc/xml/manual/status_cxx1998.xml: Refer to "this section" instead
+	of "this page".
+	* doc/xml/manual/status_cxx2011.xml: Formatting and other corrections
+	to the C++11 status table.
+	* doc/xml/manual/status_cxx2014.xml: Replace list of C++14 feature
+	proposals with table matching contents of the C++14 standard.
+	* doc/html/*: Regenerate.
+
+	Backport from mainline
+	2020-02-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/erase_if.h (__cpp_lib_erase_if): Define to 202002L.
+	* include/std/deque (__cpp_lib_erase_if): Likewise.
+	* include/std/forward_list (__cpp_lib_erase_if): Likewise.
+	* include/std/list (__cpp_lib_erase_if): Likewise.
+	* include/std/string (__cpp_lib_erase_if): Likewise.
+	* include/std/vector (__cpp_lib_erase_if): Likewise.
+	* include/std/version (__cpp_lib_erase_if): Likewise.
+	* testsuite/21_strings/basic_string/erasure.cc: Test for new value.
+	* testsuite/23_containers/deque/erasure.cc: Likewise.
+	* testsuite/23_containers/forward_list/erasure.cc: Likewise.
+	* testsuite/23_containers/list/erasure.cc: Likewise.
+	* testsuite/23_containers/map/erasure.cc: Likewise.
+	* testsuite/23_containers/set/erasure.cc: Likewise.
+	* testsuite/23_containers/unordered_map/erasure.cc: Likewise.
+	* testsuite/23_containers/unordered_set/erasure.cc: Likewise.
+	* testsuite/23_containers/vector/erasure.cc: Likewise.
+
+2020-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Fix name of feature test macro.
+	* doc/html/*: Regenerate.
+
+2020-04-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-04-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93960
+	* include/bits/ptr_traits.h (__to_address): Add special case for debug
+	iterators, to avoid dereferenceable check.
+	* testsuite/20_util/to_address/1_neg.cc: Adjust dg-error line number.
+	* testsuite/20_util/to_address/debug.cc: New test.
+
+2020-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94199
+	* include/experimental/executor (service_already_exists): Add default
+	constructor. Declare make_service to be a friend.
+	* testsuite/experimental/net/execution_context/make_service.cc: New
+	test.
+
+2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94063
+	* src/c++17/fs_path.cc (path::operator+=(const path&)): Add kluge to
+	handle concatenations that change the type of the first component.
+	(path::operator+=(basic_string_view<value_type>)): Likewise.
+	* testsuite/27_io/filesystem/path/concat/94063.cc: New test.
+
+	Backport from mainline
+	2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/functional (_GLIBCXX_NOT_FN_CALL_OP): Un-define after
+	use.
+
+	Backport from mainline
+	2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/tr1/8_c_compatibility/cstdlib/functions.cc: Do not pass
+	a null pointer to functions with nonnull(1) attribute.
+
+	Backport from mainline
+	2020-02-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for
+	filesystems that silently truncate timestamps.
+	* testsuite/experimental/filesystem/operations/last_write_time.cc:
+	Likewise.
+
+	Backport from mainline
+	2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93244
+	* include/bits/fs_path.h (path::generic_string<C,A>)
+	[_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Convert root-dir to forward-slash.
+	* testsuite/27_io/filesystem/path/generic/generic_string.cc: Check
+	root-dir is converted to forward slash in generic pathname.
+	* testsuite/27_io/filesystem/path/generic/utf.cc: New test.
+	* testsuite/27_io/filesystem/path/generic/wchar_t.cc: New test.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index d22e30230b3..93d86d2c363 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -4374,7 +4374,8 @@ AC_DEFUN([GLIBCXX_ENABLE_FILESYSTEM_TS], [
 ])
 
 dnl
-dnl Check whether the library calls required by the Filesystem TS are present.
+dnl Check whether the library calls required by the C++17 Filesystem library
+dnl and the Filesystem TS are present.
 dnl Defines:
 dnl  HAVE_STRUCT_DIRENT_D_TYPE
 dnl  _GLIBCXX_USE_REALPATH
@@ -4389,226 +4390,224 @@ dnl  HAVE_SYMLINK
 dnl
 AC_DEFUN([GLIBCXX_CHECK_FILESYSTEM_DEPS], [dnl
 dnl
-  if test $enable_libstdcxx_filesystem_ts = yes; then
-    AC_LANG_SAVE
-    AC_LANG_CPLUSPLUS
-    ac_save_CXXFLAGS="$CXXFLAGS"
-    CXXFLAGS="$CXXFLAGS -fno-exceptions"
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -fno-exceptions"
 dnl
-    AC_MSG_CHECKING([for struct dirent.d_type])
-    AC_CACHE_VAL(glibcxx_cv_dirent_d_type, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <dirent.h>],
-        [
-         struct dirent d;
-         if (sizeof d.d_type) return 0;
-        ],
-        [glibcxx_cv_dirent_d_type=yes],
-        [glibcxx_cv_dirent_d_type=no])
-    ])
-    if test $glibcxx_cv_dirent_d_type = yes; then
-      AC_DEFINE(HAVE_STRUCT_DIRENT_D_TYPE, 1, [Define to 1 if `d_type' is a member of `struct dirent'.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_dirent_d_type)
+  AC_MSG_CHECKING([for struct dirent.d_type])
+  AC_CACHE_VAL(glibcxx_cv_dirent_d_type, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <dirent.h>],
+      [
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
+      ],
+      [glibcxx_cv_dirent_d_type=yes],
+      [glibcxx_cv_dirent_d_type=no])
+  ])
+  if test $glibcxx_cv_dirent_d_type = yes; then
+    AC_DEFINE(HAVE_STRUCT_DIRENT_D_TYPE, 1, [Define to 1 if `d_type' is a member of `struct dirent'.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_dirent_d_type)
 dnl
-    AC_MSG_CHECKING([for realpath])
-    AC_CACHE_VAL(glibcxx_cv_realpath, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [
-         #include <limits.h>
-         #include <stdlib.h>
-         #include <unistd.h>
-        ],
-        [
-         #if _XOPEN_VERSION < 500
-         #error
-         #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
-         char *tmp = realpath((const char*)NULL, (char*)NULL);
-         #else
-         #error
-         #endif
-        ],
-        [glibcxx_cv_realpath=yes],
-        [glibcxx_cv_realpath=no])
-    ])
-    if test $glibcxx_cv_realpath = yes; then
-      AC_DEFINE(_GLIBCXX_USE_REALPATH, 1, [Define if usable realpath is available in <stdlib.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_realpath)
+  AC_MSG_CHECKING([for realpath])
+  AC_CACHE_VAL(glibcxx_cv_realpath, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+       #include <limits.h>
+       #include <stdlib.h>
+       #include <unistd.h>
+      ],
+      [
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
+      ],
+      [glibcxx_cv_realpath=yes],
+      [glibcxx_cv_realpath=no])
+  ])
+  if test $glibcxx_cv_realpath = yes; then
+    AC_DEFINE(_GLIBCXX_USE_REALPATH, 1, [Define if usable realpath is available in <stdlib.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_realpath)
 dnl
-    AC_MSG_CHECKING([for utimensat])
-    AC_CACHE_VAL(glibcxx_cv_utimensat, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [
-          #include <fcntl.h>
-          #include <sys/stat.h>
-        ],
-        [
-          struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
-          int i = utimensat(AT_FDCWD, "path", ts, 0);
-        ],
-        [glibcxx_cv_utimensat=yes],
-        [glibcxx_cv_utimensat=no])
-    ])
-    if test $glibcxx_cv_utimensat = yes; then
-      AC_DEFINE(_GLIBCXX_USE_UTIMENSAT, 1, [Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and AT_FDCWD in <fcntl.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_utimensat)
+  AC_MSG_CHECKING([for utimensat])
+  AC_CACHE_VAL(glibcxx_cv_utimensat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+	#include <fcntl.h>
+	#include <sys/stat.h>
+      ],
+      [
+	struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+	int i = utimensat(AT_FDCWD, "path", ts, 0);
+      ],
+      [glibcxx_cv_utimensat=yes],
+      [glibcxx_cv_utimensat=no])
+  ])
+  if test $glibcxx_cv_utimensat = yes; then
+    AC_DEFINE(_GLIBCXX_USE_UTIMENSAT, 1, [Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and AT_FDCWD in <fcntl.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_utimensat)
 dnl
-    AC_MSG_CHECKING([for utime])
-    AC_CACHE_VAL(glibcxx_cv_utime, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [
-          #include <utime.h>
-        ],
-        [
-          struct utimbuf t = { 1, 1 };
-          int i = utime("path", &t);
-        ],
-        [glibcxx_cv_utime=yes],
-        [glibcxx_cv_utime=no])
-    ])
-    if test $glibcxx_cv_utime = yes; then
-      AC_DEFINE(_GLIBCXX_USE_UTIME, 1, [Define if utime is available in <utime.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_utime)
+  AC_MSG_CHECKING([for utime])
+  AC_CACHE_VAL(glibcxx_cv_utime, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+	#include <utime.h>
+      ],
+      [
+	struct utimbuf t = { 1, 1 };
+	int i = utime("path", &t);
+      ],
+      [glibcxx_cv_utime=yes],
+      [glibcxx_cv_utime=no])
+  ])
+  if test $glibcxx_cv_utime = yes; then
+    AC_DEFINE(_GLIBCXX_USE_UTIME, 1, [Define if utime is available in <utime.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_utime)
 dnl
-    AC_MSG_CHECKING([for lstat])
-    AC_CACHE_VAL(glibcxx_cv_lstat, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [ #include <sys/stat.h> ],
-        [
-          struct stat st;
-          int i = lstat("path", &st);
-        ],
-        [glibcxx_cv_lstat=yes],
-        [glibcxx_cv_lstat=no])
-    ])
-    if test $glibcxx_cv_lstat = yes; then
-      AC_DEFINE(_GLIBCXX_USE_LSTAT, 1, [Define if lstat is available in <sys/stat.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_lstat)
+  AC_MSG_CHECKING([for lstat])
+  AC_CACHE_VAL(glibcxx_cv_lstat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [ #include <sys/stat.h> ],
+      [
+	struct stat st;
+	int i = lstat("path", &st);
+      ],
+      [glibcxx_cv_lstat=yes],
+      [glibcxx_cv_lstat=no])
+  ])
+  if test $glibcxx_cv_lstat = yes; then
+    AC_DEFINE(_GLIBCXX_USE_LSTAT, 1, [Define if lstat is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_lstat)
 dnl
-    AC_MSG_CHECKING([for struct stat.st_mtim.tv_nsec])
-    AC_CACHE_VAL(glibcxx_cv_st_mtim, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [ #include <sys/stat.h> ],
-        [
-          struct stat st;
-          return st.st_mtim.tv_nsec;
-        ],
-        [glibcxx_cv_st_mtim=yes],
-        [glibcxx_cv_st_mtim=no])
-    ])
-    if test $glibcxx_cv_st_mtim = yes; then
-      AC_DEFINE(_GLIBCXX_USE_ST_MTIM, 1, [Define if struct stat has timespec members.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_st_mtim)
+  AC_MSG_CHECKING([for struct stat.st_mtim.tv_nsec])
+  AC_CACHE_VAL(glibcxx_cv_st_mtim, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [ #include <sys/stat.h> ],
+      [
+	struct stat st;
+	return st.st_mtim.tv_nsec;
+      ],
+      [glibcxx_cv_st_mtim=yes],
+      [glibcxx_cv_st_mtim=no])
+  ])
+  if test $glibcxx_cv_st_mtim = yes; then
+    AC_DEFINE(_GLIBCXX_USE_ST_MTIM, 1, [Define if struct stat has timespec members.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_st_mtim)
 dnl
-    AC_MSG_CHECKING([for fchmod])
-    AC_CACHE_VAL(glibcxx_cv_fchmod, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <sys/stat.h>],
-        [fchmod(1, S_IWUSR);],
-        [glibcxx_cv_fchmod=yes],
-        [glibcxx_cv_fchmod=no])
-    ])
-    if test $glibcxx_cv_fchmod = yes; then
-      AC_DEFINE(_GLIBCXX_USE_FCHMOD, 1, [Define if fchmod is available in <sys/stat.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_fchmod)
+  AC_MSG_CHECKING([for fchmod])
+  AC_CACHE_VAL(glibcxx_cv_fchmod, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <sys/stat.h>],
+      [fchmod(1, S_IWUSR);],
+      [glibcxx_cv_fchmod=yes],
+      [glibcxx_cv_fchmod=no])
+  ])
+  if test $glibcxx_cv_fchmod = yes; then
+    AC_DEFINE(_GLIBCXX_USE_FCHMOD, 1, [Define if fchmod is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_fchmod)
 dnl
-    AC_MSG_CHECKING([for fchmodat])
-    AC_CACHE_VAL(glibcxx_cv_fchmodat, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [
-          #include <fcntl.h>
-          #include <sys/stat.h>
-        ],
-        [fchmodat(AT_FDCWD, "", 0, AT_SYMLINK_NOFOLLOW);],
-        [glibcxx_cv_fchmodat=yes],
-        [glibcxx_cv_fchmodat=no])
-    ])
-    if test $glibcxx_cv_fchmodat = yes; then
-      AC_DEFINE(_GLIBCXX_USE_FCHMODAT, 1, [Define if fchmodat is available in <sys/stat.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_fchmodat)
-dnl
-    AC_MSG_CHECKING([for sendfile that can copy files])
-    AC_CACHE_VAL(glibcxx_cv_sendfile, [dnl
-      case "${target_os}" in
-        gnu* | linux* | solaris*)
-          GCC_TRY_COMPILE_OR_LINK(
-            [#include <sys/sendfile.h>],
-            [sendfile(1, 2, (off_t*)0, sizeof 1);],
-            [glibcxx_cv_sendfile=yes],
-            [glibcxx_cv_sendfile=no])
-          ;;
-        *)
-          glibcxx_cv_sendfile=no
-          ;;
-      esac
-    ])
-    if test $glibcxx_cv_sendfile = yes; then
-      AC_DEFINE(_GLIBCXX_USE_SENDFILE, 1, [Define if sendfile is available in <sys/sendfile.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_sendfile)
+  AC_MSG_CHECKING([for fchmodat])
+  AC_CACHE_VAL(glibcxx_cv_fchmodat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+	#include <fcntl.h>
+	#include <sys/stat.h>
+      ],
+      [fchmodat(AT_FDCWD, "", 0, AT_SYMLINK_NOFOLLOW);],
+      [glibcxx_cv_fchmodat=yes],
+      [glibcxx_cv_fchmodat=no])
+  ])
+  if test $glibcxx_cv_fchmodat = yes; then
+    AC_DEFINE(_GLIBCXX_USE_FCHMODAT, 1, [Define if fchmodat is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_fchmodat)
 dnl
-    AC_MSG_CHECKING([for link])
-    AC_CACHE_VAL(glibcxx_cv_link, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <unistd.h>],
-        [link("", "");],
-        [glibcxx_cv_link=yes],
-        [glibcxx_cv_link=no])
-    ])
-    if test $glibcxx_cv_link = yes; then
-      AC_DEFINE(HAVE_LINK, 1, [Define if link is available in <unistd.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_link)
+  AC_MSG_CHECKING([for sendfile that can copy files])
+  AC_CACHE_VAL(glibcxx_cv_sendfile, [dnl
+    case "${target_os}" in
+      gnu* | linux* | solaris*)
+	GCC_TRY_COMPILE_OR_LINK(
+	  [#include <sys/sendfile.h>],
+	  [sendfile(1, 2, (off_t*)0, sizeof 1);],
+	  [glibcxx_cv_sendfile=yes],
+	  [glibcxx_cv_sendfile=no])
+	;;
+      *)
+	glibcxx_cv_sendfile=no
+	;;
+    esac
+  ])
+  if test $glibcxx_cv_sendfile = yes; then
+    AC_DEFINE(_GLIBCXX_USE_SENDFILE, 1, [Define if sendfile is available in <sys/sendfile.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_sendfile)
 dnl
-    AC_MSG_CHECKING([for readlink])
-    AC_CACHE_VAL(glibcxx_cv_readlink, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <unistd.h>],
-        [char buf[32]; readlink("", buf, sizeof(buf));],
-        [glibcxx_cv_readlink=yes],
-        [glibcxx_cv_readlink=no])
-    ])
-    if test $glibcxx_cv_readlink = yes; then
-      AC_DEFINE(HAVE_READLINK, 1, [Define if readlink is available in <unistd.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_readlink)
+  AC_MSG_CHECKING([for link])
+  AC_CACHE_VAL(glibcxx_cv_link, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <unistd.h>],
+      [link("", "");],
+      [glibcxx_cv_link=yes],
+      [glibcxx_cv_link=no])
+  ])
+  if test $glibcxx_cv_link = yes; then
+    AC_DEFINE(HAVE_LINK, 1, [Define if link is available in <unistd.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_link)
 dnl
-    AC_MSG_CHECKING([for symlink])
-    AC_CACHE_VAL(glibcxx_cv_symlink, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <unistd.h>],
-        [symlink("", "");],
-        [glibcxx_cv_symlink=yes],
-        [glibcxx_cv_symlink=no])
-    ])
-    if test $glibcxx_cv_symlink = yes; then
-      AC_DEFINE(HAVE_SYMLINK, 1, [Define if symlink is available in <unistd.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_symlink)
+  AC_MSG_CHECKING([for readlink])
+  AC_CACHE_VAL(glibcxx_cv_readlink, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <unistd.h>],
+      [char buf[32]; readlink("", buf, sizeof(buf));],
+      [glibcxx_cv_readlink=yes],
+      [glibcxx_cv_readlink=no])
+  ])
+  if test $glibcxx_cv_readlink = yes; then
+    AC_DEFINE(HAVE_READLINK, 1, [Define if readlink is available in <unistd.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_readlink)
 dnl
-    AC_MSG_CHECKING([for truncate])
-    AC_CACHE_VAL(glibcxx_cv_truncate, [dnl
-      GCC_TRY_COMPILE_OR_LINK(
-        [#include <unistd.h>],
-        [truncate("", 99);],
-        [glibcxx_cv_truncate=yes],
-        [glibcxx_cv_truncate=no])
-    ])
-    if test $glibcxx_cv_truncate = yes; then
-      AC_DEFINE(HAVE_TRUNCATE, 1, [Define if truncate is available in <unistd.h>.])
-    fi
-    AC_MSG_RESULT($glibcxx_cv_truncate)
+  AC_MSG_CHECKING([for symlink])
+  AC_CACHE_VAL(glibcxx_cv_symlink, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <unistd.h>],
+      [symlink("", "");],
+      [glibcxx_cv_symlink=yes],
+      [glibcxx_cv_symlink=no])
+  ])
+  if test $glibcxx_cv_symlink = yes; then
+    AC_DEFINE(HAVE_SYMLINK, 1, [Define if symlink is available in <unistd.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_symlink)
 dnl
-    CXXFLAGS="$ac_save_CXXFLAGS"
-    AC_LANG_RESTORE
+  AC_MSG_CHECKING([for truncate])
+  AC_CACHE_VAL(glibcxx_cv_truncate, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <unistd.h>],
+      [truncate("", 99);],
+      [glibcxx_cv_truncate=yes],
+      [glibcxx_cv_truncate=no])
+  ])
+  if test $glibcxx_cv_truncate = yes; then
+    AC_DEFINE(HAVE_TRUNCATE, 1, [Define if truncate is available in <unistd.h>.])
   fi
+  AC_MSG_RESULT($glibcxx_cv_truncate)
+dnl
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  AC_LANG_RESTORE
 ])
 
 dnl
diff --git a/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
index 53c87f115e0..089537d5ddf 100644
--- a/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/aarch64-linux-gnu/baseline_symbols.txt
@@ -2062,16 +2062,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3001,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4408,6 +4418,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4492,6 +4503,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4921,6 +4933,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5053,6 +5066,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5206,6 +5220,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5619,6 +5634,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
index e488ada5c72..f9eca6c7b0e 100644
--- a/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-linux-gnu/baseline_symbols.txt
@@ -2062,16 +2062,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3001,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4409,6 +4419,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4435,6 +4446,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5062,6 +5074,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5070,6 +5083,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5177,6 +5192,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5754,6 +5770,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
index dc1a34fa9f5..52d4a38a024 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.10/amd64/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4457,6 +4463,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4884,6 +4891,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5016,6 +5024,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5160,6 +5169,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5587,6 +5597,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
index c097965d4b2..ae23c0d8d6e 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.10/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4399,6 +4405,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5023,6 +5030,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5031,6 +5039,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5126,6 +5136,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5714,6 +5725,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
index 2a8f88bac7b..2aa9e2639ab 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.11/amd64/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4459,6 +4465,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4886,6 +4893,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5018,6 +5026,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5162,6 +5171,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5589,6 +5599,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
index 85796b3689b..3500f8a76ca 100644
--- a/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i386-solaris2.11/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4401,6 +4407,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5025,6 +5032,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5033,6 +5041,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5128,6 +5138,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5716,6 +5727,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
index e488ada5c72..f9eca6c7b0e 100644
--- a/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/i486-linux-gnu/baseline_symbols.txt
@@ -2062,16 +2062,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3001,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4409,6 +4419,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4435,6 +4446,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5062,6 +5074,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5070,6 +5083,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5177,6 +5192,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5754,6 +5770,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
index 65ee06d5c2a..58c11a5972b 100644
--- a/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/powerpc64-linux-gnu/baseline_symbols.txt
@@ -2208,16 +2208,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3191,12 +3195,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4642,6 +4652,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4734,6 +4745,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -5185,6 +5197,7 @@ OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIcSt19istreambuf_iteratorIcSt11cha
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5317,6 +5330,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5473,6 +5487,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5901,6 +5916,8 @@ OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_getIcSt19istreambuf_iteratorIcSt11cha
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
index 65ee06d5c2a..58c11a5972b 100644
--- a/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/s390x-linux-gnu/baseline_symbols.txt
@@ -2208,16 +2208,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3191,12 +3195,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4642,6 +4652,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4734,6 +4745,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -5185,6 +5197,7 @@ OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIcSt19istreambuf_iteratorIcSt11cha
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:24:_ZTINSt17__gnu_cxx_ldbl1289money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5317,6 +5330,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5473,6 +5487,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5901,6 +5916,8 @@ OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_getIcSt19istreambuf_iteratorIcSt11cha
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEE@@GLIBCXX_LDBL_3.4
 OBJECT:56:_ZTVNSt17__gnu_cxx_ldbl1289money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEE@@GLIBCXX_LDBL_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
index b4b39e3fbae..1c3b84cd9fc 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.10/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4398,6 +4404,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5020,6 +5027,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5028,6 +5036,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5122,6 +5132,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5708,6 +5719,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
index 769d83c53bb..965ee3d8e27 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.10/sparcv9/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4456,6 +4462,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4882,6 +4889,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5014,6 +5022,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5155,6 +5164,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5580,6 +5590,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
index ceb8f02d402..d1ea64e17ab 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.11/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4400,6 +4406,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5022,6 +5029,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5030,6 +5038,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5124,6 +5134,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5710,6 +5721,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
index b8a89bb1ef4..7596acb3013 100644
--- a/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc-solaris2.11/sparcv9/baseline_symbols.txt
@@ -2968,12 +2968,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4458,6 +4464,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4884,6 +4891,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5016,6 +5024,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5157,6 +5166,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5582,6 +5592,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/config/abi/post/sparc64-linux-gnu/32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc64-linux-gnu/32/baseline_symbols.txt
index 31c73b03659..77c65db856f 100644
--- a/libstdc++-v3/config/abi/post/sparc64-linux-gnu/32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc64-linux-gnu/32/baseline_symbols.txt
@@ -338,7 +338,9 @@ FUNC:_ZNKSt10filesystem16filesystem_error4whatEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem16filesystem_error5path1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem16filesystem_error5path2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem18directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem28recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem28recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem4path11parent_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem4path12has_filenameEv@@GLIBCXX_3.4.26
@@ -364,7 +366,9 @@ FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error4whatEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1118directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx114path11parent_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx114path12has_filenameEv@@GLIBCXX_3.4.26
@@ -982,6 +986,13 @@ FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES4_bRSt8ios_basewe@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb0EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE6do_outERS0_PKDiS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE9do_lengthERS0_PKDuS4_j@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -989,6 +1000,13 @@ FUNC:_ZNKSt7codecvtIDic11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE5do_inERS0_PKcS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE6do_outERS0_PKDiS4_RS4_PcS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE9do_lengthERS0_PKcS4_j@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDsS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE6do_outERS0_PKDsS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE9do_lengthERS0_PKDuS4_j@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -1790,6 +1808,7 @@ FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorppEv@@GLIBCXX_3.4.26
@@ -1801,6 +1820,7 @@ FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
@@ -1809,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1852,9 +1873,11 @@ FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIc
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD0Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
@@ -1863,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2038,13 +2062,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -2973,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -3720,9 +3758,15 @@ FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEC2Ej@
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED2Ev@@GLIBCXX_3.4.21
@@ -4343,6 +4387,7 @@ OBJECT:0:CXXABI_1.3
 OBJECT:0:CXXABI_1.3.1
 OBJECT:0:CXXABI_1.3.10
 OBJECT:0:CXXABI_1.3.11
+OBJECT:0:CXXABI_1.3.12
 OBJECT:0:CXXABI_1.3.2
 OBJECT:0:CXXABI_1.3.3
 OBJECT:0:CXXABI_1.3.4
@@ -4372,6 +4417,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4398,6 +4445,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -4498,7 +4546,9 @@ OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt5ctypeIwE@@GLIBCXX_3.4
+OBJECT:12:_ZTISt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTISt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:12:_ZTISt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTISt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:12:_ZTISt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:12:_ZTISt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -4558,12 +4608,14 @@ OBJECT:16:_ZTIPDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIPDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIPDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIPDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIPDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIPKDd@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDe@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIPKDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIPKDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIPKDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIPKDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIPKa@@CXXABI_1.3
 OBJECT:16:_ZTIPKb@@CXXABI_1.3
 OBJECT:16:_ZTIPKc@@CXXABI_1.3
@@ -4697,6 +4749,19 @@ OBJECT:1:_ZNSt14numeric_limitsIDsE8is_exactE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_iec559E@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_moduloE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_signedE@@GLIBCXX_3.4.11
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_boundedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_integerE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE12has_infinityE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE13has_quiet_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE14is_specializedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15has_denorm_lossE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15tinyness_beforeE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE17has_signaling_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE5trapsE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE8is_exactE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_iec559E@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_moduloE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_signedE@@GLIBCXX_3.4.26
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_boundedE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_integerE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE12has_infinityE@@GLIBCXX_3.4
@@ -5006,6 +5071,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5014,6 +5080,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5070,6 +5138,8 @@ OBJECT:2:_ZTSv@@CXXABI_1.3
 OBJECT:2:_ZTSw@@CXXABI_1.3
 OBJECT:2:_ZTSx@@CXXABI_1.3
 OBJECT:2:_ZTSy@@CXXABI_1.3
+OBJECT:30:_ZTSSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
+OBJECT:30:_ZTSSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIcLb0EEE@@GLIBCXX_3.4.21
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIcLb1EEE@@GLIBCXX_3.4.21
 OBJECT:32:_ZTINSt7__cxx1110moneypunctIwLb0EEE@@GLIBCXX_3.4.21
@@ -5118,6 +5188,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5224,7 +5295,9 @@ OBJECT:44:_ZTVSt23__codecvt_abstract_baseIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
+OBJECT:44:_ZTVSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:44:_ZTVSt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:44:_ZTVSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:44:_ZTVSt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:44:_ZTVSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:44:_ZTVSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -5276,6 +5349,15 @@ OBJECT:4:_ZNSt14numeric_limitsIDsE14min_exponent10E@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE5radixE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE6digitsE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE8digits10E@@GLIBCXX_3.4.11
+OBJECT:4:_ZNSt14numeric_limitsIDuE10has_denormE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE11round_styleE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12max_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12min_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14max_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14min_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE5radixE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE6digitsE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE8digits10E@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt14numeric_limitsIaE10has_denormE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE11round_styleE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE12max_digits10E@@GLIBCXX_3.4.14
@@ -5475,7 +5557,9 @@ OBJECT:4:_ZNSt7__cxx119money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2
 OBJECT:4:_ZNSt7__cxx119money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7__cxx119money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
+OBJECT:4:_ZNSt7codecvtIDiDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt7codecvtIDic11__mbstate_tE2idE@@GLIBCXX_3.4.21
+OBJECT:4:_ZNSt7codecvtIDsDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt7codecvtIDsc11__mbstate_tE2idE@@GLIBCXX_3.4.21
 OBJECT:4:_ZNSt7codecvtIcc11__mbstate_tE2idE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt7codecvtIwc11__mbstate_tE2idE@@GLIBCXX_3.4
@@ -5674,11 +5758,13 @@ OBJECT:8:_ZTIDf@@CXXABI_1.3.4
 OBJECT:8:_ZTIDi@@CXXABI_1.3.3
 OBJECT:8:_ZTIDn@@CXXABI_1.3.5
 OBJECT:8:_ZTIDs@@CXXABI_1.3.3
+OBJECT:8:_ZTIDu@@CXXABI_1.3.12
 OBJECT:8:_ZTIN10__cxxabiv115__forced_unwindE@@CXXABI_1.3.2
 OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -5714,3 +5800,5 @@ OBJECT:8:_ZTTSi@@GLIBCXX_3.4
 OBJECT:8:_ZTTSo@@GLIBCXX_3.4
 OBJECT:8:_ZTTSt13basic_istreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:8:_ZTTSt13basic_ostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+TLS:4:_ZSt11__once_call@@GLIBCXX_3.4.11
+TLS:4:_ZSt15__once_callable@@GLIBCXX_3.4.11
diff --git a/libstdc++-v3/config/abi/post/sparc64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/sparc64-linux-gnu/baseline_symbols.txt
index d56b39c9337..f0bdad20607 100644
--- a/libstdc++-v3/config/abi/post/sparc64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/sparc64-linux-gnu/baseline_symbols.txt
@@ -338,7 +338,9 @@ FUNC:_ZNKSt10filesystem16filesystem_error4whatEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem16filesystem_error5path1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem16filesystem_error5path2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem18directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem28recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem28recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem28recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem4path11parent_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem4path12has_filenameEv@@GLIBCXX_3.4.26
@@ -364,7 +366,9 @@ FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error4whatEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1116filesystem_error5path2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1118directory_iteratordeEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator17recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator5depthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iterator7optionsEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx1128recursive_directory_iteratordeEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx114path11parent_pathEv@@GLIBCXX_3.4.26
 FUNC:_ZNKSt10filesystem7__cxx114path12has_filenameEv@@GLIBCXX_3.4.26
@@ -982,6 +986,13 @@ FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES4_bRSt8ios_basewe@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb0EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES4_S4_RSt8ios_basewRKNS_12basic_stringIwS3_SaIwEEE@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE6do_outERS0_PKDiS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDiDu11__mbstate_tE9do_lengthERS0_PKDuS4_m@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -989,6 +1000,13 @@ FUNC:_ZNKSt7codecvtIDic11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE5do_inERS0_PKcS4_RS4_PDiS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE6do_outERS0_PKDiS4_RS4_PcS6_RS6_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDic11__mbstate_tE9do_lengthERS0_PKcS4_m@@GLIBCXX_3.4.21
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE10do_unshiftERS0_PDuS3_RS3_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE16do_always_noconvEv@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE5do_inERS0_PKDuS4_RS4_PDsS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE6do_outERS0_PKDsS4_RS4_PDuS6_RS6_@@GLIBCXX_3.4.26
+FUNC:_ZNKSt7codecvtIDsDu11__mbstate_tE9do_lengthERS0_PKDuS4_m@@GLIBCXX_3.4.26
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE10do_unshiftERS0_PcS3_RS3_@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE11do_encodingEv@@GLIBCXX_3.4.21
 FUNC:_ZNKSt7codecvtIDsc11__mbstate_tE13do_max_lengthEv@@GLIBCXX_3.4.21
@@ -1790,6 +1808,7 @@ FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_4pathERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18create_directoriesERKNS_7__cxx114pathERSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem18directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorC1ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorC2ERKNS_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem18directory_iteratorppEv@@GLIBCXX_3.4.26
@@ -1801,6 +1820,7 @@ FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_4pathES2_RSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem24create_directory_symlinkERKNS_7__cxx114pathES3_RSt10error_code@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
@@ -1809,6 +1829,7 @@ FUNC:_ZNSt10filesystem28recursive_directory_iteratorC2ERKNS_4pathENS_17directory
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSEOS0_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem28recursive_directory_iteratoraSERKS0_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem28recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsE@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem4copyERKNS_4pathES2_NS_12copy_optionsERSt10error_code@@GLIBCXX_3.4.26
@@ -1852,9 +1873,11 @@ FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorC2ERKNSt7__cxx1112basic_stringIc
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD0Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1116filesystem_errorD2Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1118directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC1ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorC2ERKNS0_4pathENS_17directory_optionsEPSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1118directory_iteratorppEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator25disable_recursion_pendingEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popERSt10error_code@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator3popEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iterator9incrementERSt10error_code@@GLIBCXX_3.4.26
@@ -1863,6 +1886,7 @@ FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorC2ERKNS0_4pathENS_17
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD1Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorD2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSEOS1_@@GLIBCXX_3.4.26
+FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratoraSERKS1_@@GLIBCXX_3.4.27
 FUNC:_ZNSt10filesystem7__cxx1128recursive_directory_iteratorppEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_M_split_cmptsEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt10filesystem7__cxx114path14_S_convert_locEPKcS3_RKSt6locale@@GLIBCXX_3.4.26
@@ -2038,13 +2062,21 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
 FUNC:_ZNSt12bad_weak_ptrD1Ev@@GLIBCXX_3.4.15
@@ -2973,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -3720,9 +3758,15 @@ FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEEC2Em@
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDiDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDic11__mbstate_tED2Ev@@GLIBCXX_3.4.21
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED0Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt7codecvtIDsDu11__mbstate_tED2Ev@@GLIBCXX_3.4.26
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED0Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt7codecvtIDsc11__mbstate_tED2Ev@@GLIBCXX_3.4.21
@@ -4343,6 +4387,7 @@ OBJECT:0:CXXABI_1.3
 OBJECT:0:CXXABI_1.3.1
 OBJECT:0:CXXABI_1.3.10
 OBJECT:0:CXXABI_1.3.11
+OBJECT:0:CXXABI_1.3.12
 OBJECT:0:CXXABI_1.3.2
 OBJECT:0:CXXABI_1.3.3
 OBJECT:0:CXXABI_1.3.4
@@ -4372,6 +4417,8 @@ OBJECT:0:GLIBCXX_3.4.23
 OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
+OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4450,11 +4497,13 @@ OBJECT:16:_ZTIDf@@CXXABI_1.3.4
 OBJECT:16:_ZTIDi@@CXXABI_1.3.3
 OBJECT:16:_ZTIDn@@CXXABI_1.3.5
 OBJECT:16:_ZTIDs@@CXXABI_1.3.3
+OBJECT:16:_ZTIDu@@CXXABI_1.3.12
 OBJECT:16:_ZTIN10__cxxabiv115__forced_unwindE@@CXXABI_1.3.2
 OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4570,6 +4619,19 @@ OBJECT:1:_ZNSt14numeric_limitsIDsE8is_exactE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_iec559E@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_moduloE@@GLIBCXX_3.4.11
 OBJECT:1:_ZNSt14numeric_limitsIDsE9is_signedE@@GLIBCXX_3.4.11
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_boundedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE10is_integerE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE12has_infinityE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE13has_quiet_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE14is_specializedE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15has_denorm_lossE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE15tinyness_beforeE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE17has_signaling_NaNE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE5trapsE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE8is_exactE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_iec559E@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_moduloE@@GLIBCXX_3.4.26
+OBJECT:1:_ZNSt14numeric_limitsIDuE9is_signedE@@GLIBCXX_3.4.26
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_boundedE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE10is_integerE@@GLIBCXX_3.4
 OBJECT:1:_ZNSt14numeric_limitsIaE12has_infinityE@@GLIBCXX_3.4
@@ -4871,6 +4933,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -4971,7 +5034,9 @@ OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt5ctypeIwE@@GLIBCXX_3.4
+OBJECT:24:_ZTISt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTISt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:24:_ZTISt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTISt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:24:_ZTISt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:24:_ZTISt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -5001,6 +5066,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5057,6 +5123,8 @@ OBJECT:2:_ZTSv@@CXXABI_1.3
 OBJECT:2:_ZTSw@@CXXABI_1.3
 OBJECT:2:_ZTSx@@CXXABI_1.3
 OBJECT:2:_ZTSy@@CXXABI_1.3
+OBJECT:30:_ZTSSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
+OBJECT:30:_ZTSSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:32:_ZNSbIwSt11char_traitsIwESaIwEE4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
 OBJECT:32:_ZNSs4_Rep20_S_empty_rep_storageE@@GLIBCXX_3.4
 OBJECT:32:_ZTIPDd@@CXXABI_1.3.4
@@ -5065,12 +5133,14 @@ OBJECT:32:_ZTIPDf@@CXXABI_1.3.4
 OBJECT:32:_ZTIPDi@@CXXABI_1.3.3
 OBJECT:32:_ZTIPDn@@CXXABI_1.3.5
 OBJECT:32:_ZTIPDs@@CXXABI_1.3.3
+OBJECT:32:_ZTIPDu@@CXXABI_1.3.12
 OBJECT:32:_ZTIPKDd@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDe@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDf@@CXXABI_1.3.4
 OBJECT:32:_ZTIPKDi@@CXXABI_1.3.3
 OBJECT:32:_ZTIPKDn@@CXXABI_1.3.5
 OBJECT:32:_ZTIPKDs@@CXXABI_1.3.3
+OBJECT:32:_ZTIPKDu@@CXXABI_1.3.12
 OBJECT:32:_ZTIPKa@@CXXABI_1.3
 OBJECT:32:_ZTIPKb@@CXXABI_1.3
 OBJECT:32:_ZTIPKc@@CXXABI_1.3
@@ -5150,6 +5220,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5273,6 +5344,15 @@ OBJECT:4:_ZNSt14numeric_limitsIDsE14min_exponent10E@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE5radixE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE6digitsE@@GLIBCXX_3.4.11
 OBJECT:4:_ZNSt14numeric_limitsIDsE8digits10E@@GLIBCXX_3.4.11
+OBJECT:4:_ZNSt14numeric_limitsIDuE10has_denormE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE11round_styleE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12max_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE12min_exponentE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14max_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE14min_exponent10E@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE5radixE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE6digitsE@@GLIBCXX_3.4.26
+OBJECT:4:_ZNSt14numeric_limitsIDuE8digits10E@@GLIBCXX_3.4.26
 OBJECT:4:_ZNSt14numeric_limitsIaE10has_denormE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE11round_styleE@@GLIBCXX_3.4
 OBJECT:4:_ZNSt14numeric_limitsIaE12max_digits10E@@GLIBCXX_3.4.14
@@ -5554,6 +5634,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5667,7 +5749,9 @@ OBJECT:88:_ZTVSt23__codecvt_abstract_baseIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt25__codecvt_utf8_utf16_baseIwE@@GLIBCXX_3.4.21
+OBJECT:88:_ZTVSt7codecvtIDiDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:88:_ZTVSt7codecvtIDic11__mbstate_tE@@GLIBCXX_3.4.21
+OBJECT:88:_ZTVSt7codecvtIDsDu11__mbstate_tE@@GLIBCXX_3.4.26
 OBJECT:88:_ZTVSt7codecvtIDsc11__mbstate_tE@@GLIBCXX_3.4.21
 OBJECT:88:_ZTVSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:88:_ZTVSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
@@ -5745,7 +5829,9 @@ OBJECT:8:_ZNSt7__cxx119money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2
 OBJECT:8:_ZNSt7__cxx119money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7__cxx119money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7__cxx119money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE@@GLIBCXX_3.4.21
+OBJECT:8:_ZNSt7codecvtIDiDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:8:_ZNSt7codecvtIDic11__mbstate_tE2idE@@GLIBCXX_3.4.21
+OBJECT:8:_ZNSt7codecvtIDsDu11__mbstate_tE2idE@@GLIBCXX_3.4.26
 OBJECT:8:_ZNSt7codecvtIDsc11__mbstate_tE2idE@@GLIBCXX_3.4.21
 OBJECT:8:_ZNSt7codecvtIcc11__mbstate_tE2idE@@GLIBCXX_3.4
 OBJECT:8:_ZNSt7codecvtIwc11__mbstate_tE2idE@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
index e488ada5c72..f9eca6c7b0e 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
@@ -2062,16 +2062,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3001,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvjj@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4409,6 +4419,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4435,6 +4446,7 @@ OBJECT:12:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:12:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:12:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:12:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:12:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5062,6 +5074,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:27:_ZTSSt19__codecvt_utf8_baseIwE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDiE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTSSt19__codecvt_utf8_baseIDsE@@GLIBCXX_3.4.21
@@ -5070,6 +5083,8 @@ OBJECT:28:_ZTSSt7codecvtIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTSSt7codecvtIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:28:_ZTTSd@@GLIBCXX_3.4
 OBJECT:28:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:28:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:28:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:28:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
@@ -5177,6 +5192,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTVN10__cxxabiv117__pbase_type_infoE@@CXXABI_1.3
@@ -5754,6 +5770,7 @@ OBJECT:8:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:8:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:8:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:8:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:8:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:8:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:8:_ZTISt10ctype_base@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
index a403f4b660a..ab2e0951c31 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
@@ -2062,16 +2062,20 @@ FUNC:_ZNSt12__basic_fileIcED1Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__basic_fileIcED2Ev@@GLIBCXX_3.4
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem28recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS4_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem4_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS4_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1EOS6_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2EOS6_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx1128recursive_directory_iterator10_Dir_stackELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1EOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC1Ev@@GLIBCXX_3.4.26
+FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2EOS5_@@GLIBCXX_3.4.28
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEC2Ev@@GLIBCXX_3.4.27
 FUNC:_ZNSt12__shared_ptrINSt10filesystem7__cxx114_DirELN9__gnu_cxx12_Lock_policyE2EEaSEOS5_@@GLIBCXX_3.4.26
 FUNC:_ZNSt12bad_weak_ptrD0Ev@@GLIBCXX_3.4.15
@@ -3001,12 +3005,18 @@ FUNC:_ZNSt3_V214error_categoryD1Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V214error_categoryD2Ev@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V215system_categoryEv@@GLIBCXX_3.4.21
 FUNC:_ZNSt3_V216generic_categoryEv@@GLIBCXX_3.4.21
+FUNC:_ZNSt3pmr15memory_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr15memory_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr19new_delete_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20get_default_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20null_memory_resourceEv@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv@@GLIBCXX_3.4.26
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD0Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD1Ev@@GLIBCXX_3.4.28
+FUNC:_ZNSt3pmr25monotonic_buffer_resourceD2Ev@@GLIBCXX_3.4.28
 FUNC:_ZNSt3pmr26synchronized_pool_resource11do_allocateEmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource13do_deallocateEPvmm@@GLIBCXX_3.4.26
 FUNC:_ZNSt3pmr26synchronized_pool_resource7releaseEv@@GLIBCXX_3.4.26
@@ -4409,6 +4419,7 @@ OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.25
 OBJECT:0:GLIBCXX_3.4.26
 OBJECT:0:GLIBCXX_3.4.27
+OBJECT:0:GLIBCXX_3.4.28
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
@@ -4493,6 +4504,7 @@ OBJECT:16:_ZTIN10__cxxabiv119__foreign_exceptionE@@CXXABI_1.3.2
 OBJECT:16:_ZTINSt13__future_base11_State_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt13__future_base12_Result_baseE@@GLIBCXX_3.4.15
 OBJECT:16:_ZTINSt3_V214error_categoryE@@GLIBCXX_3.4.21
+OBJECT:16:_ZTINSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:16:_ZTINSt6locale5facetE@@GLIBCXX_3.4
 OBJECT:16:_ZTINSt6thread6_StateE@@GLIBCXX_3.4.22
 OBJECT:16:_ZTISt10ctype_base@@GLIBCXX_3.4
@@ -4923,6 +4935,7 @@ OBJECT:24:_ZTIN9__gnu_cxx18stdio_sync_filebufIwSt11char_traitsIwEEE@@GLIBCXX_3.4
 OBJECT:24:_ZTINSt10filesystem16filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt10filesystem7__cxx1116filesystem_errorE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt13__future_base19_Async_state_commonE@@GLIBCXX_3.4.17
+OBJECT:24:_ZTINSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:24:_ZTINSt3pmr26synchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt3pmr28unsynchronized_pool_resourceE@@GLIBCXX_3.4.26
 OBJECT:24:_ZTINSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
@@ -5055,6 +5068,7 @@ OBJECT:25:_ZTSNSt7__cxx118messagesIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIcEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSNSt7__cxx118numpunctIwEE@@GLIBCXX_3.4.21
 OBJECT:25:_ZTSSt20bad_array_new_length@@CXXABI_1.3.8
+OBJECT:26:_ZTSNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
 OBJECT:272:_ZSt4cerr@@GLIBCXX_3.4
 OBJECT:272:_ZSt4clog@@GLIBCXX_3.4
 OBJECT:272:_ZSt4cout@@GLIBCXX_3.4
@@ -5211,6 +5225,7 @@ OBJECT:34:_ZTSSt25__codecvt_utf8_utf16_baseIDsE@@GLIBCXX_3.4.21
 OBJECT:34:_ZTSSt9basic_iosIcSt11char_traitsIcEE@@GLIBCXX_3.4
 OBJECT:34:_ZTSSt9basic_iosIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:36:_ZTSN10__cxxabiv119__pointer_type_infoE@@CXXABI_1.3
+OBJECT:36:_ZTSNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:36:_ZTSSt14codecvt_bynameIcc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:36:_ZTSSt14codecvt_bynameIwc11__mbstate_tE@@GLIBCXX_3.4
 OBJECT:37:_ZTSN10__cxxabiv120__function_type_infoE@@CXXABI_1.3
@@ -5626,6 +5641,8 @@ OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIcSt11char_traitsIcESaIcEEE@@GLIBCXX_3
 OBJECT:56:_ZTSNSt7__cxx1115basic_stringbufIwSt11char_traitsIwESaIwEEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTTSd@@GLIBCXX_3.4
 OBJECT:56:_ZTTSt14basic_iostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+OBJECT:56:_ZTVNSt3pmr15memory_resourceE@@GLIBCXX_3.4.28
+OBJECT:56:_ZTVNSt3pmr25monotonic_buffer_resourceE@@GLIBCXX_3.4.28
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIcEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1114collate_bynameIwEE@@GLIBCXX_3.4.21
 OBJECT:56:_ZTVNSt7__cxx1115messages_bynameIcEE@@GLIBCXX_3.4.21
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 1225edc596b..86db10fbe75 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -80612,22 +80612,21 @@ $as_echo_n "checking whether to build Filesystem TS support... " >&6; }
 $as_echo "$enable_libstdcxx_filesystem_ts" >&6; }
 
 
-  if test $enable_libstdcxx_filesystem_ts = yes; then
 
-    ac_ext=cpp
+  ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-    ac_save_CXXFLAGS="$CXXFLAGS"
-    CXXFLAGS="$CXXFLAGS -fno-exceptions"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct dirent.d_type" >&5
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -fno-exceptions"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct dirent.d_type" >&5
 $as_echo_n "checking for struct dirent.d_type... " >&6; }
-    if ${glibcxx_cv_dirent_d_type+:} false; then :
+  if ${glibcxx_cv_dirent_d_type+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <dirent.h>
@@ -80635,8 +80634,8 @@ int
 main ()
 {
 
-         struct dirent d;
-         if (sizeof d.d_type) return 0;
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
 
   ;
   return 0;
@@ -80659,8 +80658,8 @@ int
 main ()
 {
 
-         struct dirent d;
-         if (sizeof d.d_type) return 0;
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
 
   ;
   return 0;
@@ -80677,37 +80676,37 @@ fi
 
 fi
 
-    if test $glibcxx_cv_dirent_d_type = yes; then
+  if test $glibcxx_cv_dirent_d_type = yes; then
 
 $as_echo "#define HAVE_STRUCT_DIRENT_D_TYPE 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirent_d_type" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirent_d_type" >&5
 $as_echo "$glibcxx_cv_dirent_d_type" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for realpath" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for realpath" >&5
 $as_echo_n "checking for realpath... " >&6; }
-    if ${glibcxx_cv_realpath+:} false; then :
+  if ${glibcxx_cv_realpath+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-         #include <limits.h>
-         #include <stdlib.h>
-         #include <unistd.h>
+       #include <limits.h>
+       #include <stdlib.h>
+       #include <unistd.h>
 
 int
 main ()
 {
 
-         #if _XOPEN_VERSION < 500
-         #error
-         #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
-         char *tmp = realpath((const char*)NULL, (char*)NULL);
-         #else
-         #error
-         #endif
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
 
   ;
   return 0;
@@ -80726,21 +80725,21 @@ fi
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-         #include <limits.h>
-         #include <stdlib.h>
-         #include <unistd.h>
+       #include <limits.h>
+       #include <stdlib.h>
+       #include <unistd.h>
 
 int
 main ()
 {
 
-         #if _XOPEN_VERSION < 500
-         #error
-         #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
-         char *tmp = realpath((const char*)NULL, (char*)NULL);
-         #else
-         #error
-         #endif
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
 
   ;
   return 0;
@@ -80757,31 +80756,31 @@ fi
 
 fi
 
-    if test $glibcxx_cv_realpath = yes; then
+  if test $glibcxx_cv_realpath = yes; then
 
 $as_echo "#define _GLIBCXX_USE_REALPATH 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_realpath" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_realpath" >&5
 $as_echo "$glibcxx_cv_realpath" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utimensat" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utimensat" >&5
 $as_echo_n "checking for utimensat... " >&6; }
-    if ${glibcxx_cv_utimensat+:} false; then :
+  if ${glibcxx_cv_utimensat+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <fcntl.h>
-          #include <sys/stat.h>
+	#include <fcntl.h>
+	#include <sys/stat.h>
 
 int
 main ()
 {
 
-          struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
-          int i = utimensat(AT_FDCWD, "path", ts, 0);
+	struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+	int i = utimensat(AT_FDCWD, "path", ts, 0);
 
   ;
   return 0;
@@ -80800,15 +80799,15 @@ fi
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <fcntl.h>
-          #include <sys/stat.h>
+	#include <fcntl.h>
+	#include <sys/stat.h>
 
 int
 main ()
 {
 
-          struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
-          int i = utimensat(AT_FDCWD, "path", ts, 0);
+	struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+	int i = utimensat(AT_FDCWD, "path", ts, 0);
 
   ;
   return 0;
@@ -80825,30 +80824,30 @@ fi
 
 fi
 
-    if test $glibcxx_cv_utimensat = yes; then
+  if test $glibcxx_cv_utimensat = yes; then
 
 $as_echo "#define _GLIBCXX_USE_UTIMENSAT 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utimensat" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utimensat" >&5
 $as_echo "$glibcxx_cv_utimensat" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utime" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utime" >&5
 $as_echo_n "checking for utime... " >&6; }
-    if ${glibcxx_cv_utime+:} false; then :
+  if ${glibcxx_cv_utime+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <utime.h>
+	#include <utime.h>
 
 int
 main ()
 {
 
-          struct utimbuf t = { 1, 1 };
-          int i = utime("path", &t);
+	struct utimbuf t = { 1, 1 };
+	int i = utime("path", &t);
 
   ;
   return 0;
@@ -80867,14 +80866,14 @@ fi
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <utime.h>
+	#include <utime.h>
 
 int
 main ()
 {
 
-          struct utimbuf t = { 1, 1 };
-          int i = utime("path", &t);
+	struct utimbuf t = { 1, 1 };
+	int i = utime("path", &t);
 
   ;
   return 0;
@@ -80891,19 +80890,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_utime = yes; then
+  if test $glibcxx_cv_utime = yes; then
 
 $as_echo "#define _GLIBCXX_USE_UTIME 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utime" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utime" >&5
 $as_echo "$glibcxx_cv_utime" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for lstat" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for lstat" >&5
 $as_echo_n "checking for lstat... " >&6; }
-    if ${glibcxx_cv_lstat+:} false; then :
+  if ${glibcxx_cv_lstat+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
  #include <sys/stat.h>
@@ -80911,8 +80910,8 @@ int
 main ()
 {
 
-          struct stat st;
-          int i = lstat("path", &st);
+	struct stat st;
+	int i = lstat("path", &st);
 
   ;
   return 0;
@@ -80935,8 +80934,8 @@ int
 main ()
 {
 
-          struct stat st;
-          int i = lstat("path", &st);
+	struct stat st;
+	int i = lstat("path", &st);
 
   ;
   return 0;
@@ -80953,19 +80952,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_lstat = yes; then
+  if test $glibcxx_cv_lstat = yes; then
 
 $as_echo "#define _GLIBCXX_USE_LSTAT 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_lstat" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_lstat" >&5
 $as_echo "$glibcxx_cv_lstat" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct stat.st_mtim.tv_nsec" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct stat.st_mtim.tv_nsec" >&5
 $as_echo_n "checking for struct stat.st_mtim.tv_nsec... " >&6; }
-    if ${glibcxx_cv_st_mtim+:} false; then :
+  if ${glibcxx_cv_st_mtim+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
  #include <sys/stat.h>
@@ -80973,8 +80972,8 @@ int
 main ()
 {
 
-          struct stat st;
-          return st.st_mtim.tv_nsec;
+	struct stat st;
+	return st.st_mtim.tv_nsec;
 
   ;
   return 0;
@@ -80997,8 +80996,8 @@ int
 main ()
 {
 
-          struct stat st;
-          return st.st_mtim.tv_nsec;
+	struct stat st;
+	return st.st_mtim.tv_nsec;
 
   ;
   return 0;
@@ -81015,19 +81014,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_st_mtim = yes; then
+  if test $glibcxx_cv_st_mtim = yes; then
 
 $as_echo "#define _GLIBCXX_USE_ST_MTIM 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_st_mtim" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_st_mtim" >&5
 $as_echo "$glibcxx_cv_st_mtim" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmod" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmod" >&5
 $as_echo_n "checking for fchmod... " >&6; }
-    if ${glibcxx_cv_fchmod+:} false; then :
+  if ${glibcxx_cv_fchmod+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/stat.h>
@@ -81071,24 +81070,24 @@ fi
 
 fi
 
-    if test $glibcxx_cv_fchmod = yes; then
+  if test $glibcxx_cv_fchmod = yes; then
 
 $as_echo "#define _GLIBCXX_USE_FCHMOD 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmod" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmod" >&5
 $as_echo "$glibcxx_cv_fchmod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmodat" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmodat" >&5
 $as_echo_n "checking for fchmodat... " >&6; }
-    if ${glibcxx_cv_fchmodat+:} false; then :
+  if ${glibcxx_cv_fchmodat+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <fcntl.h>
-          #include <sys/stat.h>
+	#include <fcntl.h>
+	#include <sys/stat.h>
 
 int
 main ()
@@ -81111,8 +81110,8 @@ fi
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-          #include <fcntl.h>
-          #include <sys/stat.h>
+	#include <fcntl.h>
+	#include <sys/stat.h>
 
 int
 main ()
@@ -81133,21 +81132,21 @@ fi
 
 fi
 
-    if test $glibcxx_cv_fchmodat = yes; then
+  if test $glibcxx_cv_fchmodat = yes; then
 
 $as_echo "#define _GLIBCXX_USE_FCHMODAT 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmodat" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmodat" >&5
 $as_echo "$glibcxx_cv_fchmodat" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sendfile that can copy files" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sendfile that can copy files" >&5
 $as_echo_n "checking for sendfile that can copy files... " >&6; }
-    if ${glibcxx_cv_sendfile+:} false; then :
+  if ${glibcxx_cv_sendfile+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        case "${target_os}" in
-        gnu* | linux* | solaris*)
-          if test x$gcc_no_link = xyes; then
+      case "${target_os}" in
+      gnu* | linux* | solaris*)
+	if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/sendfile.h>
@@ -81188,27 +81187,27 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 fi
-          ;;
-        *)
-          glibcxx_cv_sendfile=no
-          ;;
-      esac
+	;;
+      *)
+	glibcxx_cv_sendfile=no
+	;;
+    esac
 
 fi
 
-    if test $glibcxx_cv_sendfile = yes; then
+  if test $glibcxx_cv_sendfile = yes; then
 
 $as_echo "#define _GLIBCXX_USE_SENDFILE 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_sendfile" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_sendfile" >&5
 $as_echo "$glibcxx_cv_sendfile" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for link" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for link" >&5
 $as_echo_n "checking for link... " >&6; }
-    if ${glibcxx_cv_link+:} false; then :
+  if ${glibcxx_cv_link+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <unistd.h>
@@ -81252,19 +81251,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_link = yes; then
+  if test $glibcxx_cv_link = yes; then
 
 $as_echo "#define HAVE_LINK 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_link" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_link" >&5
 $as_echo "$glibcxx_cv_link" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for readlink" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for readlink" >&5
 $as_echo_n "checking for readlink... " >&6; }
-    if ${glibcxx_cv_readlink+:} false; then :
+  if ${glibcxx_cv_readlink+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <unistd.h>
@@ -81308,19 +81307,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_readlink = yes; then
+  if test $glibcxx_cv_readlink = yes; then
 
 $as_echo "#define HAVE_READLINK 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_readlink" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_readlink" >&5
 $as_echo "$glibcxx_cv_readlink" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for symlink" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for symlink" >&5
 $as_echo_n "checking for symlink... " >&6; }
-    if ${glibcxx_cv_symlink+:} false; then :
+  if ${glibcxx_cv_symlink+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <unistd.h>
@@ -81364,19 +81363,19 @@ fi
 
 fi
 
-    if test $glibcxx_cv_symlink = yes; then
+  if test $glibcxx_cv_symlink = yes; then
 
 $as_echo "#define HAVE_SYMLINK 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_symlink" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_symlink" >&5
 $as_echo "$glibcxx_cv_symlink" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for truncate" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for truncate" >&5
 $as_echo_n "checking for truncate... " >&6; }
-    if ${glibcxx_cv_truncate+:} false; then :
+  if ${glibcxx_cv_truncate+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-        if test x$gcc_no_link = xyes; then
+      if test x$gcc_no_link = xyes; then
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <unistd.h>
@@ -81420,21 +81419,20 @@ fi
 
 fi
 
-    if test $glibcxx_cv_truncate = yes; then
+  if test $glibcxx_cv_truncate = yes; then
 
 $as_echo "#define HAVE_TRUNCATE 1" >>confdefs.h
 
-    fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_truncate" >&5
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_truncate" >&5
 $as_echo "$glibcxx_cv_truncate" >&6; }
-    CXXFLAGS="$ac_save_CXXFLAGS"
-    ac_ext=c
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-  fi
 
 
 # For Networking TS.
diff --git a/libstdc++-v3/doc/Makefile.am b/libstdc++-v3/doc/Makefile.am
index 4427e5da6ad..bd88bdaa8c5 100644
--- a/libstdc++-v3/doc/Makefile.am
+++ b/libstdc++-v3/doc/Makefile.am
@@ -342,6 +342,8 @@ xml_sources_manual = \
 	${xml_dir}/manual/status_cxx1998.xml \
 	${xml_dir}/manual/status_cxx2011.xml \
 	${xml_dir}/manual/status_cxx2014.xml \
+	${xml_dir}/manual/status_cxx2017.xml \
+	${xml_dir}/manual/status_cxx2020.xml \
 	${xml_dir}/manual/status_cxxtr1.xml \
 	${xml_dir}/manual/status_cxxtr24733.xml \
 	${xml_dir}/manual/strings.xml \
diff --git a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
index 1058d5c3cc8..9bde1026804 100644
--- a/libstdc++-v3/doc/Makefile.in
+++ b/libstdc++-v3/doc/Makefile.in
@@ -483,6 +483,8 @@ xml_sources_manual = \
 	${xml_dir}/manual/status_cxx1998.xml \
 	${xml_dir}/manual/status_cxx2011.xml \
 	${xml_dir}/manual/status_cxx2014.xml \
+	${xml_dir}/manual/status_cxx2017.xml \
+	${xml_dir}/manual/status_cxx2020.xml \
 	${xml_dir}/manual/status_cxxtr1.xml \
 	${xml_dir}/manual/status_cxxtr24733.xml \
 	${xml_dir}/manual/strings.xml \
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
index ac99835acf2..18407225d7a 100644
--- a/libstdc++-v3/doc/html/faq.html
+++ b/libstdc++-v3/doc/html/faq.html
@@ -194,7 +194,7 @@
     information is available on the homepage (including how to browse
     the list archives); to send a message to the list,
     use <code class="email">&lt;<a class="email" href="mailto:libstdc++@gcc.gnu.org">libstdc++@gcc.gnu.org</a>&gt;</code>.
-    </p><p> 
+    </p><p>
     If you have a question that you think should be included
     here, or if you have a question <span class="emphasis"><em>about</em></span> a question/answer
     here, please send email to the libstdc++ mailing list, as above.
@@ -246,8 +246,8 @@
     development tools. It may be necessary to install extra
     development packages to get the headers, or the documentation, or
     the source: please consult your vendor for details.
-    </p><p> 
-    To build and install from the GNU GCC sources, please consult the 
+    </p><p>
+    To build and install from the GNU GCC sources, please consult the
     <a class="link" href="manual/setup.html" title="Chapter 2. Setup">setup
     documentation</a> for detailed
     instructions. You may wish to browse those files ahead
@@ -268,7 +268,7 @@
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-how_to_test"></a></td><td align="left" valign="top"><p>
     Libstdc++ comes with its own validation testsuite, which includes
     conformance testing, regression testing, ABI testing, and
-    performance testing. Please consult the 
+    performance testing. Please consult the
     <a class="link" href="http://gcc.gnu.org/install/test.html" target="_top">testing
     documentation</a> for GCC and
     <a class="link" href="manual/test.html" title="Testing">Testing</a> in the libstdc++
@@ -424,12 +424,12 @@
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-solaris_long_long"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
     By default we try to support the C99 <span class="type">long long</span> type.
     This requires that certain functions from your C library be present.
-    </p><p> 
+    </p><p>
     Up through release 3.0.2 the platform-specific tests performed by
     libstdc++ were too general, resulting in a conservative approach
     to enabling the <span class="type">long long</span> code paths. The most
     commonly reported platform affected was Solaris.
-    </p><p> 
+    </p><p>
     This has been fixed for libstdc++ releases greater than 3.0.3.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.predefined"></a><a id="q-predefined"></a><p><strong>4.3.</strong></p></td><td align="left" valign="top"><p>
       <code class="constant">_XOPEN_SOURCE</code> and <code class="constant">_GNU_SOURCE</code> are always defined?
@@ -484,7 +484,7 @@
     and later.  A patch went in just after the 3.3 release to
     make mips* use the generic implementation instead.  You can also
     configure for mipsel-elf as a workaround.
-    </p><p>    
+    </p><p>
     The mips*-*-linux* port continues to use the MIPS II routines, and more
     work in this area is expected.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.linux_glibc"></a><a id="q-linux_glibc"></a><p><strong>4.7.</strong></p></td><td align="left" valign="top"><p>
@@ -510,7 +510,7 @@
     enable <span class="type">wchar_t</span> and C++ library structures
     like <code class="classname">wstring</code> were present. This impacted Solaris,
     Darwin, and BSD variants, and is fixed in libstdc++ versions post 4.1.0.
-    </p><p> 
+    </p><p>
     </p></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>5.1. <a href="faq.html#faq.what_works">
       What works already?
     </a></dt><dt>5.2. <a href="faq.html#faq.standard_bugs">
@@ -526,8 +526,8 @@
     platforms. Also dependent on the underlying platform is support
     for <span class="type">wchar_t</span> and <span class="type">long long</span> specializations,
     and details of thread support.
-    </p><p>    
-    Long answer: See the implementation status pages for 
+    </p><p>
+    Long answer: See the implementation status pages for
     <a class="link" href="manual/status.html#status.iso.1998" title="C++ 1998/2003">C++98</a>,
     <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>,
     <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>,
@@ -536,7 +536,7 @@
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.standard_bugs"></a><a id="q-standard_bugs"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>
       Bugs in the ISO C++ language or library specification
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-standard_bugs"></a></td><td align="left" valign="top"><p>
-    Unfortunately, there are some. 
+    Unfortunately, there are some.
     </p><p>
     For those people who are not part of the ISO Library Group
     (i.e., nearly all of us needing to read this page in the first
@@ -560,7 +560,7 @@
     or an older version of the GNU compilers. Third, you can find more
     information on the libstdc++ and the GCC mailing lists: search
     these lists with terms describing your issue.
-    </p><p> 
+    </p><p>
     Before reporting a bug, please examine the
     <a class="link" href="https://gcc.gnu.org/bugs/" target="_top">bugs database</a>, with the
     component set to <span class="quote">“<span class="quote">c++</span>”</span>.
@@ -813,7 +813,7 @@
     and <a class="link" href="manual/backwards.html" title="Backwards Compatibility">backwards
     compatibility</a> documentation.
     </p><p>
-    The <a class="link" href="https://web.archive.org/web/20171225062613/http://www.sgi.com/tech/stl/FAQ.html" target="_top">FAQ</a>
+    The <a class="link" href="https://web.archive.org/web/20171104092813/http://www.sgi.com/tech/stl/FAQ.html" target="_top">FAQ</a>
     for SGI's STL is still recommended reading.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.extensions_and_backwards_compat"></a><a id="q-extensions_and_backwards_compat"></a><p><strong>7.4.</strong></p></td><td align="left" valign="top"><p>
       Extensions and Backward Compatibility
diff --git a/libstdc++-v3/doc/html/manual/abi.html b/libstdc++-v3/doc/html/manual/abi.html
index 96383c33112..8ed8de64b32 100644
--- a/libstdc++-v3/doc/html/manual/abi.html
+++ b/libstdc++-v3/doc/html/manual/abi.html
@@ -110,7 +110,7 @@ compatible.
 	has the same filename and <code class="constant">DT_SONAME</code> as the
 	preceding release.
       </p><p>It is versioned as follows:
-    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: libstdc++.so.3.0.0</p></li><li class="listitem"><p>GCC 3.0.1: libstdc++.so.3.0.1</p></li><li class="listitem"><p>GCC 3.0.2: libstdc++.so.3.0.2</p></li><li class="listitem"><p>GCC 3.0.3: libstdc++.so.3.0.2 (See Note 1)</p></li><li class="listitem"><p>GCC 3.0.4: libstdc++.so.3.0.4</p></li><li class="listitem"><p>GCC 3.1.0: libstdc++.so.4.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.1.1: libstdc++.so.4.0.1</p></li><li class="listitem"><p>GCC 3.2.0: libstdc++.so.5.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.2.1: libstdc++.so.5.0.1</p></li><li class="listitem"><p>GCC 3.2.2: libstdc++.so.5.0.2</p></li><li class="listitem"><p>GCC 3.2.3: libstdc++.so.5.0.3 (See Note 2)</p></li><li class="listitem"><p>GCC 3.3.0: libstdc++.so.5.0.4</p></li><li class="listitem"><p>GCC 3.3.1: libstdc++.so.5.0.5</p></li><li class="listitem"><p>GCC 3.4.0: libstdc++.so.6.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.4.1: libstdc++.so.6.0.1</p></li><li class="listitem"><p>GCC 3.4.2: libstdc++.so.6.0.2</p></li><li class="listitem"><p>GCC 3.4.3: libstdc++.so.6.0.3</p></li><li class="listitem"><p>GCC 4.0.0: libstdc++.so.6.0.4</p></li><li class="listitem"><p>GCC 4.0.1: libstdc++.so.6.0.5</p></li><li class="listitem"><p>GCC 4.0.2: libstdc++.so.6.0.6</p></li><li class="listitem"><p>GCC 4.0.3: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.0: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.1: libstdc++.so.6.0.8</p></li><li class="listitem"><p>GCC 4.2.0: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.2.1: libstdc++.so.6.0.9 (See Note 3)</p></li><li class="listitem"><p>GCC 4.2.2: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.3.0: libstdc++.so.6.0.10</p></li><li class="listitem"><p>GCC 4.4.0: libstdc++.so.6.0.11</p></li><li class="listitem"><p>GCC 4.4.1: libstdc++.so.6.0.12</p></li><li class="listitem"><p>GCC 4.4.2: libstdc++.so.6.0.13</p></li><li class="listitem"><p>GCC 4.5.0: libstdc++.so.6.0.14</p></li><li class="listitem"><p>GCC 4.6.0: libstdc++.so.6.0.15</p></li><li class="listitem"><p>GCC 4.6.1: libstdc++.so.6.0.16</p></li><li class="listitem"><p>GCC 4.7.0: libstdc++.so.6.0.17</p></li><li class="listitem"><p>GCC 4.8.0: libstdc++.so.6.0.18</p></li><li class="listitem"><p>GCC 4.8.3: libstdc++.so.6.0.19</p></li><li class="listitem"><p>GCC 4.9.0: libstdc++.so.6.0.20</p></li><li class="listitem"><p>GCC 5.1.0: libstdc++.so.6.0.21</p></li><li class="listitem"><p>GCC 6.1.0: libstdc++.so.6.0.22</p></li><li class="listitem"><p>GCC 7.1.0: libstdc++.so.6.0.23</p></li><li class="listitem"><p>GCC 7.2.0: libstdc++.so.6.0.24</p></li><li class="listitem"><p>GCC 8.0.0: libstdc++.so.6.0.25</p></li><li class="listitem"><p>GCC 9.1.0: libstdc++.so.6.0.26</p></li><li class="listitem"><p>GCC 9.2.0: libstdc++.so.6.0.27</p></li><li class="listitem"><p>GCC 9.3.0: libstdc++.so.6.0.28</p></li></ul></div><p>
+    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: libstdc++.so.3.0.0</p></li><li class="listitem"><p>GCC 3.0.1: libstdc++.so.3.0.1</p></li><li class="listitem"><p>GCC 3.0.2: libstdc++.so.3.0.2</p></li><li class="listitem"><p>GCC 3.0.3: libstdc++.so.3.0.2 (See Note 1)</p></li><li class="listitem"><p>GCC 3.0.4: libstdc++.so.3.0.4</p></li><li class="listitem"><p>GCC 3.1.0: libstdc++.so.4.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.1.1: libstdc++.so.4.0.1</p></li><li class="listitem"><p>GCC 3.2.0: libstdc++.so.5.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.2.1: libstdc++.so.5.0.1</p></li><li class="listitem"><p>GCC 3.2.2: libstdc++.so.5.0.2</p></li><li class="listitem"><p>GCC 3.2.3: libstdc++.so.5.0.3 (See Note 2)</p></li><li class="listitem"><p>GCC 3.3.0: libstdc++.so.5.0.4</p></li><li class="listitem"><p>GCC 3.3.1: libstdc++.so.5.0.5</p></li><li class="listitem"><p>GCC 3.4.0: libstdc++.so.6.0.0 <span class="emphasis"><em>(Incompatible with previous)</em></span></p></li><li class="listitem"><p>GCC 3.4.1: libstdc++.so.6.0.1</p></li><li class="listitem"><p>GCC 3.4.2: libstdc++.so.6.0.2</p></li><li class="listitem"><p>GCC 3.4.3: libstdc++.so.6.0.3</p></li><li class="listitem"><p>GCC 4.0.0: libstdc++.so.6.0.4</p></li><li class="listitem"><p>GCC 4.0.1: libstdc++.so.6.0.5</p></li><li class="listitem"><p>GCC 4.0.2: libstdc++.so.6.0.6</p></li><li class="listitem"><p>GCC 4.0.3: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.0: libstdc++.so.6.0.7</p></li><li class="listitem"><p>GCC 4.1.1: libstdc++.so.6.0.8</p></li><li class="listitem"><p>GCC 4.2.0: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.2.1: libstdc++.so.6.0.9 (See Note 3)</p></li><li class="listitem"><p>GCC 4.2.2: libstdc++.so.6.0.9</p></li><li class="listitem"><p>GCC 4.3.0: libstdc++.so.6.0.10</p></li><li class="listitem"><p>GCC 4.4.0: libstdc++.so.6.0.11</p></li><li class="listitem"><p>GCC 4.4.1: libstdc++.so.6.0.12</p></li><li class="listitem"><p>GCC 4.4.2: libstdc++.so.6.0.13</p></li><li class="listitem"><p>GCC 4.5.0: libstdc++.so.6.0.14</p></li><li class="listitem"><p>GCC 4.6.0: libstdc++.so.6.0.15</p></li><li class="listitem"><p>GCC 4.6.1: libstdc++.so.6.0.16</p></li><li class="listitem"><p>GCC 4.7.0: libstdc++.so.6.0.17</p></li><li class="listitem"><p>GCC 4.8.0: libstdc++.so.6.0.18</p></li><li class="listitem"><p>GCC 4.8.3: libstdc++.so.6.0.19</p></li><li class="listitem"><p>GCC 4.9.0: libstdc++.so.6.0.20</p></li><li class="listitem"><p>GCC 5.1.0: libstdc++.so.6.0.21</p></li><li class="listitem"><p>GCC 6.1.0: libstdc++.so.6.0.22</p></li><li class="listitem"><p>GCC 7.1.0: libstdc++.so.6.0.23</p></li><li class="listitem"><p>GCC 7.2.0: libstdc++.so.6.0.24</p></li><li class="listitem"><p>GCC 8.1.0: libstdc++.so.6.0.25</p></li><li class="listitem"><p>GCC 9.1.0: libstdc++.so.6.0.26</p></li><li class="listitem"><p>GCC 9.2.0: libstdc++.so.6.0.27</p></li><li class="listitem"><p>GCC 9.3.0: libstdc++.so.6.0.28</p></li><li class="listitem"><p>GCC 10.1.0: libstdc++.so.6.0.28</p></li></ul></div><p>
       Note 1: Error should be libstdc++.so.3.0.3.
     </p><p>
       Note 2: Not strictly required.
@@ -128,7 +128,7 @@ compatible.
    GLIBCPP_3.2 for symbols that were introduced in the GCC 3.2.0
    release.) If a particular release is not listed, it has the same
    version labels as the preceding release.
-   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.1: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.2: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.3: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.4: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.1.0: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.1.1: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.2.0: GLIBCPP_3.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.1: GLIBCPP_3.2.1, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.2: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.3: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.3.0: GLIBCPP_3.2.2, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.1: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.2: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.3: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.4.0: GLIBCXX_3.4, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.1: GLIBCXX_3.4.1, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.2: GLIBCXX_3.4.2</p></li><li class="listitem"><p>GCC 3.4.3: GLIBCXX_3.4.3</p></li><li class="listitem"><p>GCC 4.0.0: GLIBCXX_3.4.4, CXXABI_1.3.1</p></li><li class="listitem"><p>GCC 4.0.1: GLIBCXX_3.4.5</p></li><li class="listitem"><p>GCC 4.0.2: GLIBCXX_3.4.6</p></li><li class="listitem"><p>GCC 4.0.3: GLIBCXX_3.4.7</p></li><li class="listitem"><p>GCC 4.1.1: GLIBCXX_3.4.8</p></li><li class="listitem"><p>GCC 4.2.0: GLIBCXX_3.4.9</p></li><li class="listitem"><p>GCC 4.3.0: GLIBCXX_3.4.10, CXXABI_1.3.2</p></li><li class="listitem"><p>GCC 4.4.0: GLIBCXX_3.4.11, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.1: GLIBCXX_3.4.12, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.2: GLIBCXX_3.4.13, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.5.0: GLIBCXX_3.4.14, CXXABI_1.3.4</p></li><li class="listitem"><p>GCC 4.6.0: GLIBCXX_3.4.15, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.6.1: GLIBCXX_3.4.16, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.7.0: GLIBCXX_3.4.17, CXXABI_1.3.6</p></li><li class="listitem"><p>GCC 4.8.0: GLIBCXX_3.4.18, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.8.3: GLIBCXX_3.4.19, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.9.0: GLIBCXX_3.4.20, CXXABI_1.3.8</p></li><li class="listitem"><p>GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9</p></li><li class="listitem"><p>GCC 6.1.0: GLIBCXX_3.4.22, CXXABI_1.3.10</p></li><li class="listitem"><p>GCC 7.1.0: GLIBCXX_3.4.23, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 7.2.0: GLIBCXX_3.4.24, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 8.0.0: GLIBCXX_3.4.25, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 9.0.0: GLIBCXX_3.4.26, CXXABI_1.3.11</p></li></ul></div></li><li class="listitem"><p>Incremental bumping of a compiler pre-defined macro,
+   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.1: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.2: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.3: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.4: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.1.0: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.1.1: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.2.0: GLIBCPP_3.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.1: GLIBCPP_3.2.1, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.2: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.3: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.3.0: GLIBCPP_3.2.2, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.1: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.2: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.3: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.4.0: GLIBCXX_3.4, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.1: GLIBCXX_3.4.1, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.2: GLIBCXX_3.4.2</p></li><li class="listitem"><p>GCC 3.4.3: GLIBCXX_3.4.3</p></li><li class="listitem"><p>GCC 4.0.0: GLIBCXX_3.4.4, CXXABI_1.3.1</p></li><li class="listitem"><p>GCC 4.0.1: GLIBCXX_3.4.5</p></li><li class="listitem"><p>GCC 4.0.2: GLIBCXX_3.4.6</p></li><li class="listitem"><p>GCC 4.0.3: GLIBCXX_3.4.7</p></li><li class="listitem"><p>GCC 4.1.1: GLIBCXX_3.4.8</p></li><li class="listitem"><p>GCC 4.2.0: GLIBCXX_3.4.9</p></li><li class="listitem"><p>GCC 4.3.0: GLIBCXX_3.4.10, CXXABI_1.3.2</p></li><li class="listitem"><p>GCC 4.4.0: GLIBCXX_3.4.11, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.1: GLIBCXX_3.4.12, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.2: GLIBCXX_3.4.13, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.5.0: GLIBCXX_3.4.14, CXXABI_1.3.4</p></li><li class="listitem"><p>GCC 4.6.0: GLIBCXX_3.4.15, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.6.1: GLIBCXX_3.4.16, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.7.0: GLIBCXX_3.4.17, CXXABI_1.3.6</p></li><li class="listitem"><p>GCC 4.8.0: GLIBCXX_3.4.18, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.8.3: GLIBCXX_3.4.19, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.9.0: GLIBCXX_3.4.20, CXXABI_1.3.8</p></li><li class="listitem"><p>GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9</p></li><li class="listitem"><p>GCC 6.1.0: GLIBCXX_3.4.22, CXXABI_1.3.10</p></li><li class="listitem"><p>GCC 7.1.0: GLIBCXX_3.4.23, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 7.2.0: GLIBCXX_3.4.24, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 8.1.0: GLIBCXX_3.4.25, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 9.1.0: GLIBCXX_3.4.26, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.2.0: GLIBCXX_3.4.27, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.3.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 10.1.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li></ul></div></li><li class="listitem"><p>Incremental bumping of a compiler pre-defined macro,
     __GXX_ABI_VERSION. This macro is defined as the version of the
     compiler v3 ABI, with g++ 3.0 being version 100. This macro will
     be automatically defined whenever g++ is used (the curious can
diff --git a/libstdc++-v3/doc/html/manual/configure.html b/libstdc++-v3/doc/html/manual/configure.html
index e3321d52ebc..001c793047c 100644
--- a/libstdc++-v3/doc/html/manual/configure.html
+++ b/libstdc++-v3/doc/html/manual/configure.html
@@ -110,7 +110,8 @@
 	the build directory, will do much the same thing, without the
 	configuration difference and without building everything twice:
 	<code class="code">make CXXFLAGS='-g3 -O0 -fno-inline' all</code>
-     </p></dd><dt><span class="term"><code class="code">--enable-libstdcxx-debug-flags=FLAGS</code></span></dt><dd><p>This option is only valid when <code class="code"> --enable-debug </code>
+     </p></dd><dt><span class="term"><code class="code">--enable-libstdcxx-debug-flags=FLAGS</code></span></dt><dd><p>This option is only valid when
+	<code class="code">--enable-libstdcxx-debug</code>
 	is also specified, and applies to the debug builds only. With
 	this option, you can pass a specific string of flags to the
 	compiler to use when building the debug versions of libstdc++.
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index 440b8671e0c..26793d9fa83 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -5,7 +5,7 @@
 </th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 202a</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2020.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
 This status table is based on the table of contents of ISO/IEC 14882:2003.
 </p><p>
-This page describes the C++ support in the GCC 9 series.
+This section describes the C++ support in the GCC 9 series.
 </p><div class="table"><a id="table.cxx98_status"></a><p class="title"><strong>Table 1.1. C++ 1998/2003 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 1998/2003 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>18</em></span>
       </td><td colspan="3" align="left">
@@ -154,29 +154,29 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This page describes the C++11 support in the GCC 9 series.
+This status table is based on the table of contents of ISO/IEC 14882:2011.
+</p><p>
+This section describes the C++11 support in the GCC 9 series.
 </p><div class="table"><a id="table.cxx11_status"></a><p class="title"><strong>Table 1.2. C++ 2011 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>18</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Language support</em></span>
-      </td></tr><tr><td align="left">18.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.2</td><td align="left">Types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3</td><td align="left">Implementation properties</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2</td><td align="left">Numeric Limits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2.3</td><td align="left">Class template <code class="code">numeric_limits</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.2.4</td><td align="left"><code class="code">numeric_limits</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.5</td><td align="left"><code class="code">float_round_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.6</td><td align="left"><code class="code">float_denorm_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr><td align="left">18.3.2.7</td><td align="left"><code class="code">numeric_limits</code> specializations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.3</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.4</td><td align="left">Integer types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.4.1</td><td align="left">Header <code class="code">&lt;cstdint&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">18.5</td><td align="left">Start and termination</td><td align="left">Partial</td><td align="left">C library dependency for quick_exit, at_quick_exit</td></tr><tr><td align="left">18.6</td><td align="left">Dynamic memory management</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7</td><td align="left">Type identification</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.7.1</td><td align="left">Class type_info</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.2</td><td align="left">Class bad_cast</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.3</td><td align="left">Class bad_typeid</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8</td><td align="left">Exception handling</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.8.1</td><td align="left">Class exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.2</td><td align="left">Class bad_exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.3</td><td align="left">Abnormal termination</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.4</td><td align="left"><code class="code">uncaught_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.5</td><td align="left">Exception Propagation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.6</td><td align="left"><code class="code">nested_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9</td><td align="left">Initializer lists</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.9.1</td><td align="left">Initializer list constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.2</td><td align="left">Initializer list access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.3</td><td align="left">Initializer list range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.10</td><td align="left">Other runtime support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">18.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.2</td><td align="left">Types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3</td><td align="left">Implementation properties</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2</td><td align="left">Numeric Limits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2.3</td><td align="left">Class template <code class="code">numeric_limits</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.2.4</td><td align="left"><code class="code">numeric_limits</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.5</td><td align="left"><code class="code">float_round_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.6</td><td align="left"><code class="code">float_denorm_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr><td align="left">18.3.2.7</td><td align="left"><code class="code">numeric_limits</code> specializations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.3</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.4</td><td align="left">Integer types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.4.1</td><td align="left">Header <code class="code">&lt;cstdint&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">18.5</td><td align="left">Start and termination</td><td align="left">Partial</td><td align="left">C library dependency for quick_exit, at_quick_exit</td></tr><tr><td align="left">18.6</td><td align="left">Dynamic memory management</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7</td><td align="left">Type identification</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.7.1</td><td align="left">Class type_info</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.2</td><td align="left">Class bad_cast</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.3</td><td align="left">Class bad_typeid</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8</td><td align="left">Exception handling</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.8.1</td><td align="left">Class exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.2</td><td align="left">Class bad_exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.3</td><td align="left">Abnormal termination</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.4</td><td align="left"><code class="code">uncaught_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.5</td><td align="left">Exception Propagation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.6</td><td align="left"><code class="code">nested_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9</td><td align="left">Initializer lists</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.9.1</td><td align="left">Initializer list constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.2</td><td align="left">Initializer list access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.3</td><td align="left">Initializer list range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.10</td><td align="left">Other runtime support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>19</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Diagnostics</em></span>
-      </td></tr><tr><td align="left">19.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.2</td><td align="left">Exception classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.3</td><td align="left">Assertions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.4</td><td align="left">Error numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5</td><td align="left">System error support</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">19.5.1</td><td align="left">Class <code class="code">error_category</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.2</td><td align="left">Class <code class="code">error_code</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.3</td><td align="left">Class <code class="code">error_condition</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.4</td><td align="left">Comparison operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.5</td><td align="left">Class <code class="code">system_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">19.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">19.2</td><td align="left">Exception classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.3</td><td align="left">Assertions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.4</td><td align="left">Error numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5</td><td align="left">System error support</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">19.5.1</td><td align="left">Class <code class="code">error_category</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.2</td><td align="left">Class <code class="code">error_code</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.3</td><td align="left">Class <code class="code">error_condition</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.4</td><td align="left">Comparison operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.5</td><td align="left">Class <code class="code">system_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>20</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>General utilities</em></span>
-      </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.2</td><td align="left">Swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.3</td><td align="left"><code class="code">forward</code> and <code class="code">move</code> helpers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.4</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.2</td><td align="left">Class template <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.3</td><td align="left">Specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.4</td><td align="left">Tuple-like access to <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.5</td><td align="left">Piecewise construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2</td><td align="left">Class template <code class="code">tuple</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2.1</td><td align="left">Construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.2</td><td align="left">Assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.3</td><td align="left">Swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.4</td><td align="left">Tuple creation functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.5</td><td align="left">Tuple helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.6</td><td align="left">Element access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.7</td><td align="left">Relational operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.8</td><td align="left">Tuple traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.9</td><td align="left">Tuple specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.1</td><td align="left"><code class="code">bitset</code> constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.2</td><td align="left"><code class="code">bitset</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.3</td><td align="left"><code class="code">bitset</code> hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.4</td><td align="left"><code class="code">bitset</code> operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6</td><td align="left">Memory</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.2</td><td align="left">Header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.3</td><td align="left">Pointer traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.4</td><td align="left">Pointer safety</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.5</td><td align="left">Align</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.6</td><td align="left">Allocator argument tag</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.7</td><td align="left"><code class="code">uses_allocator</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.8</td><td align="left">Allocator traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.9</td><td align="left">The default allocator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.10</td><td align="left">Raw storage iterator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.11</td><td align="left">Temporary buffers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12</td><td align="left">Specialized algorithms</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.12.1</td><td align="left"><code class="code">addressof</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.2</td><td align="left"><code class="code">uninitialized_copy</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.3</td><td align="left"><code class="code">uninitialized_fill</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.4</td><td align="left"><code class="code">uninitialized_fill_n</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.13</td><td align="left">C library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.7.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2</td><td align="left">Shared-ownership pointers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
+      </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.2</td><td align="left">swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.3</td><td align="left">forward/move helpers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.4</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.3.2</td><td align="left">Class template <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.3</td><td align="left">Specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.4</td><td align="left">Tuple-like access to <code class="code">pair</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3.5</td><td align="left">Piecewise construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2</td><td align="left">Class template <code class="code">tuple</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.4.2.1</td><td align="left">Construction</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.2</td><td align="left">Assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.3</td><td align="left">Swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.4</td><td align="left">Tuple creation functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.5</td><td align="left">Tuple helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.6</td><td align="left">Element access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.7</td><td align="left">Relational operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.8</td><td align="left">Tuple traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4.2.9</td><td align="left">Tuple specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.1</td><td align="left"><code class="code">bitset</code> constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.2</td><td align="left"><code class="code">bitset</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.3</td><td align="left"><code class="code">bitset</code> hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.4</td><td align="left"><code class="code">bitset</code> operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6</td><td align="left">Memory</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.2</td><td align="left">Header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.3</td><td align="left">Pointer traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.4</td><td align="left">Pointer safety</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.5</td><td align="left">Align</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.6</td><td align="left">Allocator argument tag</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.7</td><td align="left"><code class="code">uses_allocator</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.8</td><td align="left">Allocator traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.9</td><td align="left">The default allocator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.10</td><td align="left">Raw storage iterator</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.11</td><td align="left">Temporary buffers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12</td><td align="left">Specialized algorithms</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.6.12.1</td><td align="left"><code class="code">addressof</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.2</td><td align="left"><code class="code">uninitialized_copy</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.3</td><td align="left"><code class="code">uninitialized_fill</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.12.4</td><td align="left"><code class="code">uninitialized_fill_n</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6.13</td><td align="left">C library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.7.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2</td><td align="left">Shared-ownership pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.7.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
-      </td></tr><tr><td align="left">20.7.2.3</td><td align="left">Class template <code class="code">weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.4</td><td align="left">Class template <code class="code">emable_shared_from_this</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.5</td><td align="left"><code class="code">shared_ptr</code> atomic access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.6</td><td align="left">Smart pointer hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8</td><td align="left">Function objects</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.1</td><td align="left">Definitions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.2</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.3</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.4</td><td align="left">Arithmetic operation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.5</td><td align="left">Comparisons</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.6</td><td align="left">Logical operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.7</td><td align="left">Bitwise operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.8</td><td align="left">Negators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.9</td><td align="left">Function template <code class="code">bind</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.10</td><td align="left">Function template <code class="code">mem_fn</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.11</td><td align="left">Polymorphic function wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.11.1</td><td align="left">Class <code class="code">bad_function_call</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.8.11.2</td><td align="left">Class template <code class="code">function</code></td><td align="left">Partial</td><td align="left">Missing allocator support</td></tr><tr><td align="left">20.8.12</td><td align="left">Class template <code class="code">hash</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9</td><td align="left">Metaprogramming and type traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.1</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.2</td><td align="left">Header <code class="code">&lt;type_traits&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.3</td><td align="left">Helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4</td><td align="left">Unary Type Traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.1</td><td align="left">Primary type categories</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.2</td><td align="left">Composite type traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.3</td><td align="left">Type properties</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.5</td><td align="left">Type property queries</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.6</td><td align="left">Relationships between types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7</td><td align="left">Transformations between types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.7.1</td><td align="left">Const-volatile modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.2</td><td align="left">Reference modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.3</td><td align="left">Sign modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.4</td><td align="left">Array modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.5</td><td align="left">Pointer modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.6</td><td align="left">Other transformations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10</td><td align="left">Compile-time rational arithmetic</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.2</td><td align="left">Header <code class="code">&lt;ratio&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.3</td><td align="left">Class template <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.4</td><td align="left">Arithmetic on <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.5</td><td align="left">Comparison of <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.6</td><td align="left">SI types for <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11</td><td align="left">Time utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.3</td><td align="left">Clock requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4</td><td align="left">Time-related traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.4.1</td><td align="left"><code class="code">treat_as_floating_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.2</td><td align="left"><code class="code">duration_values</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.3</td><td align="left">Specializations of <code class="code">common_type</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.5</td><td align="left">Class template <code class="code">duration</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.6</td><td align="left">Class template <code class="code">time_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7</td><td align="left">Clocks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.7.1</td><td align="left">Class <code class="code">system_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.2</td><td align="left">Class <code class="code">steady_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.3</td><td align="left">Class <code class="code">high_resolution_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.8</td><td align="left">Date and time functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12</td><td align="left">Scoped allocator adaptor</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.1</td><td align="left">Header <code class="code">&lt;scoped_allocator&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.12.2</td><td align="left">Scoped allocator adaptor member types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.3</td><td align="left">Scoped allocator adaptor constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.4</td><td align="left">Scoped allocator adaptor members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.5</td><td align="left">Scoped allocator operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.13</td><td align="left">Class <code class="code">type_index</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">20.7.2.3</td><td align="left">Class template <code class="code">weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.4</td><td align="left">Class template <code class="code">enable_shared_from_this</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.5</td><td align="left"><code class="code">shared_ptr</code> atomic access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7.2.6</td><td align="left">Smart pointer hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8</td><td align="left">Function objects</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.1</td><td align="left">Definitions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.2</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.3</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.4</td><td align="left">Arithmetic operation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.5</td><td align="left">Comparisons</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.6</td><td align="left">Logical operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.7</td><td align="left">Bitwise operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.8</td><td align="left">Negators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.9</td><td align="left">Function template <code class="code">bind</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.10</td><td align="left">Function template <code class="code">mem_fn</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.11</td><td align="left">Polymorphic function wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.11.1</td><td align="left">Class <code class="code">bad_function_call</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.8.11.2</td><td align="left">Class template <code class="code">function</code></td><td align="left">Partial</td><td align="left">Missing allocator support</td></tr><tr><td align="left">20.8.12</td><td align="left">Class template <code class="code">hash</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9</td><td align="left">Metaprogramming and type traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.1</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.2</td><td align="left">Header <code class="code">&lt;type_traits&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.3</td><td align="left">Helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4</td><td align="left">Unary Type Traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.1</td><td align="left">Primary type categories</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.2</td><td align="left">Composite type traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4.3</td><td align="left">Type properties</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.5</td><td align="left">Type property queries</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.6</td><td align="left">Relationships between types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7</td><td align="left">Transformations between types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.7.1</td><td align="left">Const-volatile modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.2</td><td align="left">Reference modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.3</td><td align="left">Sign modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.4</td><td align="left">Array modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.5</td><td align="left">Pointer modifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7.6</td><td align="left">Other transformations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10</td><td align="left">Compile-time rational arithmetic</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.2</td><td align="left">Header <code class="code">&lt;ratio&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.3</td><td align="left">Class template <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.4</td><td align="left">Arithmetic on <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.5</td><td align="left">Comparison of <code class="code">ratio</code>s</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.6</td><td align="left">SI types for <code class="code">ratio</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11</td><td align="left">Time utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.3</td><td align="left">Clock requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4</td><td align="left">Time-related traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.4.1</td><td align="left"><code class="code">treat_as_floating_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.2</td><td align="left"><code class="code">duration_values</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.4.3</td><td align="left">Specializations of <code class="code">common_type</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.5</td><td align="left">Class template <code class="code">duration</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.6</td><td align="left">Class template <code class="code">time_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7</td><td align="left">Clocks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.11.7.1</td><td align="left">Class <code class="code">system_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.2</td><td align="left">Class <code class="code">steady_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.7.3</td><td align="left">Class <code class="code">high_resolution_clock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11.8</td><td align="left">Date and time functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12</td><td align="left">Scoped allocator adaptor</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.1</td><td align="left">Header <code class="code">&lt;scoped_allocator&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.12.2</td><td align="left">Scoped allocator adaptor member types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.3</td><td align="left">Scoped allocator adaptor constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.4</td><td align="left">Scoped allocator adaptor members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.5</td><td align="left">Scoped allocator operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.13</td><td align="left">Class <code class="code">type_index</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>21</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Strings</em></span>
-      </td></tr><tr><td align="left">21.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2</td><td align="left">Character traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">21.2.1</td><td align="left">Character traits requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.2</td><td align="left">traits typedefs</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3</td><td align="left"><code class="code">char_traits</code> specializations</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">21.2.3.1</td><td align="left">struct <code class="code">char_traits&lt;char&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.2</td><td align="left">struct <code class="code">char_traits&lt;char16_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.3</td><td align="left">struct <code class="code">char_traits&lt;char32_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.4</td><td align="left">struct <code class="code">char_traits&lt;wchar_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.3</td><td align="left">String classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.4</td><td align="left">Class template <code class="code">basic_string</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.5</td><td align="left">Numeric Conversions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.6</td><td align="left">Hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">21.7</td><td align="left">Null-terminated sequence utilities</td><td align="left">Partial</td><td align="left">C library dependency.
-      Missing <code class="filename">&lt;cuchar&gt;</code>
-      </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">21.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2</td><td align="left">Character traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">21.2.1</td><td align="left">Character traits requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.2</td><td align="left">traits typedefs</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3</td><td align="left"><code class="code">char_traits</code> specializations</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">21.2.3.1</td><td align="left">struct <code class="code">char_traits&lt;char&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.2</td><td align="left">struct <code class="code">char_traits&lt;char16_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.3</td><td align="left">struct <code class="code">char_traits&lt;char32_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2.3.4</td><td align="left">struct <code class="code">char_traits&lt;wchar_t&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.3</td><td align="left">String classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.4</td><td align="left">Class template <code class="code">basic_string</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.5</td><td align="left">Numeric Conversions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.6</td><td align="left">Hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">21.7</td><td align="left">Null-terminated sequence utilities</td><td align="left">Partial</td><td align="left">C library dependency. </td></tr><tr><td align="left">
       	<span class="emphasis"><em>22</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Localization</em></span>
@@ -196,7 +196,7 @@ This page describes the C++11 support in the GCC 9 series.
       <span class="emphasis"><em>26</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Numerics</em></span>
-      </td></tr><tr><td align="left">26.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.2</td><td align="left">Numeric type requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.3</td><td align="left">The floating-point environment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.4</td><td align="left">Complex numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5</td><td align="left">Random number generation</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.1</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.2</td><td align="left">Header <code class="code">&lt;random&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.3</td><td align="left">Random number engine class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.3.1</td><td align="left">Class template <code class="code">linear_congruential_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.3.2</td><td align="left">Class template <code class="code">mersenne_twister_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.3.3</td><td align="left">Class template <code class="code">subtract_with_carry_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4</td><td align="left">Random number engine adaptor class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.4.2</td><td align="left">Class template <code class="code">discard_block_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4.3</td><td align="left">Class template <code class="code">independent_bits_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4.4</td><td align="left">Class template <code class="code">shuffle_order_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.5</td><td align="left">Engines and engine adaptors with predefined parameters</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.6</td><td align="left">Class <code class="code">random_device</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.7</td><td align="left">Utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.7.1</td><td align="left">Class <code class="code">seed_seq</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.7.2</td><td align="left">Function template <code class="code">generate_canonical</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8</td><td align="left">Random number distribution class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.2</td><td align="left">Uniform distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.2.1</td><td align="left">Class template <code class="code">uniform_int_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.2.2</td><td align="left">Class template <code class="code">uniform_real_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3</td><td align="left">Bernoulli distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.1</td><td align="left">Class <code class="code">bernoulli_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.2</td><td align="left">Class template <code class="code">binomial_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.3</td><td align="left">Class template <code class="code">geometric_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.4</td><td align="left">Class template <code class="code">negative_binomial_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4</td><td align="left">Poisson distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.1</td><td align="left">Class template <code class="code">poisson_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.2</td><td align="left">Class template <code class="code">exponential_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.3</td><td align="left">Class template <code class="code">gamma_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.4</td><td align="left">Class template <code class="code">weibull_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.5</td><td align="left">Class template <code class="code">extreme_value_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5</td><td align="left">Normal distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.1</td><td align="left">Class template <code class="code">normal_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.2</td><td align="left">Class template <code class="code">lognormal_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.3</td><td align="left">Class template <code class="code">chi_squared_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.4</td><td align="left">Class template <code class="code">cauchy_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.5</td><td align="left">Class template <code class="code">fisher_f_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.6</td><td align="left">Class template <code class="code">student_t_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6</td><td align="left">Sampling distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.1</td><td align="left">Class template <code class="code">discrete_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.2</td><td align="left">Class template <code class="code">piecewise_constant_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.3</td><td align="left">Class template <code class="code">piecewise_linear_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6</td><td align="left">Numeric arrays</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.6.1</td><td align="left">Header <code class="code">&lt;valarray&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.2</td><td align="left">Class template <code class="code">valarray</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.3</td><td align="left"><code class="code">valarray</code> non-member operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.4</td><td align="left">Class <code class="code">slice</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.5</td><td align="left">Class template <code class="code">slice_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.6</td><td align="left">The <code class="code">gslice</code> class</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.7</td><td align="left">Class template <code class="code">gslice_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.8</td><td align="left">Class template <code class="code">mask_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.9</td><td align="left">Class template <code class="code">indirect_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.10</td><td align="left"><code class="code">valarray</code> range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7</td><td align="left">Generalized numeric operations</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.7.1</td><td align="left">Header <code class="code">&lt;numeric&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.2</td><td align="left"><code class="code">accumulate</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.3</td><td align="left"><code class="code">inner_product</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.4</td><td align="left"><code class="code">partial_sum</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.5</td><td align="left"><code class="code">adjacent_difference</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.6</td><td align="left">iota</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.8</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">26.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.2</td><td align="left">Numeric type requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.3</td><td align="left">The floating-point environment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.4</td><td align="left">Complex numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5</td><td align="left">Random number generation</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.1</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.2</td><td align="left">Header <code class="code">&lt;random&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.3</td><td align="left">Random number engine class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.3.1</td><td align="left">Class template <code class="code">linear_congruential_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.3.2</td><td align="left">Class template <code class="code">mersenne_twister_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.3.3</td><td align="left">Class template <code class="code">subtract_with_carry_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4</td><td align="left">Random number engine adaptor class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.4.2</td><td align="left">Class template <code class="code">discard_block_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4.3</td><td align="left">Class template <code class="code">independent_bits_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.4.4</td><td align="left">Class template <code class="code">shuffle_order_engine</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.5</td><td align="left">Engines and engine adaptors with predefined parameters</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.6</td><td align="left">Class <code class="code">random_device</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.7</td><td align="left">Utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.7.1</td><td align="left">Class <code class="code">seed_seq</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.7.2</td><td align="left">Function template <code class="code">generate_canonical</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8</td><td align="left">Random number distribution class templates</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.2</td><td align="left">Uniform distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.2.1</td><td align="left">Class template <code class="code">uniform_int_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.2.2</td><td align="left">Class template <code class="code">uniform_real_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3</td><td align="left">Bernoulli distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.1</td><td align="left">Class <code class="code">bernoulli_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.2</td><td align="left">Class template <code class="code">binomial_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.3</td><td align="left">Class template <code class="code">geometric_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.3.4</td><td align="left">Class template <code class="code">negative_binomial_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4</td><td align="left">Poisson distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.1</td><td align="left">Class template <code class="code">poisson_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.2</td><td align="left">Class template <code class="code">exponential_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.3</td><td align="left">Class template <code class="code">gamma_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.4</td><td align="left">Class template <code class="code">weibull_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.4.5</td><td align="left">Class template <code class="code">extreme_value_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5</td><td align="left">Normal distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.1</td><td align="left">Class template <code class="code">normal_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.2</td><td align="left">Class template <code class="code">lognormal_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.3</td><td align="left">Class template <code class="code">chi_squared_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.4</td><td align="left">Class template <code class="code">cauchy_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.5</td><td align="left">Class template <code class="code">fisher_f_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.5.6</td><td align="left">Class template <code class="code">student_t_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6</td><td align="left">Sampling distributions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.1</td><td align="left">Class template <code class="code">discrete_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.2</td><td align="left">Class template <code class="code">piecewise_constant_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5.8.6.3</td><td align="left">Class template <code class="code">piecewise_linear_distribution</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6</td><td align="left">Numeric arrays</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.6.1</td><td align="left">Header <code class="code">&lt;valarray&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.2</td><td align="left">Class template <code class="code">valarray</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.3</td><td align="left"><code class="code">valarray</code> non-member operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.4</td><td align="left">Class <code class="code">slice</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.5</td><td align="left">Class template <code class="code">slice_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.6</td><td align="left">The <code class="code">gslice</code> class</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.7</td><td align="left">Class template <code class="code">gslice_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.8</td><td align="left">Class template <code class="code">mask_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.9</td><td align="left">Class template <code class="code">indirect_array</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6.10</td><td align="left"><code class="code">valarray</code> range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7</td><td align="left">Generalized numeric operations</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.7.1</td><td align="left">Header <code class="code">&lt;numeric&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.2</td><td align="left">Accumulate&gt;</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.3</td><td align="left">Inner product</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.4</td><td align="left">Partial sum</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.5</td><td align="left">Adjacent difference</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7.6</td><td align="left">Iota</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.8</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>27</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Input/output library</em></span>
@@ -208,15 +208,17 @@ This page describes the C++11 support in the GCC 9 series.
 	<span class="emphasis"><em>29</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Atomic operations</em></span>
-      </td></tr><tr><td align="left">29.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.2</td><td align="left">Header <code class="code">&lt;atomic&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">29.3</td><td align="left">Order and consistency</td><td align="left">Partial</td><td align="left"> </td></tr><tr><td align="left">29.4</td><td align="left">Lock-free property</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.5</td><td align="left">Atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.6</td><td align="left">Operations on atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.7</td><td align="left">Flag Type and operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.8</td><td align="left">Fences</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">29.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.2</td><td align="left">Header <code class="code">&lt;atomic&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.3</td><td align="left">Order and consistency</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.4</td><td align="left">Lock-free property</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.5</td><td align="left">Atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.6</td><td align="left">Operations on atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.7</td><td align="left">Flag Type and operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.8</td><td align="left">Fences</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
 	<span class="emphasis"><em>30</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Thread support</em></span>
-      </td></tr><tr><td align="left">30.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.2</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.3</td><td align="left">Threads</td><td align="left"> </td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">30.3.1</td><td align="left">Class <code class="code">thread</code></td><td align="left">Partial</td><td align="left"><code class="code">thread::id</code> comparisons not well-defined</td></tr><tr><td align="left">30.3.2</td><td align="left">Namespace <code class="code">this_thread</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4</td><td align="left">Mutual exclusion</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1</td><td align="left">Mutex requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2</td><td align="left">Mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.1</td><td align="left">Class <code class="code">mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.2</td><td align="left">Class <code class="code">recursive_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3</td><td align="left">Timed mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.1</td><td align="left">Class <code class="code">timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.2</td><td align="left">Class <code class="code">recursive_timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2</td><td align="left">Locks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.2.1</td><td align="left">Class template <code class="code">lock_guard</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2.2</td><td align="left">Class template <code class="code">unique_lock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.3</td><td align="left">Generic locking algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.4</td><td align="left">Call once</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.4.1</td><td align="left">Struct <code class="code">once_flag</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.4.2</td><td align="left">Function <code class="code">call_once</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5</td><td align="left">Condition variables</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.1</td><td align="left">Class <code class="code">condition_variable</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.2</td><td align="left">Class <code class="code">condition_variable_any</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6</td><td align="left">Futures</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.1</td><td align="left">Overview</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.2</td><td align="left">Error handling</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.3</td><td align="left">Class <code class="code">future_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.4</td><td align="left">Shared state</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.5</td><td align="left">Class template <code class="code">promise</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.6</td><td align="left">Class template <code class="code">future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.7</td><td align="left">Class template <code class="code">shared_future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.8</td><td align="left">Function template <code class="code">async</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.9</td><td align="left">Class template <code class="code">packaged_task</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      </td></tr><tr><td align="left">30.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.2</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.3</td><td align="left">Threads</td><td align="left"> </td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">30.3.1</td><td align="left">Class <code class="code">thread</code></td><td align="left">Partial</td><td align="left"><code class="code">thread::id</code> comparisons not well-defined</td></tr><tr><td align="left">30.3.2</td><td align="left">Namespace <code class="code">this_thread</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4</td><td align="left">Mutual exclusion</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1</td><td align="left">Mutex requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2</td><td align="left">Mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.1</td><td align="left">Class <code class="code">mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.2</td><td align="left">Class <code class="code">recursive_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3</td><td align="left">Timed mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.1</td><td align="left">Class <code class="code">timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.2</td><td align="left">Class <code class="code">recursive_timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2</td><td align="left">Locks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.2.1</td><td align="left">Class template <code class="code">lock_guard</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2.2</td><td align="left">Class template <code class="code">unique_lock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.3</td><td align="left">Generic locking algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.4</td><td align="left">Call once</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.4.1</td><td align="left">Struct <code class="code">once_flag</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">30.4.4.2</td><td align="left">Function <code class="code">call_once</code></td><td align="left">Broken</td><td align="left">See <a class="link" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146" target="_top">PR
+	66146</a>
+      </td></tr><tr><td align="left">30.5</td><td align="left">Condition variables</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.1</td><td align="left">Class <code class="code">condition_variable</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.2</td><td align="left">Class <code class="code">condition_variable_any</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6</td><td align="left">Futures</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.1</td><td align="left">Overview</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.2</td><td align="left">Error handling</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.3</td><td align="left">Class <code class="code">future_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.4</td><td align="left">Shared state</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.5</td><td align="left">Class template <code class="code">promise</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.6</td><td align="left">Class template <code class="code">future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.7</td><td align="left">Class template <code class="code">shared_future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.8</td><td align="left">Function template <code class="code">async</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.9</td><td align="left">Class template <code class="code">packaged_task</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
       	<span class="emphasis"><em>Appendix D</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Compatibility features</em></span>
-      </td></tr><tr><td align="left">D.1</td><td align="left">Increment operator with <code class="code">bool</code> operand</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.2</td><td align="left"><code class="code">register</code> keyword</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.3</td><td align="left">Implicit declaration of copy functions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.4</td><td align="left">Dynamic exception specifications</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.5</td><td align="left">C standard library headers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.6</td><td align="left">Old iostreams members</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.7</td><td align="left"><code class="code">char*</code> streams</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.8</td><td align="left">Function objects</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.9</td><td align="left">Binders</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.10</td><td align="left"><code class="code">auto_ptr</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.11</td><td align="left">Violating exception-specifications</td><td align="left"> </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.2011.specific"></a>Implementation Specific Behavior</h4></div></div></div><p>For behaviour which is also specified by the 1998 and 2003 standards,
+      </td></tr><tr><td align="left">D.1</td><td align="left">Increment operator with <code class="code">bool</code> operand</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.2</td><td align="left"><code class="code">register</code> keyword</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.3</td><td align="left">Implicit declaration of copy functions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.4</td><td align="left">Dynamic exception specifications</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.5</td><td align="left">C standard library headers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.6</td><td align="left">Old iostreams members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.7</td><td align="left"><code class="code">char*</code> streams</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.8</td><td align="left">Function objects</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.9</td><td align="left">Binders</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.10</td><td align="left"><code class="code">auto_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.11</td><td align="left">Violating exception-specifications</td><td align="left">Y</td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.2011.specific"></a>Implementation Specific Behavior</h4></div></div></div><p>For behaviour which is also specified by the 1998 and 2003 standards,
       see <a class="link" href="status.html#iso.1998.specific" title="Implementation Specific Behavior">C++ 1998/2003 Implementation
       Specific Behavior</a>. This section only documents behaviour which
       is new in the 2011 standard.
@@ -386,80 +388,73 @@ options. The pre-defined symbol
 <code class="constant">__cplusplus</code> is used to check for the
 presence of the required flag.
 </p><p>
-This page describes the C++14 and library TS support in the GCC 9 series.
-</p><div class="table"><a id="table.cxx14_status"></a><p class="title"><strong>Table 1.3. C++ 2014 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 2014 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Paper</th><th align="left">Title</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3669.pdf" target="_top">
-	  N3669
-	</a>
-      </td><td align="left">Fixing constexpr member functions without const</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3668.html" target="_top">
-	  N3668
-	</a>
-      </td><td align="left"><code class="code">exchange()</code> utility function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3670.html" target="_top">
-	  N3670
-	</a>
-      </td><td align="left">Wording for Addressing Tuples by Type</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3656.htm" target="_top">
-	  N3656
-	</a>
-      </td><td align="left"><code class="code">make_unique</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3462.html" target="_top">
-	  N3462
-	</a>
-      </td><td align="left"><code class="code">std::result_of</code> and SFINAE</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3545.pdf" target="_top">
-	  N3545
-	</a>
-      </td><td align="left">An Incremental Improvement to <code class="code">integral_constant</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3642.pdf" target="_top">
-	  N3642
-	</a>
-      </td><td align="left">User-defined Literals for Standard Library Types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3671.html" target="_top">
-	  N3671
-	</a>
-      </td><td align="left">Making non-modifying sequence operations more robust</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3654.html" target="_top">
-	  N3654
-	</a>
-      </td><td align="left">Quoted Strings Library Proposal</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3469.html" target="_top">
-	  N3469
-	</a>
-      </td><td align="left">Constexpr Library Additions: chrono</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3470.html" target="_top">
-	  N3470
-	</a>
-      </td><td align="left">Constexpr Library Additions: containers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3471.html" target="_top">
-	  N3471
-	</a>
-      </td><td align="left">Constexpr Library Additions: utilities</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3658.html" target="_top">
-	  N3658
-	</a>
-      </td><td align="left">Compile-time integer sequences</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3659.html" target="_top">
-	  N3659
-	</a>
-      </td><td align="left">Shared Locking in C++</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3421.htm" target="_top">
-	  N3421
-	</a>
-      </td><td align="left">Making Operator Functors greater&lt;&gt;</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3657.htm" target="_top">
-	  N3657
-	</a>
-      </td><td align="left">Adding heterogeneous comparison lookup to associative containers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3655.pdf" target="_top">
-	  N3655
-	</a>
-      </td><td align="left">TransformationTraits Redux</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">
-	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3644.pdf" target="_top">
-	  N3644
-	</a>
-      </td><td align="left">Null Forward Iterators</td><td align="left">Partial</td><td align="left">Only affects Debug Mode</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table.ts_status"></a><p class="title"><strong>Table 1.4. C++ Technical Specifications Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Technical Specifications Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Paper</th><th align="left">Title</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#C8B0B0"><td align="left">
+This status table is based on the table of contents of ISO/IEC 14882:2014.
+Some subclauses are not shown in the table where the content is unchanged
+since C++11 and the implementation is complete.
+</p><p>
+This section describes the C++14 and library TS support in the GCC 9 series.
+</p><div class="table"><a id="table.cxx14_status"></a><p class="title"><strong>Table 1.3. C++ 2014 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ 2014 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
+	<span class="emphasis"><em>18</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Language support</em></span>
+      </td></tr><tr><td align="left">18.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.2</td><td align="left">Types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3</td><td align="left">Implementation properties</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2</td><td align="left">Numeric Limits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.3.2.3</td><td align="left">Class template <code class="code">numeric_limits</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.2.4</td><td align="left"><code class="code">numeric_limits</code> members</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.5</td><td align="left"><code class="code">float_round_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">18.3.2.6</td><td align="left"><code class="code">float_denorm_style</code></td><td align="left">N</td><td align="left"> </td></tr><tr><td align="left">18.3.2.7</td><td align="left"><code class="code">numeric_limits</code> specializations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.3.3</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.4</td><td align="left">Integer types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.4.1</td><td align="left">Header <code class="code">&lt;cstdint&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">18.5</td><td align="left">Start and termination</td><td align="left">Partial</td><td align="left">C library dependency for quick_exit, at_quick_exit</td></tr><tr><td align="left">18.6</td><td align="left">Dynamic memory management</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7</td><td align="left">Type identification</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.7.1</td><td align="left">Class type_info</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.2</td><td align="left">Class bad_cast</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.7.3</td><td align="left">Class bad_typeid</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8</td><td align="left">Exception handling</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.8.1</td><td align="left">Class exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.2</td><td align="left">Class bad_exception</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.3</td><td align="left">Abnormal termination</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.4</td><td align="left"><code class="code">uncaught_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.5</td><td align="left">Exception Propagation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.8.6</td><td align="left"><code class="code">nested_exception</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9</td><td align="left">Initializer lists</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">18.9.1</td><td align="left">Initializer list constructors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.2</td><td align="left">Initializer list access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.9.3</td><td align="left">Initializer list range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">18.10</td><td align="left">Other runtime support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>19</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Diagnostics</em></span>
+      </td></tr><tr><td align="left">19.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">19.2</td><td align="left">Exception classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.3</td><td align="left">Assertions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.4</td><td align="left">Error numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5</td><td align="left">System error support</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">19.5.1</td><td align="left">Class <code class="code">error_category</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.2</td><td align="left">Class <code class="code">error_code</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.3</td><td align="left">Class <code class="code">error_condition</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.4</td><td align="left">Comparison operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">19.5.5</td><td align="left">Class <code class="code">system_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>20</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>General utilities</em></span>
+      </td></tr><tr><td align="left">20.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2</td><td align="left">Utility components</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.2.1</td><td align="left">Operators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.2</td><td align="left">swap</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.3</td><td align="left">exchange</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.4</td><td align="left">forward/move helpers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.2.5</td><td align="left">Function template <code class="code">declval</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.3</td><td align="left">Pairs</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.4</td><td align="left">Tuples</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5</td><td align="left">Compile-time integer sequences</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.5.2</td><td align="left">Class template <code class="code">integer_sequence</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.5.3</td><td align="left">Alias template <code class="code">make_integer_sequence</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.6</td><td align="left">Class template <code class="code">bitset</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.7</td><td align="left">Memory</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.1</td><td align="left">Class template <code class="code">unique_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.1.1</td><td align="left">Default deleters</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.1.2</td><td align="left"><code class="code">unique_ptr</code> for single objects</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.1.3</td><td align="left"><code class="code">unique_ptr</code> for array objects with a runtime length</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.1.4</td><td align="left"><code class="code">unique_ptr</code> creation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.1.5</td><td align="left"><code class="code">unique_ptr</code> specialized algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2</td><td align="left">Shared-ownership pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.8.2.1</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2.2</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left">Y</td><td align="left">
+	  Uses code from
+	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
+      </td></tr><tr><td align="left">20.8.2.3</td><td align="left">Class template <code class="code">weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2.4</td><td align="left">Class template <code class="code">owner_less</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2.5</td><td align="left">Class template <code class="code">enable_shared_from_this</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2.6</td><td align="left"><code class="code">shared_ptr</code> atomic access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.2.7</td><td align="left">Smart pointer hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9</td><td align="left">Function objects</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.1</td><td align="left">Definitions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.2</td><td align="left">Requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.3</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.4</td><td align="left">Arithmetic operation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.5</td><td align="left">Comparisons</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.8.6</td><td align="left">Logical operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.7</td><td align="left">Bitwise operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.8</td><td align="left">Negators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.9</td><td align="left">Function object binders</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.10</td><td align="left">Function template <code class="code">mem_fn</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.9.11</td><td align="left">Polymorphic function wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.9.11.1</td><td align="left">Class <code class="code">bad_function_call</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">20.9.11.2</td><td align="left">Class template <code class="code">function</code></td><td align="left">Partial</td><td align="left">Missing allocator support</td></tr><tr><td align="left">20.9.12</td><td align="left">Class template <code class="code">hash</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10</td><td align="left">Metaprogramming and type traits</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.1</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.2</td><td align="left">Header <code class="code">&lt;type_traits&gt;</code> synopsis</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.10.3</td><td align="left">Helper classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.4</td><td align="left">Unary Type Traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.5</td><td align="left">Type property queries</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.6</td><td align="left">Relationships between types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.10.7</td><td align="left">Transformations between types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.11</td><td align="left">Compile-time rational arithmetic</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12</td><td align="left">Time utilities</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">20.12.3</td><td align="left">Clock requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.4</td><td align="left">Time-related traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.5</td><td align="left">Class template <code class="code">duration</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.5.8</td><td align="left">Suffixes for duration literals</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.6</td><td align="left">Class template <code class="code">time_point</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.7</td><td align="left">Clocks</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.12.8</td><td align="left">Date and time functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.13</td><td align="left">Scoped allocator adaptor</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">20.14</td><td align="left">Class <code class="code">type_index</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>21</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Strings</em></span>
+      </td></tr><tr><td align="left">21.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.2</td><td align="left">Character traits</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.3</td><td align="left">String classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.4</td><td align="left">Class template <code class="code">basic_string</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.5</td><td align="left">Numeric Conversions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.6</td><td align="left">Hash support</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">21.7</td><td align="left">Suffixes for <code class="code">basic_string</code> literals</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">21.7</td><td align="left">Null-terminated sequence utilities</td><td align="left">Partial</td><td align="left">C library dependency. </td></tr><tr><td align="left">
+	<span class="emphasis"><em>22</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Localization</em></span>
+      </td></tr><tr><td align="left">22.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">22.2</td><td align="left">Header <code class="code">&lt;locale&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">22.3</td><td align="left">Locales</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">22.4</td><td align="left">Standard <code class="code">locale</code> categories</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">22.5</td><td align="left">Standard code conversion facets</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">22.6</td><td align="left">C Library Locales</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>23</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Containers</em></span>
+      </td></tr><tr><td align="left">23.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">23.2</td><td align="left">Container requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">23.3</td><td align="left">Sequence containers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">23.4</td><td align="left">Associative containers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">23.5</td><td align="left">Unordered associative containers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">23.6</td><td align="left">Container adaptors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>24</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Iterators</em></span>
+      </td></tr><tr><td align="left">24.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.2</td><td align="left">Iterator requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.3</td><td align="left">Header <code class="code">&lt;iterator&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.4</td><td align="left">Iterator primitives</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.5</td><td align="left">Iterator adaptors</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.6</td><td align="left">Stream iterators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">24.7</td><td align="left">range access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>25</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Algorithms</em></span>
+      </td></tr><tr><td align="left">25.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">25.2</td><td align="left">Non-modifying sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">25.3</td><td align="left">Mutating sequence operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">25.4</td><td align="left">Sorting and related operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">25.5</td><td align="left">C library algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+      <span class="emphasis"><em>26</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Numerics</em></span>
+      </td></tr><tr><td align="left">26.1</td><td align="left">General</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">26.2</td><td align="left">Numeric type requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.3</td><td align="left">The floating-point environment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.4</td><td align="left">Complex numbers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.4.10</td><td align="left">Suffixes for complex number literals</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.5</td><td align="left">Random number generation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.6</td><td align="left">Numeric arrays</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.7</td><td align="left">Generalized numeric operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">26.8</td><td align="left">C Library</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>27</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Input/output library</em></span>
+      </td></tr><tr><td align="left">27.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.2</td><td align="left">Iostreams requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.2.1</td><td align="left">Imbue Limitations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.2.2</td><td align="left">Positioning Type Limitations</td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">27.2.3</td><td align="left">Thread safety</td><td align="left">Partial</td><td align="left"> </td></tr><tr><td align="left">27.3</td><td align="left">Forward declarations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.4</td><td align="left">Standard iostream objects</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.5</td><td align="left">Iostreams base classes</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.6</td><td align="left">Stream buffers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.7</td><td align="left">Formatting and manipulators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.7.6</td><td align="left">Quoted manipulators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.8</td><td align="left">String-based streams</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">27.9</td><td align="left">File-based streams</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>28</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Regular expressions</em></span>
+      </td></tr><tr><td align="left">28.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.2</td><td align="left">Definitions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.3</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.4</td><td align="left">Header <code class="code">&lt;regex&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.5</td><td align="left">Namespace <code class="code">std::regex_constants</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.6</td><td align="left">Class <code class="code">regex_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">28.7</td><td align="left">Class template <code class="code">regex_traits</code></td><td align="left">Partial</td><td align="left"><code class="code">transform_primary</code> is not correctly implemented</td><td align="left"> </td></tr><tr><td align="left">28.8</td><td align="left">Class template <code class="code">basic_regex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.9</td><td align="left">Class template <code class="code">sub_match</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.10</td><td align="left">Class template <code class="code">match_results</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.11</td><td align="left">Regular expression algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.12</td><td align="left">Regular expression Iterators</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">28.13</td><td align="left">Modified ECMAScript regular expression grammar</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>29</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Atomic operations</em></span>
+      </td></tr><tr><td align="left">29.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.2</td><td align="left">Header <code class="code">&lt;atomic&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.3</td><td align="left">Order and consistency</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.4</td><td align="left">Lock-free property</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.5</td><td align="left">Atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.6</td><td align="left">Operations on atomic types</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.7</td><td align="left">Flag Type and operations</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">29.8</td><td align="left">Fences</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>30</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Thread support</em></span>
+      </td></tr><tr><td align="left">30.1</td><td align="left">General</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.2</td><td align="left">Requirements</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.3</td><td align="left">Threads</td><td align="left"> </td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">30.3.1</td><td align="left">Class <code class="code">thread</code></td><td align="left">Partial</td><td align="left"><code class="code">thread::id</code> comparisons not well-defined</td></tr><tr><td align="left">30.3.2</td><td align="left">Namespace <code class="code">this_thread</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4</td><td align="left">Mutual exclusion</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1</td><td align="left">Mutex requirements</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.1</td><td align="left">In general</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2</td><td align="left">Mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.1</td><td align="left">Class <code class="code">mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.2.2</td><td align="left">Class <code class="code">recursive_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3</td><td align="left">Timed mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.1</td><td align="left">Class <code class="code">timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.3.2</td><td align="left">Class <code class="code">recursive_timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.1.4</td><td align="left">Shared timed mutex types</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.1.4.1</td><td align="left">Class <code class="code">shared_timed_mutex</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2</td><td align="left">Locks</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.2.1</td><td align="left">Class template <code class="code">lock_guard</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2.2</td><td align="left">Class template <code class="code">unique_lock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.2.3</td><td align="left">Class template <code class="code">shared_lock</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.3</td><td align="left">Generic locking algorithms</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.4.4</td><td align="left">Call once</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.4.4.1</td><td align="left">Struct <code class="code">once_flag</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">30.4.4.2</td><td align="left">Function <code class="code">call_once</code></td><td align="left">Broken</td><td align="left">See <a class="link" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146" target="_top">PR
+	66146</a>
+      </td></tr><tr><td align="left">30.5</td><td align="left">Condition variables</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.1</td><td align="left">Class <code class="code">condition_variable</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.5.2</td><td align="left">Class <code class="code">condition_variable_any</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6</td><td align="left">Futures</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.1</td><td align="left">Overview</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">30.6.2</td><td align="left">Error handling</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.3</td><td align="left">Class <code class="code">future_error</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.4</td><td align="left">Shared state</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.5</td><td align="left">Class template <code class="code">promise</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.6</td><td align="left">Class template <code class="code">future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.7</td><td align="left">Class template <code class="code">shared_future</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.8</td><td align="left">Function template <code class="code">async</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">30.6.9</td><td align="left">Class template <code class="code">packaged_task</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">
+	<span class="emphasis"><em>Appendix D</em></span>
+      </td><td colspan="3" align="left">
+	<span class="emphasis"><em>Compatibility features</em></span>
+      </td></tr><tr><td align="left">D.1</td><td align="left">Increment operator with <code class="code">bool</code> operand</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.2</td><td align="left"><code class="code">register</code> keyword</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.3</td><td align="left">Implicit declaration of copy functions</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.4</td><td align="left">Dynamic exception specifications</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">D.5</td><td align="left">C standard library headers</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.6</td><td align="left">Old iostreams members</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.7</td><td align="left"><code class="code">char*</code> streams</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.8</td><td align="left">Function objects</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.9</td><td align="left">Binders</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.10</td><td align="left"><code class="code">auto_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.11</td><td align="left">Violating exception-specifications</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">D.12</td><td align="left">Random shuffle</td><td align="left">Y</td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table.ts_status"></a><p class="title"><strong>Table 1.4. C++ Technical Specifications Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Technical Specifications Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Paper</th><th align="left">Title</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#C8B0B0"><td align="left">
 	<a class="link" href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3662.html" target="_top">
 	  N3662
 	</a>
@@ -693,7 +688,7 @@ Feature-testing recommendations for C++</a>.
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html" target="_top">
 	P0077R2
 	</a>
-      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> __cpp_lib_is_callable &gt;= 201603 </code></td></tr><tr><td align="left"> has_unique_object_representations </td><td align="left">
+      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> __cpp_lib_is_invocable &gt;= 201703 </code></td></tr><tr><td align="left"> has_unique_object_representations </td><td align="left">
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0258r2.html" target="_top">
 	P0258R2
 	</a>
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
index aff6c8d6004..cf8684e1cea 100644
--- a/libstdc++-v3/doc/xml/faq.xml
+++ b/libstdc++-v3/doc/xml/faq.xml
@@ -2,9 +2,9 @@
 
 <article xml:id="faq" xreflabel="Frequently Asked Questions">
 <?dbhtml filename="faq.html"?>
- 
+
 <info><title>Frequently Asked Questions</title>
-  
+
   <copyright>
     <year>
       2008-2018
@@ -36,7 +36,7 @@
      exactly how far the project has come, or just want the latest
      bleeding-edge code, the up-to-date source can be cloned via
      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/git.html">Git</link>.
-    </para> 
+    </para>
 
     <para>
     N.B. The library is called libstdc++ <emphasis>not</emphasis> stdlibc++.
@@ -58,7 +58,7 @@
     (as the Draft Standard used to say) <quote>incomplet and
     incorrekt</quote>, and many suffered from limitations of the compilers
     that used them.
-    </para> 
+    </para>
     <para>
     The GNU compiler collection
     (<command>gcc</command>, <command>g++</command>, etc) is widely
@@ -68,7 +68,7 @@
     the rapid development and near-legendary
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/buildstat.html">portability</link>
     that are the hallmarks of an open-source project are applied to libstdc++.
-    </para> 
+    </para>
     <para>
     All of the standard classes and functions from C++98/C++03, C++11 and C++14
     (such as <classname>string</classname>,
@@ -100,7 +100,7 @@
     archives, is open to everyone.  You can read instructions for
     doing so on the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/lists.html">GCC mailing lists</link> page.
     If you have questions, ideas, code, or are just curious, sign up!
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -115,7 +115,7 @@
     Nathan Myers gave the best of all possible answers, responding to
     a Usenet article asking this question: <emphasis>Sooner, if you
     help.</emphasis>
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -135,7 +135,7 @@
     anybody who is willing to help write documentation, for example,
     or has found a bug in code that we all thought was working and is
     willing to provide details, is more than welcome!
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -152,7 +152,7 @@
     being developed.</quote>
     It should not be used for new projects, and won't even compile with
     recent releases of GCC (or most other C++ compilers).
-    </para> 
+    </para>
     <para>
     More information can be found in the
     <link linkend="manual.appendix.porting.backwards">Backwards
@@ -175,13 +175,13 @@
     information is available on the homepage (including how to browse
     the list archives); to send a message to the list,
     use <email>libstdc++@gcc.gnu.org</email>.
-    </para> 
+    </para>
 
-    <para> 
+    <para>
     If you have a question that you think should be included
     here, or if you have a question <emphasis>about</emphasis> a question/answer
     here, please send email to the libstdc++ mailing list, as above.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -201,7 +201,7 @@
     <para>
     See <link linkend="manual.intro.status.license">our license description</link>
     for these and related questions.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -215,7 +215,7 @@
     <para>
      No. The special exception permits use of the library in
      proprietary applications.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -235,7 +235,7 @@
      are expanded inside the code that uses the library.  So to allow people
      to replace the library code, someone using the library would have to
      distribute their own source, rendering the LGPL equivalent to the GPL.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -249,7 +249,7 @@
     <para>
       None.  We encourage such programs to be released as free software,
      but we won't punish you or sue you if you choose otherwise.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -271,14 +271,14 @@
     development tools. It may be necessary to install extra
     development packages to get the headers, or the documentation, or
     the source: please consult your vendor for details.
-    </para> 
-    <para> 
-    To build and install from the GNU GCC sources, please consult the 
+    </para>
+    <para>
+    To build and install from the GNU GCC sources, please consult the
     <link linkend="manual.intro.setup">setup
     documentation</link> for detailed
     instructions. You may wish to browse those files ahead
     of time to get a feel for what's required.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -313,12 +313,12 @@
     <para>
     Libstdc++ comes with its own validation testsuite, which includes
     conformance testing, regression testing, ABI testing, and
-    performance testing. Please consult the 
+    performance testing. Please consult the
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/install/test.html">testing
     documentation</link> for GCC and
     <link linkend="manual.intro.setup.test">Testing</link> in the libstdc++
     manual for more details.
-    </para> 
+    </para>
     <para>
     If you find bugs in the testsuite programs themselves, or if you
     think of a new test program that should be added to the suite,
@@ -432,7 +432,7 @@
       using anything from the rest of the library, such as IOStreams
       or vectors, then you'll still need pieces from
       <filename class="libraryfile">libstdc++.a</filename>.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -465,7 +465,7 @@
     is only possible to a certain extent; the object files in question contain
     template classes and template functions, pre-instantiated, and
     splitting those up causes severe maintenance headaches.
-    </para> 
+    </para>
     <para>
     On supported platforms, libstdc++ takes advantage of garbage
     collection in the GNU linker to get a result similar to separating
@@ -495,12 +495,12 @@
   <answer xml:id="a-other_compilers">
     <para>
     Perhaps.
-    </para> 
+    </para>
     <para>
     Since the goal of ISO Standardization is for all C++
     implementations to be able to share code, libstdc++ should be
     usable under any ISO-compliant compiler, at least in theory.
-    </para> 
+    </para>
     <para>
     However, the reality is that libstdc++ is targeted and optimized
     for GCC/G++. This means that often libstdc++ uses specific,
@@ -515,7 +515,7 @@
     been known to work with versions of the EDG C++ compiler, and
     vendor-specific proprietary C++ compilers such as the Intel ICC
     C++ compiler.
-    </para> 
+    </para>
 
   </answer>
 </qandaentry>
@@ -533,16 +533,16 @@
     <para>
     By default we try to support the C99 <type>long long</type> type.
     This requires that certain functions from your C library be present.
-    </para> 
-    <para> 
+    </para>
+    <para>
     Up through release 3.0.2 the platform-specific tests performed by
     libstdc++ were too general, resulting in a conservative approach
     to enabling the <type>long long</type> code paths. The most
     commonly reported platform affected was Solaris.
-    </para> 
-    <para> 
+    </para>
+    <para>
     This has been fixed for libstdc++ releases greater than 3.0.3.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -651,10 +651,10 @@
     make mips* use the generic implementation instead.  You can also
     configure for mipsel-elf as a workaround.
     </para>
-    <para>    
+    <para>
     The mips*-*-linux* port continues to use the MIPS II routines, and more
     work in this area is expected.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -700,9 +700,9 @@
     enable <type>wchar_t</type> and C++ library structures
     like <classname>wstring</classname> were present. This impacted Solaris,
     Darwin, and BSD variants, and is fixed in libstdc++ versions post 4.1.0.
-    </para> 
-    <para> 
-    </para> 
+    </para>
+    <para>
+    </para>
   </answer>
 </qandaentry>
 
@@ -728,14 +728,14 @@
     for <type>wchar_t</type> and <type>long long</type> specializations,
     and details of thread support.
     </para>
-    <para>    
-    Long answer: See the implementation status pages for 
+    <para>
+    Long answer: See the implementation status pages for
     <link linkend="status.iso.1998">C++98</link>,
     <link linkend="status.iso.tr1">TR1</link>,
     <link linkend="status.iso.2011">C++11</link>,
     <link linkend="status.iso.2014">C++14</link>, and
     <link linkend="status.iso.2017">C++17</link>.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -747,7 +747,7 @@
   </question>
   <answer xml:id="a-standard_bugs">
     <para>
-    Unfortunately, there are some. 
+    Unfortunately, there are some.
     </para>
     <para>
     For those people who are not part of the ISO Library Group
@@ -758,7 +758,7 @@
     website</link>.
     Many of these issues have resulted in
     <link linkend="manual.intro.status.bugs.iso">code changes in libstdc++</link>.
-    </para> 
+    </para>
     <para>
     If you think you've discovered a new bug that is not listed,
     please post a message describing your problem to the author of
@@ -784,12 +784,12 @@
     or an older version of the GNU compilers. Third, you can find more
     information on the libstdc++ and the GCC mailing lists: search
     these lists with terms describing your issue.
-    </para> 
-    <para> 
+    </para>
+    <para>
     Before reporting a bug, please examine the
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://gcc.gnu.org/bugs/">bugs database</link>, with the
     component set to <quote>c++</quote>.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -824,7 +824,7 @@
     fs.close();
     fs.open("a_new_file");
     </programlisting>
-    
+
     <para>
     All operations on the re-opened <varname>fs</varname> would fail, or at
     least act very strangely, especially if <varname>fs</varname> reached the
@@ -840,7 +840,7 @@
     of <link linkend="manual.bugs.dr409">DR #409</link> and
     <function>open()</function>
     now calls <function>clear()</function> on success.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -859,7 +859,7 @@
     necessarily trying to be OO. The option also enforces outdated guidelines
     from old editions of the books, and the advice isn't all relevant to
     modern C++ (especially C++11 and later).
-    </para> 
+    </para>
     <para>
     We do, however, try to have libstdc++ sources as clean as possible. If
     you see some simple changes that pacify <option>-Weffc++</option>
@@ -889,7 +889,7 @@
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/ml/libstdc++/2001-01/msg00247.html">sums
       things up here</link>.  The collisions with vector/string iterator
     types have been fixed for 3.1.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -947,7 +947,7 @@
     checks, is available in the
     <link linkend="std.diagnostics.concept_checking">Diagnostics</link>.
     chapter of the manual.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1013,7 +1013,7 @@
     want to test the library for memory leaks please read
     <link linkend="debug.memory">Tips for memory leak hunting</link>
     first.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1028,7 +1028,7 @@
     See
     the <link linkend="std.containers">Containers</link>
     chapter.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1056,7 +1056,7 @@
     fixes.  Bugs have a way of being reintroduced; if an old bug
     creeps back in, it will be caught immediately by the testsuite -
     but only if such a test exists.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1150,9 +1150,9 @@
     compatibility</link> documentation.
     </para>
     <para>
-    The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://web.archive.org/web/20171225062613/http://www.sgi.com/tech/stl/FAQ.html">FAQ</link>
+    The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://web.archive.org/web/20171104092813/http://www.sgi.com/tech/stl/FAQ.html">FAQ</link>
     for SGI's STL is still recommended reading.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1165,7 +1165,7 @@
   <answer xml:id="a-extensions_and_backwards_compat">
     <para>
       See the <link linkend="manual.appendix.porting.backwards">link</link> on backwards compatibility and <link linkend="appendix.porting.api">link</link> on evolution.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1206,7 +1206,7 @@
     <para>
     Please refer to the <link linkend="appendix.contrib">Contributing</link>
     section in our manual.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1272,7 +1272,7 @@
     so they may later be changed.  Deciding which, and implementing
     the decisions, must happen before you can reasonably document a
     candidate C++ ABI that encompasses the standard library.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
@@ -1302,7 +1302,7 @@
     <para>
     See <link linkend="strings.string.shrink">Shrink-to-fit
     strings</link> for a similar solution for strings.
-    </para> 
+    </para>
   </answer>
 </qandaentry>
 
diff --git a/libstdc++-v3/doc/xml/manual/abi.xml b/libstdc++-v3/doc/xml/manual/abi.xml
index 969edd7c834..7aec810d45f 100644
--- a/libstdc++-v3/doc/xml/manual/abi.xml
+++ b/libstdc++-v3/doc/xml/manual/abi.xml
@@ -267,10 +267,11 @@ compatible.
     <listitem><para>GCC 6.1.0: libstdc++.so.6.0.22</para></listitem>
     <listitem><para>GCC 7.1.0: libstdc++.so.6.0.23</para></listitem>
     <listitem><para>GCC 7.2.0: libstdc++.so.6.0.24</para></listitem>
-    <listitem><para>GCC 8.0.0: libstdc++.so.6.0.25</para></listitem>
+    <listitem><para>GCC 8.1.0: libstdc++.so.6.0.25</para></listitem>
     <listitem><para>GCC 9.1.0: libstdc++.so.6.0.26</para></listitem>
     <listitem><para>GCC 9.2.0: libstdc++.so.6.0.27</para></listitem>
     <listitem><para>GCC 9.3.0: libstdc++.so.6.0.28</para></listitem>
+    <listitem><para>GCC 10.1.0: libstdc++.so.6.0.28</para></listitem>
     </itemizedlist>
     <para>
       Note 1: Error should be libstdc++.so.3.0.3.
@@ -340,8 +341,12 @@ compatible.
     <listitem><para>GCC 6.1.0: GLIBCXX_3.4.22, CXXABI_1.3.10</para></listitem>
     <listitem><para>GCC 7.1.0: GLIBCXX_3.4.23, CXXABI_1.3.11</para></listitem>
     <listitem><para>GCC 7.2.0: GLIBCXX_3.4.24, CXXABI_1.3.11</para></listitem>
-    <listitem><para>GCC 8.0.0: GLIBCXX_3.4.25, CXXABI_1.3.11</para></listitem>
-    <listitem><para>GCC 9.0.0: GLIBCXX_3.4.26, CXXABI_1.3.11</para></listitem>
+    <listitem><para>GCC 8.1.0: GLIBCXX_3.4.25, CXXABI_1.3.11</para></listitem>
+    <listitem><para>GCC 9.1.0: GLIBCXX_3.4.26, CXXABI_1.3.12</para></listitem>
+    <listitem><para>GCC 9.2.0: GLIBCXX_3.4.27, CXXABI_1.3.12</para></listitem>
+    <listitem><para>GCC 9.3.0: GLIBCXX_3.4.28, CXXABI_1.3.12</para></listitem>
+    <listitem><para>GCC 10.1.0: GLIBCXX_3.4.28, CXXABI_1.3.12</para></listitem>
+
     </itemizedlist>
     </listitem>
 
diff --git a/libstdc++-v3/doc/xml/manual/configure.xml b/libstdc++-v3/doc/xml/manual/configure.xml
index d296c8d8a49..3370bc883b7 100644
--- a/libstdc++-v3/doc/xml/manual/configure.xml
+++ b/libstdc++-v3/doc/xml/manual/configure.xml
@@ -198,7 +198,8 @@
 
  <varlistentry><term><code>--enable-libstdcxx-debug-flags=FLAGS</code></term>
 
- <listitem><para>This option is only valid when <code> --enable-debug </code>
+ <listitem><para>This option is only valid when
+	<code>--enable-libstdcxx-debug</code>
 	is also specified, and applies to the debug builds only. With
 	this option, you can pass a specific string of flags to the
 	compiler to use when building the debug versions of libstdc++.
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
index 44a042c2724..df3b2c80d20 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
@@ -18,7 +18,7 @@ This status table is based on the table of contents of ISO/IEC 14882:2003.
 </para>
 
 <para>
-This page describes the C++ support in the GCC 9 series.
+This section describes the C++ support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
index 568102823b0..431eb02bb6b 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2011.xml
@@ -27,7 +27,11 @@ presence of the required flag.
 </para>
 
 <para>
-This page describes the C++11 support in the GCC 9 series.
+This status table is based on the table of contents of ISO/IEC 14882:2011.
+</para>
+
+<para>
+This section describes the C++11 support in the GCC 9 series.
 </para>
 
 <!-- Status is Yes or No, Broken/Partial-->
@@ -70,7 +74,7 @@ This page describes the C++11 support in the GCC 9 series.
     <row>
       <entry>18.1</entry>
       <entry>General</entry>
-      <entry>Y</entry>
+      <entry/>
       <entry/>
     </row>
     <row>
@@ -264,7 +268,7 @@ This page describes the C++11 support in the GCC 9 series.
     <row>
       <entry>19.1</entry>
       <entry>General</entry>
-      <entry>Y</entry>
+      <entry/>
       <entry/>
     </row>
     <row>
@@ -349,13 +353,13 @@ This page describes the C++11 support in the GCC 9 series.
     </row>
     <row>
       <entry>20.2.2</entry>
-      <entry>Swap</entry>
+      <entry>swap</entry>
       <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>20.2.3</entry>
-      <entry><code>forward</code> and <code>move</code> helpers</entry>
+      <entry>forward/move helpers</entry>
       <entry>Y</entry>
       <entry/>
     </row>
@@ -626,7 +630,7 @@ This page describes the C++11 support in the GCC 9 series.
     <row>
       <entry>20.7.2</entry>
       <entry>Shared-ownership pointers</entry>
-      <entry>Y</entry>
+      <entry/>
       <entry/>
     </row>
     <row>
@@ -652,7 +656,7 @@ This page describes the C++11 support in the GCC 9 series.
     </row>
     <row>
       <entry>20.7.2.4</entry>
-      <entry>Class template <code>emable_shared_from_this</code></entry>
+      <entry>Class template <code>enable_shared_from_this</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
@@ -1114,9 +1118,7 @@ This page describes the C++11 support in the GCC 9 series.
       <entry>21.7</entry>
       <entry>Null-terminated sequence utilities</entry>
       <entry>Partial</entry>
-      <entry>C library dependency.
-      Missing <filename class="headerfile">&lt;cuchar&gt;</filename>
-      </entry>
+      <entry>C library dependency. </entry>
     </row>
     <row>
       <entry>
@@ -1635,7 +1637,7 @@ This page describes the C++11 support in the GCC 9 series.
     <row>
       <entry>26.1</entry>
       <entry>General</entry>
-      <entry>Y</entry>
+      <entry/>
       <entry/>
     </row>
     <row>
@@ -1988,31 +1990,31 @@ This page describes the C++11 support in the GCC 9 series.
     </row>
     <row>
       <entry>26.7.2</entry>
-      <entry><code>accumulate</code></entry>
+      <entry>Accumulate></entry>
       <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>26.7.3</entry>
-      <entry><code>inner_product</code></entry>
+      <entry>Inner product</entry>
       <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>26.7.4</entry>
-      <entry><code>partial_sum</code></entry>
+      <entry>Partial sum</entry>
       <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>26.7.5</entry>
-      <entry><code>adjacent_difference</code></entry>
+      <entry>Adjacent difference</entry>
       <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>26.7.6</entry>
-      <entry>iota</entry>
+      <entry>Iota</entry>
       <entry>Y</entry>
       <entry/>
     </row>
@@ -2230,10 +2232,9 @@ This page describes the C++11 support in the GCC 9 series.
       <entry/>
     </row>
     <row>
-      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>29.3</entry>
       <entry>Order and consistency</entry>
-      <entry>Partial</entry>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
@@ -2396,10 +2397,14 @@ This page describes the C++11 support in the GCC 9 series.
       <entry/>
     </row>
     <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
       <entry>30.4.4.2</entry>
       <entry>Function <code>call_once</code></entry>
-      <entry>Y</entry>
-      <entry/>
+      <entry>Broken</entry>
+      <entry>See <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	xlink:href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146">PR
+	66146</link>
+      </entry>
     </row>
     <row>
       <entry>30.5</entry>
@@ -2514,43 +2519,43 @@ This page describes the C++11 support in the GCC 9 series.
     <row>
       <entry>D.5</entry>
       <entry>C standard library headers</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.6</entry>
       <entry>Old iostreams members</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.7</entry>
       <entry><code>char*</code> streams</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.8</entry>
       <entry>Function objects</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.9</entry>
       <entry>Binders</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.10</entry>
       <entry><code>auto_ptr</code></entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
     <row>
       <entry>D.11</entry>
       <entry>Violating exception-specifications</entry>
-      <entry/>
+      <entry>Y</entry>
       <entry/>
     </row>
 
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
index 7b604307c8e..f0872f6f8d0 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2014.xml
@@ -1,4 +1,4 @@
-<section xmlns="http://docbook.org/ns/docbook" version="5.0" 
+<section xmlns="http://docbook.org/ns/docbook" version="5.0"
 	 xml:id="status.iso.2014" xreflabel="Status C++ 2014">
 <?dbhtml filename="status_iso_cxx2014.html"?>
 
@@ -20,9 +20,24 @@ presence of the required flag.
 </para>
 
 <para>
-This page describes the C++14 and library TS support in the GCC 9 series.
+This status table is based on the table of contents of ISO/IEC 14882:2014.
+Some subclauses are not shown in the table where the content is unchanged
+since C++11 and the implementation is complete.
 </para>
 
+<para>
+This section describes the C++14 and library TS support in the GCC 9 series.
+</para>
+
+<!-- Status is Yes or No, Broken/Partial-->
+<!--
+   Yes
+
+   No
+      <?dbhtml bgcolor="#C8B0B0" ?>
+   Broken/Partial
+      <?dbhtml bgcolor="#B0B0B0" ?>
+-->
 <table frame="all" xml:id="table.cxx14_status">
 <title>C++ 2014 Implementation Status</title>
 
@@ -31,10 +46,10 @@ This page describes the C++14 and library TS support in the GCC 9 series.
 <colspec colname="c2"/>
 <colspec colname="c3"/>
 <colspec colname="c4"/>
-  <thead>
+<thead>
     <row>
-      <entry>Paper</entry>
-      <entry>Title</entry>
+      <entry>Section</entry>
+      <entry>Description</entry>
       <entry>Status</entry>
       <entry>Comments</entry>
     </row>
@@ -44,210 +59,1501 @@ This page describes the C++14 and library TS support in the GCC 9 series.
 
     <row>
       <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3669.pdf">
-	  N3669
-	</link>
+	<emphasis>18</emphasis>
       </entry>
-      <entry>Fixing constexpr member functions without const</entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Language support</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry>18.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.2</entry>
+      <entry>Types</entry>
       <entry>Y</entry>
       <entry/>
     </row>
+    <row>
+      <entry>18.3</entry>
+      <entry>Implementation properties</entry>
+      <entry/>
+      <entry/>
+    </row>
 
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3668.html">
-	  N3668
-	</link>
-      </entry>
-      <entry><code>exchange()</code> utility function</entry>
+      <entry>18.3.2</entry>
+      <entry>Numeric Limits</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.3.2.3</entry>
+      <entry>Class template <code>numeric_limits</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3670.html">
-	  N3670
-	</link>
-      </entry>
-      <entry>Wording for Addressing Tuples by Type</entry>
+      <entry>18.3.2.4</entry>
+      <entry><code>numeric_limits</code> members</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3656.htm">
-	  N3656
-	</link>
-      </entry>
-      <entry><code>make_unique</code></entry>
+      <?dbhtml bgcolor="#C8B0B0" ?>
+      <entry>18.3.2.5</entry>
+      <entry><code>float_round_style</code></entry>
+      <entry>N</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#C8B0B0" ?>
+      <entry>18.3.2.6</entry>
+      <entry><code>float_denorm_style</code></entry>
+      <entry>N</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.3.2.7</entry>
+      <entry><code>numeric_limits</code> specializations</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3462.html">
-	  N3462
-	</link>
-      </entry>
-      <entry><code>std::result_of</code> and SFINAE</entry>
+      <entry>18.3.3</entry>
+      <entry>C Library</entry>
       <entry>Y</entry>
       <entry/>
     </row>
 
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3545.pdf">
-	  N3545
-	</link>
-      </entry>
-      <entry>An Incremental Improvement to <code>integral_constant</code></entry>
+      <entry>18.4</entry>
+      <entry>Integer types</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.4.1</entry>
+      <entry>Header <code>&lt;cstdint&gt;</code> synopsis</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3642.pdf">
-	  N3642
-	</link>
-      </entry>
-      <entry>User-defined Literals for Standard Library Types</entry>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>18.5</entry>
+      <entry>Start and termination</entry>
+      <entry>Partial</entry>
+      <entry>C library dependency for quick_exit, at_quick_exit</entry>
+    </row>
+    <row>
+      <entry>18.6</entry>
+      <entry>Dynamic memory management</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3671.html">
-	  N3671
-	</link>
-      </entry>
-      <entry>Making non-modifying sequence operations more robust</entry>
+      <entry>18.7</entry>
+      <entry>Type identification</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.7.1</entry>
+      <entry>Class type_info</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3654.html">
-	  N3654
-	</link>
-      </entry>
-      <entry>Quoted Strings Library Proposal</entry>
+      <entry>18.7.2</entry>
+      <entry>Class bad_cast</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3469.html">
-	  N3469
-	</link>
-      </entry>
-      <entry>Constexpr Library Additions: chrono</entry>
+      <entry>18.7.3</entry>
+      <entry>Class bad_typeid</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3470.html">
-	  N3470
-	</link>
-      </entry>
-      <entry>Constexpr Library Additions: containers</entry>
+      <entry>18.8</entry>
+      <entry>Exception handling</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.1</entry>
+      <entry>Class exception</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.2</entry>
+      <entry>Class bad_exception</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.3</entry>
+      <entry>Abnormal termination</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.4</entry>
+      <entry><code>uncaught_exception</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.5</entry>
+      <entry>Exception Propagation</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.8.6</entry>
+      <entry><code>nested_exception</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.9</entry>
+      <entry>Initializer lists</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.9.1</entry>
+      <entry>Initializer list constructors</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.9.2</entry>
+      <entry>Initializer list access</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.9.3</entry>
+      <entry>Initializer list range access</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>18.10</entry>
+      <entry>Other runtime support</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
       <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3471.html">
-	  N3471
-	</link>
+	<emphasis>19</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Diagnostics</emphasis>
       </entry>
-      <entry>Constexpr Library Additions: utilities</entry>
+    </row>
+    <row>
+      <entry>19.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.2</entry>
+      <entry>Exception classes</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.3</entry>
+      <entry>Assertions</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.4</entry>
+      <entry>Error numbers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5</entry>
+      <entry>System error support</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5.1</entry>
+      <entry>Class <code>error_category</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5.2</entry>
+      <entry>Class <code>error_code</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5.3</entry>
+      <entry>Class <code>error_condition</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5.4</entry>
+      <entry>Comparison operators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>19.5.5</entry>
+      <entry>Class <code>system_error</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
-
     <row>
       <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3658.html">
-	  N3658
-	</link>
+	<emphasis>20</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>General utilities</emphasis>
       </entry>
+    </row>
+    <row>
+      <entry>20.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2</entry>
+      <entry>Utility components</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2.1</entry>
+      <entry>Operators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2.2</entry>
+      <entry>swap</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2.3</entry>
+      <entry>exchange</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2.4</entry>
+      <entry>forward/move helpers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.2.5</entry>
+      <entry>Function template <code>declval</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.3</entry>
+      <entry>Pairs</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.4</entry>
+      <entry>Tuples</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.5</entry>
       <entry>Compile-time integer sequences</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.5.2</entry>
+      <entry>Class template <code>integer_sequence</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3659.html">
-	  N3659
-	</link>
-      </entry>
-      <entry>Shared Locking in C++</entry>
+      <entry>20.5.3</entry>
+      <entry>Alias template <code>make_integer_sequence</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2012/n3421.htm">
-	  N3421
-	</link>
-      </entry>
-      <entry>Making Operator Functors greater&lt;&gt;</entry>
+      <entry>20.6</entry>
+      <entry>Class template <code>bitset</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3657.htm">
-	  N3657
-	</link>
-      </entry>
-      <entry>Adding heterogeneous comparison lookup to associative containers</entry>
+      <entry>20.7</entry>
+      <entry>Memory</entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3655.pdf">
-	  N3655
-	</link>
-      </entry>
-      <entry>TransformationTraits Redux</entry>
+      <entry>20.8</entry>
+      <entry>Smart pointers</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.1</entry>
+      <entry>Class template <code>unique_ptr</code></entry>
       <entry>Y</entry>
       <entry/>
     </row>
-
     <row>
-      <?dbhtml bgcolor="#B0B0B0" ?>
-      <entry>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3644.pdf">
-	  N3644
-	</link>
-      </entry>
-      <entry>Null Forward Iterators</entry>
-      <entry>Partial</entry>
-      <entry>Only affects Debug Mode</entry>
+      <entry>20.8.1.1</entry>
+      <entry>Default deleters</entry>
+      <entry>Y</entry>
+      <entry/>
     </row>
-
-  </tbody>
-</tgroup>
-</table>
-
+    <row>
+      <entry>20.8.1.2</entry>
+      <entry><code>unique_ptr</code> for single objects</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.1.3</entry>
+      <entry><code>unique_ptr</code> for array objects with a runtime length</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.1.4</entry>
+      <entry><code>unique_ptr</code> creation</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.1.5</entry>
+      <entry><code>unique_ptr</code> specialized algorithms</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2</entry>
+      <entry>Shared-ownership pointers</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.1</entry>
+      <entry>Class <code>bad_weak_ptr</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.2</entry>
+      <entry>Class template <code>shared_ptr</code></entry>
+      <entry>Y</entry>
+      <entry>
+	  Uses code from
+	  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</link>.
+      </entry>
+    </row>
+    <row>
+      <entry>20.8.2.3</entry>
+      <entry>Class template <code>weak_ptr</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.4</entry>
+      <entry>Class template <code>owner_less</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.5</entry>
+      <entry>Class template <code>enable_shared_from_this</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.6</entry>
+      <entry><code>shared_ptr</code> atomic access</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.2.7</entry>
+      <entry>Smart pointer hash support</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9</entry>
+      <entry>Function objects</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.1</entry>
+      <entry>Definitions</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.2</entry>
+      <entry>Requirements</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.3</entry>
+      <entry>Class template <code>reference_wrapper</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.4</entry>
+      <entry>Arithmetic operation</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.5</entry>
+      <entry>Comparisons</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.8.6</entry>
+      <entry>Logical operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.7</entry>
+      <entry>Bitwise operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.8</entry>
+      <entry>Negators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.9</entry>
+      <entry>Function object binders</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.10</entry>
+      <entry>Function template <code>mem_fn</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.11</entry>
+      <entry>Polymorphic function wrappers</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.9.11.1</entry>
+      <entry>Class <code>bad_function_call</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>20.9.11.2</entry>
+      <entry>Class template <code>function</code></entry>
+      <entry>Partial</entry>
+      <entry>Missing allocator support</entry>
+    </row>
+    <row>
+      <entry>20.9.12</entry>
+      <entry>Class template <code>hash</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10</entry>
+      <entry>Metaprogramming and type traits</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.1</entry>
+      <entry>Requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.2</entry>
+      <entry>Header <code>&lt;type_traits&gt;</code> synopsis</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.3</entry>
+      <entry>Helper classes</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.4</entry>
+      <entry>Unary Type Traits</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.5</entry>
+      <entry>Type property queries</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.6</entry>
+      <entry>Relationships between types</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.10.7</entry>
+      <entry>Transformations between types</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.11</entry>
+      <entry>Compile-time rational arithmetic</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12</entry>
+      <entry>Time utilities</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.3</entry>
+      <entry>Clock requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.4</entry>
+      <entry>Time-related traits</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.5</entry>
+      <entry>Class template <code>duration</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.5.8</entry>
+      <entry>Suffixes for duration literals</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.6</entry>
+      <entry>Class template <code>time_point</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.7</entry>
+      <entry>Clocks</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.12.8</entry>
+      <entry>Date and time functions</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.13</entry>
+      <entry>Scoped allocator adaptor</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>20.14</entry>
+      <entry>Class <code>type_index</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>21</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Strings</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>21.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.2</entry>
+      <entry>Character traits</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.3</entry>
+      <entry>String classes</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.4</entry>
+      <entry>Class template <code>basic_string</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.5</entry>
+      <entry>Numeric Conversions</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.6</entry>
+      <entry>Hash support</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>21.7</entry>
+      <entry>Suffixes for <code>basic_string</code> literals</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>21.7</entry>
+      <entry>Null-terminated sequence utilities</entry>
+      <entry>Partial</entry>
+      <entry>C library dependency. </entry>
+    </row>
+    <row>
+      <entry>
+	<emphasis>22</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Localization</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>22.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>22.2</entry>
+      <entry>Header <code>&lt;locale&gt;</code> synopsis</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>22.3</entry>
+      <entry>Locales</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>22.4</entry>
+      <entry>Standard <code>locale</code> categories</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>22.5</entry>
+      <entry>Standard code conversion facets</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>22.6</entry>
+      <entry>C Library Locales</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>23</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Containers</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>23.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>23.2</entry>
+      <entry>Container requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>23.3</entry>
+      <entry>Sequence containers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>23.4</entry>
+      <entry>Associative containers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>23.5</entry>
+      <entry>Unordered associative containers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>23.6</entry>
+      <entry>Container adaptors</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>24</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Iterators</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>24.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.2</entry>
+      <entry>Iterator requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.3</entry>
+      <entry>Header <code>&lt;iterator&gt;</code> synopsis</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.4</entry>
+      <entry>Iterator primitives</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.5</entry>
+      <entry>Iterator adaptors</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.6</entry>
+      <entry>Stream iterators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>24.7</entry>
+      <entry>range access</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>25</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Algorithms</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>25.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>25.2</entry>
+      <entry>Non-modifying sequence operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>25.3</entry>
+      <entry>Mutating sequence operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>25.4</entry>
+      <entry>Sorting and related operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>25.5</entry>
+      <entry>C library algorithms</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+      <emphasis>26</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Numerics</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>26.1</entry>
+      <entry>General</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.2</entry>
+      <entry>Numeric type requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.3</entry>
+      <entry>The floating-point environment</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.4</entry>
+      <entry>Complex numbers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.4.10</entry>
+      <entry>Suffixes for complex number literals</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.5</entry>
+      <entry>Random number generation</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.6</entry>
+      <entry>Numeric arrays</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.7</entry>
+      <entry>Generalized numeric operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>26.8</entry>
+      <entry>C Library</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>27</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Input/output library</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>27.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.2</entry>
+      <entry>Iostreams requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.2.1</entry>
+      <entry>Imbue Limitations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.2.2</entry>
+      <entry>Positioning Type Limitations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>27.2.3</entry>
+      <entry>Thread safety</entry>
+      <entry>Partial</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.3</entry>
+      <entry>Forward declarations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.4</entry>
+      <entry>Standard iostream objects</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.5</entry>
+      <entry>Iostreams base classes</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.6</entry>
+      <entry>Stream buffers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.7</entry>
+      <entry>Formatting and manipulators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.7.6</entry>
+      <entry>Quoted manipulators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.8</entry>
+      <entry>String-based streams</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>27.9</entry>
+      <entry>File-based streams</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>28</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Regular expressions</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>28.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.2</entry>
+      <entry>Definitions</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.3</entry>
+      <entry>Requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.4</entry>
+      <entry>Header <code>&lt;regex&gt;</code> synopsis</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.5</entry>
+      <entry>Namespace <code>std::regex_constants</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.6</entry>
+      <entry>Class <code>regex_error</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>28.7</entry>
+      <entry>Class template <code>regex_traits</code></entry>
+      <entry>Partial</entry>
+      <entry><code>transform_primary</code> is not correctly implemented</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.8</entry>
+      <entry>Class template <code>basic_regex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.9</entry>
+      <entry>Class template <code>sub_match</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.10</entry>
+      <entry>Class template <code>match_results</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.11</entry>
+      <entry>Regular expression algorithms</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.12</entry>
+      <entry>Regular expression Iterators</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>28.13</entry>
+      <entry>Modified ECMAScript regular expression grammar</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>29</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Atomic operations</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>29.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.2</entry>
+      <entry>Header <code>&lt;atomic&gt;</code> synopsis</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.3</entry>
+      <entry>Order and consistency</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.4</entry>
+      <entry>Lock-free property</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.5</entry>
+      <entry>Atomic types</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.6</entry>
+      <entry>Operations on atomic types</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.7</entry>
+      <entry>Flag Type and operations</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>29.8</entry>
+      <entry>Fences</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>30</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Thread support</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>30.1</entry>
+      <entry>General</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.2</entry>
+      <entry>Requirements</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.3</entry>
+      <entry>Threads</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>30.3.1</entry>
+      <entry>Class <code>thread</code></entry>
+      <entry>Partial</entry>
+      <entry><code>thread::id</code> comparisons not well-defined</entry>
+    </row>
+    <row>
+      <entry>30.3.2</entry>
+      <entry>Namespace <code>this_thread</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4</entry>
+      <entry>Mutual exclusion</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1</entry>
+      <entry>Mutex requirements</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.1</entry>
+      <entry>In general</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.2</entry>
+      <entry>Mutex types</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.2.1</entry>
+      <entry>Class <code>mutex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.2.2</entry>
+      <entry>Class <code>recursive_mutex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.3</entry>
+      <entry>Timed mutex types</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.3.1</entry>
+      <entry>Class <code>timed_mutex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.3.2</entry>
+      <entry>Class <code>recursive_timed_mutex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.4</entry>
+      <entry>Shared timed mutex types</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.1.4.1</entry>
+      <entry>Class <code>shared_timed_mutex</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.2</entry>
+      <entry>Locks</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.2.1</entry>
+      <entry>Class template <code>lock_guard</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.2.2</entry>
+      <entry>Class template <code>unique_lock</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.2.3</entry>
+      <entry>Class template <code>shared_lock</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.3</entry>
+      <entry>Generic locking algorithms</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.4</entry>
+      <entry>Call once</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.4.4.1</entry>
+      <entry>Struct <code>once_flag</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry>30.4.4.2</entry>
+      <entry>Function <code>call_once</code></entry>
+      <entry>Broken</entry>
+      <entry>See <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	xlink:href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146">PR
+	66146</link>
+      </entry>
+    </row>
+    <row>
+      <entry>30.5</entry>
+      <entry>Condition variables</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.5.1</entry>
+      <entry>Class <code>condition_variable</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.5.2</entry>
+      <entry>Class <code>condition_variable_any</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6</entry>
+      <entry>Futures</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.1</entry>
+      <entry>Overview</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.2</entry>
+      <entry>Error handling</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.3</entry>
+      <entry>Class <code>future_error</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.4</entry>
+      <entry>Shared state</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.5</entry>
+      <entry>Class template <code>promise</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.6</entry>
+      <entry>Class template <code>future</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.7</entry>
+      <entry>Class template <code>shared_future</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.8</entry>
+      <entry>Function template <code>async</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>30.6.9</entry>
+      <entry>Class template <code>packaged_task</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>
+	<emphasis>Appendix D</emphasis>
+      </entry>
+      <entry namest="c2" nameend="c4" align="left">
+	<emphasis>Compatibility features</emphasis>
+      </entry>
+    </row>
+    <row>
+      <entry>D.1</entry>
+      <entry>Increment operator with <code>bool</code> operand</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.2</entry>
+      <entry><code>register</code> keyword</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.3</entry>
+      <entry>Implicit declaration of copy functions</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.4</entry>
+      <entry>Dynamic exception specifications</entry>
+      <entry/>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.5</entry>
+      <entry>C standard library headers</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.6</entry>
+      <entry>Old iostreams members</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.7</entry>
+      <entry><code>char*</code> streams</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.8</entry>
+      <entry>Function objects</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.9</entry>
+      <entry>Binders</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.10</entry>
+      <entry><code>auto_ptr</code></entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.11</entry>
+      <entry>Violating exception-specifications</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+    <row>
+      <entry>D.12</entry>
+      <entry>Random shuffle</entry>
+      <entry>Y</entry>
+      <entry/>
+    </row>
+
+  </tbody>
+</tgroup>
+</table>
 
 <table frame="all" xml:id="table.ts_status">
 <title>C++ Technical Specifications Implementation Status</title>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
index e1513142415..898b029e66b 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
@@ -468,7 +468,7 @@ Feature-testing recommendations for C++</link>.
 	</link>
       </entry>
       <entry align="center"> 7.1 </entry>
-      <entry><code> __cpp_lib_is_callable >= 201603 </code></entry>
+      <entry><code> __cpp_lib_is_invocable >= 201703 </code></entry>
     </row>
 
     <row>
diff --git a/libstdc++-v3/include/bits/alloc_traits.h b/libstdc++-v3/include/bits/alloc_traits.h
index cda768bf391..a81122e7a64 100644
--- a/libstdc++-v3/include/bits/alloc_traits.h
+++ b/libstdc++-v3/include/bits/alloc_traits.h
@@ -248,8 +248,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
 			       is_constructible<_Tp, _Args...>>>
 	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
-	noexcept(noexcept(::new((void*)__p)
-			  _Tp(std::forward<_Args>(__args)...)))
+	noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 	{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }
 
       template<typename _Alloc2, typename _Tp>
@@ -262,7 +261,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Alloc2, typename _Tp>
 	static void
 	_S_destroy(_Alloc2&, _Tp* __p, ...)
-	noexcept(noexcept(__p->~_Tp()))
+	noexcept(std::is_nothrow_destructible<_Tp>::value)
 	{ __p->~_Tp(); }
 
       template<typename _Alloc2>
@@ -333,7 +332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { __a.deallocate(__p, __n); }
 
       /**
-       *  @brief  Construct an object of type @a _Tp
+       *  @brief  Construct an object of type `_Tp`
        *  @param  __a  An allocator.
        *  @param  __p  Pointer to memory of suitable size and alignment for Tp
        *  @param  __args Constructor arguments.
@@ -480,7 +479,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up, typename... _Args>
 	static void
 	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
-	noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
+	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 	{ __a.construct(__p, std::forward<_Args>(__args)...); }
 
       /**
diff --git a/libstdc++-v3/include/bits/allocator.h b/libstdc++-v3/include/bits/allocator.h
index f0f8fe41e31..664b2ea4127 100644
--- a/libstdc++-v3/include/bits/allocator.h
+++ b/libstdc++-v3/include/bits/allocator.h
@@ -88,14 +88,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up, typename... _Args>
 	void
 	construct(_Up* __p, _Args&&... __args)
-	noexcept(noexcept(::new((void *)__p)
-			    _Up(std::forward<_Args>(__args)...)))
+	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 
       template<typename _Up>
 	void
 	destroy(_Up* __p)
-	noexcept(noexcept(__p->~_Up()))
+	noexcept(std::is_nothrow_destructible<_Up>::value)
 	{ __p->~_Up(); }
 #endif
     };
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index e30caef91bf..52b8f8511d6 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -817,7 +817,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }
     };
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/basic_ios.h b/libstdc++-v3/include/bits/basic_ios.h
index e203af1dd8b..7b72b0d55c0 100644
--- a/libstdc++-v3/include/bits/basic_ios.h
+++ b/libstdc++-v3/include/bits/basic_ios.h
@@ -67,7 +67,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_ios : public ios_base
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -78,9 +78,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename _Traits::pos_type             pos_type;
       typedef typename _Traits::off_type             off_type;
       typedef _Traits                                traits_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These are non-standard types.
       */
@@ -89,7 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 						     __num_put_type;
       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 						     __num_get_type;
-      //@}
+      ///@}
 
       // Data members:
     protected:
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       const __num_get_type*                          _M_num_get;
 
     public:
-      //@{
+      ///@{
       /**
        *  @brief  The quick-and-easy status check.
        *
@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       operator!() const
       { return this->fail(); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns the error state of the stream buffer.
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 40ef8758a51..cacc31a9aa9 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -4660,10 +4660,9 @@ _GLIBCXX_END_NAMESPACE_CXX11
 
       /**
        *  @brief  Insert a string_view.
-       *  @param __pos  Iterator referencing position in string to insert at.
-       *  @param __svt  The object convertible to string_view to insert from.
-       *  @param __pos  Iterator referencing position in string_view to insert
-       *  from.
+       *  @param __pos1  Position in string to insert at.
+       *  @param __svt   The object convertible to string_view to insert from.
+       *  @param __pos2  Position in string_view to insert from.
        *  @param __n    The number of characters to insert.
        *  @return  Reference to this string.
       */
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index 7e0962edd19..d2c2efe1c06 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -77,6 +77,7 @@
 // Macros for deprecated attributes.
 //   _GLIBCXX_USE_DEPRECATED
 //   _GLIBCXX_DEPRECATED
+//   _GLIBCXX_DEPRECATED_SUGGEST
 //   _GLIBCXX17_DEPRECATED
 #ifndef _GLIBCXX_USE_DEPRECATED
 # define _GLIBCXX_USE_DEPRECATED 1
@@ -84,8 +85,11 @@
 
 #if defined(__DEPRECATED) && (__cplusplus >= 201103L)
 # define _GLIBCXX_DEPRECATED __attribute__ ((__deprecated__))
+# define _GLIBCXX_DEPRECATED_SUGGEST(ALT) \
+  __attribute__ ((__deprecated__ ("use '" ALT "' instead")))
 #else
 # define _GLIBCXX_DEPRECATED
+# define _GLIBCXX_DEPRECATED_SUGGEST(ALT)
 #endif
 
 #if defined(__DEPRECATED) && (__cplusplus >= 201703L)
diff --git a/libstdc++-v3/include/bits/erase_if.h b/libstdc++-v3/include/bits/erase_if.h
index 4641dbebd85..523bbecfab3 100644
--- a/libstdc++-v3/include/bits/erase_if.h
+++ b/libstdc++-v3/include/bits/erase_if.h
@@ -39,7 +39,7 @@ namespace std
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201703L
-# define __cpp_lib_erase_if 201900L
+# define __cpp_lib_erase_if 202002L
 #endif
 
   namespace __detail
diff --git a/libstdc++-v3/include/bits/forward_list.h b/libstdc++-v3/include/bits/forward_list.h
index 4c277845a51..f3bb1a3b460 100644
--- a/libstdc++-v3/include/bits/forward_list.h
+++ b/libstdc++-v3/include/bits/forward_list.h
@@ -1149,7 +1149,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       splice_after(const_iterator __pos, forward_list&,
 		   const_iterator __before, const_iterator __last) noexcept
       { _M_splice_after(__pos, __before, __last); }
-      // @}
+      /// @}
 
     private:
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/include/bits/fs_dir.h b/libstdc++-v3/include/bits/fs_dir.h
index 69f0eb825fe..eaa530c5a74 100644
--- a/libstdc++-v3/include/bits/fs_dir.h
+++ b/libstdc++-v3/include/bits/fs_dir.h
@@ -522,7 +522,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
   // Use explicit instantiations of these types. Any inconsistency in the
diff --git a/libstdc++-v3/include/bits/fs_fwd.h b/libstdc++-v3/include/bits/fs_fwd.h
index a0e3d73e2a3..5cc5ae65ac0 100644
--- a/libstdc++-v3/include/bits/fs_fwd.h
+++ b/libstdc++-v3/include/bits/fs_fwd.h
@@ -379,7 +379,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_regular_file(file_status) noexcept;
   bool is_symlink(file_status) noexcept;
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/fs_ops.h b/libstdc++-v3/include/bits/fs_ops.h
index ee16499a9f9..d1bf3dce361 100644
--- a/libstdc++-v3/include/bits/fs_ops.h
+++ b/libstdc++-v3/include/bits/fs_ops.h
@@ -303,7 +303,7 @@ namespace filesystem
   path weakly_canonical(const path& __p);
   path weakly_canonical(const path& __p, error_code& __ec);
 
-  // @} group filesystem
+  /// @} group filesystem
 } // namespace filesystem
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 5dc624dbb1e..f674d6aec45 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -545,7 +545,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _CharT, typename _Traits, typename _Allocator>
       static basic_string<_CharT, _Traits, _Allocator>
-      _S_str_convert(const string_type&, const _Allocator& __a);
+      _S_str_convert(basic_string_view<value_type>, const _Allocator&);
 
     void _M_split_cmpts();
 
@@ -953,7 +953,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
   template<typename _CharT, typename _Traits, typename _Allocator>
     std::basic_string<_CharT, _Traits, _Allocator>
-    path::_S_str_convert(const string_type& __str, const _Allocator& __a)
+    path::_S_str_convert(basic_string_view<value_type> __str,
+			 const _Allocator& __a)
     {
       static_assert(!is_same_v<_CharT, value_type>);
 
@@ -1063,7 +1064,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 #else
       const value_type __slash = '/';
 #endif
-      string_type __str(__a);
+      using _Alloc2 = typename allocator_traits<_Allocator>::template
+	rebind_alloc<value_type>;
+      basic_string<value_type, char_traits<value_type>, _Alloc2> __str(__a);
 
       if (_M_type() == _Type::_Root_dir)
 	__str.assign(1, __slash);
@@ -1073,9 +1076,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	  bool __add_slash = false;
 	  for (auto& __elem : *this)
 	    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+	      if (__elem._M_type() == _Type::_Root_dir)
+		{
+		  __str += __slash;
+		  continue;
+		}
+#endif
 	      if (__add_slash)
 		__str += __slash;
-	      __str += __elem._M_pathname;
+	      __str += basic_string_view<value_type>(__elem._M_pathname);
 	      __add_slash = __elem._M_type() == _Type::_Filename;
 	    }
 	}
@@ -1256,7 +1266,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem
+  /// @} group filesystem
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace filesystem
 
diff --git a/libstdc++-v3/include/bits/functional_hash.h b/libstdc++-v3/include/bits/functional_hash.h
index 6a27beed754..a1f80632120 100644
--- a/libstdc++-v3/include/bits/functional_hash.h
+++ b/libstdc++-v3/include/bits/functional_hash.h
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #endif
 
-  // @} group hashes
+  /// @} group hashes
 
   // Hint about performance of hash functor. If not fast the hash-based
   // containers will cache the hash code.
diff --git a/libstdc++-v3/include/bits/gslice.h b/libstdc++-v3/include/bits/gslice.h
index 9d1c8e5c0d8..95d37619648 100644
--- a/libstdc++-v3/include/bits/gslice.h
+++ b/libstdc++-v3/include/bits/gslice.h
@@ -177,7 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     return *this;
   }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/gslice_array.h b/libstdc++-v3/include/bits/gslice_array.h
index 8d3999888a5..d184df63b1a 100644
--- a/libstdc++-v3/include/bits/gslice_array.h
+++ b/libstdc++-v3/include/bits/gslice_array.h
@@ -215,7 +215,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/hashtable.h b/libstdc++-v3/include/bits/hashtable.h
index d7d9e9940e3..910cbaecae2 100644
--- a/libstdc++-v3/include/bits/hashtable.h
+++ b/libstdc++-v3/include/bits/hashtable.h
@@ -409,6 +409,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  __hashtable_alloc(__node_alloc_type(__a))
       { }
 
+      template<bool _No_realloc = true>
+	static constexpr bool
+	_S_nothrow_move()
+	{
+#if __cplusplus <= 201402L
+	  return __and_<__bool_constant<_No_realloc>,
+			is_nothrow_copy_constructible<_H1>,
+			is_nothrow_copy_constructible<_Equal>>::value;
+#else
+	  if constexpr (_No_realloc)
+	    if constexpr (is_nothrow_copy_constructible<_H1>())
+	      return is_nothrow_copy_constructible<_Equal>();
+	  return false;
+#endif
+	}
+
+      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+		 true_type /* alloc always equal */)
+	noexcept(_S_nothrow_move());
+
+      _Hashtable(_Hashtable&&, __node_alloc_type&&,
+		 false_type /* alloc always equal */);
+
+
     public:
       // Constructor, destructor, assignment, swap
       _Hashtable() = default;
@@ -426,11 +450,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _Hashtable(const _Hashtable&);
 
-      _Hashtable(_Hashtable&&) noexcept;
+      _Hashtable(_Hashtable&& __ht)
+	noexcept(_S_nothrow_move())
+      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
+		   true_type{})
+      { }
 
       _Hashtable(const _Hashtable&, const allocator_type&);
 
-      _Hashtable(_Hashtable&&, const allocator_type&);
+      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+	noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
+      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
+		   typename __node_alloc_traits::is_always_equal{})
+      { }
 
       // Use delegating constructors.
       explicit
@@ -1249,18 +1281,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht) noexcept
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       true_type /* alloc always equal */)
+    noexcept(_S_nothrow_move())
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(std::move(__ht._M_base_alloc())),
+      __hashtable_alloc(std::move(__a)),
       _M_buckets(__ht._M_buckets),
       _M_bucket_count(__ht._M_bucket_count),
       _M_before_begin(__ht._M_before_begin._M_nxt),
       _M_element_count(__ht._M_element_count),
       _M_rehash_policy(__ht._M_rehash_policy)
     {
-      // Update, if necessary, buckets if __ht is using its single bucket.
+      // Update buckets if __ht is using its single bucket.
       if (__ht._M_uses_single_bucket())
 	{
 	  _M_buckets = &_M_single_bucket;
@@ -1302,11 +1336,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	   typename _Traits>
     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
 	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
-    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
+    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
+	       false_type /* alloc always equal */)
     : __hashtable_base(__ht),
       __map_base(__ht),
       __rehash_base(__ht),
-      __hashtable_alloc(__node_alloc_type(__a)),
+      __hashtable_alloc(std::move(__a)),
       _M_buckets(nullptr),
       _M_bucket_count(__ht._M_bucket_count),
       _M_element_count(__ht._M_element_count),
diff --git a/libstdc++-v3/include/bits/hashtable_policy.h b/libstdc++-v3/include/bits/hashtable_policy.h
index b06c2fb61ab..17b173dee63 100644
--- a/libstdc++-v3/include/bits/hashtable_policy.h
+++ b/libstdc++-v3/include/bits/hashtable_policy.h
@@ -2148,7 +2148,7 @@ namespace __detail
       __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
     }
 
- //@} hashtable-detail
+ ///@} hashtable-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/indirect_array.h b/libstdc++-v3/include/bits/indirect_array.h
index f054b85228f..96938374021 100644
--- a/libstdc++-v3/include/bits/indirect_array.h
+++ b/libstdc++-v3/include/bits/indirect_array.h
@@ -204,7 +204,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/ios_base.h b/libstdc++-v3/include/bits/ios_base.h
index be908b3ffd2..bc96ff6ddc8 100644
--- a/libstdc++-v3/include/bits/ios_base.h
+++ b/libstdc++-v3/include/bits/ios_base.h
@@ -471,12 +471,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus <= 201402L
     // Annex D.6 (removed in C++17)
-    typedef int io_state;
-    typedef int open_mode;
-    typedef int seek_dir;
-
-    typedef std::streampos streampos;
-    typedef std::streamoff streamoff;
+    typedef int io_state
+      _GLIBCXX_DEPRECATED_SUGGEST("std::iostate");
+    typedef int open_mode
+      _GLIBCXX_DEPRECATED_SUGGEST("std::openmode");
+    typedef int seek_dir
+      _GLIBCXX_DEPRECATED_SUGGEST("std::seekdir");
+
+    typedef std::streampos streampos
+      _GLIBCXX_DEPRECATED_SUGGEST("std::streampos");
+    typedef std::streamoff streamoff
+      _GLIBCXX_DEPRECATED_SUGGEST("std::streamoff");
 #endif
 
     // Callbacks;
diff --git a/libstdc++-v3/include/bits/locale_classes.h b/libstdc++-v3/include/bits/locale_classes.h
index 94dcc85a2c0..32ba37255ed 100644
--- a/libstdc++-v3/include/bits/locale_classes.h
+++ b/libstdc++-v3/include/bits/locale_classes.h
@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Cache>
       friend struct __use_cache;
 
-    //@{
+    ///@{
     /**
      *  @brief  Category values.
      *
@@ -104,7 +104,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     static const category messages	= 1L << 5;
     static const category all		= (ctype | numeric | collate |
 					   time  | monetary | messages);
-    //@}
+    ///@}
 
     // Construct/copy/destroy:
 
@@ -643,11 +643,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
@@ -816,11 +816,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate<_CharT>
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT               char_type;
       typedef basic_string<_CharT> string_type;
-      //@}
+      ///@}
 
       explicit
       collate_byname(const char* __s, size_t __refs = 0)
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index 0db24d53e83..53a387d8b87 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -1671,11 +1671,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __numpunct_cache<_CharT>  __cache_type;
 
     protected:
@@ -1953,11 +1953,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -2000,7 +2000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, bool& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2063,9 +2063,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  ios_base::iostate& __err, unsigned long long& __v)  const
       { return this->do_get(__in, __end, __io, __err, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2106,7 +2106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       get(iter_type __in, iter_type __end, ios_base& __io,
 	  ios_base::iostate& __err, long double& __v) const
       { return this->do_get(__in, __end, __io, __err, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric parsing.
@@ -2193,7 +2193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  return __ret;
 	}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric parsing.
        *
@@ -2270,7 +2270,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
 	     long double&) const;
 #endif
-      //@}
+      ///@}
     };
 
   template<typename _CharT, typename _InIter>
@@ -2294,11 +2294,11 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT		char_type;
       typedef _OutIter		iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id		id;
@@ -2332,7 +2332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2389,9 +2389,9 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
 	  unsigned long long __v) const
       { return this->do_put(__s, __io, __fill, __v); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2441,7 +2441,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       put(iter_type __s, ios_base& __io, char_type __fill,
 	  long double __v) const
       { return this->do_put(__s, __io, __fill, __v); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Numeric formatting.
@@ -2492,7 +2492,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual
       ~num_put() { }
 
-      //@{
+      ///@{
       /**
        *  @brief  Numeric formatting.
        *
@@ -2550,7 +2550,7 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL
       virtual iter_type
       do_put(iter_type, ios_base&, char_type, long double) const;
 #endif
-      //@}
+      ///@}
     };
 
   template <typename _CharT, typename _OutIter>
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.h b/libstdc++-v3/include/bits/locale_facets_nonio.h
index 8247cfd0bc9..236e47df79e 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.h
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.h
@@ -369,11 +369,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -798,11 +798,11 @@ _GLIBCXX_END_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1025,11 +1025,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
       typedef __moneypunct_cache<_CharT, _Intl>     __cache_type;
 
     private:
@@ -1201,7 +1201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       frac_digits() const
       { return this->do_frac_digits(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Return pattern for money values.
        *
@@ -1240,7 +1240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       pattern
       neg_format() const
       { return this->do_neg_format(); }
-      //@}
+      ///@}
 
     protected:
       /// Destructor.
@@ -1469,12 +1469,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _InIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1621,12 +1621,12 @@ _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
     class money_put : public locale::facet
     {
     public:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef _OutIter			iter_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
       /// Numpunct facet id.
       static locale::id			id;
@@ -1800,11 +1800,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			char_type;
       typedef basic_string<_CharT>	string_type;
-      //@}
+      ///@}
 
     protected:
       // Underlying "C" library locale information saved from
diff --git a/libstdc++-v3/include/bits/mask_array.h b/libstdc++-v3/include/bits/mask_array.h
index 8985d7d8d79..c3f8c414508 100644
--- a/libstdc++-v3/include/bits/mask_array.h
+++ b/libstdc++-v3/include/bits/mask_array.h
@@ -205,7 +205,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/ptr_traits.h b/libstdc++-v3/include/bits/ptr_traits.h
index c90a35080f1..80ecf5b420d 100644
--- a/libstdc++-v3/include/bits/ptr_traits.h
+++ b/libstdc++-v3/include/bits/ptr_traits.h
@@ -34,6 +34,11 @@
 
 #include <bits/move.h>
 
+#if __cplusplus > 201703L
+#define __cpp_lib_constexpr_memory 201811L
+namespace __gnu_debug { struct _Safe_iterator_base; }
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -169,7 +174,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Ptr, typename... _None>
     constexpr auto
     __to_address(const _Ptr& __ptr, _None...) noexcept
-    { return std::__to_address(__ptr.operator->()); }
+    {
+      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
+	return std::__to_address(__ptr.base().operator->());
+      else
+	return std::__to_address(__ptr.operator->());
+    }
+
+#define __cpp_lib_to_address 201711L
 
   /**
    * @brief Obtain address referenced by a pointer to an object
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
index 14f680f50c4..b36781ed290 100644
--- a/libstdc++-v3/include/bits/random.h
+++ b/libstdc++-v3/include/bits/random.h
@@ -1667,7 +1667,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
   };
 
-  /* @} */ // group random_generators
+  /// @} group random_generators
 
   /**
    * @addtogroup random_distributions Random Number Distributions
@@ -1943,7 +1943,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator>>(std::basic_istream<_CharT, _Traits>&,
 	       std::uniform_real_distribution<_RealType>&);
 
-  /* @} */ // group random_distributions_uniform
+  /// @} group random_distributions_uniform
 
   /**
    * @addtogroup random_distributions_normal Normal Distributions
@@ -3498,7 +3498,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_normal
+  /// @} group random_distributions_normal
 
   /**
    * @addtogroup random_distributions_bernoulli Bernoulli Distributions
@@ -4394,7 +4394,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_bernoulli
+  /// @} group random_distributions_bernoulli
 
   /**
    * @addtogroup random_distributions_poisson Poisson Distributions
@@ -6040,9 +6040,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return !(__d1 == __d2); }
 
 
-  /* @} */ // group random_distributions_poisson
+  /// @} group random_distributions_poisson
 
-  /* @} */ // group random_distributions
+  /// @} *group random_distributions
 
   /**
    * @addtogroup random_utilities Random Number Utilities
@@ -6066,7 +6066,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { }
 
     template<typename _IntType>
-      seed_seq(std::initializer_list<_IntType> il);
+      seed_seq(std::initializer_list<_IntType> __il);
 
     template<typename _InputIterator>
       seed_seq(_InputIterator __begin, _InputIterator __end);
@@ -6093,9 +6093,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     std::vector<result_type> _M_v;
   };
 
-  /* @} */ // group random_utilities
+  /// @} group random_utilities
 
-  /* @} */ // group random
+  /// @} group random
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/refwrap.h b/libstdc++-v3/include/bits/refwrap.h
index d95f7c57172..82136011b7a 100644
--- a/libstdc++-v3/include/bits/refwrap.h
+++ b/libstdc++-v3/include/bits/refwrap.h
@@ -376,7 +376,7 @@ _GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)
     cref(reference_wrapper<_Tp> __t) noexcept
     { return { __t.get() }; }
 
-  // @} group functors
+  /// @} group functors
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 7576cd7a9c0..8fb89071461 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -400,7 +400,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @name Constants
        * std [28.8.1](1)
        */
-      //@{
+      ///@{
       static constexpr flag_type icase = regex_constants::icase;
       static constexpr flag_type nosubs = regex_constants::nosubs;
       static constexpr flag_type optimize = regex_constants::optimize;
@@ -411,7 +411,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       static constexpr flag_type awk = regex_constants::awk;
       static constexpr flag_type grep = regex_constants::grep;
       static constexpr flag_type egrep = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -910,9 +910,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *
        * @param __s Another matched sequence to compare to this one.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const sub_match& __s) const
@@ -920,13 +920,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
       /**
        * @{
-       * @brief Compares this sub_match to a string.
+       * @brief Compares this `sub_match` to a string.
        *
-       * @param __s A string to compare to this sub_match.
+       * @param __s A string to compare to this `sub_match`.
        *
-       * @retval <0 this matched sequence will collate before @p __s.
-       * @retval =0 this matched sequence is equivalent to @p __s.
-       * @retval <0 this matched sequence will collate after @p __s.
+       * @retval negative  This matched sequence will collate before `__s`.
+       * @retval zero      This matched sequence is equivalent to `__s`.
+       * @retval positive  This matched sequence will collate after `__s`.
        */
       int
       compare(const string_type& __s) const
@@ -935,7 +935,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       int
       compare(const value_type* __s) const
       { return this->_M_str().compare(__s); }
-      // @}
+      /// @}
 
       // Non-standard, used by comparison operators
       int
@@ -1608,7 +1608,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 10.? Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>			   value_type;
       typedef const value_type&				   const_reference;
       typedef value_type&				   reference;
@@ -1619,13 +1619,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       typedef _Alloc					   allocator_type;
       typedef typename __iter_traits::value_type 	   char_type;
       typedef std::basic_string<char_type>		   string_type;
-      //@}
+      ///@}
 
     public:
       /**
        * @name 28.10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1639,7 +1639,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       : _Base_type(__a)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Copy constructs a %match_results.
@@ -1668,7 +1668,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       ~match_results() = default;
 
-      //@}
+      ///@}
 
       // 28.10.2, state:
       /**
@@ -1681,7 +1681,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       /**
        * @name 28.10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1709,12 +1709,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       empty() const noexcept
       { return size() == 0; }
 
-      //@}
+      ///@}
 
       /**
        * @name 10.3 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1834,7 +1834,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       cend() const noexcept
       { return this->end(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 10.4 Formatting
@@ -1844,7 +1844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * escape sequences accepted by these functions are determined by
        * their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @pre   ready() == true
@@ -1895,12 +1895,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	return __result;
       }
 
-      //@}
+      ///@}
 
       /**
        * @name 10.5 Allocator
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -1909,12 +1909,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       get_allocator() const noexcept
       { return _Base_type::get_allocator(); }
 
-      //@}
+      ///@}
 
       /**
        * @name 10.6 Swap
        */
-       //@{
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -1926,7 +1926,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	_Base_type::swap(__that);
 	swap(_M_begin, __that._M_begin);
       }
-      //@}
+      ///@}
 
     private:
       template<typename, typename, typename, bool>
@@ -1989,7 +1989,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename _Bi_iter, typename _Alloc>
     inline bool
     operator==(const match_results<_Bi_iter, _Alloc>& __m1,
-	       const match_results<_Bi_iter, _Alloc>& __m2) noexcept
+	       const match_results<_Bi_iter, _Alloc>& __m2)
     {
       if (__m1.ready() != __m2.ready())
 	return false;
@@ -2013,7 +2013,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename _Bi_iter, class _Alloc>
     inline bool
     operator!=(const match_results<_Bi_iter, _Alloc>& __m1,
-	       const match_results<_Bi_iter, _Alloc>& __m2) noexcept
+	       const match_results<_Bi_iter, _Alloc>& __m2)
     { return !(__m1 == __m2); }
 
   // [7.10.6] match_results swap
@@ -2036,7 +2036,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2498,7 +2498,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       return __result;
     }
 
-  //@}
+  ///@}
 
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
@@ -2861,7 +2861,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
 
-  //@} // group regex
+  ///@} // group regex
 
 _GLIBCXX_END_NAMESPACE_CXX11
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index e5e184b5678..8ba5ea2086d 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -392,7 +392,7 @@ namespace __detail
       _StateIdT _M_end;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/regex_compiler.h b/libstdc++-v3/include/bits/regex_compiler.h
index 45a24a6b740..a2305566adb 100644
--- a/libstdc++-v3/include/bits/regex_compiler.h
+++ b/libstdc++-v3/include/bits/regex_compiler.h
@@ -552,7 +552,7 @@ namespace __detail
 #endif
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_constants.h b/libstdc++-v3/include/bits/regex_constants.h
index a7b51ddef20..7eda80cac34 100644
--- a/libstdc++-v3/include/bits/regex_constants.h
+++ b/libstdc++-v3/include/bits/regex_constants.h
@@ -50,7 +50,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
   {
     _S_icase,
@@ -216,7 +216,7 @@ namespace regex_constants
   operator^=(syntax_option_type& __a, syntax_option_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -227,7 +227,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
   {
@@ -407,9 +407,9 @@ namespace regex_constants
   operator^=(match_flag_type& __a, match_flag_type __b)
   { return __a = __a ^ __b; }
 
-  //@}
+  ///@}
 } // namespace regex_constants
-/* @} */ // group regex
+/// @} group regex
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_error.h b/libstdc++-v3/include/bits/regex_error.h
index af32616619d..40cd7a1690f 100644
--- a/libstdc++-v3/include/bits/regex_error.h
+++ b/libstdc++-v3/include/bits/regex_error.h
@@ -44,7 +44,7 @@ namespace regex_constants
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
 
   enum error_type
     {
@@ -119,7 +119,7 @@ namespace regex_constants
    */
   constexpr error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 } // namespace regex_constants
 
   // [7.8] Class regex_error
@@ -161,7 +161,7 @@ namespace regex_constants
     friend void __throw_regex_error(regex_constants::error_type, const char*);
   };
 
-  //@} // group regex
+  ///@} // group regex
 
   void
   __throw_regex_error(regex_constants::error_type __ecode);
diff --git a/libstdc++-v3/include/bits/regex_executor.h b/libstdc++-v3/include/bits/regex_executor.h
index 265b493532a..d812eeec4c5 100644
--- a/libstdc++-v3/include/bits/regex_executor.h
+++ b/libstdc++-v3/include/bits/regex_executor.h
@@ -250,7 +250,7 @@ namespace __detail
       bool                                                  _M_has_sol;
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index 8150e944c4d..981f612a120 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -264,7 +264,7 @@ namespace __detail
       void (_Scanner::* _M_eat_escape)();
     };
 
- //@} regex-detail
+ ///@} regex-detail
 } // namespace __detail
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 2d53478f1f4..281600b2901 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -730,7 +730,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
-  // @} group pointer_abstractions
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/shared_ptr_atomic.h b/libstdc++-v3/include/bits/shared_ptr_atomic.h
index fb99eb55b14..12fe1a0c94d 100644
--- a/libstdc++-v3/include/bits/shared_ptr_atomic.h
+++ b/libstdc++-v3/include/bits/shared_ptr_atomic.h
@@ -82,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     atomic_is_lock_free(const shared_ptr<_Tp>* __p)
     { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
 
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic load for shared_ptr objects.
@@ -118,7 +118,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
     { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic store for shared_ptr objects.
@@ -157,7 +157,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline void
     atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
     { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic exchange for shared_ptr objects.
@@ -202,7 +202,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_exchange_explicit(__p, std::move(__r),
 					   memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
   /**
    *  @brief  Atomic compare-and-swap for shared_ptr objects.
@@ -320,9 +320,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return std::atomic_compare_exchange_weak_explicit(__p, __v,
 	  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
     }
-  // @}
+  /// @}
 
-  // @} group pointer_abstractions
+  /// @} group pointer_abstractions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/slice_array.h b/libstdc++-v3/include/bits/slice_array.h
index 3d461cbcc5c..901a7608060 100644
--- a/libstdc++-v3/include/bits/slice_array.h
+++ b/libstdc++-v3/include/bits/slice_array.h
@@ -271,7 +271,7 @@ _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/specfun.h b/libstdc++-v3/include/bits/specfun.h
index 28f9eb46f3a..60e29ccf5cf 100644
--- a/libstdc++-v3/include/bits/specfun.h
+++ b/libstdc++-v3/include/bits/specfun.h
@@ -1196,7 +1196,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  // @} group mathsf
+  /// @} group mathsf
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/std_function.h b/libstdc++-v3/include/bits/std_function.h
index b59f6978971..b8eca90b8da 100644
--- a/libstdc++-v3/include/bits/std_function.h
+++ b/libstdc++-v3/include/bits/std_function.h
@@ -603,7 +603,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Functor>       _Functor* target() noexcept;
 
       template<typename _Functor> const _Functor* target() const noexcept;
-      // @}
+      /// @}
 #endif
 
     private:
diff --git a/libstdc++-v3/include/bits/std_mutex.h b/libstdc++-v3/include/bits/std_mutex.h
index c5036acfe74..65676138506 100644
--- a/libstdc++-v3/include/bits/std_mutex.h
+++ b/libstdc++-v3/include/bits/std_mutex.h
@@ -171,7 +171,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       mutex_type&  _M_device;
     };
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 #endif // C++11
diff --git a/libstdc++-v3/include/bits/stl_algo.h b/libstdc++-v3/include/bits/stl_algo.h
index 61319d1fd15..48fde9d2627 100644
--- a/libstdc++-v3/include/bits/stl_algo.h
+++ b/libstdc++-v3/include/bits/stl_algo.h
@@ -5787,6 +5787,9 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
       using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
 
+      if (__first == __last)
+	return __out;
+
       __distrib_type __d{};
       _Size __unsampled_sz = std::distance(__first, __last);
       __n = std::min(__n, __unsampled_sz);
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 5a95399162f..f2daf2ed936 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -1911,7 +1911,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	}
 
       // called by the second initialize_dispatch above
-      //@{
+      ///@{
       /**
        *  @brief Fills the deque with whatever is in [first,last).
        *  @param  __first  An input iterator.
@@ -1932,7 +1932,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	void
 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
 			    std::forward_iterator_tag);
-      //@}
+      ///@}
 
       /**
        *  @brief Fills the %deque with copies of value.
@@ -2014,7 +2014,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  }
       }
 
-      //@{
+      ///@{
       /// Helper functions for push_* and pop_*.
 #if __cplusplus < 201103L
       void _M_push_back_aux(const value_type&);
@@ -2031,7 +2031,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       void _M_pop_back_aux();
 
       void _M_pop_front_aux();
-      //@}
+      ///@}
 
       // Internal insert functions follow.  The *_aux functions do the actual
       // insertion work when all shortcuts fail.
@@ -2152,7 +2152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _M_shrink_to_fit();
 #endif
 
-      //@{
+      ///@{
       /// Memory-handling helpers for the previous internal insert functions.
       iterator
       _M_reserve_elements_at_front(size_type __n)
@@ -2179,10 +2179,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_new_elements_at_back(size_type __new_elements);
-      //@}
+      ///@}
 
 
-      //@{
+      ///@{
       /**
        *  @brief Memory-handling helpers for the major %map.
        *
@@ -2208,7 +2208,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       void
       _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
-      //@}
+      ///@}
 
 #if __cplusplus >= 201103L
       // Constant-time, nothrow move assignment when source object's memory
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index e9d90fa01f4..c743215c83e 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -69,8 +69,8 @@
 # include <type_traits>
 #endif
 
-#if __cplusplus > 201402L
-# define __cpp_lib_array_constexpr 201603
+#if __cplusplus >= 201703L
+# define __cpp_lib_array_constexpr 201803L
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -310,7 +310,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         { return __t.operator->(); }
     };
 
-  //@{
+  ///@{
   /**
    *  @param  __x  A %reverse_iterator.
    *  @param  __y  A %reverse_iterator.
@@ -393,7 +393,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator>=(const reverse_iterator<_IteratorL>& __x,
 	       const reverse_iterator<_IteratorR>& __y)
     { return !(__x < __y); }
-  //@}
+  ///@}
 
 #if __cplusplus < 201103L
   template<typename _Iterator>
@@ -765,7 +765,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 					 typename _Container::iterator(__i));
     }
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1242,7 +1242,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __make_move_if_noexcept_iterator(_Tp* __i)
     { return _ReturnType(__i); }
 
-  // @} group iterators
+  /// @} group iterators
 
   template<typename _Iterator>
     auto
diff --git a/libstdc++-v3/include/bits/stl_iterator_base_types.h b/libstdc++-v3/include/bits/stl_iterator_base_types.h
index 4920b61a840..a330a8ce8c0 100644
--- a/libstdc++-v3/include/bits/stl_iterator_base_types.h
+++ b/libstdc++-v3/include/bits/stl_iterator_base_types.h
@@ -75,7 +75,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  @defgroup iterators Iterators
    *  Abstractions for uniform iterating through various underlying types.
   */
-  //@{ 
+  ///@{
 
   /**
    *  @defgroup iterator_tags Iterator Tags
@@ -84,7 +84,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  are.  Different underlying algorithms can then be used based on the
    *  different operations supported by different iterator types.
   */
-  //@{ 
+  ///@{
   ///  Marking input iterators.
   struct input_iterator_tag { };
 
@@ -101,7 +101,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// Random-access iterators support a superset of bidirectional
   /// iterator operations.
   struct random_access_iterator_tag : public bidirectional_iterator_tag { };
-  //@}
+  ///@}
 
   /**
    *  @brief  Common %iterator class.
@@ -205,7 +205,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __iterator_category(const _Iter&)
     { return typename iterator_traits<_Iter>::iterator_category(); }
 
-  //@}
+  ///@}
 
 #if __cplusplus < 201103L
   // If _Iterator has a base returns it otherwise _Iterator is returned
diff --git a/libstdc++-v3/include/bits/stl_map.h b/libstdc++-v3/include/bits/stl_map.h
index 322d0a8290a..6b5d66f1790 100644
--- a/libstdc++-v3/include/bits/stl_map.h
+++ b/libstdc++-v3/include/bits/stl_map.h
@@ -814,7 +814,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
 #if __cplusplus >= 201103L
       /**
@@ -876,7 +876,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					     std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Template function that attempts to insert a range of elements.
@@ -892,7 +892,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	{ _M_t._M_insert_range_unique(__first, __last); }
 
 #if __cplusplus > 201402L
-#define __cpp_lib_map_insertion 201411
+#define __cpp_lib_map_insertion 201411 // non-standard macro
       /**
        *  @brief Attempts to insert or assign a std::pair into the %map.
        *  @param __k    Key to use for finding a possibly existing pair in
@@ -1035,7 +1035,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %map.
@@ -1151,7 +1151,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // [23.3.1.3] map operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1174,9 +1174,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %map.
        *  @param  __x  Key of (key, value) %pair to be located.
@@ -1199,9 +1199,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1220,10 +1220,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1238,10 +1238,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1264,9 +1264,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1289,9 +1289,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1309,9 +1309,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -1329,9 +1329,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1358,9 +1358,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1391,7 +1391,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multimap.h b/libstdc++-v3/include/bits/stl_multimap.h
index 4c4ccad3ac0..94c40366b49 100644
--- a/libstdc++-v3/include/bits/stl_multimap.h
+++ b/libstdc++-v3/include/bits/stl_multimap.h
@@ -549,7 +549,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	insert(_Pair&& __x)
 	{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief Inserts a std::pair into the %multimap.
@@ -595,7 +595,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 					    std::forward<_Pair>(__x));
 	}
 #endif
-      // @}
+      /// @}
 
       /**
        *  @brief A template function that attempts to insert a range
@@ -705,7 +705,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_t.erase(__position); }
-      // @}
+      /// @}
 #else
       /**
        *  @brief Erases an element from a %multimap.
@@ -825,7 +825,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multimap operations
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -847,9 +847,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %multimap.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -871,9 +871,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 	{ return _M_t._M_find_tr(__x); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -889,10 +889,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -907,10 +907,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -933,9 +933,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -958,9 +958,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -978,9 +978,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key of (key, value) pair to be located.
@@ -998,9 +998,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1025,9 +1025,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key of (key, value) pairs to be located.
@@ -1056,7 +1056,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      _M_t._M_equal_range_tr(__x));
 	}
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _T1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_multiset.h b/libstdc++-v3/include/bits/stl_multiset.h
index af733ea34dc..3fbe7f6492c 100644
--- a/libstdc++-v3/include/bits/stl_multiset.h
+++ b/libstdc++-v3/include/bits/stl_multiset.h
@@ -720,7 +720,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // multiset operations:
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the number of elements with given key.
        *  @param  __x  Key of elements to be located.
@@ -736,10 +736,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -754,12 +754,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -792,9 +792,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -827,9 +827,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -857,9 +857,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -896,7 +896,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_numeric.h b/libstdc++-v3/include/bits/stl_numeric.h
index 387bed91174..ab8ed208481 100644
--- a/libstdc++-v3/include/bits/stl_numeric.h
+++ b/libstdc++-v3/include/bits/stl_numeric.h
@@ -394,7 +394,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       return ++__result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 #undef _GLIBCXX_MOVE_IF_20
 
diff --git a/libstdc++-v3/include/bits/stl_set.h b/libstdc++-v3/include/bits/stl_set.h
index 3131a7974b0..60252627a2a 100644
--- a/libstdc++-v3/include/bits/stl_set.h
+++ b/libstdc++-v3/include/bits/stl_set.h
@@ -115,14 +115,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef _Key     key_type;
       typedef _Key     value_type;
       typedef _Compare key_compare;
       typedef _Compare value_compare;
       typedef _Alloc   allocator_type;
-      //@}
+      ///@}
 
     private:
       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
@@ -135,7 +135,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
 
     public:
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Alloc_traits::pointer		 pointer;
       typedef typename _Alloc_traits::const_pointer	 const_pointer;
@@ -150,7 +150,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
       typedef typename _Rep_type::size_type		 size_type;
       typedef typename _Rep_type::difference_type	 difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Rep_type::node_type;
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // set operations:
 
-      //@{
+      ///@{
       /**
        *  @brief  Finds the number of elements.
        *  @param  __x  Element to located.
@@ -755,10 +755,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(_M_t._M_count_tr(__x))
 	{ return _M_t._M_count_tr(__x); }
 #endif
-      //@}
+      ///@}
 
 #if __cplusplus > 201703L
-      //@{
+      ///@{
       /**
        *  @brief  Finds whether an element with the given key exists.
        *  @param  __x  Key of elements to be located.
@@ -773,12 +773,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	contains(const _Kt& __x) const
 	-> decltype(_M_t._M_find_tr(__x), void(), true)
 	{ return _M_t._M_find_tr(__x) != _M_t.end(); }
-      //@}
+      ///@}
 #endif
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 214.  set::find() missing const overload
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in a %set.
        *  @param  __x  Element to be located.
@@ -811,9 +811,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
 	{ return const_iterator{_M_t._M_find_tr(__x)}; }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the beginning of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -846,9 +846,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds the end of a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -876,9 +876,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -915,7 +915,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
 #endif
-      //@}
+      ///@}
 
       template<typename _K1, typename _C1, typename _A1>
 	friend bool
diff --git a/libstdc++-v3/include/bits/stl_tree.h b/libstdc++-v3/include/bits/stl_tree.h
index 4dae1da6a0d..bb0e0af98e4 100644
--- a/libstdc++-v3/include/bits/stl_tree.h
+++ b/libstdc++-v3/include/bits/stl_tree.h
@@ -694,7 +694,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  : _Node_allocator(__a), _Base_key_compare(__comp)
 	  { }
 #else
-	  _Rb_tree_impl(_Rb_tree_impl&&) = default;
+	  _Rb_tree_impl(_Rb_tree_impl&& __x)
+	  noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+	  : _Node_allocator(std::move(__x)),
+	    _Base_key_compare(std::move(__x)),
+	    _Rb_tree_header(std::move(__x))
+	  { }
 
 	  explicit
 	  _Rb_tree_impl(_Node_allocator&& __a)
diff --git a/libstdc++-v3/include/bits/stream_iterator.h b/libstdc++-v3/include/bits/stream_iterator.h
index bc3353ab10f..0473f7eb14f 100644
--- a/libstdc++-v3/include/bits/stream_iterator.h
+++ b/libstdc++-v3/include/bits/stream_iterator.h
@@ -159,12 +159,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : public iterator<output_iterator_tag, void, void, void, void>
     {
     public:
-      //@{
+      ///@{
       /// Public typedef
       typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef basic_ostream<_CharT, _Traits> ostream_type;
-      //@}
+      ///@}
 
     private:
       ostream_type*	_M_stream;
@@ -222,7 +222,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return *this; }
     };
 
-  // @} group iterators
+  /// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/streambuf_iterator.h b/libstdc++-v3/include/bits/streambuf_iterator.h
index 2f4ff494a3a..b5b170c93c6 100644
--- a/libstdc++-v3/include/bits/streambuf_iterator.h
+++ b/libstdc++-v3/include/bits/streambuf_iterator.h
@@ -59,14 +59,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT					char_type;
       typedef _Traits					traits_type;
       typedef typename _Traits::int_type		int_type;
       typedef basic_streambuf<_CharT, _Traits>		streambuf_type;
       typedef basic_istream<_CharT, _Traits>		istream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -222,13 +222,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     public:
       // Types:
-      //@{
+      ///@{
       /// Public typedefs
       typedef _CharT			       char_type;
       typedef _Traits			       traits_type;
       typedef basic_streambuf<_CharT, _Traits> streambuf_type;
       typedef basic_ostream<_CharT, _Traits>   ostream_type;
-      //@}
+      ///@}
 
       template<typename _CharT2>
 	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
@@ -450,7 +450,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __i._M_c = __eof;
     }
 
-// @} group iterators
+/// @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/bits/unique_lock.h b/libstdc++-v3/include/bits/unique_lock.h
index 9aceb6b6124..927049c2f38 100644
--- a/libstdc++-v3/include/bits/unique_lock.h
+++ b/libstdc++-v3/include/bits/unique_lock.h
@@ -237,7 +237,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
index c934873a722..3d6d1ee6219 100644
--- a/libstdc++-v3/include/bits/unique_ptr.h
+++ b/libstdc++-v3/include/bits/unique_ptr.h
@@ -868,7 +868,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     make_unique(_Args&&...) = delete;
 #endif
 
-  // @} group pointer_abstractions
+  /// @} group pointer_abstractions
 
 #if __cplusplus >= 201703L
   namespace __detail::__variant
diff --git a/libstdc++-v3/include/bits/unordered_map.h b/libstdc++-v3/include/bits/unordered_map.h
index b8243a73445..855d8c8068f 100644
--- a/libstdc++-v3/include/bits/unordered_map.h
+++ b/libstdc++-v3/include/bits/unordered_map.h
@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -114,9 +114,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -128,7 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -209,6 +209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )
       : _M_h(std::move(__umap._M_h), __a)
       { }
 
@@ -324,7 +325,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_map.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -346,7 +347,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_map.
@@ -358,7 +359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -557,7 +558,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
 
@@ -590,9 +591,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 		      pair<iterator, bool>>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -628,7 +629,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
 	{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -657,7 +658,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
 
 #if __cplusplus > 201402L
-#define __cpp_lib_unordered_map_insertion 201411
+#define __cpp_lib_unordered_map_insertion 201411 // non-standard macro
       /**
        *  @brief Attempts to insert a std::pair into the %unordered_map.
        *  @param __k    Key to use for finding a possibly existing pair in
@@ -774,7 +775,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_map.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -796,7 +797,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -904,7 +905,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_map.
        *  @param  __x  Key to be located.
@@ -923,7 +924,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -949,7 +950,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -965,9 +966,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Subscript ( @c [] ) access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -987,9 +988,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       mapped_type&
       operator[](key_type&& __k)
       { return _M_h[std::move(__k)]; }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Access to %unordered_map data.
        *  @param  __k  The key for which data should be retrieved.
@@ -1004,7 +1005,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const mapped_type&
       at(const key_type& __k) const
       { return _M_h.at(__k); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1046,7 +1047,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1060,7 +1061,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1072,7 +1073,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1086,7 +1087,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -1254,7 +1255,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
@@ -1262,9 +1263,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -1276,7 +1277,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1356,6 +1357,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multimap(unordered_multimap&& __ummap,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )
       : _M_h(std::move(__ummap._M_h), __a)
       { }
 
@@ -1471,7 +1473,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin() noexcept
       { return _M_h.begin(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multimap.
@@ -1483,7 +1485,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cbegin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read/write iterator that points one past the last element in
@@ -1493,7 +1495,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end() noexcept
       { return _M_h.end(); }
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multimap.
@@ -1505,7 +1507,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       cend() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       // modifiers.
 
@@ -1556,7 +1558,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param __x Pair to be inserted (see std::make_pair for easy
@@ -1578,9 +1580,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(_Pair&& __x)
         { return _M_h.emplace(std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts a std::pair into the %unordered_multimap.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1614,7 +1616,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
         { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -1667,7 +1669,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multimap.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1689,7 +1691,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -1799,7 +1801,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multimap.
        *  @param  __x  Key to be located.
@@ -1818,7 +1820,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1840,7 +1842,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1854,7 +1856,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1896,7 +1898,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       begin(size_type __n)
       { return _M_h.begin(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1910,7 +1912,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Returns a read/write iterator pointing to one past the last
@@ -1922,7 +1924,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       end(size_type __n)
       { return _M_h.end(__n); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1936,7 +1938,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/bits/unordered_set.h b/libstdc++-v3/include/bits/unordered_set.h
index 8ebcaf40263..515592f2079 100644
--- a/libstdc++-v3/include/bits/unordered_set.h
+++ b/libstdc++-v3/include/bits/unordered_set.h
@@ -101,16 +101,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -203,6 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )
       : _M_h(std::move(__uset._M_h), __a)
       { }
 
@@ -310,7 +311,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_set.
@@ -322,9 +323,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_set.
@@ -336,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -402,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __x  Element to be inserted.
@@ -423,9 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<iterator, bool>
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Attempts to insert an element into the %unordered_set.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -452,7 +453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that attempts to insert a range of
@@ -504,7 +505,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node(std::move(__nh)).position; }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_set.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -526,7 +527,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Erases elements according to the provided key.
@@ -633,7 +634,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_set.
        *  @param  __x  Element to be located.
@@ -652,7 +653,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -678,7 +679,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -694,7 +695,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -726,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -744,9 +745,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -764,7 +765,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
@@ -916,16 +917,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
     public:
       // typedefs:
-      //@{
+      ///@{
       /// Public typedefs.
       typedef typename _Hashtable::key_type	key_type;
       typedef typename _Hashtable::value_type	value_type;
       typedef typename _Hashtable::hasher	hasher;
       typedef typename _Hashtable::key_equal	key_equal;
       typedef typename _Hashtable::allocator_type allocator_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       ///  Iterator-related typedefs.
       typedef typename _Hashtable::pointer		pointer;
       typedef typename _Hashtable::const_pointer	const_pointer;
@@ -937,7 +938,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef typename _Hashtable::const_local_iterator	const_local_iterator;
       typedef typename _Hashtable::size_type		size_type;
       typedef typename _Hashtable::difference_type	difference_type;
-      //@}
+      ///@}
 
 #if __cplusplus > 201402L
       using node_type = typename _Hashtable::node_type;
@@ -1044,6 +1045,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       unordered_multiset(unordered_multiset&& __umset,
 			 const allocator_type& __a)
+	noexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )
       : _M_h(std::move(__umset._M_h), __a)
       { }
 
@@ -1124,7 +1126,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // iterators.
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points to the first
        *  element in the %unordered_multiset.
@@ -1136,9 +1138,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       begin() const noexcept
       { return _M_h.begin(); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Returns a read-only (constant) iterator that points one past the last
        *  element in the %unordered_multiset.
@@ -1150,7 +1152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       end() const noexcept
       { return _M_h.end(); }
-      //@}
+      ///@}
 
       /**
        *  Returns a read-only (constant) iterator that points to the first
@@ -1204,7 +1206,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	emplace_hint(const_iterator __pos, _Args&&... __args)
 	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __x  Element to be inserted.
@@ -1219,9 +1221,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief Inserts an element into the %unordered_multiset.
        *  @param  __hint  An iterator that serves as a hint as to where the
@@ -1245,7 +1247,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
-      //@}
+      ///@}
 
       /**
        *  @brief A template function that inserts a range of elements.
@@ -1296,7 +1298,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
 #endif // C++17
 
-      //@{
+      ///@{
       /**
        *  @brief Erases an element from an %unordered_multiset.
        *  @param  __position  An iterator pointing to the element to be erased.
@@ -1319,7 +1321,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       iterator
       erase(iterator __position)
       { return _M_h.erase(__position); }
-      //@}
+      ///@}
 
 
       /**
@@ -1432,7 +1434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       // lookup.
 
-      //@{
+      ///@{
       /**
        *  @brief Tries to locate an element in an %unordered_multiset.
        *  @param  __x  Element to be located.
@@ -1451,7 +1453,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_iterator
       find(const key_type& __x) const
       { return _M_h.find(__x); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the number of elements.
@@ -1473,7 +1475,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       { return _M_h.find(__x) != _M_h.end(); }
 #endif
 
-      //@{
+      ///@{
       /**
        *  @brief Finds a subsequence matching given key.
        *  @param  __x  Key to be located.
@@ -1487,7 +1489,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       std::pair<const_iterator, const_iterator>
       equal_range(const key_type& __x) const
       { return _M_h.equal_range(__x); }
-      //@}
+      ///@}
 
       // bucket interface.
 
@@ -1519,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bucket(const key_type& __key) const
       { return _M_h.bucket(__key); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to the first
        *         bucket element.
@@ -1537,9 +1539,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cbegin(size_type __n) const
       { return _M_h.cbegin(__n); }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Returns a read-only (constant) iterator pointing to one past
        *         the last bucket elements.
@@ -1557,7 +1559,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_local_iterator
       cend(size_type __n) const
       { return _M_h.cend(__n); }
-      //@}
+      ///@}
 
       // hash policy.
 
diff --git a/libstdc++-v3/include/debug/unordered_map b/libstdc++-v3/include/debug/unordered_map
index d844ee9fa0e..b4531a3b1e9 100644
--- a/libstdc++-v3/include/debug/unordered_map
+++ b/libstdc++-v3/include/debug/unordered_map
@@ -136,6 +136,7 @@ namespace __debug
 
       unordered_map(unordered_map&& __umap,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -160,7 +161,7 @@ namespace __debug
 	unordered_map(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
@@ -168,20 +169,20 @@ namespace __debug
 		      size_type __n,
 		      const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, hasher(), key_equal(), __a)
+      : unordered_map(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_map(initializer_list<value_type> __l,
 		    size_type __n,
 		    const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_map(__l, __n, __hf, key_equal(), __a)
+      : unordered_map(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_map() = default;
@@ -830,6 +831,7 @@ namespace __debug
 
       unordered_multimap(unordered_multimap&& __umap,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__umap._M_base()), __a)) )
       : _Safe(std::move(__umap._M_safe()), __a),
 	_Base(std::move(__umap._M_base()), __a) { }
 
@@ -853,26 +855,26 @@ namespace __debug
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multimap(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multimap(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multimap(__l, __n, __hf, key_equal(), __a)
+      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multimap() = default;
diff --git a/libstdc++-v3/include/debug/unordered_set b/libstdc++-v3/include/debug/unordered_set
index ecc084e3846..17ae5909ef5 100644
--- a/libstdc++-v3/include/debug/unordered_set
+++ b/libstdc++-v3/include/debug/unordered_set
@@ -133,6 +133,7 @@ namespace __debug
 
       unordered_set(unordered_set&& __uset,
 		    const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -144,38 +145,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_set(size_type __n, const allocator_type& __a)
-	: unordered_set(__n, hasher(), key_equal(), __a)
+      : unordered_set(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__n, __hf, key_equal(), __a)
+      : unordered_set(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_set(_InputIterator __first, _InputIterator __last,
 		      size_type __n, const hasher& __hf,
 		      const allocator_type& __a)
-	  : unordered_set(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_set(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, hasher(), key_equal(), __a)
+      : unordered_set(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_set(initializer_list<value_type> __l,
 		    size_type __n, const hasher& __hf,
 		    const allocator_type& __a)
-	: unordered_set(__l, __n, __hf, key_equal(), __a)
+      : unordered_set(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_set() = default;
@@ -700,6 +701,7 @@ namespace __debug
 
       unordered_multiset(unordered_multiset&& __uset,
 			 const allocator_type& __a)
+      noexcept( noexcept(_Base(std::move(__uset._M_base()), __a)) )
       : _Safe(std::move(__uset._M_safe()), __a),
 	_Base(std::move(__uset._M_base()), __a) { }
 
@@ -711,38 +713,38 @@ namespace __debug
       : _Base(__l, __n, __hf, __eql, __a) { }
 
       unordered_multiset(size_type __n, const allocator_type& __a)
-	: unordered_multiset(__n, hasher(), key_equal(), __a)
+      : unordered_multiset(__n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__n, __hf, key_equal(), __a)
+      : unordered_multiset(__n, __hf, key_equal(), __a)
       { }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
 	{ }
 
       template<typename _InputIterator>
 	unordered_multiset(_InputIterator __first, _InputIterator __last,
 			   size_type __n, const hasher& __hf,
 			   const allocator_type& __a)
-	  : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
+	: unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
 	{ }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, hasher(), key_equal(), __a)
+      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)
       { }
 
       unordered_multiset(initializer_list<value_type> __l,
 			 size_type __n, const hasher& __hf,
 			 const allocator_type& __a)
-	: unordered_multiset(__l, __n, __hf, key_equal(), __a)
+      : unordered_multiset(__l, __n, __hf, key_equal(), __a)
       { }
 
       ~unordered_multiset() = default;
diff --git a/libstdc++-v3/include/decimal/decimal b/libstdc++-v3/include/decimal/decimal
index 32f3cdacfc4..7c28da283f8 100644
--- a/libstdc++-v3/include/decimal/decimal
+++ b/libstdc++-v3/include/decimal/decimal
@@ -484,7 +484,7 @@ namespace decimal
 
 #define _GLIBCXX_USE_DECIMAL_ 1
 } // namespace decimal
-  // @} group decimal
+  /// @} group decimal
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/experimental/any b/libstdc++-v3/include/experimental/any
index 33a2d514cf3..aa48db4a4c6 100644
--- a/libstdc++-v3/include/experimental/any
+++ b/libstdc++-v3/include/experimental/any
@@ -409,7 +409,7 @@ inline namespace fundamentals_v1
 	return std::move(*__p);
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -476,7 +476,7 @@ inline namespace fundamentals_v1
 	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
@@ -552,7 +552,7 @@ inline namespace fundamentals_v1
       _S_manage(_Op, const any*, _Arg*) { }
     };
 
-  // @} group any
+  /// @} group any
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/array b/libstdc++-v3/include/experimental/array
index 3fece233319..c2aac4a73d9 100644
--- a/libstdc++-v3/include/experimental/array
+++ b/libstdc++-v3/include/experimental/array
@@ -101,7 +101,7 @@ template <typename _Tp, size_t _Nm>
     return __to_array(__a, make_index_sequence<_Nm>{});
   }
 
-  // @} group make_array
+  /// @} group make_array
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/bits/fs_dir.h b/libstdc++-v3/include/experimental/bits/fs_dir.h
index 8e6475c48c4..453e03d31ad 100644
--- a/libstdc++-v3/include/experimental/bits/fs_dir.h
+++ b/libstdc++-v3/include/experimental/bits/fs_dir.h
@@ -351,7 +351,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
 _GLIBCXX_END_NAMESPACE_CXX11
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_fwd.h b/libstdc++-v3/include/experimental/bits/fs_fwd.h
index 97fe39f931d..0da15ef4297 100644
--- a/libstdc++-v3/include/experimental/bits/fs_fwd.h
+++ b/libstdc++-v3/include/experimental/bits/fs_fwd.h
@@ -278,7 +278,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_regular_file(file_status) noexcept;
   bool is_symlink(file_status) noexcept;
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_ops.h b/libstdc++-v3/include/experimental/bits/fs_ops.h
index 096b275e963..c92cb56bd75 100644
--- a/libstdc++-v3/include/experimental/bits/fs_ops.h
+++ b/libstdc++-v3/include/experimental/bits/fs_ops.h
@@ -288,7 +288,7 @@ inline namespace v1
   path temp_directory_path();
   path temp_directory_path(error_code& __ec);
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 } // namespace v1
 } // namespace filesystem
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 64089b432eb..33a415645d9 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -996,34 +996,56 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   inline std::u32string
   path::u32string() const { return string<char32_t>(); }
 
-#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
   template<typename _CharT, typename _Traits, typename _Allocator>
     inline std::basic_string<_CharT, _Traits, _Allocator>
     path::generic_string(const _Allocator& __a) const
-    { return string<_CharT, _Traits, _Allocator>(__a); }
+    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      const _CharT __slash = is_same<_CharT, wchar_t>::value
+	? _CharT(L'/')
+	: _CharT('/'); // Assume value is correct for the encoding.
+#else
+      const _CharT __slash = _CharT('/');
+#endif
+      basic_string<_CharT, _Traits, _Allocator> __str(__a);
+      __str.reserve(_M_pathname.size());
+      bool __add_slash = false;
+      for (auto& __elem : *this)
+	{
+	  if (__elem._M_type == _Type::_Root_dir)
+	    {
+	      __str += __slash;
+	      continue;
+	    }
+	  if (__add_slash)
+	    __str += __slash;
+	  __str += __elem.string<_CharT, _Traits, _Allocator>(__a);
+	  __add_slash = __elem._M_type == _Type::_Filename;
+	}
+      return __str;
+    }
 
   inline std::string
-  path::generic_string() const { return string(); }
+  path::generic_string() const { return generic_string<char>(); }
 
 #if _GLIBCXX_USE_WCHAR_T
   inline std::wstring
-  path::generic_wstring() const { return wstring(); }
+  path::generic_wstring() const { return generic_string<wchar_t>(); }
 #endif
 
 #ifdef _GLIBCXX_USE_CHAR8_T
   inline std::u8string
-  path::generic_u8string() const { return u8string(); }
+  path::generic_u8string() const { return generic_string<char8_t>(); }
 #else
   inline std::string
-  path::generic_u8string() const { return u8string(); }
+  path::generic_u8string() const { return generic_string<char>(); }
 #endif
 
   inline std::u16string
-  path::generic_u16string() const { return u16string(); }
+  path::generic_u16string() const { return generic_string<char16_t>(); }
 
   inline std::u32string
-  path::generic_u32string() const { return u32string(); }
-#endif
+  path::generic_u32string() const { return generic_string<char32_t>(); }
 
   inline int
   path::compare(const string_type& __s) const { return compare(path(__s)); }
@@ -1156,7 +1178,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     return _M_at_end == __rhs._M_at_end;
   }
 
-  // @} group filesystem-ts
+  /// @} group filesystem-ts
 _GLIBCXX_END_NAMESPACE_CXX11
 } // namespace v1
 } // namespace filesystem
diff --git a/libstdc++-v3/include/experimental/buffer b/libstdc++-v3/include/experimental/buffer
index 23b7b65c631..063caa62959 100644
--- a/libstdc++-v3/include/experimental/buffer
+++ b/libstdc++-v3/include/experimental/buffer
@@ -172,7 +172,7 @@ inline namespace v1
     buffer_sequence_end(const _Cont& __c) -> decltype(__c.end())
     { return __c.end(); }
 
-  // @}
+  /// @}
 
 
   /** @brief buffer type traits
@@ -250,7 +250,7 @@ inline namespace v1
   template<typename _Tp>
     constexpr bool is_dynamic_buffer_v = is_dynamic_buffer<_Tp>::value;
 
-  // @}
+  /// @}
 
   /// buffer size
   template<typename _ConstBufferSequence>
@@ -727,7 +727,7 @@ inline namespace v1
       return net::read(__stream, __b, __completion_condition, __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous read operations
    * @{
@@ -775,7 +775,7 @@ inline namespace v1
 			     std::forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #if 0
   /** @brief synchronous write operations:
@@ -811,7 +811,7 @@ inline namespace v1
     size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b,
                  _CompletionCondition __completion_condition, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous write operations
    * @{
@@ -839,7 +839,7 @@ inline namespace v1
                        _CompletionCondition __completion_condition,
                        _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
   /** @brief synchronous delimited read operations
    * @{
@@ -856,7 +856,7 @@ inline namespace v1
     size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b,
                       string_view __delim, error_code& __ec);
 
-  // @}
+  /// @}
 
   /** @brief asynchronous delimited read operations
    * @{
@@ -871,7 +871,7 @@ inline namespace v1
                           _DynamicBuffer&& __b, string_view __delim,
                           _CompletionToken&& __token);
 
-  // @}
+  /// @}
 
 #endif
   /// @}
diff --git a/libstdc++-v3/include/experimental/executor b/libstdc++-v3/include/experimental/executor
index 266a2487899..7e2a97fd8ec 100644
--- a/libstdc++-v3/include/experimental/executor
+++ b/libstdc++-v3/include/experimental/executor
@@ -127,7 +127,13 @@ inline namespace v1
   /// An extensible, type-safe, polymorphic set of services.
   class execution_context;
 
-  class service_already_exists : public logic_error { };
+  class service_already_exists : public logic_error
+  {
+  public:
+    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+    // 3414. service_already_exists has no usable constructors
+    service_already_exists() : logic_error("service already exists") { }
+  };
 
   template<typename _Tp> struct is_executor;
 
@@ -288,26 +294,22 @@ inline namespace v1
   class executor;
 
   bool
-  operator==(const executor& __a, const executor& __b) noexcept;
+  operator==(const executor&, const executor&) noexcept;
 
   bool
-  operator==(const executor& __e, nullptr_t) noexcept;
+  operator==(const executor&, nullptr_t) noexcept;
 
-  inline bool
-  operator==(nullptr_t, const executor& __e) noexcept
-  { return __e == nullptr; }
+  bool
+  operator==(nullptr_t, const executor&) noexcept;
 
-  inline bool
-  operator!=(const executor& __a, const executor& __b) noexcept
-  { return !(__a == __b); }
+  bool
+  operator!=(const executor&, const executor&) noexcept;
 
-  inline bool
-  operator!=(const executor& __e, nullptr_t) noexcept
-  { return !(__e == nullptr); }
+  bool
+  operator!=(const executor&, nullptr_t) noexcept;
 
-  inline bool
-  operator!=(nullptr_t, const executor& __e) noexcept
-  { return !(__e == nullptr); }
+  bool
+  operator!=(nullptr_t, const executor&) noexcept;
 
   void swap(executor&, executor&) noexcept;
 
@@ -847,7 +849,7 @@ inline namespace v1
 
     // construct / copy / destroy:
 
-    system_context() = default;
+    system_context() = delete;
     system_context(const system_context&) = delete;
     system_context& operator=(const system_context&) = delete;
 
@@ -992,12 +994,13 @@ inline namespace v1
 
     template<typename _Executor>
       executor(_Executor __e)
-      : _M_target(_M_create(std::move(__e)))
+      : _M_target(make_shared<_Tgt1<_Executor>>(std::move(__e)))
       { }
 
     template<typename _Executor, typename _ProtoAlloc>
       executor(allocator_arg_t, const _ProtoAlloc& __a, _Executor __e)
-      : _M_target(_M_create(std::move(__e), __a))
+      : _M_target(allocate_shared<_Tgt2<_Executor, _ProtoAlloc>>(__a,
+	    std::move(__e), __a))
       { }
 
     executor& operator=(const executor&) noexcept = default;
@@ -1094,28 +1097,46 @@ inline namespace v1
 #if __cpp_rtti
     const type_info&
     target_type() const noexcept
-    { return _M_target ? _M_target->target_type() : typeid(void); }
+    {
+      if (_M_target)
+	return *static_cast<const type_info*>(_M_target->target_type());
+      return typeid(void);
+    }
+#endif
 
     template<typename _Executor>
       _Executor*
       target() noexcept
       {
+	void* __p = nullptr;
 	if (_M_target)
-	  if (const auto* __p = _M_target->target(typeid(_Executor)))
-	    return const_cast<_Executor*>(static_cast<const _Executor>(__p));
-	return nullptr;
+	  {
+	    if (_M_target->_M_func == &_Tgt1<remove_cv_t<_Executor>>::_S_func)
+	      __p = _M_target->_M_func(_M_target.get(), nullptr);
+#if __cpp_rtti
+	    else
+	      __p = _M_target->target(&typeid(_Executor));
+#endif
+	  }
+	return static_cast<_Executor*>(__p);
       }
 
     template<typename _Executor>
       const _Executor*
       target() const noexcept
       {
+	const void* __p = nullptr;
 	if (_M_target)
-	  if (const auto* __p = _M_target->target(typeid(_Executor)))
-	    return static_cast<const _Executor*>(__p);
-	return nullptr;
-      }
+	  {
+	    if (_M_target->_M_func == &_Tgt1<remove_cv_t<_Executor>>::_S_func)
+	      return (_Executor*)_M_target->_M_func(_M_target.get(), nullptr);
+#if __cpp_rtti
+	    else
+	      __p = _M_target->target(&typeid(_Executor));
 #endif
+	  }
+	return static_cast<const _Executor*>(__p);
+      }
 
   private:
     struct _Tgt
@@ -1126,85 +1147,134 @@ inline namespace v1
       virtual void dispatch(std::function<void()>) const = 0;
       virtual void post(std::function<void()>) const = 0;
       virtual void defer(std::function<void()>) const = 0;
-#if __cpp_rtti
-      virtual const type_info& target_type() const = 0;
-      virtual void* target(const std::type_info&) const = 0;
+      virtual const void* target_type() const noexcept = 0;
+      virtual void* target(const void*) noexcept = 0;
       virtual bool _M_equals(_Tgt*) const noexcept = 0;
-      virtual const void* _M_get_executor() const noexcept = 0;
-#endif
+
+      using _Func = void* (_Tgt*, const _Tgt*);
+      _Func* _M_func; // Provides access to target without RTTI
     };
 
-    template<typename _Ex, typename _Alloc>
-      struct _TgtImpl : _Tgt
+    template<typename _Ex>
+      struct _Tgt1 : _Tgt
       {
 	explicit
-	_TgtImpl(_Ex&& __ex, const _Alloc& __a)
-	: _M_impl(std::move(__ex), __a) { }
+	_Tgt1(_Ex&& __ex)
+	: _M_ex(std::move(__ex))
+	{ this->_M_func = &_S_func; }
 
-	void on_work_started() const noexcept { _M_ex().on_work_started(); }
-	void on_work_finished() const noexcept { _M_ex().on_work_finished(); }
-	execution_context& context() const noexcept { return _M_ex().context(); }
 	void
-	dispatch(std::function<void()> __f) const
-	{ _M_ex().dispatch(std::move(__f), _M_alloc()); }
+	on_work_started() const noexcept override
+	{ _M_ex.on_work_started(); }
+
+	void
+	on_work_finished() const noexcept override
+	{ _M_ex.on_work_finished(); }
+
+	execution_context&
+	context() const noexcept override
+	{ return _M_ex.context(); }
+
+	void
+	dispatch(std::function<void()> __f) const override
+	{ _M_ex.dispatch(std::move(__f), allocator<void>()); }
+
 	void
-	post(std::function<void()> __f) const
-	{ _M_ex().post(std::move(__f), _M_alloc()); }
+	post(std::function<void()> __f) const override
+	{ _M_ex.post(std::move(__f), allocator<void>()); }
+
 	void
-	defer(std::function<void()> __f) const
-	{ _M_ex().defer(std::move(__f), _M_alloc()); }
+	defer(std::function<void()> __f) const override
+	{ _M_ex.defer(std::move(__f), allocator<void>()); }
 
+	const void*
+	target_type() const noexcept override
+	{
 #if __cpp_rtti
-	virtual const type_info&
-	target_type() const
-	{ return typeid(_Ex); }
+	  return &typeid(_Ex);
+#else
+	  return nullptr;
+#endif
+	}
 
-	virtual const void*
-	target(const std::type_info& __ti) const
+	void*
+	target(const void* __ti) noexcept override
 	{
-	  if (__ti == typeid(_Ex))
-	    return std::addressof(_M_ex());
+#if __cpp_rtti
+	  if (*static_cast<const type_info*>(__ti) == typeid(_Ex))
+	    return std::__addressof(_M_ex);
+#endif
 	  return nullptr;
 	}
 
-	virtual bool
-	_M_equals(const _Tgt* __tgt) const noexcept
+	bool
+	_M_equals(_Tgt* __tgt) const noexcept override
 	{
-	  if (__tgt->target_type() == typeid(_Ex))
-	    *static_cast<const _Ex*>(__tgt->_M_get_executor()) == _M_ex();
+#if __cpp_rtti
+	  if (const void* __p = __tgt->target(&typeid(_Ex)))
+	    return *static_cast<const _Ex*>(__p) == _M_ex;
+#endif
 	  return false;
 	}
 
-	virtual const void*
-	_M_get_executor() const noexcept
-	{ return std::addressof(_M_ex()); }
-#endif
+	_Ex _M_ex [[__no_unique_address__]];
 
-	_Ex& _M_ex() { return std::get<0>(_M_impl); }
-	_Alloc& _M_alloc() { return std::get<1>(_M_impl); }
-	std::tuple<_Ex, _Alloc> _M_impl;
+	static void*
+	_S_func(_Tgt* __p, const _Tgt* __q) noexcept
+	{
+	  auto& __ex = static_cast<_Tgt1*>(__p)->_M_ex;
+	  if (__q)
+	    {
+	      if (__ex == static_cast<const _Tgt1*>(__q)->_M_ex)
+		return __p;
+	      else
+		return nullptr;
+	    }
+	  else
+	    return std::__addressof(__ex);
+	}
       };
 
-    template<typename _Ex, typename _Alloc = std::allocator<void>>
-      shared_ptr<_Tgt>
-      _M_create(_Ex&& __ex, const _Alloc& __a = _Alloc())
+    template<typename _Ex, typename _Alloc>
+      struct _Tgt2 : _Tgt1<_Ex>
       {
-	return allocate_shared<_TgtImpl<_Ex, _Alloc>>(__a, std::move(__ex),
-						      __a);
-      }
+	explicit
+	_Tgt2(_Ex&& __ex, const _Alloc& __a)
+	: _Tgt1<_Ex>(std::move(__ex)), _M_alloc(__a) { }
+
+	void
+	dispatch(std::function<void()> __f) const override
+	{ this->_M_ex.dispatch(std::move(__f), _M_alloc); }
+
+	void
+	post(std::function<void()> __f) const override
+	{ this->_M_ex.post(std::move(__f), _M_alloc); }
+
+	void
+	defer(std::function<void()> __f) const override
+	{ this->_M_ex.defer(std::move(__f), _M_alloc); }
+
+	_Alloc _M_alloc [[__no_unique_address__]];
+      };
+
+    // Partial specialization for std::allocator<T>.
+    // Don't store the allocator.
+    template<typename _Ex, typename _Tp>
+      struct _Tgt2<_Ex, std::allocator<_Tp>> : _Tgt1<_Ex>
+      { };
 
     friend bool
     operator==(const executor& __a, const executor& __b) noexcept
     {
-      if (__a._M_target == __b._M_target)
+      _Tgt* __ta = __a._M_target.get();
+      _Tgt* __tb = __b._M_target.get();
+      if (__ta == __tb)
 	return true;
-      if (!__a._M_target || !__b._M_target)
+      if (!__ta || !__tb)
 	return false;
-#if __cpp_rtti
-      return __a._M_target->_M_equals(__b._M_target.get());
-#else
-      return false; // XXX can we do better?
-#endif
+      if (__ta->_M_func == __tb->_M_func)
+	return __ta->_M_func(__ta, __tb);
+      return __ta->_M_equals(__tb);
     }
 
     shared_ptr<_Tgt> _M_target;
@@ -1217,6 +1287,22 @@ inline namespace v1
   operator==(const executor& __e, nullptr_t) noexcept
   { return !__e; }
 
+  inline bool
+  operator==(nullptr_t, const executor& __e) noexcept
+  { return !__e; }
+
+  inline bool
+  operator!=(const executor& __a, const executor& __b) noexcept
+  { return !(__a == __b); }
+
+  inline bool
+  operator!=(const executor& __e, nullptr_t) noexcept
+  { return (bool)__e; }
+
+  inline bool
+  operator!=(nullptr_t, const executor& __e) noexcept
+  { return (bool)__e; }
+
   /// Swap two executor objects.
   inline void swap(executor& __a, executor& __b) noexcept { __a.swap(__b); }
 
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 3b397737bb6..adb17c79f1a 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -126,7 +126,7 @@ namespace ip
   struct v4_mapped_t {};
   constexpr v4_mapped_t v4_mapped;
 
-  // @}
+  /// @}
 
   /// An IPv4 address.
   class address_v4
@@ -530,7 +530,7 @@ namespace ip
   operator>=(const address_v4& __a, const address_v4& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 comparisons
    * @{
@@ -574,7 +574,7 @@ namespace ip
   operator>=(const address_v6& __a, const address_v6& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address comparisons
    * @{
@@ -612,7 +612,7 @@ namespace ip
   operator>=(const address& __a, const address& __b) noexcept
   { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /** ip::address_v4 creation
    * @{
@@ -684,7 +684,7 @@ namespace ip
   make_address_v4(string_view __str)
   { return make_address_v4(__str, __throw_on_error{"make_address_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::address_v6 creation
    * @{
@@ -847,7 +847,7 @@ namespace ip
   make_address_v6(string_view __str)
   { return make_address_v6(__str, __throw_on_error{"make_address_v6"}); }
 
-  // @}
+  /// @}
 
   /** ip::address creation
    * @{
@@ -892,7 +892,7 @@ namespace ip
   make_address(string_view __str)
   { return make_address(__str, __throw_on_error{"make_address"}); }
 
-  // @}
+  /// @}
 
   /// ip::address I/O
   template<typename _CharT, typename _Traits>
@@ -1073,7 +1073,7 @@ namespace ip
 
   typedef basic_address_range<address_v4> address_v4_range;
 
-  // @}
+  /// @}
 
   /** An IPv6 address range.
    * @{
@@ -1120,7 +1120,7 @@ namespace ip
   bool
   operator==(const network_v6& __a, const network_v6& __b) noexcept;
 
-  // @}
+  /// @}
 
   /// An IPv4 network address.
   class network_v4
@@ -1286,7 +1286,7 @@ namespace ip
   operator!=(const network_v4& __a, const network_v4& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 comparisons
    * @{
@@ -1303,7 +1303,7 @@ namespace ip
   operator!=(const network_v6& __a, const network_v6& __b) noexcept
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** ip::network_v4 creation
    * @{
@@ -1335,7 +1335,7 @@ namespace ip
   make_network_v4(string_view __str)
   { return make_network_v4(__str, __throw_on_error{"make_network_v4"}); }
 
-  // @}
+  /// @}
 
   /** ip::network_v6 creation
    * @{
@@ -1363,7 +1363,7 @@ namespace ip
   make_network_v6(string_view __str)
   { return make_network_v6(__str, __throw_on_error{"make_network_v6"}); }
 
-  // @}
+  /// @}
 
   /// ip::network_v4 I/O
   template<typename _CharT, typename _Traits>
@@ -1545,7 +1545,7 @@ namespace ip
 	       const basic_endpoint<_InternetProtocol>& __b)
     { return !(__a < __b); }
 
-  // @}
+  /// @}
 
   /// basic_endpoint I/O
   template<typename _CharT, typename _Traits, typename _InternetProtocol>
@@ -1619,7 +1619,7 @@ namespace ip
 	       const basic_resolver_entry<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /** Base class defining flags for name/address resolution.
    * @{
@@ -1685,7 +1685,7 @@ namespace ip
 
   // TODO define resolver_base::flags static constants for C++14 mode
 
-  // @}
+  /// @}
 
   /** Container for results of name/address resolution.
    * @{
@@ -1765,7 +1765,7 @@ namespace ip
 	       const basic_resolver_results<_InternetProtocol>& __b)
     { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Perform name/address resolution.
   template<typename _InternetProtocol>
@@ -2048,7 +2048,7 @@ namespace ip
   host_name()
   { return host_name(std::allocator<char>{}, __throw_on_error{"host_name"}); }
 
-  // @}
+  /// @}
 
   /// The TCP byte-stream protocol.
   class tcp
@@ -2103,7 +2103,7 @@ namespace ip
   operator!=(const tcp& __a, const tcp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// The UDP datagram protocol.
   class udp
@@ -2142,7 +2142,7 @@ namespace ip
   operator!=(const udp& __a, const udp& __b)
   { return !(__a == __b); }
 
-  // @}
+  /// @}
 
   /// Restrict a socket created for an IPv6 protocol to IPv6 only.
   struct v6_only : __sockopt_crtp<v6_only, bool>
@@ -2372,7 +2372,7 @@ namespace ip
 
   } // namespace multicast
 
-  // @}
+  /// @}
 
 } // namespace ip
 } // namespace v1
diff --git a/libstdc++-v3/include/experimental/numeric b/libstdc++-v3/include/experimental/numeric
index e5123a993d4..5621ca6e0ae 100644
--- a/libstdc++-v3/include/experimental/numeric
+++ b/libstdc++-v3/include/experimental/numeric
@@ -53,15 +53,19 @@ inline namespace fundamentals_v2
   /// Greatest common divisor
   template<typename _Mn, typename _Nn>
     constexpr common_type_t<_Mn, _Nn>
-    gcd(_Mn __m, _Nn __n)
+    gcd(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>, "gcd arguments are integers");
-      static_assert(is_integral_v<_Nn>, "gcd arguments are integers");
-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,
-		    "gcd arguments are not bools");
-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,
-		    "gcd arguments are not bools");
-      return std::__detail::__gcd(__m, __n);
+      static_assert(is_integral_v<_Mn>,
+	  "std::experimental::gcd arguments must be integers");
+      static_assert(is_integral_v<_Nn>,
+	  "std::experimental::gcd arguments must be integers");
+      static_assert(_Mn(2) != _Mn(1),
+	  "std::experimental::gcd arguments must not be bool");
+      static_assert(_Nn(2) != _Nn(1),
+	  "std::experimental::gcd arguments must not be bool");
+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
+      return std::__detail::__gcd(std::__detail::__absu<_Up>(__m),
+				  std::__detail::__absu<_Up>(__n));
     }
 
   /// Least common multiple
@@ -69,13 +73,17 @@ inline namespace fundamentals_v2
     constexpr common_type_t<_Mn, _Nn>
     lcm(_Mn __m, _Nn __n)
     {
-      static_assert(is_integral_v<_Mn>, "lcm arguments are integers");
-      static_assert(is_integral_v<_Nn>, "lcm arguments are integers");
-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,
-		    "lcm arguments are not bools");
-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,
-		    "lcm arguments are not bools");
-      return std::__detail::__lcm(__m, __n);
+      static_assert(is_integral_v<_Mn>,
+	  "std::experimental::lcm arguments must be integers");
+      static_assert(is_integral_v<_Nn>,
+	  "std::experimental::lcm arguments must be integers");
+      static_assert(_Mn(2) != _Mn(1),
+	  "std::experimental::lcm arguments must not be bool");
+      static_assert(_Nn(2) != _Nn(1),
+	  "std::experimental::lcm arguments must not be bool");
+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
+      return std::__detail::__lcm(std::__detail::__absu<_Up>(__m),
+				  std::__detail::__absu<_Up>(__n));
     }
 } // namespace fundamentals_v2
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index f465eca96f0..c4a43c3eca8 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -977,7 +977,7 @@ inline namespace fundamentals_v1
     make_optional(_Tp&& __t)
     { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }
 
-  // @} group optional
+  /// @} group optional
 } // namespace fundamentals_v1
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/propagate_const b/libstdc++-v3/include/experimental/propagate_const
index a28bed78746..f5cdb34cc23 100644
--- a/libstdc++-v3/include/experimental/propagate_const
+++ b/libstdc++-v3/include/experimental/propagate_const
@@ -421,7 +421,7 @@ inline namespace fundamentals_v2
       return __pt._M_t;
     }
 
-  // @} group propagate_const
+  /// @} group propagate_const
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff --git a/libstdc++-v3/include/experimental/socket b/libstdc++-v3/include/experimental/socket
index e80626528ce..51a3a725e1b 100644
--- a/libstdc++-v3/include/experimental/socket
+++ b/libstdc++-v3/include/experimental/socket
@@ -79,6 +79,20 @@ inline namespace v1
     not_found = 4
   };
 
+} // namespace v1
+} // namespace net
+} // namespace experimental
+
+  template<>
+    struct is_error_code_enum<experimental::net::v1::socket_errc>
+    : public true_type {};
+
+namespace experimental
+{
+namespace net
+{
+inline namespace v1
+{
   const error_category& socket_category() noexcept
   {
     struct __cat : error_category
@@ -2251,7 +2265,7 @@ inline namespace v1
       protocol_type _M_protocol;
     };
 
-  // @}
+  /// @}
 
   /** @brief Socket streams
    * @{
@@ -2421,7 +2435,7 @@ inline namespace v1
       __streambuf_type _M_sb;
     };
 
-  // @}
+  /// @}
 
   /** @brief synchronous connect operations
    * @{
@@ -2542,7 +2556,7 @@ inline namespace v1
 			  __ec);
     }
 
-  // @}
+  /// @}
 
   /** @brief asynchronous connect operations
    * @{
@@ -2592,20 +2606,16 @@ inline namespace v1
 				forward<_CompletionToken>(__token));
     }
 
-  // @}
+  /// @}
 
 #endif  // _GLIBCXX_HAVE_UNISTD_H
 
-  // @}
+  /// @}
 
 } // namespace v1
 } // namespace net
 } // namespace experimental
 
-  template<>
-    struct is_error_code_enum<experimental::net::v1::socket_errc>
-    : public true_type {};
-
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff --git a/libstdc++-v3/include/experimental/string_view b/libstdc++-v3/include/experimental/string_view
index 9e810dec844..78c4d332b27 100644
--- a/libstdc++-v3/include/experimental/string_view
+++ b/libstdc++-v3/include/experimental/string_view
@@ -178,8 +178,7 @@ inline namespace fundamentals_v1
       constexpr const _CharT&
       operator[](size_type __pos) const
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(__pos < this->_M_len);
+	__glibcxx_assert(__pos < this->_M_len);
 	return *(this->_M_str + __pos);
       }
 
@@ -198,16 +197,14 @@ inline namespace fundamentals_v1
       constexpr const _CharT&
       front() const
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(this->_M_len > 0);
+	__glibcxx_assert(this->_M_len > 0);
 	return *this->_M_str;
       }
 
       constexpr const _CharT&
       back() const
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(this->_M_len > 0);
+	__glibcxx_assert(this->_M_len > 0);
 	return *(this->_M_str + this->_M_len - 1);
       }
 
diff --git a/libstdc++-v3/include/ext/malloc_allocator.h b/libstdc++-v3/include/ext/malloc_allocator.h
index e225923b20f..c8fce2c861c 100644
--- a/libstdc++-v3/include/ext/malloc_allocator.h
+++ b/libstdc++-v3/include/ext/malloc_allocator.h
@@ -151,14 +151,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up, typename... _Args>
         void
         construct(_Up* __p, _Args&&... __args)
-	noexcept(noexcept(::new((void *)__p)
-			  _Up(std::forward<_Args>(__args)...)))
+	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 
       template<typename _Up>
         void 
         destroy(_Up* __p)
-	noexcept(noexcept(__p->~_Up()))
+	noexcept(std::is_nothrow_destructible<_Up>::value)
 	{ __p->~_Up(); }
 #else
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
diff --git a/libstdc++-v3/include/ext/new_allocator.h b/libstdc++-v3/include/ext/new_allocator.h
index e24539100f9..22c95efc2d5 100644
--- a/libstdc++-v3/include/ext/new_allocator.h
+++ b/libstdc++-v3/include/ext/new_allocator.h
@@ -142,14 +142,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Up, typename... _Args>
 	void
 	construct(_Up* __p, _Args&&... __args)
-	noexcept(noexcept(::new((void *)__p)
-			    _Up(std::forward<_Args>(__args)...)))
+	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 
       template<typename _Up>
 	void
 	destroy(_Up* __p)
-	noexcept(noexcept( __p->~_Up()))
+	noexcept(std::is_nothrow_destructible<_Up>::value)
 	{ __p->~_Up(); }
 #else
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
diff --git a/libstdc++-v3/include/ext/numeric_traits.h b/libstdc++-v3/include/ext/numeric_traits.h
index 67993fdc58e..206bcda46d0 100644
--- a/libstdc++-v3/include/ext/numeric_traits.h
+++ b/libstdc++-v3/include/ext/numeric_traits.h
@@ -39,29 +39,43 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // Compile time constants for builtin types.
-  // Sadly std::numeric_limits member functions cannot be used for this.
-#define __glibcxx_signed(_Tp) ((_Tp)(-1) < 0)
-#define __glibcxx_digits(_Tp) \
-  (sizeof(_Tp) * __CHAR_BIT__ - __glibcxx_signed(_Tp))
-
-#define __glibcxx_min(_Tp) \
-  (__glibcxx_signed(_Tp) ? (_Tp)1 << __glibcxx_digits(_Tp) : (_Tp)0)
+  // In C++98 std::numeric_limits member functions are not constant expressions
+  // (that changed in C++11 with the addition of 'constexpr').
+  // Even for C++11, this header is smaller than <limits> and can be used
+  // when only is_signed, digits, min, or max values are needed for integers,
+  // or is_signed, digits10, max_digits10, or max_exponent10 for floats.
+
+  // Unlike __is_integer (and std::is_integral) this trait is true for
+  // non-standard built-in integer types such as __int128 and __int20.
+  template<typename _Tp>
+    struct __is_integer_nonstrict
+    : public std::__is_integer<_Tp>
+    {
+      using std::__is_integer<_Tp>::__value;
 
-#define __glibcxx_max(_Tp) \
-  (__glibcxx_signed(_Tp) ? \
-   (((((_Tp)1 << (__glibcxx_digits(_Tp) - 1)) - 1) << 1) + 1) : ~(_Tp)0)
+      // The number of bits in the value representation.
+      enum { __width = __value ? sizeof(_Tp) * __CHAR_BIT__ : 0 };
+    };
 
   template<typename _Value>
     struct __numeric_traits_integer
     {
-      // Only integers for initialization of member constant.
-      static const _Value __min = __glibcxx_min(_Value);
-      static const _Value __max = __glibcxx_max(_Value);
-
-      // NB: these two also available in std::numeric_limits as compile
-      // time constants, but <limits> is big and we avoid including it.
-      static const bool __is_signed = __glibcxx_signed(_Value);
-      static const int __digits = __glibcxx_digits(_Value);      
+#if __cplusplus >= 201103L
+      static_assert(__is_integer_nonstrict<_Value>::__value,
+		    "invalid specialization");
+#endif
+
+      // NB: these two are also available in std::numeric_limits as compile
+      // time constants, but <limits> is big and we can avoid including it.
+      static const bool __is_signed = (_Value)(-1) < 0;
+      static const int __digits
+	= __is_integer_nonstrict<_Value>::__width - __is_signed;
+
+      // The initializers must be constants so that __max and __min are too.
+      static const _Value __max = __is_signed
+	? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
+	: ~(_Value)0;
+      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
     };
 
   template<typename _Value>
@@ -76,10 +90,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Value>
     const int __numeric_traits_integer<_Value>::__digits;
 
-#undef __glibcxx_signed
-#undef __glibcxx_digits
-#undef __glibcxx_min
-#undef __glibcxx_max
+  // Enable __numeric_traits_integer for types where the __is_integer_nonstrict
+  // primary template doesn't give the right answer.
+#define _GLIBCXX_INT_N_TRAITS(T, WIDTH)			\
+  template<> struct __is_integer_nonstrict<T>		\
+  {							\
+    enum { __value = 1 };				\
+    typedef std::__true_type __type;			\
+    enum { __width = WIDTH };				\
+  };							\
+  template<> struct __is_integer_nonstrict<unsigned T>	\
+  {							\
+    enum { __value = 1 };				\
+    typedef std::__true_type __type;			\
+    enum { __width = WIDTH };				\
+  };
+
+  // We need to specify the width for some __intNN types because they
+  // have padding bits, e.g. the object representation of __int20 has 32 bits,
+  // but its width (number of bits in the value representation) is only 20.
+#if defined __GLIBCXX_TYPE_INT_N_0 && __GLIBCXX_BITSIZE_INT_N_0 % __CHAR_BIT__
+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_0, __GLIBCXX_BITSIZE_INT_N_0)
+#endif
+#if defined __GLIBCXX_TYPE_INT_N_1 && __GLIBCXX_BITSIZE_INT_N_1 % __CHAR_BIT__
+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_1, __GLIBCXX_BITSIZE_INT_N_1)
+#endif
+#if defined __GLIBCXX_TYPE_INT_N_2 && __GLIBCXX_BITSIZE_INT_N_2 % __CHAR_BIT__
+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_2, __GLIBCXX_BITSIZE_INT_N_2)
+#endif
+#if defined __GLIBCXX_TYPE_INT_N_3 && __GLIBCXX_BITSIZE_INT_N_3 % __CHAR_BIT__
+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_3, __GLIBCXX_BITSIZE_INT_N_3)
+#endif
+
+#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__
+  // In strict modes __is_integer<__int128> is false,
+  // but we still want to define __numeric_traits_integer<__int128>.
+  _GLIBCXX_INT_N_TRAITS(__int128, 128)
+#endif
+
+#undef _GLIBCXX_INT_N_TRAITS
+
+#if __cplusplus >= 201103L
+  /// Convenience alias for __numeric_traits<integer-type>.
+  template<typename _Tp>
+    using __int_traits = __numeric_traits_integer<_Tp>;
+#endif
 
 #define __glibcxx_floating(_Tp, _Fval, _Dval, _LDval) \
   (std::__are_same<_Tp, float>::__value ? _Fval \
@@ -96,10 +151,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, \
 		     __LDBL_MAX_10_EXP__)
 
+  // N.B. this only supports float, double and long double (no __float128 etc.)
   template<typename _Value>
     struct __numeric_traits_floating
     {
-      // Only floating point types. See N1822. 
+      // Only floating point types. See N1822.
       static const int __max_digits10 = __glibcxx_max_digits10(_Value);
 
       // See above comment...
@@ -135,4 +191,4 @@ _GLIBCXX_END_NAMESPACE_VERSION
 #undef __glibcxx_digits10
 #undef __glibcxx_max_exponent10
 
-#endif 
+#endif
diff --git a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
index 823b576ca3a..a01ec403650 100644
--- a/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/assoc_container.hpp
@@ -516,7 +516,7 @@ namespace __gnu_pbds
     swap(gp_hash_table& other)
     { base_type::swap(other); }
   };
-  //@} hash-based
+  ///@} hash-based
 #undef PB_DS_GP_HASH_BASE
 
 
@@ -780,7 +780,7 @@ namespace __gnu_pbds
     swap(trie& other)
     { base_type::swap(other); }
   };
-  //@} branch-based
+  ///@} branch-based
 #undef PB_DS_TRIE_BASE
 #undef PB_DS_TRIE_NODE_AND_IT_TRAITS
 
@@ -852,10 +852,10 @@ namespace __gnu_pbds
     swap(list_update& other)
     { base_type::swap(other); }
   };
-  //@} list-based
+  ///@} list-based
 #undef PB_DS_LU_BASE
 
-  // @} group containers-pbds
+  /// @} group containers-pbds
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
index b39643fecab..8356250034e 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/priority_queue_base_dispatch.hpp
@@ -63,6 +63,12 @@ namespace __gnu_pbds
 {
   namespace detail
   {
+    /**
+     *  @ingroup pbds
+     *
+     *  @{
+     */
+
     /// Specialization for pairing_heap.
     template<typename _VTp, typename Cmp_Fn, typename _Alloc>
       struct container_base_dispatch<_VTp, Cmp_Fn, _Alloc, pairing_heap_tag,
@@ -107,7 +113,7 @@ namespace __gnu_pbds
 	/// Dispatched type.
 	typedef thin_heap<_VTp, Cmp_Fn, _Alloc> 		type;
       };
-    //@} group pbds
+    ///@} group pbds
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
index e0d1ce493e0..d156b881500 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/tree_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename tree_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
index 8621dc1cd21..4502f7af946 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/trie_policy/node_metadata_selector.hpp
@@ -96,7 +96,7 @@ namespace __gnu_pbds
     public:
       typedef typename trie_metadata_helper<__node_u, null_update>::type type;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
index 908d61d1ed3..07df86ff40c 100644
--- a/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/detail/types_traits.hpp
@@ -281,7 +281,7 @@ namespace __gnu_pbds
 	store_extra			       	m_store_extra_indicator;
 	no_throw_indicator 		 	m_no_throw_copies_indicator;
     };
-    //@}
+    ///@}
   } // namespace detail
 } // namespace __gnu_pbds
 
diff --git a/libstdc++-v3/include/ext/pb_ds/exception.hpp b/libstdc++-v3/include/ext/pb_ds/exception.hpp
index e6643dff71f..126a66519af 100644
--- a/libstdc++-v3/include/ext/pb_ds/exception.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/exception.hpp
@@ -87,7 +87,7 @@ namespace __gnu_pbds
   inline void
   __throw_resize_error()
   { _GLIBCXX_THROW_OR_ABORT(resize_error()); }
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
index c779e8c1b83..6a9f28c9020 100644
--- a/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/priority_queue.hpp
@@ -51,6 +51,7 @@ namespace __gnu_pbds
   /**
    *  @defgroup heap-based Heap-Based
    *  @ingroup containers-pbds
+   *
    *  @{
    */
 
@@ -152,6 +153,6 @@ namespace __gnu_pbds
     swap(priority_queue& other)
     { base_type::swap(other); }
   };
+ ///@} heap-based
 } // namespace __gnu_pbds
- //@} heap-based
 #endif
diff --git a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
index 5aa78ff6ca3..e0a99153e01 100644
--- a/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
+++ b/libstdc++-v3/include/ext/pb_ds/tag_and_trait.hpp
@@ -113,7 +113,7 @@ namespace __gnu_pbds
    */
   struct range_invalidation_guarantee : public point_invalidation_guarantee
   { };
-  //@}
+  ///@}
 
 
   /**
@@ -184,8 +184,8 @@ namespace __gnu_pbds
 
   /// Thin heap.
   struct thin_heap_tag : public priority_queue_tag { };
-  //@}
-  //@}
+  ///@}
+  ///@}
 
 
   /**
@@ -438,7 +438,7 @@ namespace __gnu_pbds
 	reverse_iteration = base_type::reverse_iteration
       };
   };
-  //@}
+  ///@}
 
 
   namespace detail
@@ -448,7 +448,7 @@ namespace __gnu_pbds
 	     typename Policy_Tl = null_type>
       struct container_base_dispatch;
   } // namespace detail
-  //@}
+  ///@}
 } // namespace __gnu_pbds
 
 #endif
diff --git a/libstdc++-v3/include/ext/random b/libstdc++-v3/include/ext/random
index 41a2962c8f6..1f9a853fda6 100644
--- a/libstdc++-v3/include/ext/random
+++ b/libstdc++-v3/include/ext/random
@@ -1028,7 +1028,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ndy(result_type(0), __p.sigma())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1280,7 +1280,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd(__p.mu(), __p.omega() / __p.mu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1525,7 +1525,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_ud()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -1786,7 +1786,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	_M_gd2(__p.nu(), __p.mu() / __p.nu())
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -2025,7 +2025,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      +1.5707963267948966192313216916397514L)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3288,7 +3288,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p)
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
@@ -3694,7 +3694,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       : _M_param(__p), _M_uosd()
       { }
 
-      // @}
+      /// @}
 
       /**
        * @brief Resets the distribution state.
diff --git a/libstdc++-v3/include/ext/throw_allocator.h b/libstdc++-v3/include/ext/throw_allocator.h
index 38e80f721da..bbb3b057832 100644
--- a/libstdc++-v3/include/ext/throw_allocator.h
+++ b/libstdc++-v3/include/ext/throw_allocator.h
@@ -63,6 +63,13 @@
 # include <tr1/random>
 #endif
 
+#ifdef __has_builtin
+# if !__has_builtin(__builtin_sprintf)
+#  include <cstdio>
+#  define _GLIBCXX_NO_BUILTIN_SPRINTF
+# endif
+#endif
+
 namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -309,6 +316,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     static void
     log_to_string(std::string& s, const_reference ref)
     {
+#ifdef _GLIBCXX_NO_BUILTIN_SPRINTF
+      __typeof__(&std::sprintf) __builtin_sprintf = &std::sprintf;
+#endif
+
       char buf[40];
       const char tab('\t');
       s += "label: ";
@@ -331,6 +342,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     static void
     log_to_string(std::string& s, const std::pair<const void*, size_t>& ref)
     {
+#ifdef _GLIBCXX_NO_BUILTIN_SPRINTF
+      auto __builtin_sprintf = &std::sprintf;
+#endif
+
       char buf[40];
       const char tab('\t');
       s += "label: ";
@@ -565,6 +580,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static gen_t generator(engine(), distribution);
 #endif
 
+#ifdef _GLIBCXX_NO_BUILTIN_SPRINTF
+      __typeof__(&std::sprintf) __builtin_sprintf = &std::sprintf;
+#endif
+
       double random = generator();
       if (random < distribution.min() || random > distribution.max())
 	{
@@ -945,6 +964,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
+#undef _GLIBCXX_NO_BUILTIN_SPRINTF
+
 #if __cplusplus >= 201103L
 
 # include <bits/functional_hash.h>
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index 229c7c6b65e..91c4c1a7cf1 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -501,7 +501,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return static_cast<_ValueType>(std::move(*__p));
       __throw_bad_any_cast();
     }
-  // @}
+  /// @}
 
   /// @cond undocumented
   template<typename _Tp>
@@ -560,7 +560,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
-  // @}
+  /// @}
 
   template<typename _Tp>
     void
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index 699431e9727..bf09e2dd5c7 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -1472,7 +1472,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		     __atomic_val_t<_ITp> __i) noexcept
     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }
 
-  // @} group atomics
+  /// @} group atomics
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/bit b/libstdc++-v3/include/std/bit
index c753e39b64a..c4af1cfcb4d 100644
--- a/libstdc++-v3/include/std/bit
+++ b/libstdc++-v3/include/std/bit
@@ -250,6 +250,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201703L
 
+#define __cpp_lib_bitops 201907L
+
   template<typename _Tp, typename _Up, bool = is_integral_v<_Tp>>
     struct _If_is_unsigned_integer_type { };
 
@@ -305,6 +307,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // [bit.pow.two], integral powers of 2
 
+#define __cpp_lib_int_pow2 201806L
+
   template<typename _Tp>
     constexpr _If_is_unsigned_integer<_Tp, bool>
     ispow2(_Tp __x) noexcept
diff --git a/libstdc++-v3/include/std/bitset b/libstdc++-v3/include/std/bitset
index d6958301e8a..dde6e67915f 100644
--- a/libstdc++-v3/include/std/bitset
+++ b/libstdc++-v3/include/std/bitset
@@ -961,7 +961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #endif
 
       // 23.3.5.2 bitset operations:
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __rhs  A same-sized bitset.
@@ -988,9 +988,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	this->_M_do_xor(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  Operations on bitsets.
        *  @param  __position  The number of places to shift.
@@ -1022,9 +1022,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  These versions of single-bit set, reset, flip, and test are
        *  extensions from the SGI version.  They do no range checking.
@@ -1065,7 +1065,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT
       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
 		!= static_cast<_WordT>(0)); }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -1144,7 +1144,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator~() const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __position  Index into the %bitset.
@@ -1166,7 +1166,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       _GLIBCXX_CONSTEXPR bool
       operator[](size_t __position) const
       { return _Unchecked_test(__position); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %bitset.
@@ -1300,7 +1300,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       size() const _GLIBCXX_NOEXCEPT
       { return _Nb; }
 
-      //@{
+      ///@{
       /// These comparisons for equality/inequality are, well, @e bitwise.
       bool
       operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
@@ -1309,7 +1309,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bool
       operator!=(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_equal(__rhs); }
-      //@}
+      ///@}
 
       /**
        *  @brief Tests the value of a bit.
@@ -1350,7 +1350,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       none() const _GLIBCXX_NOEXCEPT
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       bitset<_Nb>
       operator<<(size_t __position) const _GLIBCXX_NOEXCEPT
@@ -1359,7 +1359,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       bitset<_Nb>
       operator>>(size_t __position) const _GLIBCXX_NOEXCEPT
       { return bitset<_Nb>(*this) >>= __position; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1419,7 +1419,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       }
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1454,9 +1454,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __result ^= __y;
       return __result;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief Global I/O operators for bitsets.
    *
@@ -1546,7 +1546,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
       return __os << __tmp;
     }
-  //@}
+  ///@}
 
 _GLIBCXX_END_NAMESPACE_CONTAINER
 } // namespace std
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index 9f01d4c0889..a6a3ceb3ce9 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -425,7 +425,11 @@ namespace __detail
       static_assert(is_unsigned<_Tp>::value, "implementation bug");
 
       const ptrdiff_t __len = __last - __first;
-      int __i = 0;
+      ptrdiff_t __i = 0;
+      while (__i < __len && __first[__i] == '0')
+	++__i;
+      const ptrdiff_t __leading_zeroes = __i;
+
       while (__i < __len)
 	{
 	  const unsigned char __c = (unsigned)__first[__i] - '0';
@@ -436,7 +440,7 @@ namespace __detail
 	  __i++;
 	}
       __first += __i;
-      return __i <= (sizeof(_Tp) * __CHAR_BIT__);
+      return (__i - __leading_zeroes) <= (sizeof(_Tp) * __CHAR_BIT__);
     }
 
   /// std::from_chars implementation for integers in bases 3 to 10.
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 9e63fa9c698..27bb46ff4f6 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -975,7 +975,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #endif // C++14
 
-  // @} group chrono
+  /// @} group chrono
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/std/complex b/libstdc++-v3/include/std/complex
index 45450e8ca01..448ca25332e 100644
--- a/libstdc++-v3/include/std/complex
+++ b/libstdc++-v3/include/std/complex
@@ -47,6 +47,10 @@
 // Get rid of a macro possibly defined in <complex.h>
 #undef complex
 
+#if __cplusplus > 201703L
+# define __cpp_lib_constexpr_complex 201711L
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -320,7 +324,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   // Operators:
-  //@{
+  ///@{
   ///  Return new complex value @a x plus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -348,9 +352,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x minus @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -378,9 +382,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r += __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x times @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -408,9 +412,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r *= __x;
       return __r;
     }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return new complex value @a x divided by @a y.
   template<typename _Tp>
     inline _GLIBCXX20_CONSTEXPR complex<_Tp>
@@ -438,7 +442,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __r /= __y;
       return __r;
     }
-  //@}
+  ///@}
 
   ///  Return @a x.
   template<typename _Tp>
@@ -452,7 +456,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator-(const complex<_Tp>& __x)
     { return complex<_Tp>(-__x.real(), -__x.imag()); }
 
-  //@{
+  ///@{
   ///  Return true if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -468,9 +472,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline _GLIBCXX_CONSTEXPR bool
     operator==(const _Tp& __x, const complex<_Tp>& __y)
     { return __x == __y.real() && _Tp() == __y.imag(); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   ///  Return false if @a x is equal to @a y.
   template<typename _Tp>
     inline _GLIBCXX_CONSTEXPR bool
@@ -486,7 +490,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline _GLIBCXX_CONSTEXPR bool
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
     { return __x != __y.real() || _Tp() != __y.imag(); }
-  //@}
+  ///@}
 
   ///  Extraction operator for complex values.
   template<typename _Tp, typename _CharT, class _Traits>
@@ -1542,7 +1546,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 #endif
 
-  // @} group complex_numbers
+  /// @} group complex_numbers
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/condition_variable b/libstdc++-v3/include/std/condition_variable
index a83996aca3d..ace029a1597 100644
--- a/libstdc++-v3/include/std/condition_variable
+++ b/libstdc++-v3/include/std/condition_variable
@@ -324,7 +324,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   } // end inline namespace
 
-  // @} group condition_variables
+  /// @} group condition_variables
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/deque b/libstdc++-v3/include/std/deque
index ed4927e13b7..b940dacb848 100644
--- a/libstdc++-v3/include/std/deque
+++ b/libstdc++-v3/include/std/deque
@@ -95,7 +95,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 201900L
+#define __cpp_lib_erase_if 202002L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename deque<_Tp, _Alloc>::size_type
diff --git a/libstdc++-v3/include/std/execution b/libstdc++-v3/include/std/execution
index 2d821e5c624..9f941c5e2f4 100644
--- a/libstdc++-v3/include/std/execution
+++ b/libstdc++-v3/include/std/execution
@@ -50,6 +50,7 @@
 
 // Feature test macro for parallel algorithms
 # define __cpp_lib_parallel_algorithm 201603L
+# define __cpp_lib_execution 201902L
 
 #endif // C++17
 
diff --git a/libstdc++-v3/include/std/forward_list b/libstdc++-v3/include/std/forward_list
index 9d6cc40593b..4b319f93a61 100644
--- a/libstdc++-v3/include/std/forward_list
+++ b/libstdc++-v3/include/std/forward_list
@@ -66,7 +66,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 201900L
+#define __cpp_lib_erase_if 202002L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename forward_list<_Tp, _Alloc>::size_type 
diff --git a/libstdc++-v3/include/std/fstream b/libstdc++-v3/include/std/fstream
index 419cb92c96c..5ac1da15d85 100644
--- a/libstdc++-v3/include/std/fstream
+++ b/libstdc++-v3/include/std/fstream
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool                      _M_reading;
       bool                      _M_writing;
 
-      //@{
+      ///@{
       /**
        *  Necessary bits for putback buffer management.
        *
@@ -165,7 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char_type*		_M_pback_cur_save;
       char_type*		_M_pback_end_save;
       bool			_M_pback_init;
-      //@}
+      ///@}
 
       // Cached codecvt facet.
       const __codecvt_type* 	_M_codecvt;
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index 528452fed40..ec832bab3b0 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -928,8 +928,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Fn, typename... _Args>
     _Bind_front_t<_Fn, _Args...>
     bind_front(_Fn&& __fn, _Args&&... __args)
-    noexcept(is_nothrow_constructible_v<int, _Bind_front_t<_Fn, _Args...>,
-					_Fn, _Args...>)
+    noexcept(is_nothrow_constructible_v<_Bind_front_t<_Fn, _Args...>,
+					int, _Fn, _Args...>)
     {
       return _Bind_front_t<_Fn, _Args...>(0, std::forward<_Fn>(__fn),
 					  std::forward<_Args>(__args)...);
@@ -974,7 +974,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _GLIBCXX_NOT_FN_CALL_OP( const & )
       _GLIBCXX_NOT_FN_CALL_OP( && )
       _GLIBCXX_NOT_FN_CALL_OP( const && )
-#undef _GLIBCXX_NOT_FN_CALL
+#undef _GLIBCXX_NOT_FN_CALL_OP
 
     private:
       _Fn _M_fn;
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 10136e57a84..8ed53d0a5b6 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1747,7 +1747,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif // _GLIBCXX_ASYNC_ABI_COMPAT
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group futures
+  /// @} group futures
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/iostream b/libstdc++-v3/include/std/iostream
index fa1bf2cc641..97283c1b03a 100644
--- a/libstdc++-v3/include/std/iostream
+++ b/libstdc++-v3/include/std/iostream
@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  startup and termination. For more information, see the section of the
    *  manual linked to above.
   */
-  //@{
+  ///@{
   extern istream cin;		/// Linked to standard input
   extern ostream cout;		/// Linked to standard output
   extern ostream cerr;		/// Linked to standard error (unbuffered)
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern wostream wcerr;	/// Linked to standard error (unbuffered)
   extern wostream wclog;	/// Linked to standard error (buffered)
 #endif
-  //@}
+  ///@}
 
   // For construction of filebuffers for cout, cin, cerr, clog et. al.
   static ios_base::Init __ioinit;
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 9bba178c40f..5e4b62dc14a 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -107,7 +107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -133,9 +133,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Extractors
        *
@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown if badbit is set in the exceptions mask.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief  Integer arithmetic extractors
        *  @param  __n A variable of builtin integral type.
@@ -199,9 +199,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator>>(unsigned long long& __n)
       { return _M_extract(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic extractors
        *  @param  __f A variable of builtin floating point type.
@@ -221,7 +221,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __istream_type&
       operator>>(long double& __f)
       { return _M_extract(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Basic arithmetic extractors
@@ -257,7 +257,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       operator>>(__streambuf_type* __sb);
-      //@}
+      ///@}
 
       // [27.6.1.3] unformatted input
       /**
@@ -269,7 +269,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       gcount() const
       { return _M_gcount; }
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Input Functions
        *
@@ -600,7 +600,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __istream_type&
       seekg(off_type, ios_base::seekdir);
-      //@}
+      ///@}
 
     protected:
       basic_istream()
@@ -735,7 +735,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character extractors
    *  @param  __in  An input stream.
@@ -760,9 +760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
     { return (__in >> reinterpret_cast<char&>(__c)); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  Character string extractors
    *  @param  __in  An input stream.
@@ -807,7 +807,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<char, _Traits>&
     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
     { return (__in >> reinterpret_cast<char*>(__s)); }
-  //@}
+  ///@}
 
   /**
    *  @brief  Template class basic_iostream
diff --git a/libstdc++-v3/include/std/list b/libstdc++-v3/include/std/list
index 8d6ac198c9a..6fb5ea8dcc4 100644
--- a/libstdc++-v3/include/std/list
+++ b/libstdc++-v3/include/std/list
@@ -90,7 +90,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 201900L
+#define __cpp_lib_erase_if 202002L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename list<_Tp, _Alloc>::size_type
diff --git a/libstdc++-v3/include/std/memory b/libstdc++-v3/include/std/memory
index b6950c76089..995bfa27a17 100644
--- a/libstdc++-v3/include/std/memory
+++ b/libstdc++-v3/include/std/memory
@@ -157,14 +157,32 @@ inline pointer_safety
 get_pointer_safety() noexcept { return pointer_safety::relaxed; }
 
 #if __cplusplus > 201703L
-  /// Inform the compiler that a pointer is aligned.
+#define __cpp_lib_assume_aligned 201811L
+  /** @brief Inform the compiler that a pointer is aligned.
+   *
+   *  @tparam _Align An alignment value (i.e. a power of two)
+   *  @tparam _Tp    An object type
+   *  @param  __ptr  A pointer that is aligned to _Align
+   *
+   *  C++20 20.10.6 [ptr.align]
+   *
+   *  @ingroup memory
+   */
   template<size_t _Align, class _Tp>
     [[nodiscard,__gnu__::__always_inline__]]
-    constexpr _Tp* assume_aligned(_Tp* __ptr)
+    constexpr _Tp*
+    assume_aligned(_Tp* __ptr) noexcept
     {
       static_assert(std::ispow2(_Align));
-      _GLIBCXX_DEBUG_ASSERT((std::uintptr_t)__ptr % _Align == 0);
-      return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Align));
+      if (std::is_constant_evaluated())
+	return __ptr;
+      else
+	{
+	  // This function is expected to be used in hot code, where
+	  // __glibcxx_assert would add unwanted overhead.
+	  _GLIBCXX_DEBUG_ASSERT((std::uintptr_t)__ptr % _Align == 0);
+	  return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Align));
+	}
     }
 #endif // C++2a
 
diff --git a/libstdc++-v3/include/std/memory_resource b/libstdc++-v3/include/std/memory_resource
index 7ff5d17afe7..5b6ec60268a 100644
--- a/libstdc++-v3/include/std/memory_resource
+++ b/libstdc++-v3/include/std/memory_resource
@@ -61,6 +61,7 @@ namespace pmr
   template<typename _Tp>
     class polymorphic_allocator;
 #else // C++20
+# define __cpp_lib_polymorphic_allocator 201902L
   template<typename _Tp = std::byte>
     class polymorphic_allocator;
 #endif
diff --git a/libstdc++-v3/include/std/mutex b/libstdc++-v3/include/std/mutex
index dfb5f7eb31a..26dd7d8d8c1 100644
--- a/libstdc++-v3/include/std/mutex
+++ b/libstdc++-v3/include/std/mutex
@@ -672,7 +672,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			std::forward<_Args>(__args)...);
       };
 #ifdef _GLIBCXX_HAVE_TLS
-      __once_callable = std::__addressof(__callable);
+      __once_callable = std::__addressof(__callable); // NOLINT: PR 82481
       __once_call = []{ (*(decltype(__callable)*)__once_callable)(); };
 #else
       unique_lock<mutex> __functor_lock(__get_once_mutex());
@@ -687,18 +687,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
         __set_once_functor_lock_ptr(0);
 #endif
 
-#ifdef __clang_analyzer__
-      // PR libstdc++/82481
-      __once_callable = nullptr;
-      __once_call = nullptr;
-#endif
-
       if (__e)
 	__throw_system_error(__e);
     }
 #endif // _GLIBCXX_HAS_GTHREADS
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index 87a50e572d1..7f80d06cfbc 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -60,6 +60,7 @@
 #include <bits/c++config.h>
 #include <bits/stl_iterator_base_types.h>
 #include <bits/stl_numeric.h>
+#include <ext/numeric_traits.h>
 
 #ifdef _GLIBCXX_PARALLEL
 # include <parallel/numeric>
@@ -82,38 +83,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 namespace __detail
 {
-  // std::abs is not constexpr and doesn't support unsigned integers.
-  template<typename _Tp>
-    constexpr
-    enable_if_t<__and_<is_integral<_Tp>, is_signed<_Tp>>::value, _Tp>
-    __abs_integral(_Tp __val)
-    { return __val < 0 ? -__val : __val; }
-
-  template<typename _Tp>
-    constexpr
-    enable_if_t<__and_<is_integral<_Tp>, is_unsigned<_Tp>>::value, _Tp>
-    __abs_integral(_Tp __val)
-    { return __val; }
+  // std::abs is not constexpr, doesn't support unsigned integers,
+  // and std::abs(std::numeric_limits<T>::min()) is undefined.
+  template<typename _Up, typename _Tp>
+    constexpr _Up
+    __absu(_Tp __val)
+    {
+      static_assert(is_unsigned<_Up>::value, "result type must be unsigned");
+      static_assert(sizeof(_Up) >= sizeof(_Tp),
+	  "result type must be at least as wide as the input type");
+      return __val < 0 ? -(_Up)__val : (_Up)__val;
+    }
 
-  void __abs_integral(bool) = delete;
+  template<typename _Up> void __absu(bool) = delete;
 
-  template<typename _Mn, typename _Nn>
-    constexpr common_type_t<_Mn, _Nn>
-    __gcd(_Mn __m, _Nn __n)
+  // GCD implementation
+  template<typename _Tp>
+    constexpr _Tp
+    __gcd(_Tp __m, _Tp __n)
     {
-      return __m == 0 ? __detail::__abs_integral(__n)
-	: __n == 0 ? __detail::__abs_integral(__m)
-	: __detail::__gcd(__n, __m % __n);
+      static_assert(is_unsigned<_Tp>::value, "type must be unsigned");
+      return __m == 0 ? __n
+	: __n == 0 ? __m
+	: __detail::__gcd(__n, _Tp(__m % __n));
     }
 
-  /// Least common multiple
-  template<typename _Mn, typename _Nn>
-    constexpr common_type_t<_Mn, _Nn>
-    __lcm(_Mn __m, _Nn __n)
+  // LCM implementation
+  template<typename _Tp>
+    constexpr _Tp
+    __lcm(_Tp __m, _Tp __n)
     {
       return (__m != 0 && __n != 0)
-	? (__detail::__abs_integral(__m) / __detail::__gcd(__m, __n))
-	  * __detail::__abs_integral(__n)
+	? (__m / __detail::__gcd(__m, __n)) * __n
 	: 0;
     }
 } // namespace __detail
@@ -128,29 +129,29 @@ namespace __detail
   /// Greatest common divisor
   template<typename _Mn, typename _Nn>
     constexpr common_type_t<_Mn, _Nn>
-    gcd(_Mn __m, _Nn __n)
+    gcd(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>, "gcd arguments are integers");
-      static_assert(is_integral_v<_Nn>, "gcd arguments are integers");
-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,
-		    "gcd arguments are not bools");
-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,
-		    "gcd arguments are not bools");
-      return __detail::__gcd(__m, __n);
+      static_assert(is_integral_v<_Mn>, "std::gcd arguments must be integers");
+      static_assert(is_integral_v<_Nn>, "std::gcd arguments must be integers");
+      static_assert(_Mn(2) != _Mn(1), "std::gcd arguments must not be bool");
+      static_assert(_Nn(2) != _Nn(1), "std::gcd arguments must not be bool");
+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
+      return __detail::__gcd(__detail::__absu<_Up>(__m),
+			     __detail::__absu<_Up>(__n));
     }
 
   /// Least common multiple
   template<typename _Mn, typename _Nn>
     constexpr common_type_t<_Mn, _Nn>
-    lcm(_Mn __m, _Nn __n)
+    lcm(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>, "lcm arguments are integers");
-      static_assert(is_integral_v<_Nn>, "lcm arguments are integers");
-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,
-		    "lcm arguments are not bools");
-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,
-		    "lcm arguments are not bools");
-      return __detail::__lcm(__m, __n);
+      static_assert(is_integral_v<_Mn>, "std::lcm arguments must be integers");
+      static_assert(is_integral_v<_Nn>, "std::lcm arguments must be integers");
+      static_assert(_Mn(2) == 2, "std::lcm arguments must not be bool");
+      static_assert(_Nn(2) == 2, "std::lcm arguments must not be bool");
+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
+      return __detail::__lcm(__detail::__absu<_Up>(__m),
+			     __detail::__absu<_Up>(__n));
     }
 
 #endif // C++17
@@ -681,7 +682,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return __result;
     }
 
-  // @} group numeric_ops
+  /// @} group numeric_ops
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
index 2541d978886..790c7e328ab 100644
--- a/libstdc++-v3/include/std/ostream
+++ b/libstdc++-v3/include/std/ostream
@@ -96,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       class sentry;
       friend class sentry;
 
-      //@{
+      ///@{
       /**
        *  @brief  Interface for manipulators.
        *
@@ -132,9 +132,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	__pf(*this);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Inserters
        *
@@ -153,7 +153,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  be rethrown.
       */
 
-      //@{
+      ///@{
       /**
        *  @brief Integer arithmetic inserters
        *  @param  __n A variable of builtin integral type.
@@ -205,9 +205,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       operator<<(unsigned long long __n)
       { return _M_insert(__n); }
 #endif
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Floating point arithmetic inserters
        *  @param  __f A variable of builtin floating point type.
@@ -231,7 +231,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __ostream_type&
       operator<<(long double __f)
       { return _M_insert(__f); }
-      //@}
+      ///@}
 
       /**
        *  @brief  Pointer arithmetic inserters
@@ -274,9 +274,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       operator<<(__streambuf_type* __sb);
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @name Unformatted Output Functions
        *
@@ -339,7 +339,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       __ostream_type&
       write(const char_type* __s, streamsize __n);
-      //@}
+      ///@}
 
       /**
        *  @brief  Synchronizing the stream buffer.
@@ -485,7 +485,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_ok; }
     };
 
-  //@{
+  ///@{
   /**
    *  @brief  Character inserters
    *  @param  __out  An output stream.
@@ -527,9 +527,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_ostream<char, _Traits>&
     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
     { return (__out << static_cast<char>(__c)); }
-  //@}
+  ///@}
 
-  //@{
+  ///@{
   /**
    *  @brief  String inserters
    *  @param  __out  An output stream.
@@ -582,7 +582,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_ostream<char, _Traits> &
     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
     { return (__out << reinterpret_cast<const char*>(__s)); }
-  //@}
+  ///@}
 
   // Standard basic_ostream manipulators
 
diff --git a/libstdc++-v3/include/std/ratio b/libstdc++-v3/include/std/ratio
index 8bbdcce957b..02780655ca8 100644
--- a/libstdc++-v3/include/std/ratio
+++ b/libstdc++-v3/include/std/ratio
@@ -542,7 +542,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   typedef ratio<         1000000000000000, 1> peta;
   typedef ratio<      1000000000000000000, 1> exa;
 
-  // @} group ratio
+  /// @} group ratio
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/shared_mutex b/libstdc++-v3/include/std/shared_mutex
index cb998977741..5bce457a553 100644
--- a/libstdc++-v3/include/std/shared_mutex
+++ b/libstdc++-v3/include/std/shared_mutex
@@ -759,7 +759,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
-  // @} group mutexes
+  /// @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff --git a/libstdc++-v3/include/std/stdexcept b/libstdc++-v3/include/std/stdexcept
index be348812d3b..6cca0b44d2a 100644
--- a/libstdc++-v3/include/std/stdexcept
+++ b/libstdc++-v3/include/std/stdexcept
@@ -299,7 +299,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     virtual ~underflow_error() _GLIBCXX_NOTHROW;
   };
 
-  // @} group exceptions
+  /// @} group exceptions
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/streambuf b/libstdc++-v3/include/std/streambuf
index d9ca981d704..ca5bf9afba0 100644
--- a/libstdc++-v3/include/std/streambuf
+++ b/libstdc++-v3/include/std/streambuf
@@ -122,7 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     class basic_streambuf
     {
     public:
-      //@{
+      ///@{
       /**
        *  These are standard types.  They permit a standardized way of
        *  referring to names of (or names dependent on) the template
@@ -133,12 +133,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       typedef typename traits_type::int_type 		int_type;
       typedef typename traits_type::pos_type 		pos_type;
       typedef typename traits_type::off_type 		off_type;
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /// This is a non-standard type.
       typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
-      //@}
+      ///@}
 
       friend class basic_ios<char_type, traits_type>;
       friend class basic_istream<char_type, traits_type>;
@@ -234,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return _M_buf_locale; }
 
       // [27.5.2.2.2] buffer management and positioning
-      //@{
+      ///@{
       /**
        *  @brief  Entry points for derived buffer functions.
        *
@@ -276,7 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       int
       pubsync() { return this->sync(); }
-      //@}
+      ///@}
 
       // [27.5.2.2.3] get area
       /**
@@ -474,7 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { }
 
       // [27.5.2.3.1] get area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the get area.
        *
@@ -493,7 +493,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       egptr() const { return _M_in_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the read position.
@@ -521,7 +521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
       // [27.5.2.3.2] put area access
-      //@{
+      ///@{
       /**
        *  @brief  Access to the put area.
        *
@@ -540,7 +540,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       char_type*
       epptr() const { return _M_out_end; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Moving the write position.
@@ -786,9 +786,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *
        *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html
        */
-#if __cplusplus >= 201103L
-      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]
-#endif
+      _GLIBCXX_DEPRECATED_SUGGEST("std::basic_streambuf::sbumpc")
       void
       stossc()
       {
diff --git a/libstdc++-v3/include/std/string b/libstdc++-v3/include/std/string
index 6ccc06f337a..506cb78313e 100644
--- a/libstdc++-v3/include/std/string
+++ b/libstdc++-v3/include/std/string
@@ -118,7 +118,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 201900L
+#define __cpp_lib_erase_if 202002L
 
   template<typename _CharT, typename _Traits, typename _Alloc,
 	   typename _Predicate>
diff --git a/libstdc++-v3/include/std/string_view b/libstdc++-v3/include/std/string_view
index 42822cc41ab..1787b417bd9 100644
--- a/libstdc++-v3/include/std/string_view
+++ b/libstdc++-v3/include/std/string_view
@@ -22,7 +22,7 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-/** @file string_view
+/** @file include/string_view
  *  This is a Standard C++ Library header.
  */
 
@@ -47,7 +47,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_string_view 201603
+#define __cpp_lib_string_view 201803
 
   // Helper for basic_string and basic_string_view members.
   constexpr size_t
@@ -193,8 +193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       constexpr const_reference
       operator[](size_type __pos) const noexcept
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(__pos < this->_M_len);
+	__glibcxx_assert(__pos < this->_M_len);
 	return *(this->_M_str + __pos);
       }
 
@@ -211,16 +210,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       constexpr const_reference
       front() const noexcept
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(this->_M_len > 0);
+	__glibcxx_assert(this->_M_len > 0);
 	return *this->_M_str;
       }
 
       constexpr const_reference
       back() const noexcept
       {
-	// TODO: Assert to restore in a way compatible with the constexpr.
-	// __glibcxx_assert(this->_M_len > 0);
+	__glibcxx_assert(this->_M_len > 0);
 	return *(this->_M_str + this->_M_len - 1);
       }
 
@@ -310,6 +307,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
 #if __cplusplus > 201703L
+#define __cpp_lib_starts_ends_with 201711L
       constexpr bool
       starts_with(basic_string_view __x) const noexcept
       { return this->substr(0, __x.size()) == __x; }
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index 4eb744d4152..7b6b0587fa1 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -402,7 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
   }
 
-  // @} group threads
+  /// @} group threads
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index f942109ed01..164027816f4 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -275,13 +275,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
 	        std::forward<_Head>(_M_head(__in))) { }
 
-      template<typename _Alloc, typename... _UElements>
+      template<typename _Alloc, typename _UHead, typename... _UTails>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-	            const _Tuple_impl<_Idx, _UElements...>& __in)
+		    const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 	: _Inherited(__tag, __a,
-		     _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
-	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
-		_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
+		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
+	  _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
+		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) { }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
@@ -397,7 +397,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       template<typename _Alloc, typename _UHead>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 	            const _Tuple_impl<_Idx, _UHead>& __in)
-	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
+	: _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
 		_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
 
       template<typename _Alloc, typename _UHead>
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index 9bad55829ce..35bda61c500 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -926,55 +926,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : public __is_move_constructible_impl<_Tp>
     { };
 
-  template<typename _Tp>
-    struct __is_nt_default_constructible_atom
-    : public integral_constant<bool, noexcept(_Tp())>
+  template<bool, typename _Tp, typename... _Args>
+    struct __is_nt_constructible_impl
+    : public false_type
     { };
 
-  template<typename _Tp, bool = is_array<_Tp>::value>
-    struct __is_nt_default_constructible_impl;
+  template<typename _Tp, typename... _Args>
+    struct __is_nt_constructible_impl<true, _Tp, _Args...>
+    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
+    { };
 
-  template<typename _Tp>
-    struct __is_nt_default_constructible_impl<_Tp, true>
-    : public __and_<__is_array_known_bounds<_Tp>,
-		    __is_nt_default_constructible_atom<typename
-                      remove_all_extents<_Tp>::type>>
+  template<typename _Tp, typename _Arg>
+    struct __is_nt_constructible_impl<true, _Tp, _Arg>
+    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
     { };
 
   template<typename _Tp>
-    struct __is_nt_default_constructible_impl<_Tp, false>
-    : public __is_nt_default_constructible_atom<_Tp>
+    struct __is_nt_constructible_impl<true, _Tp>
+    : public __bool_constant<noexcept(_Tp())>
     { };
 
-  /// is_nothrow_default_constructible
-  template<typename _Tp>
-    struct is_nothrow_default_constructible
-    : public __and_<is_default_constructible<_Tp>,
-                    __is_nt_default_constructible_impl<_Tp>>
+  template<typename _Tp, size_t _Num>
+    struct __is_nt_constructible_impl<true, _Tp[_Num]>
+    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
     { };
 
   template<typename _Tp, typename... _Args>
-    struct __is_nt_constructible_impl
-    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
-    { };
+    using __is_nothrow_constructible_impl
+      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
+				   _Tp, _Args...>;
 
-  template<typename _Tp, typename _Arg>
-    struct __is_nt_constructible_impl<_Tp, _Arg>
-    : public integral_constant<bool,
-                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
+  /// is_nothrow_constructible
+  template<typename _Tp, typename... _Args>
+    struct is_nothrow_constructible
+    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
     { };
 
+  /// is_nothrow_default_constructible
   template<typename _Tp>
-    struct __is_nt_constructible_impl<_Tp>
-    : public is_nothrow_default_constructible<_Tp>
+    struct is_nothrow_default_constructible
+    : public __is_nothrow_constructible_impl<_Tp>::type
     { };
 
-  /// is_nothrow_constructible
-  template<typename _Tp, typename... _Args>
-    struct is_nothrow_constructible
-    : public __and_<is_constructible<_Tp, _Args...>,
-		    __is_nt_constructible_impl<_Tp, _Args...>>
-    { };
 
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>
     struct __is_nothrow_copy_constructible_impl;
@@ -1362,6 +1355,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       using type = decltype(__test<_From, _To>(0));
     };
 
+#define __cpp_lib_is_nothrow_convertible 201806L
   /// is_nothrow_convertible
   template<typename _From, typename _To>
     struct is_nothrow_convertible
@@ -3027,6 +3021,8 @@ template <typename _From, typename _To>
 #endif // C++17
 
 #if __cplusplus > 201703L
+#define __cpp_lib_remove_cvref 201711L
+
   /// Remove references and cv-qualifiers.
   template<typename _Tp>
     struct remove_cvref
@@ -3037,6 +3033,7 @@ template <typename _From, typename _To>
   template<typename _Tp>
     using remove_cvref_t = __remove_cvref_t<_Tp>;
 
+#define __cpp_lib_type_identity 201806L
   /// Identity metafunction.
   template<typename _Tp>
     struct type_identity { using type = _Tp; };
@@ -3044,6 +3041,8 @@ template <typename _From, typename _To>
   template<typename _Tp>
     using type_identity_t = typename type_identity<_Tp>::type;
 
+#define __cpp_lib_unwrap_ref 201811L
+
   /// Unwrap a reference_wrapper
   template<typename _Tp>
     struct unwrap_reference { using type = _Tp; };
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index 86cbb4203a5..10b294ba012 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -595,7 +595,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return _M_data[__i];
     }
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1245,7 +1245,7 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
     { return std::__addressof(__va[0]) + __va.size(); }
 #endif // C++11
 
-  // @} group numeric_arrays
+  /// @} group numeric_arrays
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index 75fb0dc164a..321228753cd 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -23,7 +23,7 @@
 // <http://www.gnu.org/licenses/>.
 
 /** @file variant
- *  This is the <variant> C++ Library header.
+ *  This is the `<variant>` C++ Library header.
  */
 
 #ifndef _GLIBCXX_VARIANT
@@ -372,12 +372,16 @@ namespace __variant
   template<typename... _Types>
     struct _Variant_storage<false, _Types...>
     {
-      constexpr _Variant_storage() : _M_index(variant_npos) { }
+      constexpr
+      _Variant_storage()
+      : _M_index(static_cast<__index_type>(variant_npos))
+      { }
 
       template<size_t _Np, typename... _Args>
-	constexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
+	constexpr
+	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
-	_M_index(_Np)
+	_M_index{_Np}
 	{ }
 
       constexpr void _M_reset_impl()
@@ -395,7 +399,7 @@ namespace __variant
       void _M_reset()
       {
 	_M_reset_impl();
-	_M_index = variant_npos;
+	_M_index = static_cast<__index_type>(variant_npos);
       }
 
       ~_Variant_storage()
@@ -424,16 +428,20 @@ namespace __variant
   template<typename... _Types>
     struct _Variant_storage<true, _Types...>
     {
-      constexpr _Variant_storage() : _M_index(variant_npos) { }
+      constexpr
+      _Variant_storage()
+      : _M_index(static_cast<__index_type>(variant_npos))
+      { }
 
       template<size_t _Np, typename... _Args>
-	constexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
+	constexpr
+	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
-	_M_index(_Np)
+	_M_index{_Np}
 	{ }
 
       void _M_reset()
-      { _M_index = variant_npos; }
+      { _M_index = static_cast<__index_type>(variant_npos); }
 
       void*
       _M_storage() const
@@ -447,7 +455,7 @@ namespace __variant
       {
 	if constexpr (__never_valueless<_Types...>())
 	  return true;
-	return this->_M_index != __index_type(variant_npos);
+	return this->_M_index != static_cast<__index_type>(variant_npos);
       }
 
       _Variadic_union<_Types...> _M_u;
@@ -606,7 +614,8 @@ namespace __variant
 		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
 		    else
 		      __variant_cast<_Types...>(*this)
-			= variant<_Types...>(__rhs_mem);
+			= variant<_Types...>(std::in_place_index<__rhs_index>,
+					     __rhs_mem);
 		  }
 	      }
 	    else
diff --git a/libstdc++-v3/include/std/vector b/libstdc++-v3/include/std/vector
index e5e13ab3ef7..1c1e2fd60e7 100644
--- a/libstdc++-v3/include/std/vector
+++ b/libstdc++-v3/include/std/vector
@@ -105,7 +105,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#define __cpp_lib_erase_if 201900L
+#define __cpp_lib_erase_if 202002L
 
   template<typename _Tp, typename _Alloc, typename _Predicate>
     inline typename vector<_Tp, _Alloc>::size_type
diff --git a/libstdc++-v3/include/std/version b/libstdc++-v3/include/std/version
index 3c288301952..0f704c054cf 100644
--- a/libstdc++-v3/include/std/version
+++ b/libstdc++-v3/include/std/version
@@ -35,7 +35,9 @@
 #include <bits/c++config.h>
 
 // c++03
-#define __cpp_lib_incomplete_container_elements 201505
+#if _GLIBCXX_HOSTED
+# define __cpp_lib_incomplete_container_elements 201505
+#endif
 
 #if !defined(__STRICT_ANSI__)
 // gnu++03
@@ -44,17 +46,22 @@
 
 #if __cplusplus >= 201103L
 // c++11
-#define __cpp_lib_allocator_is_always_equal 201411
-#define __cpp_lib_allocator_traits_is_always_equal 201411
 #define __cpp_lib_is_null_pointer 201309
 #define __cpp_lib_result_of_sfinae 201210
-#define __cpp_lib_shared_ptr_arrays 201611L
+
+#if _GLIBCXX_HOSTED
+# define __cpp_lib_allocator_is_always_equal 201411
+# define __cpp_lib_allocator_traits_is_always_equal 201411
+# define __cpp_lib_shared_ptr_arrays 201611L
+#endif
 
 #if !defined(__STRICT_ANSI__)
 // gnu++11
-# define __cpp_lib_enable_shared_from_this 201603
 # define __cpp_lib_is_swappable 201603
 # define __cpp_lib_void_t 201411
+# if _GLIBCXX_HOSTED
+#  define __cpp_lib_enable_shared_from_this 201603
+# endif
 #endif
 
 // For C++11 and later we support ISO/IEC 29124 Mathematical Special Functions
@@ -62,52 +69,41 @@
 
 #if __cplusplus >= 201402L
 // c++14
-#define __cpp_lib_chrono_udls 201304
-#define __cpp_lib_complex_udls 201309
-#define __cpp_lib_exchange_function 201304
-#define __cpp_lib_generic_associative_lookup 201304
-#define __cpp_lib_integer_sequence 201304
 #define __cpp_lib_integral_constant_callable 201304
 #define __cpp_lib_is_final 201402L
-#define __cpp_lib_make_reverse_iterator 201402
-#define __cpp_lib_make_unique 201304
-#ifndef _GLIBCXX_DEBUG // PR libstdc++/70303
-# define __cpp_lib_null_iterators 201304L
-#endif
-#define __cpp_lib_quoted_string_io 201304
-#define __cpp_lib_robust_nonmodifying_seq_ops 201304
-#ifdef _GLIBCXX_HAS_GTHREADS
-# define __cpp_lib_shared_timed_mutex 201402
-#endif
-#define __cpp_lib_string_udls 201304
 #define __cpp_lib_transformation_trait_aliases 201304
-#define __cpp_lib_transparent_operators 201510
-#define __cpp_lib_tuple_element_t 201402L
-#define __cpp_lib_tuples_by_type 201304
+
+#if _GLIBCXX_HOSTED
+# define __cpp_lib_chrono_udls 201304
+# define __cpp_lib_complex_udls 201309
+# define __cpp_lib_exchange_function 201304
+# define __cpp_lib_generic_associative_lookup 201304
+# define __cpp_lib_integer_sequence 201304
+# define __cpp_lib_make_reverse_iterator 201402
+# define __cpp_lib_make_unique 201304
+# ifndef _GLIBCXX_DEBUG // PR libstdc++/70303
+#  define __cpp_lib_null_iterators 201304L
+# endif
+# define __cpp_lib_quoted_string_io 201304
+# define __cpp_lib_robust_nonmodifying_seq_ops 201304
+# ifdef _GLIBCXX_HAS_GTHREADS
+#  define __cpp_lib_shared_timed_mutex 201402
+# endif
+# define __cpp_lib_string_udls 201304
+# define __cpp_lib_transparent_operators 201510
+# define __cpp_lib_tuple_element_t 201402L
+# define __cpp_lib_tuples_by_type 201304
+#endif
 
 #if __cplusplus >= 201703L
 // c++17
 #define __cpp_lib_addressof_constexpr 201603
-#define __cpp_lib_any 201606L
-#define __cpp_lib_apply 201603
-#define __cpp_lib_array_constexpr 201603
-#define __cpp_lib_as_const 201510
 #define __cpp_lib_atomic_is_always_lock_free 201603
 #define __cpp_lib_bool_constant 201505
-#define __cpp_lib_boyer_moore_searcher 201603
 #define __cpp_lib_byte 201603
-#define __cpp_lib_chrono 201611
-#define __cpp_lib_clamp 201603
-#define __cpp_lib_constexpr_char_traits 201611
-#define __cpp_lib_enable_shared_from_this 201603
-#define __cpp_lib_filesystem 201703
-#define __cpp_lib_gcd 201606
-#define __cpp_lib_gcd_lcm 201606
 #ifdef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
 # define __cpp_lib_has_unique_object_representations 201606
 #endif
-#define __cpp_lib_hypot 201603
-#define __cpp_lib_invoke 201411
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE
 # define __cpp_lib_is_aggregate 201703
 #endif
@@ -116,10 +112,30 @@
 #ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
 # define __cpp_lib_launder 201606
 #endif
-#define __cpp_lib_lcm 201606
 #define __cpp_lib_logical_traits 201510
+#define __cpp_lib_type_trait_variable_templates 201510L
+#define __cpp_lib_uncaught_exceptions 201411L
+#define __cpp_lib_void_t 201411
+
+#if _GLIBCXX_HOSTED
+#define __cpp_lib_any 201606L
+#define __cpp_lib_apply 201603
+#define __cpp_lib_array_constexpr 201803L
+#define __cpp_lib_as_const 201510
+#define __cpp_lib_boyer_moore_searcher 201603
+#define __cpp_lib_chrono 201611
+#define __cpp_lib_clamp 201603
+#define __cpp_lib_constexpr_char_traits 201611
+#define __cpp_lib_enable_shared_from_this 201603
+#define __cpp_lib_execution 201902L // FIXME: should be 201603L
+#define __cpp_lib_filesystem 201703
+#define __cpp_lib_gcd 201606
+#define __cpp_lib_gcd_lcm 201606
+#define __cpp_lib_hypot 201603
+#define __cpp_lib_invoke 201411
+#define __cpp_lib_lcm 201606
 #define __cpp_lib_make_from_tuple 201606
-#define __cpp_lib_map_insertion 201411
+#define __cpp_lib_map_insertion 201411  // non-standard macro
 #define __cpp_lib_map_try_emplace 201411
 #define __cpp_lib_math_special_functions 201603L
 #ifdef _GLIBCXX_HAS_GTHREADS
@@ -138,29 +154,45 @@
 # define __cpp_lib_shared_mutex 201505
 #endif
 #define __cpp_lib_shared_ptr_weak_type 201606
-#define __cpp_lib_string_view 201603
-#define __cpp_lib_type_trait_variable_templates 201510L
-#define __cpp_lib_uncaught_exceptions 201411L
-#define __cpp_lib_unordered_map_insertion 201411
+#define __cpp_lib_string_view 201803
+// #define __cpp_lib_to_chars 201611L
+#define __cpp_lib_unordered_map_insertion 201411  // non-standard macro
 #define __cpp_lib_unordered_map_try_emplace 201411
 #define __cpp_lib_variant 201606L
-#define __cpp_lib_void_t 201411
 #define __cpp_lib_parallel_algorithm 201603L
+#endif
 
 #if __cplusplus > 201703L
 // c++2a
-#define __cpp_lib_bind_front 201907L
+#define __cpp_lib_bitops 201907L
 #define __cpp_lib_bounded_array_traits 201902L
+// __cpp_lib_char8_t is defined in <bits/c++config.h>
 #if __cpp_impl_destroying_delete
 # define __cpp_lib_destroying_delete 201806L
 #endif
 #define __cpp_lib_endian 201907L
-#define __cpp_lib_erase_if 201900L
-#define __cpp_lib_interpolate 201902L
+#define __cpp_lib_int_pow2 201806L
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
 # define __cpp_lib_is_constant_evaluated 201811L
 #endif
+#define __cpp_lib_is_nothrow_convertible 201806L
+#define __cpp_lib_remove_cvref 201711L
+#define __cpp_lib_type_identity 201806L
+#define __cpp_lib_unwrap_ref 201811L
+
+#if _GLIBCXX_HOSTED
+#define __cpp_lib_assume_aligned 201811L
+#define __cpp_lib_bind_front 201907L
+// FIXME: #define __cpp_lib_execution 201902L
+#define __cpp_lib_constexpr_complex 201711L
+#define __cpp_lib_constexpr_memory 201811L
+#define __cpp_lib_erase_if 202002L
+#define __cpp_lib_interpolate 201902L
 #define __cpp_lib_list_remove_return_type 201806L
+#define __cpp_lib_polymorphic_allocator 201902L
+#define __cpp_lib_starts_ends_with 201711L
+#define __cpp_lib_to_address 201711L
+#endif
 #endif // C++2a
 #endif // C++17
 #endif // C++14
diff --git a/libstdc++-v3/include/tr1/cmath b/libstdc++-v3/include/tr1/cmath
index 4ff82419c25..8ae153b5ac9 100644
--- a/libstdc++-v3/include/tr1/cmath
+++ b/libstdc++-v3/include/tr1/cmath
@@ -1057,7 +1057,7 @@ namespace tr1
 
 #endif // __cplusplus < 201103L
 
-  // @}
+  /// @}
 
 #endif /* _GLIBCXX_USE_C99_MATH_TR1 */
 
@@ -1220,7 +1220,7 @@ namespace tr1
   using std::sph_neumannl;
   using std::sph_neumann;
 
-  /* @} */ // tr1_math_spec_func
+  /** @} */ // tr1_math_spec_func
 
 #else // ! _GLIBCXX_USE_STD_SPEC_FUNCS
 
@@ -1617,7 +1617,7 @@ namespace tr1
       return __detail::__sph_neumann<__type>(__n, __x);
     }
 
-  /* @} */ // tr1_math_spec_func
+  /** @} */ // tr1_math_spec_func
 #endif // _GLIBCXX_USE_STD_SPEC_FUNCS
 
 } // namespace tr1
diff --git a/libstdc++-v3/include/tr1/complex b/libstdc++-v3/include/tr1/complex
index a7c261516d1..f9df6e357ef 100644
--- a/libstdc++-v3/include/tr1/complex
+++ b/libstdc++-v3/include/tr1/complex
@@ -411,7 +411,7 @@ namespace tr1
     pow(const std::complex<_Tp>& __x, const std::complex<_Tp>& __y)
     { return std::pow(__x, __y); }
 
-// @} group complex_numbers
+/// @} group complex_numbers
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/random.h b/libstdc++-v3/include/tr1/random.h
index 0be82afec3f..09b9fd95b7a 100644
--- a/libstdc++-v3/include/tr1/random.h
+++ b/libstdc++-v3/include/tr1/random.h
@@ -1543,7 +1543,7 @@ namespace tr1
 #endif
   };
 
-  /* @} */ // group tr1_random_generators
+  /// @} group tr1_random_generators
 
   /**
    * @addtogroup tr1_random_distributions Random Number Distributions
@@ -2046,7 +2046,7 @@ namespace tr1
       bool      _M_easy;
     };
 
-  /* @} */ // group tr1_random_distributions_discrete
+  /// @} group tr1_random_distributions_discrete
 
   /**
    * @addtogroup tr1_random_distributions_continuous Continuous Distributions
@@ -2403,9 +2403,9 @@ namespace tr1
       result_type _M_l_d;
     };
 
-  /* @} */ // group tr1_random_distributions_continuous
-  /* @} */ // group tr1_random_distributions
-  /* @} */ // group tr1_random
+  /// @} group tr1_random_distributions_continuous
+  /// @} group tr1_random_distributions
+  /// @} group tr1_random
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr1/regex b/libstdc++-v3/include/tr1/regex
index 73c610d2bbd..589823a2bb1 100644
--- a/libstdc++-v3/include/tr1/regex
+++ b/libstdc++-v3/include/tr1/regex
@@ -53,7 +53,7 @@ namespace tr1
  * @defgroup tr1_regex Regular Expressions
  * A facility for performing regular expression pattern matching.
  */
- //@{
+ ///@{
 
 /** @namespace std::regex_constants
  *  @brief ISO C++ 0x entities sub namespace for regex.
@@ -63,7 +63,7 @@ namespace regex_constants
   /**
    * @name 5.1 Regular Expression Syntax Options
    */
-  //@{
+  ///@{
   enum __syntax_option
     {
       _S_icase,
@@ -174,7 +174,7 @@ namespace regex_constants
    */
   static const syntax_option_type egrep      = 1 << _S_egrep;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.2 Matching Rules
@@ -185,7 +185,7 @@ namespace regex_constants
    * below for any bitmask elements set.
    *
    */
-  //@{
+  ///@{
 
   enum __match_flag
     {
@@ -315,12 +315,12 @@ namespace regex_constants
    */
   static const match_flag_type format_first_only = 1 << _S_first_only;
 
-  //@}
+  ///@}
 
   /**
    * @name 5.3 Error Types
    */
-  //@{
+  ///@{
  
   enum error_type
     {
@@ -396,7 +396,7 @@ namespace regex_constants
    */
   static const error_type error_stack(_S_error_stack);
 
-  //@}
+  ///@}
 }
 
   // [7.8] Class regex_error
@@ -735,7 +735,7 @@ namespace regex_constants
        * @name Constants
        * tr1 [7.8.1] std [28.8.1]
        */
-      //@{
+      ///@{
       static const regex_constants::syntax_option_type icase
         = regex_constants::icase;
       static const regex_constants::syntax_option_type nosubs
@@ -756,7 +756,7 @@ namespace regex_constants
         = regex_constants::grep;
       static const regex_constants::syntax_option_type egrep
         = regex_constants::egrep;
-      //@}
+      ///@}
 
       // [7.8.2] construct/copy/destroy
       /**
@@ -1787,7 +1787,7 @@ namespace regex_constants
       /**
        * @name 10.? Public Types
        */
-      //@{
+      ///@{
       typedef sub_match<_Bi_iter>                             value_type;
       typedef typename _Allocator::const_reference            const_reference;
       typedef const_reference                                 reference;
@@ -1799,13 +1799,13 @@ namespace regex_constants
       typedef _Allocator                                      allocator_type;
       typedef typename iterator_traits<_Bi_iter>::value_type  char_type;
       typedef basic_string<char_type>                         string_type;
-      //@}
+      ///@}
   
     public:
       /**
        * @name 10.1 Construction, Copying, and Destruction
        */
-      //@{
+      ///@{
 
       /**
        * @brief Constructs a default %match_results container.
@@ -1841,12 +1841,12 @@ namespace regex_constants
       ~match_results()
       { }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.2 Size
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the number of matches and submatches.
@@ -1874,12 +1874,12 @@ namespace regex_constants
       empty() const
       { return size() == 0; }
       
-      //@}
+      ///@}
 
       /**
        * @name 10.3 Element Access
        */
-      //@{
+      ///@{
 
       /**
        * @brief Gets the length of the indicated submatch.
@@ -1988,7 +1988,7 @@ namespace regex_constants
       { return _Base_type::end(); }
 #endif
 
-      //@}
+      ///@}
 
       /**
        * @name 10.4 Formatting
@@ -1998,7 +1998,7 @@ namespace regex_constants
        * and escape sequences accepted by these functions are
        * determined by their @p flags parameter as documented above.
        */
-       //@{
+       ///@{
 
       /**
        * @todo Implement this function.
@@ -2017,12 +2017,12 @@ namespace regex_constants
 	     regex_constants::match_flag_type __flags
 	     = regex_constants::format_default) const;
 
-      //@} 
+      ///@}
 
       /**
        * @name 10.5 Allocator
        */
-      //@{ 
+      ///@{
 
       /**
        * @brief Gets a copy of the allocator.
@@ -2031,12 +2031,12 @@ namespace regex_constants
       //get_allocator() const;
       using _Base_type::get_allocator;
       
-      //@} 
+      ///@}
 
       /**
        * @name 10.6 Swap
        */
-       //@{ 
+       ///@{
 
       /**
        * @brief Swaps the contents of two match_results.
@@ -2049,7 +2049,7 @@ namespace regex_constants
 	std::swap(_M_prefix,  __that._M_prefix);
 	std::swap(_M_suffix,  __that._M_suffix);
       }
-      //@} 
+      ///@}
       
     private:
       bool       _M_matched;
@@ -2105,7 +2105,7 @@ namespace regex_constants
   /**
    * @name Matching, Searching, and Replacing
    */
-  //@{
+  ///@{
 
   /**
    * @brief Determines if there is a match between the regular expression @p e
@@ -2432,7 +2432,7 @@ namespace regex_constants
       return __result;
     }
 
-  //@}
+  ///@}
 
   // tr1 [7.12.1] std [28.12] Class template regex_iterator
   /**
@@ -2718,7 +2718,7 @@ namespace regex_constants
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
 #endif
   
-  //@}
+  ///@}
 }
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
index 28c877c0484..7f903599eed 100644
--- a/libstdc++-v3/include/tr2/dynamic_bitset
+++ b/libstdc++-v3/include/tr2/dynamic_bitset
@@ -748,7 +748,7 @@ namespace tr2
 	}
 
       // 23.3.5.2 dynamic_bitset operations:
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __rhs  A same-sized dynamic_bitset.
@@ -789,9 +789,9 @@ namespace tr2
 	this->_M_do_dif(__rhs);
 	return *this;
       }
-      //@}
+      ///@}
 
-      //@{
+      ///@{
       /**
        *  @brief  Operations on dynamic_bitsets.
        *  @param  __pos The number of places to shift.
@@ -823,7 +823,7 @@ namespace tr2
 	  this->_M_do_reset();
 	return *this;
       }
-      //@}
+      ///@}
 
       // Set, reset, and flip.
       /**
@@ -905,7 +905,7 @@ namespace tr2
       operator~() const
       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }
 
-      //@{
+      ///@{
       /**
        *  @brief  Array-indexing support.
        *  @param  __pos  Index into the %dynamic_bitset.
@@ -921,7 +921,7 @@ namespace tr2
       const_reference
       operator[](size_type __pos) const
       { return _M_unchecked_test(__pos); }
-      //@}
+      ///@}
 
       /**
        *  @brief Returns a numerical interpretation of the %dynamic_bitset.
@@ -1052,7 +1052,7 @@ namespace tr2
       none() const
       { return !this->_M_is_any(); }
 
-      //@{
+      ///@{
       /// Self-explanatory.
       dynamic_bitset
       operator<<(size_type __pos) const
@@ -1061,7 +1061,7 @@ namespace tr2
       dynamic_bitset
       operator>>(size_type __pos) const
       { return dynamic_bitset(*this) >>= __pos; }
-      //@}
+      ///@}
 
       /**
        *  @brief  Finds the index of the first "on" bit.
@@ -1115,7 +1115,7 @@ namespace tr2
       }
 
 
-  //@{
+  ///@{
   /// These comparisons for equality/inequality are, well, @e bitwise.
 
   template<typename _WordT, typename _Alloc>
@@ -1141,10 +1141,10 @@ namespace tr2
     operator>=(const dynamic_bitset<_WordT, _Alloc>& __lhs,
 	       const dynamic_bitset<_WordT, _Alloc>& __rhs)
     { return !(__lhs < __rhs); }
-  //@}
+  ///@}
 
   // 23.3.5.3 bitset operations:
-  //@{
+  ///@{
   /**
    *  @brief  Global bitwise operations on bitsets.
    *  @param  __x  A bitset.
@@ -1192,7 +1192,7 @@ namespace tr2
       __result -= __y;
       return __result;
     }
-  //@}
+  ///@}
 
   /// Stream output operator for dynamic_bitset.
   template <typename _CharT, typename _Traits,
diff --git a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
index 614a84c1fa8..2be25936fcc 100644
--- a/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
+++ b/libstdc++-v3/libsupc++/atomic_lockfree_defines.h
@@ -61,6 +61,6 @@
 #define ATOMIC_POINTER_LOCK_FREE	__GCC_ATOMIC_POINTER_LOCK_FREE
 #endif
 
-// @} group atomics
+/// @} group atomics
 
 #endif
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
index 073bfdda42d..f2585675b7b 100644
--- a/libstdc++-v3/libsupc++/exception
+++ b/libstdc++-v3/libsupc++/exception
@@ -107,7 +107,7 @@ namespace std
   int uncaught_exceptions() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 #endif
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 namespace __gnu_cxx
diff --git a/libstdc++-v3/libsupc++/exception.h b/libstdc++-v3/libsupc++/exception.h
index 8b9da533411..4800117232c 100644
--- a/libstdc++-v3/libsupc++/exception.h
+++ b/libstdc++-v3/libsupc++/exception.h
@@ -45,7 +45,7 @@ namespace std
    * @defgroup exceptions Exceptions
    * @ingroup diagnostics
    *
-   * Classes and functions for reporting errors via exception classes.
+   * Classes and functions for reporting errors via exceptions.
    * @{
    */
 
@@ -75,6 +75,8 @@ namespace std
     what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
   };
 
+  /// @}
+
 } // namespace std
 
 }
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
index 3f21a70e54c..bd2178b3a1a 100644
--- a/libstdc++-v3/libsupc++/exception_ptr.h
+++ b/libstdc++-v3/libsupc++/exception_ptr.h
@@ -207,7 +207,7 @@ namespace std
 #endif
     }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/libsupc++/nested_exception.h b/libstdc++-v3/libsupc++/nested_exception.h
index 52d3ea8b336..fee203a720a 100644
--- a/libstdc++-v3/libsupc++/nested_exception.h
+++ b/libstdc++-v3/libsupc++/nested_exception.h
@@ -151,7 +151,7 @@ namespace std
     rethrow_if_nested(const _Ex& __ex)
     { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }
 
-  // @} group exceptions
+  /// @} group exceptions
 } // namespace std
 
 } // extern "C++"
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 8f16b53c953..3082b0e4d8c 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -94,13 +94,77 @@ def find_type(orig, name):
         # The type was not found, so try the superclass.  We only need
         # to check the first superclass, so we don't bother with
         # anything fancier here.
-        field = typ.fields()[0]
-        if not field.is_base_class:
+        fields = typ.fields()
+        if len(fields) and fields[0].is_base_class:
+            typ = fields[0].type
+        else:
             raise ValueError("Cannot find type %s::%s" % (str(orig), name))
-        typ = field.type
 
 _versioned_namespace = '__8::'
 
+def lookup_templ_spec(templ, *args):
+    """
+    Lookup template specialization templ<args...>
+    """
+    t = '{}<{}>'.format(templ, ', '.join([str(a) for a in args]))
+    try:
+        return gdb.lookup_type(t)
+    except gdb.error as e:
+        # Type not found, try again in versioned namespace.
+        global _versioned_namespace
+        if _versioned_namespace and _versioned_namespace not in templ:
+            t = t.replace('::', '::' + _versioned_namespace, 1)
+            try:
+                return gdb.lookup_type(t)
+            except gdb.error:
+                # If that also fails, rethrow the original exception
+                pass
+        raise e
+
+# Use this to find container node types instead of find_type,
+# see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91997 for details.
+def lookup_node_type(nodename, containertype):
+    """
+    Lookup specialization of template NODENAME corresponding to CONTAINERTYPE.
+    e.g. if NODENAME is '_List_node' and CONTAINERTYPE is std::list<int>
+    then return the type std::_List_node<int>.
+    Returns None if not found.
+    """
+    # If nodename is unqualified, assume it's in namespace std.
+    if '::' not in nodename:
+        nodename = 'std::' + nodename
+    try:
+        valtype = find_type(containertype, 'value_type')
+    except:
+        valtype = containertype.template_argument(0)
+    valtype = valtype.strip_typedefs()
+    try:
+        return lookup_templ_spec(nodename, valtype)
+    except gdb.error as e:
+        # For debug mode containers the node is in std::__cxx1998.
+        if is_member_of_namespace(nodename, 'std'):
+            if is_member_of_namespace(containertype, 'std::__cxx1998',
+                                      'std::__debug', '__gnu_debug'):
+                nodename = nodename.replace('::', '::__cxx1998::', 1)
+                try:
+                    return lookup_templ_spec(nodename, valtype)
+                except gdb.error:
+                    pass
+        return None
+
+def is_member_of_namespace(typ, *namespaces):
+    """
+    Test whether a type is a member of one of the specified namespaces.
+    The type can be specified as a string or a gdb.Type object.
+    """
+    if type(typ) is gdb.Type:
+        typ = str(typ)
+    typ = strip_versioned_namespace(typ)
+    for namespace in namespaces:
+        if typ.startswith(namespace + '::'):
+            return True
+    return False
+
 def is_specialization_of(x, template_name):
     "Test if a type is a given template instantiation."
     global _versioned_namespace
@@ -181,13 +245,22 @@ class UniquePointerPrinter:
 
     def __init__ (self, typename, val):
         self.val = val
-        impl_type = val.type.fields()[0].type.tag
+        impl_type = val.type.fields()[0].type.strip_typedefs()
         if is_specialization_of(impl_type, '__uniq_ptr_impl'): # New implementation
-            self.pointer = val['_M_t']['_M_t']['_M_head_impl']
+            tuple_member = val['_M_t']['_M_t']
         elif is_specialization_of(impl_type, 'tuple'):
-            self.pointer = val['_M_t']['_M_head_impl']
+            tuple_member = val['_M_t']
         else:
-            raise ValueError("Unsupported implementation for unique_ptr: %s" % impl_type)
+            raise ValueError("Unsupported implementation for unique_ptr: %s" % str(impl_type))
+        tuple_impl_type = tuple_member.type.fields()[0].type # _Tuple_impl
+        tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base
+        head_field = tuple_head_type.fields()[0]
+        if head_field.name == '_M_head_impl':
+            self.pointer = tuple_member['_M_head_impl']
+        elif head_field.is_base_class:
+            self.pointer = tuple_member.cast(head_field.type)
+        else:
+            raise ValueError("Unsupported implementation for tuple in unique_ptr: %s" % str(impl_type))
 
     def children (self):
         return SmartPtrIterator(self.pointer)
@@ -242,40 +315,40 @@ class StdListPrinter:
         self.val = val
 
     def children(self):
-        nodetype = find_type(self.val.type, '_Node')
-        nodetype = nodetype.strip_typedefs().pointer()
+        nodetype = lookup_node_type('_List_node', self.val.type).pointer()
         return self._iterator(nodetype, self.val['_M_impl']['_M_node'])
 
     def to_string(self):
-        if self.val['_M_impl']['_M_node'].address == self.val['_M_impl']['_M_node']['_M_next']:
+        headnode = self.val['_M_impl']['_M_node']
+        if headnode['_M_next'] == headnode.address:
             return 'empty %s' % (self.typename)
         return '%s' % (self.typename)
 
 class NodeIteratorPrinter:
-    def __init__(self, typename, val, contname):
+    def __init__(self, typename, val, contname, nodename):
         self.val = val
         self.typename = typename
         self.contname = contname
+        self.nodetype = lookup_node_type(nodename, val.type)
 
     def to_string(self):
         if not self.val['_M_node']:
             return 'non-dereferenceable iterator for std::%s' % (self.contname)
-        nodetype = find_type(self.val.type, '_Node')
-        nodetype = nodetype.strip_typedefs().pointer()
-        node = self.val['_M_node'].cast(nodetype).dereference()
+        node = self.val['_M_node'].cast(self.nodetype.pointer()).dereference()
         return str(get_value_from_list_node(node))
 
 class StdListIteratorPrinter(NodeIteratorPrinter):
     "Print std::list::iterator"
 
     def __init__(self, typename, val):
-        NodeIteratorPrinter.__init__(self, typename, val, 'list')
+        NodeIteratorPrinter.__init__(self, typename, val, 'list', '_List_node')
 
 class StdFwdListIteratorPrinter(NodeIteratorPrinter):
     "Print std::forward_list::iterator"
 
     def __init__(self, typename, val):
-        NodeIteratorPrinter.__init__(self, typename, val, 'forward_list')
+        NodeIteratorPrinter.__init__(self, typename, val, 'forward_list',
+                                     '_Fwd_list_node')
 
 class StdSlistPrinter:
     "Print a __gnu_cxx::slist"
@@ -302,9 +375,8 @@ class StdSlistPrinter:
         self.val = val
 
     def children(self):
-        nodetype = find_type(self.val.type, '_Node')
-        nodetype = nodetype.strip_typedefs().pointer()
-        return self._iterator(nodetype, self.val)
+        nodetype = lookup_node_type('__gnu_cxx::_Slist_node', self.val.type)
+        return self._iterator(nodetype.pointer(), self.val)
 
     def to_string(self):
         if self.val['_M_head']['_M_next'] == 0:
@@ -320,8 +392,7 @@ class StdSlistIteratorPrinter:
     def to_string(self):
         if not self.val['_M_node']:
             return 'non-dereferenceable iterator for __gnu_cxx::slist'
-        nodetype = find_type(self.val.type, '_Node')
-        nodetype = nodetype.strip_typedefs().pointer()
+        nodetype = lookup_node_type('__gnu_cxx::_Slist_node', self.val.type).pointer()
         return str(self.val['_M_node'].cast(nodetype).dereference()['_M_data'])
 
 class StdVectorPrinter:
@@ -574,12 +645,8 @@ class StdRbtreeIteratorPrinter:
 
     def __init__ (self, typename, val):
         self.val = val
-        valtype = self.val.type.template_argument(0).strip_typedefs()
-        nodetype = '_Rb_tree_node<' + str(valtype) + '>'
-        if _versioned_namespace and typename.startswith('std::' + _versioned_namespace):
-            nodetype = _versioned_namespace + nodetype
-        nodetype = gdb.lookup_type('std::' + nodetype)
-        self.link_type = nodetype.strip_typedefs().pointer()
+        nodetype = lookup_node_type('_Rb_tree_node', self.val.type)
+        self.link_type = nodetype.pointer()
 
     def to_string (self):
         if not self.val['_M_node']:
@@ -644,9 +711,7 @@ class StdMapPrinter:
                                num_elements(len(RbtreeIterator (self.val))))
 
     def children (self):
-        rep_type = find_type(self.val.type, '_Rep_type')
-        node = find_type(rep_type, '_Link_type')
-        node = node.strip_typedefs()
+        node = lookup_node_type('_Rb_tree_node', self.val.type).pointer()
         return self._iter (RbtreeIterator (self.val), node)
 
     def display_hint (self):
@@ -684,9 +749,7 @@ class StdSetPrinter:
                                num_elements(len(RbtreeIterator (self.val))))
 
     def children (self):
-        rep_type = find_type(self.val.type, '_Rep_type')
-        node = find_type(rep_type, '_Link_type')
-        node = node.strip_typedefs()
+        node = lookup_node_type('_Rb_tree_node', self.val.type).pointer()
         return self._iter (RbtreeIterator (self.val), node)
 
 class StdBitsetPrinter:
@@ -844,11 +907,11 @@ class StdStringPrinter:
         return 'string'
 
 class Tr1HashtableIterator(Iterator):
-    def __init__ (self, hash):
-        self.buckets = hash['_M_buckets']
+    def __init__ (self, hashtable):
+        self.buckets = hashtable['_M_buckets']
         self.bucket = 0
-        self.bucket_count = hash['_M_bucket_count']
-        self.node_type = find_type(hash.type, '_Node').pointer()
+        self.bucket_count = hashtable['_M_bucket_count']
+        self.node_type = find_type(hashtable.type, '_Node').pointer()
         self.node = 0
         while self.bucket != self.bucket_count:
             self.node = self.buckets[self.bucket]
@@ -875,9 +938,13 @@ class Tr1HashtableIterator(Iterator):
         return result
 
 class StdHashtableIterator(Iterator):
-    def __init__(self, hash):
-        self.node = hash['_M_before_begin']['_M_nxt']
-        self.node_type = find_type(hash.type, '__node_type').pointer()
+    def __init__(self, hashtable):
+        self.node = hashtable['_M_before_begin']['_M_nxt']
+        valtype = hashtable.type.template_argument(1)
+        cached = hashtable.type.template_argument(9).template_argument(0)
+        node_type = lookup_templ_spec('std::__detail::_Hash_node', str(valtype),
+                                      'true' if cached else 'false')
+        self.node_type = node_type.pointer()
 
     def __iter__(self):
         return self
@@ -892,7 +959,7 @@ class StdHashtableIterator(Iterator):
         return valptr.dereference()
 
 class Tr1UnorderedSetPrinter:
-    "Print a tr1::unordered_set"
+    "Print a std::unordered_set or tr1::unordered_set"
 
     def __init__ (self, typename, val):
         self.typename = strip_versioned_namespace(typename)
@@ -918,7 +985,7 @@ class Tr1UnorderedSetPrinter:
         return izip (counter, StdHashtableIterator (self.hashtable()))
 
 class Tr1UnorderedMapPrinter:
-    "Print a tr1::unordered_map"
+    "Print a std::unordered_map or tr1::unordered_map"
 
     def __init__ (self, typename, val):
         self.typename = strip_versioned_namespace(typename)
@@ -989,8 +1056,7 @@ class StdForwardListPrinter:
         self.typename = strip_versioned_namespace(typename)
 
     def children(self):
-        nodetype = find_type(self.val.type, '_Node')
-        nodetype = nodetype.strip_typedefs().pointer()
+        nodetype = lookup_node_type('_Fwd_list_node', self.val.type).pointer()
         return self._iterator(nodetype, self.val['_M_impl']['_M_head'])
 
     def to_string(self):
@@ -1041,6 +1107,29 @@ class SingleObjContainerPrinter(object):
             return self.visualizer.display_hint ()
         return self.hint
 
+def function_pointer_to_name(f):
+    "Find the name of the function referred to by the gdb.Value f, "
+    " which should contain a function pointer from the program."
+
+    # Turn the function pointer into an actual address.
+    # This is needed to unpack ppc64 function descriptors.
+    f = f.dereference().address
+
+    if sys.version_info[0] == 2:
+        # Older versions of GDB need to use long for Python 2,
+        # because int(f) on 64-bit big-endian values raises a
+        # gdb.error saying "Cannot convert value to int."
+        f = long(f)
+    else:
+        f = int(f)
+
+    try:
+        # If the function can't be found older versions of GDB raise a
+        # RuntimeError saying "Cannot locate object file for block."
+        return gdb.block_for_pc(f).function.name
+    except:
+        return None
+
 class StdExpAnyPrinter(SingleObjContainerPrinter):
     "Print a std::any or std::experimental::any"
 
@@ -1053,11 +1142,11 @@ class StdExpAnyPrinter(SingleObjContainerPrinter):
         visualizer = None
         mgr = self.val['_M_manager']
         if mgr != 0:
-            func = gdb.block_for_pc(int(mgr.cast(gdb.lookup_type('intptr_t'))))
+            func = function_pointer_to_name(mgr)
             if not func:
-                raise ValueError("Invalid function pointer in %s" % self.typename)
+                raise ValueError("Invalid function pointer in %s" % (self.typename))
             rx = r"""({0}::_Manager_\w+<.*>)::_S_manage\((enum )?{0}::_Op, (const {0}|{0} const) ?\*, (union )?{0}::_Arg ?\*\)""".format(typename)
-            m = re.match(rx, func.function.name)
+            m = re.match(rx, func)
             if not m:
                 raise ValueError("Unknown manager function in %s" % self.typename)
 
@@ -1209,6 +1298,7 @@ class StdExpPathPrinter:
 
     def __init__ (self, typename, val):
         self.val = val
+        self.typename = typename
         start = self.val['_M_cmpts']['_M_impl']['_M_start']
         finish = self.val['_M_cmpts']['_M_impl']['_M_finish']
         self.num_cmpts = int (finish - start)
@@ -1227,10 +1317,11 @@ class StdExpPathPrinter:
             t = self._path_type()
             if t:
                 path = '%s [%s]' % (path, t)
-        return "filesystem::path %s" % path
+        return "experimental::filesystem::path %s" % path
 
     class _iterator(Iterator):
-        def __init__(self, cmpts):
+        def __init__(self, cmpts, pathtype):
+            self.pathtype = pathtype
             self.item = cmpts['_M_impl']['_M_start']
             self.finish = cmpts['_M_impl']['_M_finish']
             self.count = 0
@@ -1246,13 +1337,13 @@ class StdExpPathPrinter:
             self.count = self.count + 1
             self.item = self.item + 1
             path = item['_M_pathname']
-            t = StdExpPathPrinter(item.type.name, item)._path_type()
+            t = StdExpPathPrinter(self.pathtype, item)._path_type()
             if not t:
                 t = count
             return ('[%s]' % t, path)
 
     def children(self):
-        return self._iterator(self.val['_M_cmpts'])
+        return self._iterator(self.val['_M_cmpts'], self.typename)
 
 class StdPathPrinter:
     "Print a std::filesystem::path"
@@ -1285,6 +1376,7 @@ class StdPathPrinter:
 
     class _iterator(Iterator):
         def __init__(self, impl, pathtype):
+            self.pathtype = pathtype
             if impl:
                 # We can't access _Impl::_M_size because _Impl is incomplete
                 # so cast to int* to access the _M_size member at offset zero,
@@ -1317,7 +1409,7 @@ class StdPathPrinter:
             self.count = self.count + 1
             self.item = self.item + 1
             path = item['_M_pathname']
-            t = StdPathPrinter(item.type.name, item)._path_type()
+            t = StdPathPrinter(self.pathtype, item)._path_type()
             if not t:
                 t = count
             return ('[%s]' % t, path)
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index 5f1f47b9fb7..402ed02143d 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -1175,11 +1175,17 @@ fs::path fs::read_symlink(const path& p, error_code& ec)
   path result;
 #if defined(_GLIBCXX_HAVE_READLINK) && defined(_GLIBCXX_HAVE_SYS_STAT_H)
   stat_type st;
-  if (::lstat(p.c_str(), &st))
+  if (posix::lstat(p.c_str(), &st))
     {
       ec.assign(errno, std::generic_category());
       return result;
     }
+  else if (!fs::is_symlink(make_file_status(st)))
+    {
+      ec.assign(EINVAL, std::generic_category());
+      return result;
+    }
+
   std::string buf(st.st_size ? st.st_size + 1 : 128, '\0');
   do
     {
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 54bef75efd8..b44fae03da0 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -74,7 +74,7 @@ struct path::_Parser
     const size_t len = input.size();
 
     // look for root name or root directory
-    if (is_dir_sep(input[0]))
+    if (len && is_dir_sep(input[0]))
       {
 #if SLASHSLASH_IS_ROOTNAME
 	// look for root name, such as "//foo"
@@ -845,6 +845,26 @@ path::operator+=(const path& p)
       return *this;
     }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (_M_type() == _Type::_Root_name
+      || (_M_type() == _Type::_Filename && _M_pathname.size() == 1))
+    {
+      // Handle path("C") += path(":") and path("C:") += path("/x")
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + p._M_pathname);
+      return *this;
+    }
+#endif
+#if SLASHSLASH_IS_ROOTNAME
+  if (_M_type() == _Type::_Root_dir)
+    {
+      // Handle path("/") += path("/x") and path("//") += path("x")
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + p._M_pathname);
+      return *this;
+    }
+#endif
+
   const auto orig_pathlen = _M_pathname.length();
   const auto orig_type = _M_type();
   const auto orig_size = _M_cmpts.size();
@@ -1031,6 +1051,26 @@ path::_M_concat(basic_string_view<value_type> s)
       return;
     }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (_M_type() == _Type::_Root_name
+      || (_M_type() == _Type::_Filename && _M_pathname.size() == 1))
+    {
+      // Handle path("C") += ":" and path("C:") += "/x"
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + string_type(s));
+      return;
+    }
+#endif
+#if SLASHSLASH_IS_ROOTNAME
+  if (_M_type() == _Type::_Root_dir)
+    {
+      // Handle path("/") += "/x" and path("//") += "x"
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + string_type(s));
+      return;
+    }
+#endif
+
   const auto orig_pathlen = _M_pathname.length();
   const auto orig_type = _M_type();
   const auto orig_size = _M_cmpts.size();
diff --git a/libstdc++-v3/src/c++17/memory_resource.cc b/libstdc++-v3/src/c++17/memory_resource.cc
index e28526d1bfe..f8c7fcbcaa5 100644
--- a/libstdc++-v3/src/c++17/memory_resource.cc
+++ b/libstdc++-v3/src/c++17/memory_resource.cc
@@ -228,8 +228,8 @@ namespace pmr
 	  if (__ch->_M_canary != (__ch->_M_size | __ch->_M_align))
 	    return; // buffer overflow detected!
 
-	  size_t __size = (1u << __ch->_M_size);
-	  size_t __align = (1u << __ch->_M_align);
+	  size_t __size = (size_t)1 << __ch->_M_size;
+	  size_t __align = (size_t)1 << __ch->_M_align;
 	  void* __start = (char*)(__ch + 1) - __size;
 	  __r->deallocate(__start, __size, __align);
 	}
@@ -873,7 +873,18 @@ namespace pmr
       }
     else
       {
-	// TODO round to preferred granularity ?
+	// Round to preferred granularity.
+	if (opts.max_blocks_per_chunk < size_t(-4))
+	  {
+	    // round up
+	    opts.max_blocks_per_chunk += 3;
+	    opts.max_blocks_per_chunk &= ~size_t(3);
+	  }
+	else
+	  {
+	    // round down
+	    opts.max_blocks_per_chunk &= ~size_t(3);
+	  }
       }
 
     if (opts.max_blocks_per_chunk > chunk::max_blocks_per_chunk())
@@ -1013,11 +1024,9 @@ namespace pmr
 	  : pool_sizes[i];
 
 	// Decide on initial number of blocks per chunk.
-	// Always have at least 16 blocks per chunk:
-	const size_t min_blocks_per_chunk = 16;
-	// But for smaller blocks, use a larger initial size:
-	size_t blocks_per_chunk
-	  = std::max(1024 / block_size, min_blocks_per_chunk);
+	// At least 16 blocks per chunk seems reasonable,
+	// more for smaller blocks:
+	size_t blocks_per_chunk = std::max(size_t(16), 1024 / block_size);
 	// But don't exceed the requested max_blocks_per_chunk:
 	blocks_per_chunk
 	  = std::min(blocks_per_chunk, _M_opts.max_blocks_per_chunk);
@@ -1043,7 +1052,8 @@ namespace pmr
    * exposition as _M_tpools[_M_key]).
    * The first element, _M_tpools[0], contains "orphaned chunks" which were
    * allocated by a thread which has since exited, and so there is no
-   * _M_tpools[_M_key] for that thread.
+   * _M_tpools[_M_key] for that thread. Orphaned chunks are never reused,
+   * they're only held in _M_tpools[0] so they can be deallocated.
    * A thread can access its own thread-specific set of pools via _M_key
    * while holding a shared lock on _M_mx. Accessing _M_impl._M_unpooled
    * or _M_tpools[0] or any other thread's _M_tpools[_M_key] requires an
@@ -1052,6 +1062,10 @@ namespace pmr
    * any dereference of that pointer requires an exclusive lock.
    * The _M_impl._M_opts and _M_impl._M_npools members are immutable,
    * and can safely be accessed concurrently.
+   *
+   * In a single-threaded program (i.e. __gthread_active_p() == false)
+   * the pool resource only needs one set of pools and never has orphaned
+   * chunks, so just uses _M_tpools[0] directly, and _M_tpools->next is null.
    */
 
   extern "C" {
@@ -1092,14 +1106,16 @@ namespace pmr
     void move_nonempty_chunks()
     {
       __glibcxx_assert(pools);
+      __glibcxx_assert(__gthread_active_p());
       if (!pools)
 	return;
-      memory_resource* r = owner.upstream_resource();
+      memory_resource* const r = owner.upstream_resource();
+      auto* const shared = owner._M_tpools->pools;
       // move all non-empty chunks to the shared _TPools
       for (int i = 0; i < owner._M_impl._M_npools; ++i)
 	for (auto& c : pools[i]._M_chunks)
 	  if (!c.empty())
-	    owner._M_tpools->pools[i]._M_chunks.insert(std::move(c), r);
+	    shared[i]._M_chunks.insert(std::move(c), r);
     }
 
     synchronized_pool_resource& owner;
@@ -1133,8 +1149,9 @@ namespace pmr
 			     memory_resource* upstream)
   : _M_impl(opts, upstream)
   {
-    if (int err = __gthread_key_create(&_M_key, destroy_TPools))
-      __throw_system_error(err);
+    if (__gthread_active_p())
+      if (int err = __gthread_key_create(&_M_key, destroy_TPools))
+	__throw_system_error(err);
     exclusive_lock l(_M_mx);
     _M_tpools = _M_alloc_shared_tpools(l);
   }
@@ -1143,7 +1160,8 @@ namespace pmr
   synchronized_pool_resource::~synchronized_pool_resource()
   {
     release();
-    __gthread_key_delete(_M_key); // does not run destroy_TPools
+    if (__gthread_active_p())
+      __gthread_key_delete(_M_key); // does not run destroy_TPools
   }
 
   void
@@ -1152,8 +1170,11 @@ namespace pmr
     exclusive_lock l(_M_mx);
     if (_M_tpools)
       {
-	__gthread_key_delete(_M_key); // does not run destroy_TPools
-	__gthread_key_create(&_M_key, destroy_TPools);
+	if (__gthread_active_p())
+	  {
+	    __gthread_key_delete(_M_key); // does not run destroy_TPools
+	    __gthread_key_create(&_M_key, destroy_TPools);
+	  }
 	polymorphic_allocator<_TPools> a(upstream_resource());
 	// destroy+deallocate each _TPools
 	do
@@ -1175,10 +1196,11 @@ namespace pmr
   synchronized_pool_resource::_M_thread_specific_pools() noexcept
   {
     __pool_resource::_Pool* pools = nullptr;
+    __glibcxx_assert(__gthread_active_p());
     if (auto tp = static_cast<_TPools*>(__gthread_getspecific(_M_key)))
       {
-      pools = tp->pools;
-      __glibcxx_assert(tp->pools);
+	pools = tp->pools;
+	// __glibcxx_assert(tp->pools);
       }
     return pools;
   }
@@ -1189,24 +1211,34 @@ namespace pmr
   do_allocate(size_t bytes, size_t alignment)
   {
     const auto block_size = std::max(bytes, alignment);
-    if (block_size <= _M_impl._M_opts.largest_required_pool_block)
+    const pool_options opts = _M_impl._M_opts;
+    if (block_size <= opts.largest_required_pool_block)
       {
 	const ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);
-	memory_resource* const r = upstream_resource();
-	const pool_options opts = _M_impl._M_opts;
-	{
-	  // Try to allocate from the thread-specific pool
-	  shared_lock l(_M_mx);
-	  if (auto pools = _M_thread_specific_pools()) // [[likely]]
-	    {
-	      // Need exclusive lock to replenish so use try_allocate:
-	      if (void* p = pools[index].try_allocate())
-		return p;
-	      // Need to take exclusive lock and replenish pool.
-	    }
-	  // Need to allocate or replenish thread-specific pools using
-	  // upstream resource, so need to hold exclusive lock.
-	}
+	if (__gthread_active_p())
+	  {
+	    // Try to allocate from the thread-specific pool.
+	    shared_lock l(_M_mx);
+	    if (auto pools = _M_thread_specific_pools()) // [[likely]]
+	      {
+		// Need exclusive lock to replenish so use try_allocate:
+		if (void* p = pools[index].try_allocate())
+		  return p;
+		// Need to take exclusive lock and replenish pool.
+	      }
+	    // Need to allocate or replenish thread-specific pools using
+	    // upstream resource, so need to hold exclusive lock.
+	  }
+	else // single-threaded
+	  {
+	    if (!_M_tpools) // [[unlikely]]
+	      {
+		exclusive_lock dummy(_M_mx);
+		_M_tpools = _M_alloc_shared_tpools(dummy);
+	      }
+	    return _M_tpools->pools[index].allocate(upstream_resource(), opts);
+	  }
+
 	// N.B. Another thread could call release() now lock is not held.
 	exclusive_lock excl(_M_mx);
 	if (!_M_tpools) // [[unlikely]]
@@ -1214,7 +1246,7 @@ namespace pmr
 	auto pools = _M_thread_specific_pools();
 	if (!pools)
 	  pools = _M_alloc_tpools(excl)->pools;
-	return pools[index].allocate(r, opts);
+	return pools[index].allocate(upstream_resource(), opts);
       }
     exclusive_lock l(_M_mx);
     return _M_impl.allocate(bytes, alignment); // unpooled allocation
@@ -1230,30 +1262,45 @@ namespace pmr
       {
 	const ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);
 	__glibcxx_assert(index != -1);
-	{
-	  shared_lock l(_M_mx);
-	  auto pools = _M_thread_specific_pools();
-	  if (pools)
-	    {
-	      // No need to lock here, no other thread is accessing this pool.
-	      if (pools[index].deallocate(upstream_resource(), p))
-		return;
-	    }
-	  // Block might have come from a different thread's pool,
-	  // take exclusive lock and check every pool.
-	}
+	if (__gthread_active_p())
+	  {
+	    shared_lock l(_M_mx);
+	    if (auto pools = _M_thread_specific_pools())
+	      {
+		// No need to lock here, no other thread is accessing this pool.
+		if (pools[index].deallocate(upstream_resource(), p))
+		  return;
+	      }
+	    // Block might have come from a different thread's pool,
+	    // take exclusive lock and check every pool.
+	  }
+	else // single-threaded
+	  {
+	    __glibcxx_assert(_M_tpools != nullptr);
+	    if (_M_tpools) // [[likely]]
+	      _M_tpools->pools[index].deallocate(upstream_resource(), p);
+	    return;
+	  }
+
 	// TODO store {p, bytes, alignment} somewhere and defer returning
 	// the block to the correct thread-specific pool until we next
 	// take the exclusive lock.
+
 	exclusive_lock excl(_M_mx);
+	auto my_pools = _M_thread_specific_pools();
 	for (_TPools* t = _M_tpools; t != nullptr; t = t->next)
 	  {
-	    if (t->pools) // [[likely]]
-	      {
-		if (t->pools[index].deallocate(upstream_resource(), p))
-		  return;
-	      }
+	    if (t->pools != my_pools)
+	      if (t->pools) // [[likely]]
+		{
+		  if (t->pools[index].deallocate(upstream_resource(), p))
+		    return;
+		}
 	  }
+	// Not necessarily an error to reach here, release() could have been
+	// called on another thread between releasing the shared lock and
+	// acquiring the exclusive lock.
+	return;
       }
     exclusive_lock l(_M_mx);
     _M_impl.deallocate(p, bytes, alignment);
@@ -1265,6 +1312,7 @@ namespace pmr
   -> _TPools*
   {
     __glibcxx_assert(_M_tpools != nullptr);
+    __glibcxx_assert(__gthread_active_p());
     // dump_list(_M_tpools);
     polymorphic_allocator<_TPools> a(upstream_resource());
     _TPools* p = a.allocate(1);
diff --git a/libstdc++-v3/src/filesystem/dir.cc b/libstdc++-v3/src/filesystem/dir.cc
index ac3bd3aafb3..d7d8eb74066 100644
--- a/libstdc++-v3/src/filesystem/dir.cc
+++ b/libstdc++-v3/src/filesystem/dir.cc
@@ -187,16 +187,16 @@ struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>
 
 fs::recursive_directory_iterator::
 recursive_directory_iterator(const path& p, directory_options options,
-                             error_code* ec)
+                             error_code* ecptr)
 : _M_options(options), _M_pending(true)
 {
-  if (ec)
-    ec->clear();
   if (posix::DIR* dirp = posix::opendir(p.c_str()))
     {
+      if (ecptr)
+	ecptr->clear();
       auto sp = std::make_shared<_Dir_stack>();
       sp->push(_Dir{ dirp, p });
-      if (sp->top().advance(ec))
+      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())
 	_M_dirs.swap(sp);
     }
   else
@@ -204,14 +204,18 @@ recursive_directory_iterator(const path& p, directory_options options,
       const int err = errno;
       if (err == EACCES
 	  && is_set(options, fs::directory_options::skip_permission_denied))
-	return;
+	{
+	  if (ecptr)
+	    ecptr->clear();
+	  return;
+	}
 
-      if (!ec)
+      if (!ecptr)
 	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
 	      "recursive directory iterator cannot open directory", p,
 	      std::error_code(err, std::generic_category())));
 
-      ec->assign(err, std::generic_category());
+      ecptr->assign(err, std::generic_category());
     }
 }
 
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 21d0bbabb43..5c907fbca1e 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -71,14 +71,14 @@ namespace __gnu_posix
   inline int close(int fd)
   { return ::_close(fd); }
 
-  typedef struct ::_stat stat_type;
+  typedef struct ::__stat64 stat_type;
 
   inline int stat(const wchar_t* path, stat_type* buffer)
-  { return ::_wstat(path, buffer); }
+  { return ::_wstat64(path, buffer); }
 
   inline int lstat(const wchar_t* path, stat_type* buffer)
   {
-    // TODO symlinks not currently supported
+    // FIXME: symlinks not currently supported
     return stat(path, buffer);
   }
 
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 5c5d6b9ef26..0115cff1907 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -993,11 +993,17 @@ fs::path fs::read_symlink(const path& p [[gnu::unused]], error_code& ec)
   path result;
 #if defined(_GLIBCXX_HAVE_READLINK) && defined(_GLIBCXX_HAVE_SYS_STAT_H)
   stat_type st;
-  if (::lstat(p.c_str(), &st))
+  if (posix::lstat(p.c_str(), &st))
     {
       ec.assign(errno, std::generic_category());
       return result;
     }
+  else if (!fs::is_symlink(make_file_status(st)))
+    {
+      ec.assign(EINVAL, std::generic_category());
+      return result;
+    }
+
   std::string buf(st.st_size ? st.st_size + 1 : 128, '\0');
   do
     {
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index a47d53503e3..efb0bd137a7 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -104,6 +104,11 @@
 #define uses_allocator  (
 #endif
 
+#if __cplusplus < 201402L
+// <complex> defines operator""il
+#define il  (
+#endif
+
 #if __cplusplus < 201703L
 // <charconv> defines to_chars_result::ptr and to_chars_result::ec
 #define ec (
diff --git a/libstdc++-v3/testsuite/20_util/allocator/89510.cc b/libstdc++-v3/testsuite/20_util/allocator/89510.cc
new file mode 100644
index 00000000000..a3100a2b062
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/allocator/89510.cc
@@ -0,0 +1,147 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+using AT = std::allocator_traits<std::allocator<int>>;
+
+template<typename...> using void_t = void;
+
+template<typename T, typename U, typename = void>
+struct has_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_construct<T, U,
+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_destroy<T, U,
+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_construct<T, U,
+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_destroy<T, U,
+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+struct NoDefault { NoDefault(int); };
+struct NoDest { private: ~NoDest(); };
+
+// Whether true or false, this should not give an error:
+constexpr bool c = has_construct<std::allocator<NoDefault>, NoDefault>::value;
+constexpr bool cv = has_construct<std::allocator<void>, NoDefault>::value;
+constexpr bool c2 = has_traits_construct<std::allocator<int>, NoDefault>::value;
+constexpr bool d = has_destroy<std::allocator<NoDest>, NoDest>::value;
+constexpr bool d2 = has_traits_destroy<std::allocator<int>, NoDest>::value;
+
+std::allocator<int> a;
+
+long* lp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(lp)), "" );
+static_assert( noexcept(a.construct(lp, 1L)), "" );
+static_assert( noexcept(a.construct(lp, 2)), "" );
+static_assert( noexcept(a.construct(lp, 2U)), "" );
+static_assert( noexcept(a.destroy(lp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, lp)), "" );
+static_assert( noexcept(AT::construct(a, lp, 1L)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2U)), "" );
+static_assert( noexcept(AT::destroy(a, lp)), "" );
+
+struct X
+{
+  X() noexcept;
+  X(int) noexcept;
+  ~X() noexcept;
+};
+
+X* xp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(xp)), "" );
+static_assert( noexcept(a.construct(xp, 1)), "" );
+static_assert( noexcept(a.destroy(xp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, xp)), "" );
+static_assert( noexcept(AT::construct(a, xp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, xp)), "" );
+
+struct Y
+{
+  Y() noexcept;
+  Y(int) noexcept(false);
+  ~Y() noexcept;
+};
+
+Y* yp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(yp)), "" );
+static_assert( ! noexcept(a.construct(yp, 1)), "" );
+static_assert( noexcept(a.destroy(yp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, yp)), "" );
+static_assert( ! noexcept(AT::construct(a, yp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, yp)), "" );
+
+struct Z
+{
+  Z() noexcept;
+  Z(int) noexcept;
+  ~Z() noexcept(false);
+};
+
+Z* zp;
+// These construct calls should be noexcept, but they are false because
+// they use is_nothrow_constructible which depends on is_nothrow_destructible.
+#if __cplusplus <= 201703L
+static_assert( ! noexcept(a.construct(zp)), "wrong" );
+static_assert( ! noexcept(a.construct(zp, 1)), "wrong" );
+static_assert( ! noexcept(a.destroy(zp)), "" );
+#endif
+static_assert( ! noexcept(AT::construct(a, zp)), "" );
+static_assert( ! noexcept(AT::construct(a, zp, 1)), "" );
+static_assert( ! noexcept(AT::destroy(a, zp)), "" );
diff --git a/libstdc++-v3/testsuite/20_util/assume_aligned/1.cc b/libstdc++-v3/testsuite/20_util/assume_aligned/1.cc
index 86208bcdee3..bbd100f18f5 100644
--- a/libstdc++-v3/testsuite/20_util/assume_aligned/1.cc
+++ b/libstdc++-v3/testsuite/20_util/assume_aligned/1.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++2a" }
+// { dg-options "-std=gnu++2a -O2" }
 // { dg-do run { target c++2a } }
 
 #include <memory>
@@ -29,7 +29,28 @@ test01()
   VERIFY( p == &i );
 }
 
+[[gnu::noipa,gnu::noinline]]
+int*
+create_aligned(std::size_t alignment, void* p, std::size_t n)
+{
+  return ::new(std::align(alignment, sizeof(int), p, n)) int(42);
+}
+
+extern "C" void undefined(); // call to this should be optimized away
+
+void
+test02()
+{
+  unsigned char buf[sizeof(int) * 128];
+  int* p = create_aligned(64, buf + 1, sizeof(buf) - 1);
+  int* q = std::assume_aligned<64>(p);
+  if ((std::uintptr_t)q % 64)
+    undefined();
+  VERIFY( p == q );
+}
+
 int main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/20_util/assume_aligned/97132.cc b/libstdc++-v3/testsuite/20_util/assume_aligned/97132.cc
new file mode 100644
index 00000000000..887e3470651
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/assume_aligned/97132.cc
@@ -0,0 +1,34 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <memory>
+
+// PR libstdc++/97132 - assume_aligned is not constexpr
+
+constexpr bool test01()
+{
+  struct alignas(32) S { int i; };
+  S s{42};
+  int* p = std::assume_aligned<32>(&s.i);
+  *p = 48;
+  return s.i == 48;
+}
+
+static_assert( test01() );
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/1.cc b/libstdc++-v3/testsuite/20_util/from_chars/1.cc
index a352dc87ed4..ee9f5f773e0 100644
--- a/libstdc++-v3/testsuite/20_util/from_chars/1.cc
+++ b/libstdc++-v3/testsuite/20_util/from_chars/1.cc
@@ -29,7 +29,8 @@ check_from_chars(I expected, std::string_view s, int base = 0, char term = '\0')
   std::from_chars_result r = base == 0
     ? std::from_chars(s.begin(), s.end(), val)
     : std::from_chars(s.begin(), s.end(), val, base);
-  return r.ec == std::errc{} && (r.ptr == s.end() || *r.ptr == term) && val == expected;
+  return r.ec == std::errc{} && (r.ptr == s.end() || *r.ptr == term)
+    && val == expected;
 }
 
 #include <climits>
@@ -50,10 +51,18 @@ void
 test02()
 {
   // "0x" parsed as "0" not as hex prefix:
-  VERIFY( check_from_chars(0, "0x1", 10, 'x') );
-  VERIFY( check_from_chars(0, "0X1", 10, 'X') );
-  VERIFY( check_from_chars(0, "0x1", 16, 'x') );
-  VERIFY( check_from_chars(0, "0X1", 16, 'X') );
+  for (int base = 2; base < 34; ++base)
+  {
+    VERIFY( check_from_chars(0, "0x1", base, 'x') );
+    VERIFY( check_from_chars(0, "0X1", base, 'X') );
+  }
+
+  VERIFY( check_from_chars(1123, "0x1", 34) );
+  VERIFY( check_from_chars(1123, "0X1", 34) );
+  VERIFY( check_from_chars(1156, "0x1", 35) );
+  VERIFY( check_from_chars(1156, "0X1", 35) );
+  VERIFY( check_from_chars(1189, "0x1", 36) );
+  VERIFY( check_from_chars(1189, "0X1", 36) );
 
   VERIFY( check_from_chars(1155, "xx", 34) );
   VERIFY( check_from_chars(1155, "XX", 34) );
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/3.cc b/libstdc++-v3/testsuite/20_util/from_chars/3.cc
new file mode 100644
index 00000000000..9d4a77f5c31
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/from_chars/3.cc
@@ -0,0 +1,79 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++14 } }
+
+#include <charconv>
+#include <string>
+#include <testsuite_hooks.h>
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+long long
+read(const char* first, const char* last, int base)
+{
+  long long val = 0;
+  long long place = 1;
+  while (last > first)
+  {
+    val += (*--last - '0') * place;
+    place *= base;
+  }
+  return val;
+}
+
+void
+test01()
+{
+  std::from_chars_result res;
+  long long val;
+  for (auto s : { "10001", "10010", "10011", "10101", "10110", "10111",
+		  "11001", "11010", "11011", "11101", "11110", "11111" })
+  {
+    std::string ss[2] = { s, std::string(64, '0') + s };
+    for (const auto& str : ss)
+    {
+      const char* first = str.data();
+      for (int base = 2; base < 37; ++base)
+      {
+	const char* last = str.data() + str.length();
+	for (size_t n = 0; n < ss[0].length(); ++n)
+	{
+#ifdef DEBUG
+	  printf("Parsing \"%.*s\" in base %d\n", int(last - first), first,
+		 base);
+#endif
+	  res = std::from_chars(first, last, val, base);
+	  VERIFY( res.ptr == last );
+	  VERIFY( res.ec == std::errc{} );
+	  VERIFY( val == read(first, last, base) );
+	  // Test again with shorter string to check from_chars doesn't read
+	  // the digits past the last pointer.
+	  --last;
+	}
+      }
+    }
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/bind_front/97101.cc b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/97101.cc
new file mode 100644
index 00000000000..b159eb02591
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function_objects/bind_front/97101.cc
@@ -0,0 +1,41 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <functional>
+
+void
+test01()
+{
+  struct F1
+  {
+    void operator()() { }
+  };
+
+  struct F2
+  {
+    F2() = default;
+    F2(const F2&) noexcept(false) { }
+    void operator()() { }
+  };
+
+  // PR libstdc++/97101
+  static_assert( noexcept(std::bind_front(F1{})) );
+  static_assert( ! noexcept(std::bind_front(F2{})) );
+}
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_constructible/94003.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_constructible/94003.cc
new file mode 100644
index 00000000000..392a0878ba5
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_constructible/94003.cc
@@ -0,0 +1,46 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <optional>
+#include <tuple>
+
+template <bool B> struct abc {};
+
+template <typename T>
+
+struct future : public abc<std::is_trivially_constructible_v<std::tuple<T>>> {};
+
+class mutation {
+  mutation();
+  friend class std::optional<mutation>;
+};
+
+using mutation_opt = std::optional<mutation>;
+
+future<mutation_opt> foo();
+
+template <typename Consumer> future<mutation_opt> consume_partitions() {
+  return foo();
+}
+
+future<mutation_opt> bar() { return consume_partitions<int>(); }
+
+future<mutation> zed();
+future<mutation> apply_counter_update() { return zed(); }
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_default_constructible/96999.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_default_constructible/96999.cc
new file mode 100644
index 00000000000..9ec42760051
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_default_constructible/96999.cc
@@ -0,0 +1,54 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+// PR libstdc++/96999
+
+#include <variant>
+#include <string>
+
+struct Foo {
+public:
+  explicit Foo(int) noexcept {}
+  Foo(Foo &&) noexcept = default;
+  Foo &operator=(Foo &&) = default;
+private:
+  Foo() noexcept {}
+};
+
+struct Boo {
+public:
+  explicit Boo(int) noexcept {}
+  Boo(Boo &&) noexcept = default;
+  Boo &operator=(Boo &&) = default;
+private:
+  Boo() noexcept {}
+};
+
+
+template<bool X>
+std::variant<Foo, Boo> g(int v, int x) {
+ return  v == 0 ? std::variant<Foo, Boo>{Foo{x}} :
+                                 std::variant<Foo, Boo>{Boo{x}};
+}
+
+int main()
+{
+  std::variant<std::variant<Foo, Boo>, std::string> err{std::string("aaa")};
+}
diff --git a/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/allocate_single.cc b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/allocate_single.cc
new file mode 100644
index 00000000000..d5b7b162146
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/allocate_single.cc
@@ -0,0 +1,24 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run }
+// { dg-options "-std=gnu++17" }
+// { dg-require-effective-target c++17 }
+// { dg-require-gthreads "" }
+
+// This runs the same tests as allocate.cc but without -pthread
+#include "./allocate.cc"
diff --git a/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/cons_single.cc b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/cons_single.cc
new file mode 100644
index 00000000000..060cd7628e5
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/cons_single.cc
@@ -0,0 +1,24 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run }
+// { dg-options "-std=gnu++17" }
+// { dg-require-effective-target c++17 }
+// { dg-require-gthreads "" }
+
+// This runs the same tests as cons.cc but without -pthread
+#include "./cons.cc"
diff --git a/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/release_single.cc b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/release_single.cc
new file mode 100644
index 00000000000..32e80c1be3f
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/synchronized_pool_resource/release_single.cc
@@ -0,0 +1,24 @@
+// Copyright (C) 2018-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run }
+// { dg-options "-std=gnu++17" }
+// { dg-require-effective-target c++17 }
+// { dg-require-gthreads "" }
+
+// This runs the same tests as release.cc but without -pthread
+#include "./release.cc"
diff --git a/libstdc++-v3/testsuite/20_util/to_address/1_neg.cc b/libstdc++-v3/testsuite/20_util/to_address/1_neg.cc
index 0954ac7b458..092413e6581 100644
--- a/libstdc++-v3/testsuite/20_util/to_address/1_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/to_address/1_neg.cc
@@ -17,7 +17,7 @@
 
 // { dg-options "-std=gnu++2a" }
 // { dg-do compile { target c++2a } }
-// { dg-error "not a function pointer" "" { target *-*-* } 153 }
+// { dg-error "not a function pointer" "" { target *-*-* } 158 }
 
 #include <memory>
 
diff --git a/libstdc++-v3/testsuite/20_util/to_address/debug.cc b/libstdc++-v3/testsuite/20_util/to_address/debug.cc
new file mode 100644
index 00000000000..4555284416d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/to_address/debug.cc
@@ -0,0 +1,36 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { target c++2a } }
+
+#include <debug/vector>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  __gnu_debug::vector<int> v{1, 2, 3};
+  auto p = std::to_address(v.end());
+  VERIFY( p == v.data() + v.size() );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/tuple/cons/96803.cc b/libstdc++-v3/testsuite/20_util/tuple/cons/96803.cc
new file mode 100644
index 00000000000..867a42150e0
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/tuple/cons/96803.cc
@@ -0,0 +1,62 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <tuple>
+#include <memory>
+
+struct X
+{
+  using allocator_type = std::allocator<int>;
+
+  X(X&&) { }
+  X(std::allocator_arg_t, const allocator_type&, X&&) { }
+
+  explicit X(int) { }
+  explicit X(int, allocator_type) { }
+};
+
+void
+test01()
+{
+  // PR libstdc++/96803
+  // std::tuple chooses wrong constructor for uses-allocator construction
+  std::tuple<int> o;
+  std::tuple<X> nok(std::allocator_arg, std::allocator<int>(), o);
+
+  std::tuple<int, int> oo;
+  std::tuple<X, X> nn(std::allocator_arg, std::allocator<int>(), oo);
+}
+
+struct Y
+{
+  using allocator_type = std::allocator<int>;
+
+  Y(const X&) { }
+  Y(const X&, const allocator_type&) { }
+
+  Y(X&&) { }
+  Y(std::allocator_arg_t, const allocator_type&, X&&) { }
+};
+
+void
+test02()
+{
+  std::tuple<X, X> o{1, 1};
+  std::tuple<Y, Y> oo(std::allocator_arg, std::allocator<int>(), o);
+}
diff --git a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
index c5054bd4541..c7f0b087541 100644
--- a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
@@ -239,6 +239,25 @@ test06()
   }
 }
 
+void
+test08()
+{
+  std::pmr::pool_options opts;
+  opts.largest_required_pool_block = 64;
+
+  // PR libstdc++/94160
+  // max_blocks_per_chunk=1 causes pool resources to return null pointers
+  for (int i = 0; i < 8; ++i)
+  {
+    opts.max_blocks_per_chunk = i;
+    std::pmr::unsynchronized_pool_resource upr(opts);
+    auto* p = (int*)upr.allocate(4);
+    VERIFY( p != nullptr );
+    *p = i;
+    upr.deallocate(p, 4);
+  }
+}
+
 int
 main()
 {
@@ -248,4 +267,5 @@ main()
   test04();
   test05();
   test06();
+  test08();
 }
diff --git a/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc b/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc
index 243526725a0..3c04028bb6e 100644
--- a/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc
+++ b/libstdc++-v3/testsuite/20_util/unwrap_reference/1.cc
@@ -20,6 +20,12 @@
 
 #include <type_traits>
 
+#ifndef __cpp_lib_unwrap_ref
+# error "Feature-test macro for unwrap_reference missing in <type_traits>"
+#elif __cpp_lib_unwrap_ref != 201811L
+# error "Feature-test macro for unwrap_reference has wrong value in <type_traits>"
+#endif
+
 template<typename T, typename U> struct expect_same;
 template<typename T> struct expect_same<T, T> : std::true_type { };
 
diff --git a/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc b/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc
new file mode 100644
index 00000000000..3ea9cd18a05
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/unwrap_reference/3.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_unwrap_ref
+# error "Feature-test macro for unwrap_reference missing in <version>"
+#elif __cpp_lib_unwrap_ref != 201811L
+# error "Feature-test macro for unwrap_reference has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/20_util/variant/91807.cc b/libstdc++-v3/testsuite/20_util/variant/91807.cc
new file mode 100644
index 00000000000..04bb5d7c807
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/91807.cc
@@ -0,0 +1,35 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <variant>
+
+struct me_data {
+  me_data() = default;
+
+  me_data(const me_data &) {};
+  me_data(me_data &&) noexcept {};
+  me_data& operator=(const me_data &) = default;
+};
+
+int main() {
+  std::variant<me_data, me_data> v1, v2;
+
+  v2 = v1;
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/erasure.cc b/libstdc++-v3/testsuite/21_strings/basic_string/erasure.cc
index 873dd0cbf0f..a00faf94180 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/erasure.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/erasure.cc
@@ -21,6 +21,12 @@
 #include <string>
 #include <testsuite_hooks.h>
 
+#ifndef __cpp_lib_erase_if
+# error "Feature-test macro for erase_if missing in <string>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <string>"
+#endif
+
 void
 test01()
 {
diff --git a/libstdc++-v3/testsuite/23_containers/array/element_access/constexpr_c++17.cc b/libstdc++-v3/testsuite/23_containers/array/element_access/constexpr_c++17.cc
new file mode 100644
index 00000000000..dd69645833f
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/array/element_access/constexpr_c++17.cc
@@ -0,0 +1,55 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+// Copyright (C) 2011-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <array>
+
+#ifndef __cpp_lib_array_constexpr
+# error "Feature test macro for array constexpr is missing in <array>"
+#elif __cpp_lib_array_constexpr < 201603L
+# error "Feature test macro for array constexpr has wrong value in <array>"
+#endif
+
+constexpr std::size_t test01()
+{
+  // array
+  typedef std::array<std::size_t, 6> array_type;
+  array_type a = { { 0, 55, 66, 99, 4115, 2 } };
+  auto v1  = a[1];
+  auto v2  = a.at(2);
+  auto v3  = a.front();
+  auto v4  = a.back();
+  return v1 + v2 + v3 + v4;
+}
+
+static_assert( test01() == (55 + 66 + 0 + 2) );
+
+constexpr std::size_t test02()
+{
+  // array
+  typedef std::array<std::size_t, 6> array_type;
+  const array_type a = { { 0, 55, 66, 99, 4115, 2 } };
+  auto v1  = a[1];
+  auto v2  = a.at(2);
+  auto v3  = a.front();
+  auto v4  = a.back();
+  return v1 + v2 + v3 + v4;
+}
+
+static_assert( test02() == (55 + 66 + 0 + 2) );
diff --git a/libstdc++-v3/testsuite/23_containers/array/requirements/constexpr_iter.cc b/libstdc++-v3/testsuite/23_containers/array/requirements/constexpr_iter.cc
index 208078c3b5a..7ede36073e1 100644
--- a/libstdc++-v3/testsuite/23_containers/array/requirements/constexpr_iter.cc
+++ b/libstdc++-v3/testsuite/23_containers/array/requirements/constexpr_iter.cc
@@ -1,5 +1,5 @@
-// { dg-options "-std=gnu++2a" }
-// { dg-do compile { target c++2a } }
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
 //
 // Copyright (C) 2019 Free Software Foundation, Inc.
 //
@@ -20,6 +20,15 @@
 
 #include <array>
 
+#ifndef __cpp_lib_array_constexpr
+# error "Feature test macro for array constexpr is missing in <array>"
+#elif __cpp_lib_array_constexpr < 201803L
+# error "Feature test macro for array constexpr has wrong value in <array>"
+#endif
+
+// This test is compiled as C++17 because array::iterator is just a pointer,
+// so always meets the C++20 constexpr iterator requirements, even in C++17.
+
 constexpr int
 test()
 {
diff --git a/libstdc++-v3/testsuite/23_containers/deque/erasure.cc b/libstdc++-v3/testsuite/23_containers/deque/erasure.cc
index 39ea6deecc2..da5330b300a 100644
--- a/libstdc++-v3/testsuite/23_containers/deque/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/deque/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <deque>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <deque>"
 #endif
 
 void
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc b/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc
index 724a720f654..50b35719471 100644
--- a/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <forward_list>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <forward_list>"
 #endif
 
 void
diff --git a/libstdc++-v3/testsuite/23_containers/list/erasure.cc b/libstdc++-v3/testsuite/23_containers/list/erasure.cc
index a9927b484e1..ff849808fd9 100644
--- a/libstdc++-v3/testsuite/23_containers/list/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/list/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <list>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <list>"
 #endif
 
 void
diff --git a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
index e1aee9afcbe..ad117bac4cd 100644
--- a/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/map/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mtype,
 	       mtype&&, const typename mtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::map<int, int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<std::pair<const int, int>>> amtype;
+
+static_assert( std::is_nothrow_move_constructible<amtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::map<int, int, not_noexcept_less> emtype;
 
+static_assert( !std::is_nothrow_move_constructible<emtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emtype, emtype&&,
 	       const typename emtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/map/erasure.cc b/libstdc++-v3/testsuite/23_containers/map/erasure.cc
index d8a57160865..8e5955ffbd1 100644
--- a/libstdc++-v3/testsuite/23_containers/map/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/map/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <map>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <map>"
 #endif
 
 auto is_odd_pair = [](const std::pair<const int, std::string>& p)
diff --git a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
index 5ec9fa2690e..739d7ae0954 100644
--- a/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multimap/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mmtype,
 	       mmtype&&, const typename mmtype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multimap<int, int, std::less<int>,
+		      not_noexcept_move_constructor_alloc<std::pair<const int, int>>> ammtype;
+
+static_assert( std::is_nothrow_move_constructible<ammtype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multimap<int, int, not_noexcept_less> emmtype;
 
+static_assert( !std::is_nothrow_move_constructible<emmtype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emmtype, emmtype&&,
 	       const typename emmtype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
index 57be40b709a..01039d245ba 100644
--- a/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/multiset/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<mstype,
 	       mstype&&, const typename mstype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::multiset<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> amstype;
+
+static_assert( std::is_nothrow_move_constructible<amstype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::multiset<int, not_noexcept_less> emstype;
 
+static_assert( !std::is_nothrow_move_constructible<emstype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<emstype, emstype&&,
 	       const typename emstype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
index 7c3c9af0b6e..de6d7d4c6f1 100644
--- a/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
+++ b/libstdc++-v3/testsuite/23_containers/set/cons/noexcept_move_construct.cc
@@ -29,6 +29,33 @@ static_assert( std::is_nothrow_constructible<stype,
 	       stype&&, const typename stype::allocator_type&>::value,
 	       "noexcept move constructor with allocator" );
 
+template<typename Type>
+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>
+  {
+  public:
+    not_noexcept_move_constructor_alloc() noexcept { }
+
+    not_noexcept_move_constructor_alloc(
+	const not_noexcept_move_constructor_alloc& x) noexcept
+    : std::allocator<Type>(x)
+    { }
+
+    not_noexcept_move_constructor_alloc(
+	not_noexcept_move_constructor_alloc&& x) noexcept(false)
+    : std::allocator<Type>(std::move(x))
+    { }
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };
+  };
+
+typedef std::set<int, std::less<int>,
+		 not_noexcept_move_constructor_alloc<int>> astype;
+
+static_assert( std::is_nothrow_move_constructible<astype>::value,
+	       "noexcept move constructor with not noexcept alloc" );
+
 struct not_noexcept_less
 {
   not_noexcept_less() = default;
@@ -42,6 +69,9 @@ struct not_noexcept_less
 
 typedef std::set<int, not_noexcept_less> estype;
 
+static_assert( !std::is_nothrow_move_constructible<estype>::value,
+	       "not noexcept move constructor with not noexcept less" );
+
 static_assert( !std::is_nothrow_constructible<estype, estype&&,
 	       const typename estype::allocator_type&>::value,
-	       "except move constructor with allocator" );
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/set/erasure.cc b/libstdc++-v3/testsuite/23_containers/set/erasure.cc
index 2412d69f75c..494d6315ea7 100644
--- a/libstdc++-v3/testsuite/23_containers/set/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/set/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <set>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <set>"
 #endif
 
 auto is_odd = [](const int i) { return i % 2 != 0; };
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
new file mode 100644
index 00000000000..473a5f1ce47
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/allocator/default_init.cc
@@ -0,0 +1,69 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+// { dg-xfail-run-if "PR c++/65816" { *-*-* } }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<std::pair<const T, T>> alloc_type;
+  typedef std::unordered_map<T, T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..f859ec939d0
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
+			not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..b6b5b473553
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_map<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_map<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_map<int, int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc
index 35190a0d19e..1bfc53201dd 100644
--- a/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <unordered_map>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <unordered_map>"
 #endif
 
 auto is_odd_pair = [](const std::pair<const int, std::string>& p)
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
new file mode 100644
index 00000000000..0a5ef1113d9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/move_assign.cc
@@ -0,0 +1,81 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <utility>
+#include <unordered_map>
+#include <vector>
+
+#include <testsuite_hooks.h>
+#include <testsuite_counter_type.h>
+#include <testsuite_allocator.h>
+
+void test01()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+
+  std::vector<pair<int, counter_type>> insts { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  typedef unordered_map<int, counter_type> Map;
+  Map m;
+
+  counter_type::reset();
+
+  m.insert(make_move_iterator(insts.begin()), make_move_iterator(insts.end()));
+
+  VERIFY( m.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+void test02()
+{
+  using namespace std;
+  using __gnu_test::counter_type;
+  using __gnu_test::propagating_allocator;
+
+  typedef propagating_allocator<pair<const int, counter_type>, false> Alloc;
+  typedef unordered_map<int, counter_type,
+			hash<int>, equal_to<int>,
+			Alloc> Map;
+
+  Alloc a1(1);
+  Map m1(3, a1);
+  m1 = { { 0, 0 }, { 1, 1 }, { 2, 2 } };
+  Alloc a2(2);
+  Map m2(3, a2);
+  m2 = { { 3, 0 }, { 4, 1 }, { 5, 2 } };
+
+  counter_type::reset();
+
+  m2 = move(m1);
+
+  VERIFY( m1.empty() );
+  VERIFY( m2.size() == 3 );
+  VERIFY( counter_type::default_count == 0 );
+  VERIFY( counter_type::copy_count == 0 );
+  VERIFY( counter_type::move_count == 3 );
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..98e2b017ca9
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,
+				       not_noexcept_dflt_cons_alloc<std::pair<const int, int>>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..e51ad5065a8
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_map>
+
+using type1 = std::unordered_multimap<int, int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multimap<int, int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multimap<int, int, std::hash<int>,
+				       not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..8511cb95421
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,
+				      not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..1ccb8b0cf41
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_multiset<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_multiset<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_multiset<int, std::hash<int>,
+				      not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
new file mode 100644
index 00000000000..37110dd6eb0
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/default_init.cc
@@ -0,0 +1,69 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-options "-O0" }
+// { dg-xfail-run-if "PR c++/65816" { *-*-* } }
+
+#include <unordered_set>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+#include <ext/aligned_buffer.h>
+
+using T = int;
+
+using __gnu_test::default_init_allocator;
+
+void test01()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type;
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+void test02()
+{
+  typedef default_init_allocator<T> alloc_type;
+  typedef std::unordered_set<T, std::hash<T>, std::equal_to<T>,
+			     alloc_type> test_type;
+
+  __gnu_cxx::__aligned_buffer<test_type> buf;
+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));
+
+  test_type *tmp = ::new(buf._M_addr()) test_type();
+
+  VERIFY( tmp->get_allocator().state == 0 );
+
+  tmp->~test_type();
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
new file mode 100644
index 00000000000..b209f7627f5
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/99985.cc
@@ -0,0 +1,47 @@
+// Copyright (C) 2021 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+#include <testsuite_allocator.h>
+
+template<typename Alloc, typename T = typename Alloc::value_type>
+  using Set = std::unordered_set<T, std::hash<T>, std::equal_to<T>, Alloc>;
+
+// PR libstdc++/99985 - invalid constexpr function in C++11 mode
+
+void
+test01()
+{
+  using A = std::allocator<int>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( noexcept( Set<A>(std::move(s), a) ), "non-throwing" );
+}
+
+void
+test02()
+{
+  using A = __gnu_test::uneq_allocator<long>;
+  A a;
+  Set<A> s;
+  static_assert( noexcept( Set<A>(std::move(s)) ), "non-throwing" );
+  static_assert( ! noexcept( Set<A>(std::move(s), a) ), "throwing" );
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
new file mode 100644
index 00000000000..44db4aec6cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_default_construct.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert(std::is_nothrow_default_constructible<type1>::value,
+	      "noexcept default constructible");
+
+struct not_noexcept_dflt_cons_hash
+{
+  not_noexcept_dflt_cons_hash() /* noexcept */;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_dflt_cons_hash>;
+
+static_assert( !std::is_nothrow_default_constructible<type2>::value,
+	       "not noexcept default constructible");
+
+struct not_noexcept_dflt_cons_equal_to
+{
+  not_noexcept_dflt_cons_equal_to() /* noexcept */;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_dflt_cons_equal_to>;
+
+static_assert( !std::is_nothrow_default_constructible<type3>::value,
+	       "not noexcept default constructible");
+
+template<typename _Tp>
+  struct not_noexcept_dflt_cons_alloc : std::allocator<_Tp>
+  {
+    not_noexcept_dflt_cons_alloc() /* noexcept */;
+
+    template<typename _Tp1>
+      struct rebind
+      { typedef not_noexcept_dflt_cons_alloc<_Tp1> other; };
+  };
+
+using type4 = std::unordered_set<int, std::hash<int>, std::equal_to<int>,
+				 not_noexcept_dflt_cons_alloc<int>>;
+
+static_assert(!std::is_nothrow_default_constructible<type4>::value,
+	      "not noexcept default constructible");
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
new file mode 100644
index 00000000000..65df57613ae
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/cons/noexcept_move_construct.cc
@@ -0,0 +1,65 @@
+// { dg-do compile { target c++11 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <unordered_set>
+
+using type1 = std::unordered_set<int>;
+
+static_assert( std::is_nothrow_move_constructible<type1>::value,
+	       "noexcept move constructor" );
+static_assert( std::is_nothrow_constructible<type1,
+	       type1&&, const typename type1::allocator_type&>::value,
+	       "noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_hash
+{
+  not_noexcept_copy_cons_hash() noexcept;
+  not_noexcept_copy_cons_hash(const not_noexcept_copy_cons_hash&) /* noexcept */;
+  not_noexcept_copy_cons_hash(not_noexcept_copy_cons_hash&&) noexcept;
+
+  std::size_t
+  operator()(int) const noexcept;
+};
+
+using type2 = std::unordered_set<int, not_noexcept_copy_cons_hash>;
+
+static_assert( !std::is_nothrow_move_constructible<type2>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type2, type2&&,
+	       const typename type2::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
+
+struct not_noexcept_copy_cons_equal_to
+{
+  not_noexcept_copy_cons_equal_to() noexcept;
+  not_noexcept_copy_cons_equal_to(const not_noexcept_copy_cons_equal_to&) /* noexcept */;
+  not_noexcept_copy_cons_equal_to(not_noexcept_copy_cons_equal_to&&) noexcept;
+
+  bool
+  operator()(int, int) const noexcept;
+};
+
+using type3 = std::unordered_set<int, std::hash<int>,
+				  not_noexcept_copy_cons_equal_to>;
+
+static_assert( !std::is_nothrow_move_constructible<type3>::value,
+	       "not noexcept move constructor" );
+static_assert( !std::is_nothrow_constructible<type3, type3&&,
+	       const typename type3::allocator_type&>::value,
+	       "not noexcept move constructor with allocator" );
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc
index 5ffabf538bd..97aa24c4834 100644
--- a/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <unordered_set>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <unordered_set>"
 #endif
 
 void
diff --git a/libstdc++-v3/testsuite/23_containers/vector/erasure.cc b/libstdc++-v3/testsuite/23_containers/vector/erasure.cc
index 0a23c3f0d12..ec479053cf1 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/erasure.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/erasure.cc
@@ -22,9 +22,9 @@
 #include <testsuite_hooks.h>
 
 #ifndef __cpp_lib_erase_if
-# error "Feature-test macro for erase_if missing"
-#elif __cpp_lib_erase_if < 201811
-# error "Feature-test macro for erase_if has wrong value"
+# error "Feature-test macro for erase_if missing in <vector>"
+#elif __cpp_lib_erase_if < 202002
+# error "Feature-test macro for erase_if has wrong value in <vector>"
 #endif
 
 void
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-2.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-2.cc
new file mode 100644
index 00000000000..3e74f89bc41
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-2.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do preprocess { target c++17 } }
+
+#include <numeric>
+
+#ifndef __cpp_lib_parallel_algorithm
+# error "Feature-test macro for parallel algorithms missing in <numeric>"
+#elif __cpp_lib_parallel_algorithm != 201603L
+# error "Feature-test macro for parallel algorithms has wrong value in <numeric>"
+#endif
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-3.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-3.cc
new file mode 100644
index 00000000000..4d75a186211
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-3.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do preprocess { target c++17 } }
+// { dg-require-effective-target tbb-backend }
+
+#include <execution>
+
+#ifndef __cpp_lib_execution
+# error "Feature-test macro for execution policies is missing in <execution>"
+#elif __cpp_lib_execution != 201902L
+# error "Feature-test macro for parallel algorithms has wrong value in <execution>"
+#endif
+
+// Neither SD-6 nor C++20 requires this macro to be defined in <execution>.
+#ifndef __cpp_lib_parallel_algorithm
+# error "Feature-test macro for parallel algorithms missing in <execution>"
+#elif __cpp_lib_parallel_algorithm != 201603L
+# error "Feature-test macro for parallel algorithms has wrong value in <execution>"
+#endif
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-4.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-4.cc
new file mode 100644
index 00000000000..e7bbf920499
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-4.cc
@@ -0,0 +1,33 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do preprocess { target c++17 } }
+
+#include <version>
+
+#ifndef __cpp_lib_parallel_algorithm
+# error "Feature-test macro for parallel algorithms missing in <version>"
+#elif __cpp_lib_parallel_algorithm != 201603L
+# error "Feature-test macro for parallel algorithms has wrong value in <version>"
+#endif
+
+#ifndef __cpp_lib_execution
+# error "Feature-test macro for execution policies is missing in <version>"
+#elif __cpp_lib_execution != 201902L
+# error "Feature-test macro for parallel algorithms has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-5.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-5.cc
new file mode 100644
index 00000000000..2d991958e75
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test-5.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do preprocess { target c++17 } }
+
+#include <memory>
+
+// Neither SD-6 nor C++20 requires this macro to be defined in <memory>.
+#ifndef __cpp_lib_parallel_algorithm
+# error "Feature-test macro for parallel algorithms missing in <memory>"
+#elif __cpp_lib_parallel_algorithm != 201603L
+# error "Feature-test macro for parallel algorithms has wrong value in <memory>"
+#endif
diff --git a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test.cc b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test.cc
index d9d558b9dea..c6408f523e0 100644
--- a/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/pstl/feature_test.cc
@@ -21,31 +21,7 @@
 
 #include <algorithm>
 #ifndef __cpp_lib_parallel_algorithm
-# error "Feature-test macro for parallel algorithms missing"
+# error "Feature-test macro for parallel algorithms missing in <algorithm>"
 #elif __cpp_lib_parallel_algorithm != 201603L
 # error "Feature-test macro for parallel algorithms has wrong value in <algorithm>"
 #endif
-
-#include <numeric>
-#if __cpp_lib_parallel_algorithm != 201603L
-# error "Feature-test macro for parallel algorithms has wrong value in <numeric>"
-#endif
-
-#include <version>
-#if __cpp_lib_parallel_algorithm != 201603L
-# error "Feature-test macro for parallel algorithms has wrong value in <version>"
-#endif
-
-// The N4810 draft does not require the macro to be defined in <execution>.
-#include <memory>
-#if __cpp_lib_parallel_algorithm != 201603L
-# error "Feature-test macro for parallel algorithms has wrong value in <memory>"
-#endif
-
-// The N4810 draft does not require the macro to be defined in <execution>.
-// Include this last, because it will trigger the inclusion of TBB headers,
-// which then include <memory>, so we need to have already checked <memory>.
-#include <execution>
-#if __cpp_lib_parallel_algorithm != 201603L
-# error "Feature-test macro for parallel algorithms has wrong value in <execution>"
-#endif
diff --git a/libstdc++-v3/testsuite/25_algorithms/sample/3.cc b/libstdc++-v3/testsuite/25_algorithms/sample/3.cc
new file mode 100644
index 00000000000..e89c40e27ee
--- /dev/null
+++ b/libstdc++-v3/testsuite/25_algorithms/sample/3.cc
@@ -0,0 +1,50 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+// { dg-require-cstdint "" }
+
+#include <algorithm>
+#include <random>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+std::mt19937 rng;
+
+using std::sample;
+using __gnu_test::test_container;
+using __gnu_test::output_iterator_wrapper;
+using __gnu_test::forward_iterator_wrapper;
+
+void
+test01()
+{
+  const int in = 0;
+  test_container<const int, forward_iterator_wrapper> pop(&in, &in);
+  int out;
+  test_container<int, output_iterator_wrapper> samp(&out, &out + 1);
+
+  auto it = sample(pop.begin(), pop.end(), samp.begin(), 1, rng);
+  VERIFY( it.ptr == &out );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/bit/header-2.cc b/libstdc++-v3/testsuite/26_numerics/bit/header-2.cc
new file mode 100644
index 00000000000..f67a1cdcac1
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/bit/header-2.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_bitops
+# error "Feature test macro for bitops is missing in <version>"
+#elif __cpp_lib_bitops < 201907L
+# error "Feature test macro for bitops has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/bit/header.cc b/libstdc++-v3/testsuite/26_numerics/bit/header.cc
new file mode 100644
index 00000000000..824ee002e96
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/bit/header.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do compile { target c++2a } }
+
+#include <bit>
+
+#ifndef __cpp_lib_bitops
+# error "Feature test macro for bitops is missing in <bit>"
+#elif __cpp_lib_bitops < 201907L
+# error "Feature test macro for bitops has wrong value in <bit>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/complex/1.cc b/libstdc++-v3/testsuite/26_numerics/complex/1.cc
new file mode 100644
index 00000000000..e3e6c22c5f4
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/complex/1.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <complex>
+
+#ifndef __cpp_lib_constexpr_complex
+# error "Feature test macro for constexpr complex is missing in <complex>"
+#elif __cpp_lib_constexpr_complex < 201711L
+# error "Feature test macro for constexpr complex has wrong value in <complex>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/complex/2.cc b/libstdc++-v3/testsuite/26_numerics/complex/2.cc
new file mode 100644
index 00000000000..e84e92c62ae
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/complex/2.cc
@@ -0,0 +1,27 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++2a" }
+// { dg-do preprocess { target c++2a } }
+
+#include <version>
+
+#ifndef __cpp_lib_constexpr_complex
+# error "Feature test macro for constexpr complex is missing in <version>"
+#elif __cpp_lib_constexpr_complex < 201711L
+# error "Feature test macro for constexpr complex has wrong value in <version>"
+#endif
diff --git a/libstdc++-v3/testsuite/26_numerics/gcd/92978.cc b/libstdc++-v3/testsuite/26_numerics/gcd/92978.cc
new file mode 100644
index 00000000000..ddf7237df4c
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/gcd/92978.cc
@@ -0,0 +1,41 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <numeric>
+#include <limits.h>
+
+void
+test01()
+{
+  // PR libstdc++/92978
+  static_assert( std::gcd(-120, 10U) == 10 );
+  static_assert( std::gcd(120U, -10) == 10 );
+}
+
+void
+test02()
+{
+  // |INT_MIN| should not be undefined, as long as it fits in the result type.
+  static_assert( std::gcd(INT_MIN, 0LL) == 1LL+INT_MAX );
+  static_assert( std::gcd(0LL, INT_MIN) == 1LL+INT_MAX );
+  static_assert( std::gcd(INT_MIN, 0LL + INT_MIN) == 1LL + INT_MAX );
+  static_assert( std::gcd(INT_MIN, 1LL + INT_MAX) == 1LL + INT_MAX );
+  static_assert( std::gcd(SHRT_MIN, 1U + SHRT_MAX) == 1U + SHRT_MAX );
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc b/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
index 05e21431313..9ca7b5306c2 100644
--- a/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
@@ -46,9 +46,9 @@ test01()
   std::gcd<const int&, const int&>(0.1, 0.1);   // { dg-error "from here" }
 }
 
-// { dg-error "integers" "" { target *-*-* } 133 }
-// { dg-error "integers" "" { target *-*-* } 134 }
-// { dg-error "not bools" "" { target *-*-* } 135 }
-// { dg-error "not bools" "" { target *-*-* } 137 }
+// { dg-error "must be integers" "" { target *-*-* } 134 }
+// { dg-error "must be integers" "" { target *-*-* } 135 }
+// { dg-error "must not be bool" "" { target *-*-* } 136 }
+// { dg-error "must not be bool" "" { target *-*-* } 137 }
 // { dg-prune-output "deleted function" }
-// { dg-prune-output "invalid operands" }
+// { dg-prune-output "incomplete type .*make_unsigned" }
diff --git a/libstdc++-v3/testsuite/26_numerics/lcm/92978.cc b/libstdc++-v3/testsuite/26_numerics/lcm/92978.cc
new file mode 100644
index 00000000000..f178e1e5a36
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lcm/92978.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <numeric>
+
+void
+test01()
+{
+  // PR libstdc++/92978
+  static_assert( std::lcm(-42, 21U) == 42U );
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc b/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
index 3a0f5bbe3eb..33327232af0 100644
--- a/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
@@ -46,9 +46,9 @@ test01()
   std::lcm<const int&, const int&>(0.1, 0.1);   // { dg-error "from here" }
 }
 
-// { dg-error "integers" "" { target *-*-* } 147 }
-// { dg-error "integers" "" { target *-*-* } 148 }
-// { dg-error "not bools" "" { target *-*-* } 149 }
-// { dg-error "not bools" "" { target *-*-* } 151 }
+// { dg-error "must be integers" "" { target *-*-* } 148 }
+// { dg-error "must be integers" "" { target *-*-* } 149 }
+// { dg-error "must not be bool" "" { target *-*-* } 150 }
+// { dg-error "must not be bool" "" { target *-*-* } 151 }
 // { dg-prune-output "deleted function" }
-// { dg-prune-output "invalid operands" }
+// { dg-prune-output "incomplete type .*make_unsigned" }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
index 3f31375f51b..5d6e62c421a 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
@@ -32,9 +32,12 @@
 #if _GLIBCXX_HAVE_UTIME_H
 # include <utime.h>
 #endif
+#include <stdio.h>
 
 using time_type = std::filesystem::file_time_type;
 
+namespace chrono = std::chrono;
+
 void
 test01()
 {
@@ -67,10 +70,15 @@ test01()
 
   auto end_of_time = time_type::duration::max();
   auto last_second
-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();
+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();
   if (last_second > std::numeric_limits<std::time_t>::max())
-    return; // can't test overflow
+  {
+    puts("Range of time_t is smaller than range of chrono::file_clock, "
+	 "can't test for overflow on this target.");
+    return;
+  }
 
+  // Set mtime to a date past the maximum possible file_time_type:
 #if _GLIBCXX_USE_UTIMENSAT
   struct ::timespec ts[2];
   ts[0].tv_sec = 0;
@@ -84,25 +92,34 @@ test01()
   times.actime = std::numeric_limits<std::time_t>::max() - 1;
   VERIFY( !::utime(p.string().c_str(), &times) );
 #else
+  puts("No utimensat or utime, giving up.");
   return;
 #endif
 
+  // Try to read back the impossibly-large mtime:
   mtime = last_write_time(p, ec);
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
-  VERIFY( mtime == time_type::min() );
+  // Some filesystems (e.g. XFS) silently truncate distant times to
+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when
+  // reading it back:
+  if (ec)
+  {
+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
+    VERIFY( mtime == time_type::min() );
+  }
+  else
+    puts("No overflow error, filesystem may not support 64-bit time_t.");
 
 #if __cpp_exceptions
-  caught = false;
+  // Once more, with exceptions:
   try {
-    mtime = last_write_time(p);
-  } catch (std::system_error const& e) {
-    caught = true;
-    ec = e.code();
+    auto mtime2 = last_write_time(p);
+    // If it didn't throw, expect to have read back the same value:
+    VERIFY( mtime2 == mtime );
+  } catch (std::filesystem::filesystem_error const& e) {
+    // If it did throw, expect the error_code to be the same:
+    VERIFY( e.code() == ec );
+    VERIFY( e.path1() == p );
   }
-  VERIFY( caught );
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
 #endif
 }
 
@@ -111,7 +128,7 @@ bool approx_equal(time_type file_time, time_type expected)
   auto delta = expected - file_time;
   if (delta < delta.zero())
     delta = -delta;
-  return delta < std::chrono::seconds(1);
+  return delta < chrono::seconds(1);
 }
 
 void
@@ -124,20 +141,20 @@ test02()
   std::error_code ec;
   time_type time;
 
-  time = last_write_time(f.path);
   ec = bad_ec;
+  time = last_write_time(f.path);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  time += chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
@@ -146,6 +163,28 @@ test02()
       < std::numeric_limits<std::int64_t>::max())
     return; // file clock's epoch is out of range for 32-bit time_t
 
+  using sys_time_32b
+    = chrono::time_point<chrono::system_clock, chrono::duration<std::int32_t>>;
+  auto duration_until_2038 = sys_time_32b::max() - sys_time_32b::clock::now();
+  auto file_time_2038 = time_type::clock::now() + duration_until_2038;
+
+  ec = bad_ec;
+  time = file_time_2038 - chrono::seconds(1);
+  // Assume all filesystems can store times that fit in 32-bit time_t
+  // (i.e. up to Jan 19 2038)
+  last_write_time(f.path, time, ec);
+  VERIFY( !ec );
+  VERIFY( approx_equal(last_write_time(f.path), time) );
+
+  // Check whether the filesystem supports times larger than 32-bit time_t:
+  time += chrono::seconds(60);
+  last_write_time(f.path, time, ec);
+  if (ec || !approx_equal(last_write_time(f.path), time))
+  {
+    puts("Filesystem seems to truncate times past Jan 19 2038, giving up.");
+    return; // Tests below will fail on this filesystem
+  }
+
   ec = bad_ec;
   // The file clock's epoch:
   time = time_type();
@@ -155,14 +194,14 @@ test02()
 
   ec = bad_ec;
   // A time after the epoch
-  time += std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  time += chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
   // A time before than the epoch
-  time -= std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  time -= chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/append/source.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/append/source.cc
index db80087ba6c..9249cf682ef 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/append/source.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/append/source.cc
@@ -161,6 +161,15 @@ test06()
   test(p2, s.c_str());
 }
 
+void
+test07()
+{
+  path p, p0;
+  std::string_view s;
+  p /= s; // PR libstdc++/97167
+  compare_paths(p, p0);
+}
+
 int
 main()
 {
@@ -170,4 +179,5 @@ main()
   test04();
   test05();
   test06();
+  test07();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc
new file mode 100644
index 00000000000..9f4c9c0aa08
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc
@@ -0,0 +1,111 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target { *-*-*mingw* || *-*-cygwin } } }
+// { dg-require-effective-target c++17 }
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  using std::filesystem::path;
+  path p;
+
+  // PR libstdc++/94063
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  p = L"C";
+  p += path(L":");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+  p += path(L"\\");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"\\" );
+
+  p = L"C";
+  p += L':';
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+  p += L'\\';
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"\\" );
+
+  p = L"C:";
+  p += path(L"/foo");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C:";
+  p += L"/foo";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C";
+  p += path(L":/foo");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C";
+  p += L":/foo";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+#elif defined __CYGWIN__
+  p = "/";
+  p += path("/x");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+
+  p = "/";
+  p += "/x";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+
+  p = "/";
+  p += path("/");
+  VERIFY( !p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+
+  p = "/";
+  p += "/";
+  VERIFY( !p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+#endif
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/94242.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/94242.cc
new file mode 100644
index 00000000000..c917daed94e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/94242.cc
@@ -0,0 +1,52 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
+
+#include <filesystem>
+#include <testsuite_allocator.h>
+
+using std::filesystem::path;
+using __gnu_test::SimpleAllocator;
+
+void
+test01()
+{
+  path p = "//foo//bar//.";
+  using C = path::value_type;
+  auto g = p.generic_string<C, std::char_traits<C>, SimpleAllocator<C>>();
+  VERIFY( g == path("/foo/bar/.").c_str() );
+}
+
+void
+test02()
+{
+  path p = "//foo//bar//.";
+  using C = char16_t;
+  auto g = p.generic_string<C, std::char_traits<C>, SimpleAllocator<C>>();
+  VERIFY( g == u"/foo/bar/." );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
index 5a0c24c25c3..8554e9f8f63 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
@@ -1,7 +1,7 @@
 // { dg-options "-std=gnu++17" }
 // { dg-do run { target c++17 } }
 
-// Copyright (C) 2017-2019 Free Software Foundation, Inc.
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -21,6 +21,7 @@
 // C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
 
 #include <filesystem>
+#include <testsuite_fs.h>
 #include <testsuite_hooks.h>
 
 using std::filesystem::path;
@@ -34,11 +35,15 @@ test01()
 #ifdef __CYGWIN__
   VERIFY( path("//a").generic_string() == "//a" );
   VERIFY( path("//a/").generic_string() == "//a/" );
+  VERIFY( path("//a//").generic_string() == "//a/" );
   VERIFY( path("//a/b").generic_string() == "//a/b" );
+  VERIFY( path("//a//b").generic_string() == "//a/b" );
 #else
   VERIFY( path("//a").generic_string() == "/a" );
   VERIFY( path("//a/").generic_string() == "/a/" );
+  VERIFY( path("//a//").generic_string() == "/a/" );
   VERIFY( path("//a/b").generic_string() == "/a/b" );
+  VERIFY( path("//a//b").generic_string() == "/a/b" );
 #endif
   VERIFY( path("/a//b").generic_string() == "/a/b" );
   VERIFY( path("/a//b/").generic_string() == "/a/b/" );
@@ -46,8 +51,47 @@ test01()
   VERIFY( path("/a//b//.").generic_string() == "/a/b/." );
 }
 
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_string() == "C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_string() == "C:/foo/bar" );
+  }
+}
+
+void
+test03()
+{
+  for (path p : __gnu_test::test_paths)
+  {
+    // A path constructed from the generic format string should compare equal
+    // to the original, because they represent the same path.
+    VERIFY( path(p.generic_string()) == p );
+    VERIFY( path(p.generic_wstring()) == p );
+    VERIFY( path(p.generic_u8string()) == p );
+    VERIFY( path(p.generic_u16string()) == p );
+    VERIFY( path(p.generic_u32string()) == p );
+  }
+
+  for (path p : { "a///b//c", "///a//b//c", "a:b//c", "a://b///c" })
+  {
+    // A path constructed from the generic format string should compare equal
+    // to the original, because they represent the same path.
+    VERIFY( path(p.generic_string()) == p );
+    VERIFY( path(p.generic_wstring()) == p );
+    VERIFY( path(p.generic_u8string()) == p );
+    VERIFY( path(p.generic_u16string()) == p );
+    VERIFY( path(p.generic_u32string()) == p );
+  }
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc
new file mode 100644
index 00000000000..52afdb4497b
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path().generic_u32string() == U"" );
+  VERIFY( path("/").generic_u32string() == U"/" );
+  VERIFY( path("////").generic_u32string() == U"/" );
+#ifdef __CYGWIN__
+  VERIFY( path("//a").generic_u32string() == U"//a" );
+  VERIFY( path("//a/").generic_u32string() == U"//a/" );
+  VERIFY( path("//a/b").generic_u32string() == U"//a/b" );
+#else
+  VERIFY( path("//a").generic_u32string() == U"/a" );
+  VERIFY( path("//a/").generic_u32string() == U"/a/" );
+  VERIFY( path("//a/b").generic_u32string() == U"/a/b" );
+#endif
+  VERIFY( path("/a//b").generic_u32string() == U"/a/b" );
+  VERIFY( path("/a//b/").generic_u32string() == U"/a/b/" );
+  VERIFY( path("/a//b//").generic_u32string() == U"/a/b/" );
+  VERIFY( path("/a//b//.").generic_u32string() == U"/a/b/." );
+}
+
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_u32string() == U"C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_u32string() == U"C:/foo/bar" );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc
new file mode 100644
index 00000000000..7bb2f643043
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path().generic_wstring() == L"" );
+  VERIFY( path("/").generic_wstring() == L"/" );
+  VERIFY( path("////").generic_wstring() == L"/" );
+#ifdef __CYGWIN__
+  VERIFY( path("//a").generic_wstring() == L"//a" );
+  VERIFY( path("//a/").generic_wstring() == L"//a/" );
+  VERIFY( path("//a/b").generic_wstring() == L"//a/b" );
+#else
+  VERIFY( path("//a").generic_wstring() == L"/a" );
+  VERIFY( path("//a/").generic_wstring() == L"/a/" );
+  VERIFY( path("//a/b").generic_wstring() == L"/a/b" );
+#endif
+  VERIFY( path("/a//b").generic_wstring() == L"/a/b" );
+  VERIFY( path("/a//b/").generic_wstring() == L"/a/b/" );
+  VERIFY( path("/a//b//").generic_wstring() == L"/a/b/" );
+  VERIFY( path("/a//b//.").generic_wstring() == L"/a/b/." );
+}
+
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_wstring() == L"C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_wstring() == L"C:/foo/bar" );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/types/1.cc b/libstdc++-v3/testsuite/27_io/types/1.cc
index 640ff737330..19a42360b11 100644
--- a/libstdc++-v3/testsuite/27_io/types/1.cc
+++ b/libstdc++-v3/testsuite/27_io/types/1.cc
@@ -15,6 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// { dg-options "-Wdeprecated" }
 // { dg-do compile { target c++14_down } }
 
 // 27.4.2.1 - Types [lib.ios.types]
@@ -26,6 +27,14 @@
 // Annex D, deprecated.
 void test01()
 {
-  typedef std::ios_base::streampos streampos_type;
-  typedef std::ios_base::streamoff streamoff_type;
+  typedef std::ios_base::streampos streampos_type; // { dg-warning "is deprecated: use 'std::streampos' instead" }
+  typedef std::ios_base::streamoff streamoff_type; // { dg-warning "is deprecated: use 'std::streamoff' instead" }
+}
+
+// Annex D, deprecated.
+void test02()
+{
+  typedef std::ios_base::io_state iostate_type; // { dg-warning "is deprecated: use 'std::iostate' instead" }
+  typedef std::ios_base::open_mode openmode_type; // { dg-warning "is deprecated: use 'std::openmode' instead" }
+  typedef std::ios_base::seek_dir seekdir_type; // { dg-warning "is deprecated: use 'std::seekdir' instead" }
 }
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/94627.cc b/libstdc++-v3/testsuite/28_regex/match_results/94627.cc
new file mode 100644
index 00000000000..dc4883c19a0
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/match_results/94627.cc
@@ -0,0 +1,75 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+struct iterator
+{
+  using value_type = char;
+  using difference_type = std::ptrdiff_t;
+  using reference = char&;
+  using pointer = char*;
+  using iterator_category = std::bidirectional_iterator_tag;
+
+  iterator() : ptr() { }
+  explicit iterator(pointer p) : ptr(p) { }
+
+  iterator& operator++() { if (bang) throw 1; ++ptr; return *this; }
+  iterator operator++(int) { auto copy = *this; ++*this; return copy; }
+  iterator& operator--() { if (bang) throw 1; --ptr; return *this; }
+  iterator operator--(int) { auto copy = *this; --*this; return copy; }
+
+  reference operator*() const noexcept { return *ptr; }
+  pointer operator->() const noexcept { return ptr; }
+
+  bool operator==(iterator rhs) const noexcept { return ptr == rhs.ptr; }
+  bool operator!=(iterator rhs) const noexcept { return ptr != rhs.ptr; }
+
+  static bool bang;
+
+private:
+  pointer ptr;
+};
+
+bool iterator::bang = false;
+
+int main()
+{
+  char str[] = "abc";
+  std::regex r(str);
+  std::match_results<iterator> m;
+  std::regex_match(iterator(str), iterator(str+3), m, r);
+  iterator::bang = true;
+  bool caught = false;
+  try {
+    (void) (m == m);
+  } catch (int) {
+    caught = true;
+  }
+  VERIFY( caught );
+  caught = false;
+
+  try {
+    (void) (m != m);
+  } catch (int) {
+    caught = true;
+  }
+  VERIFY( caught );
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/filesystem_error/cons.cc b/libstdc++-v3/testsuite/experimental/filesystem/filesystem_error/cons.cc
index a08852df1e3..58862ea0c65 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/filesystem_error/cons.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/filesystem_error/cons.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++17 -lstdc++fs" }
+// { dg-options "-lstdc++fs" }
 // { dg-do run { target c++11 } }
 // { dg-require-filesystem-ts "" }
 
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/97731.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/97731.cc
new file mode 100644
index 00000000000..c6a9d5663fe
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/97731.cc
@@ -0,0 +1,49 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <cerrno>
+#include <testsuite_hooks.h>
+
+bool used_custom_readdir = false;
+
+extern "C" void* readdir(void*)
+{
+  used_custom_readdir = true;
+  errno = EIO;
+  return nullptr;
+}
+
+void
+test01()
+{
+  using std::experimental::filesystem::recursive_directory_iterator;
+  std::error_code ec;
+  recursive_directory_iterator it(".", ec);
+  if (used_custom_readdir)
+    VERIFY( ec.value() == EIO );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
index 1bbc37408c3..82061f9e7e9 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
@@ -22,6 +22,7 @@
 // 15.25 Permissions [fs.op.last_write_time]
 
 #include <experimental/filesystem>
+#include <limits>
 #include <testsuite_fs.h>
 #include <testsuite_hooks.h>
 
@@ -31,9 +32,12 @@
 #if _GLIBCXX_HAVE_UTIME_H
 # include <utime.h>
 #endif
+#include <stdio.h>
 
 using time_type = std::experimental::filesystem::file_time_type;
 
+namespace chrono = std::chrono;
+
 void
 test01()
 {
@@ -66,10 +70,15 @@ test01()
 
   auto end_of_time = time_type::duration::max();
   auto last_second
-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();
+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();
   if (last_second > std::numeric_limits<std::time_t>::max())
-    return; // can't test overflow
+  {
+    puts("Range of time_t is smaller than range of chrono::file_clock, "
+	 "can't test for overflow on this target.");
+    return;
+  }
 
+  // Set mtime to a date past the maximum possible file_time_type:
 #if _GLIBCXX_USE_UTIMENSAT
   struct ::timespec ts[2];
   ts[0].tv_sec = 0;
@@ -83,25 +92,34 @@ test01()
   times.actime = std::numeric_limits<std::time_t>::max() - 1;
   VERIFY( !::utime(p.string().c_str(), &times) );
 #else
+  puts("No utimensat or utime, giving up.");
   return;
 #endif
 
+  // Try to read back the impossibly-large mtime:
   mtime = last_write_time(p, ec);
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
-  VERIFY( mtime == time_type::min() );
+  // Some filesystems (e.g. XFS) silently truncate distant times to
+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when
+  // reading it back:
+  if (ec)
+  {
+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
+    VERIFY( mtime == time_type::min() );
+  }
+  else
+    puts("No overflow error, filesystem may not support 64-bit time_t.");
 
 #if __cpp_exceptions
-  caught = false;
+  // Once more, with exceptions:
   try {
-    mtime = last_write_time(p);
-  } catch (std::system_error const& e) {
-    caught = true;
-    ec = e.code();
+    auto mtime2 = last_write_time(p);
+    // If it didn't throw, expect to have read back the same value:
+    VERIFY( mtime2 == mtime );
+  } catch (std::experimental::filesystem::filesystem_error const& e) {
+    // If it did throw, expect the error_code to be the same:
+    VERIFY( e.code() == ec );
+    VERIFY( e.path1() == p );
   }
-  VERIFY( caught );
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
 #endif
 }
 
@@ -110,7 +128,7 @@ bool approx_equal(time_type file_time, time_type expected)
   auto delta = expected - file_time;
   if (delta < delta.zero())
     delta = -delta;
-  return delta < std::chrono::seconds(1);
+  return delta < chrono::seconds(1);
 }
 
 void
@@ -118,31 +136,37 @@ test02()
 {
   // write times
 
+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);
   __gnu_test::scoped_file f;
   std::error_code ec;
   time_type time;
 
+  ec = bad_ec;
   time = last_write_time(f.path);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  ec = bad_ec;
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  ec = bad_ec;
+  time += chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
+  ec = bad_ec;
   time = time_type();
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  ec = bad_ec;
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc
index 2788ebd3082..efaa452a586 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc
@@ -23,27 +23,55 @@
 
 #include <experimental/filesystem>
 #include <testsuite_fs.h>
-#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
 
 using std::experimental::filesystem::path;
 
 void
 test01()
 {
-  for (const path& p : __gnu_test::test_paths)
+  __gnu_test::compare_paths( path("///a//b///").generic_string(), "/a/b/." );
+  __gnu_test::compare_paths( path("///a//b").generic_u16string(), "/a/b" );
+  __gnu_test::compare_paths( path("//a//b").generic_u16string(), "//a/b" );
+}
+
+using __gnu_test::SimpleAllocator;
+
+void
+test02()
+{
+  path p = "//foo//bar//.";
+  using C = char16_t;
+  auto g = p.generic_string<C, std::char_traits<C>, SimpleAllocator<C>>();
+  VERIFY( g == u"//foo/bar/." );
+}
+
+
+void
+test03()
+{
+  for (path p : { "/a///b//c", "///a//b//c", "a:b//c", "a://b///c" })
   {
-    path p2(p), p3;
-    p2.swap(p3);
-    VERIFY( p2 == path() );
-    VERIFY( p3 == p );
-    p2.swap(p3);
-    VERIFY( p2 == p );
-    VERIFY( p3 == path() );
+    // A path constructed from the generic format string should compare equal
+    // to the original, because they represent the same path.
+    VERIFY( path(p.generic_string()) == p );
+    VERIFY( path(p.generic_wstring()) == p );
+    VERIFY( path(p.generic_u8string()) == p );
+    VERIFY( path(p.generic_u16string()) == p );
+    VERIFY( path(p.generic_u32string()) == p );
   }
+
+  // Except when the original consists entirely of a root-directory with
+  // multiple slashes, because path("///").native() is "///" but the
+  // generic format string is "/". In the Filesystem TS path::compare just
+  // compares native strings, so path("///") != path("/").
+  VERIFY( path("///").generic_string() == "/" );
 }
 
 int
 main()
 {
   test01();
+  test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/experimental/net/execution_context/make_service.cc b/libstdc++-v3/testsuite/experimental/net/execution_context/make_service.cc
new file mode 100644
index 00000000000..fe8d385b0f7
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/net/execution_context/make_service.cc
@@ -0,0 +1,40 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+// { dg-require-gthreads "" }
+
+#include <experimental/executor>
+
+namespace net = std::experimental::net;
+
+struct S : net::execution_context::service
+{
+  using key_type = S;
+
+  S(net::execution_context&);
+
+  void shutdown() noexcept override { }
+};
+
+void test01(net::execution_context& c)
+{
+  net::make_service<S>(c);
+}
+
+static_assert(std::is_default_constructible<net::service_already_exists>(),
+	      "LWG 3414. service_already_exists has no usable constructors");
diff --git a/libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc b/libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc
index 5b3087059cf..e9a1915639a 100644
--- a/libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc
+++ b/libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc
@@ -15,7 +15,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do run { target c++14 } }
+// { dg-do run }
+// { dg-options "-pthread"  }
+// { dg-require-effective-target c++14 }
+// { dg-require-effective-target pthread }
+// { dg-require-gthreads "" }
 
 #include <experimental/executor>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/executor/1.cc b/libstdc++-v3/testsuite/experimental/net/executor/1.cc
new file mode 100644
index 00000000000..88e263297ee
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/net/executor/1.cc
@@ -0,0 +1,101 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++14 } }
+// { dg-require-gthreads "" }
+
+#include <experimental/executor>
+#include <testsuite_hooks.h>
+
+namespace net = std::experimental::net;
+
+void
+test01()
+{
+  net::executor e;
+  VERIFY( !e );
+  VERIFY( e == nullptr );
+  VERIFY( nullptr == e );
+  VERIFY( e == e );
+  VERIFY( e == e );
+  net::executor e2;
+  VERIFY( e == e2 );
+  swap(e, e2);
+  VERIFY( e == e2 );
+  e = e2;
+  VERIFY( e == e2 );
+}
+
+void
+test02()
+{
+  struct E
+  {
+    void on_work_started() const noexcept { }
+    void on_work_finished() const noexcept { }
+    net::execution_context& context() const noexcept { return c; }
+    void dispatch(std::function<void()>, std::allocator<void>) const { }
+    void post(std::function<void()>, std::allocator<void>) const { }
+    void defer(std::function<void()>, std::allocator<void>) const { }
+
+    net::execution_context& c;
+
+    bool operator==(const E& rhs) const noexcept
+    { return &c == &rhs.c; }
+  };
+
+  net::execution_context c;
+  E d{c};
+  net::executor e(d);
+  VERIFY( e == e );
+  VERIFY( e != nullptr );
+  VERIFY( nullptr != e );
+
+  VERIFY( &e.context() == &c );
+#if __cpp_rtti
+  VERIFY( e.target_type() == typeid(E) );
+#endif
+  VERIFY( *e.target<E>() == d );
+  VERIFY( *e.target<const E>() == d );
+  VERIFY( *const_cast<const net::executor&>(e).target<E>() == d );
+  VERIFY( *const_cast<const net::executor&>(e).target<const E>() == d );
+
+  net::executor f = e;
+  VERIFY( f == e );
+  e = nullptr;
+  VERIFY( f != e );
+  swap(e, f);
+  VERIFY( f == nullptr );
+  VERIFY( nullptr != e );
+
+  net::executor g(E{c});
+  VERIFY( e == g );
+}
+
+void
+test03()
+{
+  static_assert( ! std::is_default_constructible<net::system_context>::value, "" );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/experimental/net/headers.cc b/libstdc++-v3/testsuite/experimental/net/headers.cc
index 1705d2da59c..959ce0dcb36 100644
--- a/libstdc++-v3/testsuite/experimental/net/headers.cc
+++ b/libstdc++-v3/testsuite/experimental/net/headers.cc
@@ -16,6 +16,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
+// { dg-require-gthreads "" }
 
 #include <experimental/net>
 
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/comparisons.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/comparisons.cc
index 83a8bab88fa..83359ec1e77 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/comparisons.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/comparisons.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/cons.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/cons.cc
index 15774803c00..65f3100887e 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/cons.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/cons.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/creation.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/creation.cc
index 5919845c2f7..1a933b902d5 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/creation.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/creation.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/members.cc b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/members.cc
index 37ca8c81e32..2d71581ac2e 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/address/v4/members.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/address/v4/members.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/resolver/base.cc b/libstdc++-v3/testsuite/experimental/net/internet/resolver/base.cc
index 746557af656..f9bea5f9ccd 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/resolver/base.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/resolver/base.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/lookup.cc b/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/lookup.cc
index 39fb7fd7708..40cb3db3610 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/lookup.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/lookup.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/reverse.cc b/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/reverse.cc
index 34ebe5eba70..831d78c44fe 100644
--- a/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/reverse.cc
+++ b/libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/reverse.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options net_ts }
+// { dg-require-gthreads "" }
 
 #include <experimental/internet>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/timer/waitable/cons.cc b/libstdc++-v3/testsuite/experimental/net/timer/waitable/cons.cc
index d1886e75f06..935df8373cb 100644
--- a/libstdc++-v3/testsuite/experimental/net/timer/waitable/cons.cc
+++ b/libstdc++-v3/testsuite/experimental/net/timer/waitable/cons.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options libatomic }
+// { dg-require-gthreads "" }
 
 #include <experimental/timer>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/timer/waitable/dest.cc b/libstdc++-v3/testsuite/experimental/net/timer/waitable/dest.cc
index cc3b6ee5658..9cc3df90ce2 100644
--- a/libstdc++-v3/testsuite/experimental/net/timer/waitable/dest.cc
+++ b/libstdc++-v3/testsuite/experimental/net/timer/waitable/dest.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options libatomic }
+// { dg-require-gthreads "" }
 
 #include <experimental/timer>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/net/timer/waitable/ops.cc b/libstdc++-v3/testsuite/experimental/net/timer/waitable/ops.cc
index 0f89bec16cd..76aff0abb7e 100644
--- a/libstdc++-v3/testsuite/experimental/net/timer/waitable/ops.cc
+++ b/libstdc++-v3/testsuite/experimental/net/timer/waitable/ops.cc
@@ -17,6 +17,7 @@
 
 // { dg-do run { target c++14 } }
 // { dg-add-options libatomic }
+// { dg-require-gthreads "" }
 
 #include <experimental/timer>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/experimental/numeric/92978.cc b/libstdc++-v3/testsuite/experimental/numeric/92978.cc
new file mode 100644
index 00000000000..e2a4b1adefa
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/numeric/92978.cc
@@ -0,0 +1,48 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/numeric>
+#include <limits.h>
+
+void
+test01()
+{
+  // PR libstdc++/92978
+  static_assert( std::experimental::gcd(-120, 10U) == 10,
+      "mixed signed/unsigned" );
+  static_assert( std::experimental::gcd(120U, -10) == 10,
+      "mixed signed/unsigned" );
+
+  static_assert( std::experimental::lcm(-42, 21U) == 42U );
+}
+
+void
+test02()
+{
+  static_assert( std::experimental::gcd(INT_MIN, 0LL) == 1LL+INT_MAX,
+      "|INT_MIN| should not be undefined as long as it fits in the result" );
+  static_assert( std::experimental::gcd(0LL, INT_MIN) == 1LL+INT_MAX,
+      "|INT_MIN| should not be undefined" );
+  static_assert( std::experimental::gcd(INT_MIN, 0LL + INT_MIN) == 1LL + INT_MAX,
+      "|INT_MIN| should not be undefined" );
+  static_assert( std::experimental::gcd(INT_MIN, 1LL + INT_MAX) == 1LL + INT_MAX,
+      "|INT_MIN| should not be undefined" );
+  static_assert( std::experimental::gcd(SHRT_MIN, 1U + SHRT_MAX) == 1U + SHRT_MAX,
+      "|SHRT_MIN| should not be undefined" );
+}
diff --git a/libstdc++-v3/testsuite/ext/malloc_allocator/89510.cc b/libstdc++-v3/testsuite/ext/malloc_allocator/89510.cc
new file mode 100644
index 00000000000..f2ab25adb74
--- /dev/null
+++ b/libstdc++-v3/testsuite/ext/malloc_allocator/89510.cc
@@ -0,0 +1,149 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <ext/malloc_allocator.h>
+#include <memory>
+#include <type_traits>
+
+using __gnu_cxx::malloc_allocator;
+using AT = std::allocator_traits<malloc_allocator<int>>;
+
+template<typename...> using void_t = void;
+
+template<typename T, typename U, typename = void>
+struct has_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_construct<T, U,
+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_destroy<T, U,
+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_construct<T, U,
+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_destroy<T, U,
+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+struct NoDefault { NoDefault(int); };
+struct NoDest { private: ~NoDest(); };
+
+// Whether true or false, these should not give errors:
+constexpr bool c = has_construct<malloc_allocator<NoDefault>, NoDefault>::value;
+constexpr bool c2 = has_traits_construct<malloc_allocator<int>, NoDefault>::value;
+constexpr bool d = has_destroy<malloc_allocator<NoDest>, NoDest>::value;
+constexpr bool b2 = has_traits_destroy<malloc_allocator<int>, NoDest>::value;
+
+malloc_allocator<int> a;
+
+long* lp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(lp)), "" );
+static_assert( noexcept(a.construct(lp, 1L)), "" );
+static_assert( noexcept(a.construct(lp, 2)), "" );
+static_assert( noexcept(a.construct(lp, 2U)), "" );
+static_assert( noexcept(a.destroy(lp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, lp)), "" );
+static_assert( noexcept(AT::construct(a, lp, 1L)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2U)), "" );
+static_assert( noexcept(AT::destroy(a, lp)), "" );
+
+struct X
+{
+  X() noexcept;
+  X(int) noexcept;
+  ~X() noexcept;
+};
+
+X* xp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(xp)), "" );
+static_assert( noexcept(a.construct(xp, 1)), "" );
+static_assert( noexcept(a.destroy(xp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, xp)), "" );
+static_assert( noexcept(AT::construct(a, xp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, xp)), "" );
+
+struct Y
+{
+  Y() noexcept;
+  Y(int) noexcept(false);
+  ~Y() noexcept;
+};
+
+Y* yp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(yp)), "" );
+static_assert( ! noexcept(a.construct(yp, 1)), "" );
+static_assert( noexcept(a.destroy(yp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, yp)), "" );
+static_assert( ! noexcept(AT::construct(a, yp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, yp)), "" );
+
+struct Z
+{
+  Z() noexcept;
+  Z(int) noexcept;
+  ~Z() noexcept(false);
+};
+
+Z* zp;
+// These construct calls should be noexcept, but they are false because
+// they use is_nothrow_constructible which depends on is_nothrow_destructible.
+#if __cplusplus <= 201703L
+static_assert( ! noexcept(a.construct(zp)), "wrong" );
+static_assert( ! noexcept(a.construct(zp, 1)), "wrong" );
+static_assert( ! noexcept(a.destroy(zp)), "" );
+#endif
+static_assert( ! noexcept(AT::construct(a, zp)), "" );
+static_assert( ! noexcept(AT::construct(a, zp, 1)), "" );
+static_assert( ! noexcept(AT::destroy(a, zp)), "" );
diff --git a/libstdc++-v3/testsuite/ext/new_allocator/89510.cc b/libstdc++-v3/testsuite/ext/new_allocator/89510.cc
new file mode 100644
index 00000000000..f684a9c157d
--- /dev/null
+++ b/libstdc++-v3/testsuite/ext/new_allocator/89510.cc
@@ -0,0 +1,149 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <ext/new_allocator.h>
+#include <memory>
+#include <type_traits>
+
+using __gnu_cxx::new_allocator;
+using AT = std::allocator_traits<new_allocator<int>>;
+
+template<typename...> using void_t = void;
+
+template<typename T, typename U, typename = void>
+struct has_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_construct<T, U,
+    void_t<decltype(std::declval<T&>().construct(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_destroy<T, U,
+    void_t<decltype(std::declval<T&>().destroy(std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_construct
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_construct<T, U,
+    void_t<decltype(AT::construct(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+template<typename T, typename U, typename = void>
+struct has_traits_destroy
+: std::false_type
+{ };
+
+template<typename T, typename U>
+struct has_traits_destroy<T, U,
+    void_t<decltype(AT::destroy(std::declval<T&>(), std::declval<U*>()))>>
+: std::true_type
+{ };
+
+struct NoDefault { NoDefault(int); };
+struct NoDest { private: ~NoDest(); };
+
+// Whether true or false, these should not give errors:
+constexpr bool c = has_construct<new_allocator<NoDefault>, NoDefault>::value;
+constexpr bool c2 = has_traits_construct<new_allocator<int>, NoDefault>::value;
+constexpr bool d = has_destroy<new_allocator<NoDest>, NoDest>::value;
+constexpr bool d2 = has_traits_destroy<new_allocator<int>, NoDest>::value;
+
+new_allocator<int> a;
+
+long* lp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(lp)), "" );
+static_assert( noexcept(a.construct(lp, 1L)), "" );
+static_assert( noexcept(a.construct(lp, 2)), "" );
+static_assert( noexcept(a.construct(lp, 2U)), "" );
+static_assert( noexcept(a.destroy(lp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, lp)), "" );
+static_assert( noexcept(AT::construct(a, lp, 1L)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2)), "" );
+static_assert( noexcept(AT::construct(a, lp, 2U)), "" );
+static_assert( noexcept(AT::destroy(a, lp)), "" );
+
+struct X
+{
+  X() noexcept;
+  X(int) noexcept;
+  ~X() noexcept;
+};
+
+X* xp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(xp)), "" );
+static_assert( noexcept(a.construct(xp, 1)), "" );
+static_assert( noexcept(a.destroy(xp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, xp)), "" );
+static_assert( noexcept(AT::construct(a, xp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, xp)), "" );
+
+struct Y
+{
+  Y() noexcept;
+  Y(int) noexcept(false);
+  ~Y() noexcept;
+};
+
+Y* yp;
+#if __cplusplus <= 201703L
+static_assert( noexcept(a.construct(yp)), "" );
+static_assert( ! noexcept(a.construct(yp, 1)), "" );
+static_assert( noexcept(a.destroy(yp)), "" );
+#endif
+static_assert( noexcept(AT::construct(a, yp)), "" );
+static_assert( ! noexcept(AT::construct(a, yp, 1)), "" );
+static_assert( noexcept(AT::destroy(a, yp)), "" );
+
+struct Z
+{
+  Z() noexcept;
+  Z(int) noexcept;
+  ~Z() noexcept(false);
+};
+
+Z* zp;
+// These construct calls should be noexcept, but they are false because
+// they use is_nothrow_constructible which depends on is_nothrow_destructible.
+#if __cplusplus <= 201703L
+static_assert( ! noexcept(a.construct(zp)), "wrong" );
+static_assert( ! noexcept(a.construct(zp, 1)), "wrong" );
+static_assert( ! noexcept(a.destroy(zp)), "" );
+#endif
+static_assert( ! noexcept(AT::construct(a, zp)), "" );
+static_assert( ! noexcept(AT::construct(a, zp, 1)), "" );
+static_assert( ! noexcept(AT::destroy(a, zp)), "" );
diff --git a/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc b/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc
index e16cddc1ea4..03f95d3c265 100644
--- a/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc
+++ b/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc
@@ -26,10 +26,11 @@ void
 test01()
 {
   FILE* f = std::fopen("79820.txt", "w");
-  std::fclose(f);
   errno = 127;
   __gnu_cxx::stdio_filebuf<char> b(f, std::ios::out, BUFSIZ);
   VERIFY(errno == 127); // PR libstdc++/79820
+  b.close();
+  std::fclose(f);
 }
 
 int
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index 1ab896d3deb..a616227ae7b 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -1623,7 +1623,8 @@ proc check_effective_target_tbb-backend { } {
         puts $f "}"
         close $f
 
-        set lines [v3_target_compile $src $exe executable "additional_flags=-std=c++17 additional_flags=-ltbb"]
+        set lines [v3_target_compile $src $exe executable "additional_flags=-std=c++17 additional_flags=-ltbb
+                                                           additional_flags=-DTBB_SUPPRESS_DEPRECATED_MESSAGES=1"]
         file delete $src
 
         if [string match "" $lines] {
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/59161.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/59161.cc
index 215899f3d2e..af629496b47 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/59161.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/59161.cc
@@ -45,8 +45,6 @@ int main()
   std::list<C> l;
   l.push_back(c);
   std::list<C>::iterator liter = l.begin();
-  // Need to ensure the list<C>::iterator::_Node typedef is in the debuginfo:
-  int tmp __attribute__((unused)) = (*liter).ref;
 // { dg-final { regexp-test liter {ref = @0x.*} } }
 
   __gnu_cxx::slist<C> sl;
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/80276.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/80276.cc
index fde652e1635..76f099d5596 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/80276.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/80276.cc
@@ -19,6 +19,9 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// Type printers only recognize the old std::string for now.
+#define _GLIBCXX_USE_CXX11_ABI 0
+
 #include <iostream>
 #include <list>
 #include <memory>
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/91997.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/91997.cc
new file mode 100644
index 00000000000..059ac9aa97f
--- /dev/null
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/91997.cc
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++17 -g -O0 -Wno-unused" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <forward_list>
+#include <list>
+#include <set>
+#include <map>
+#include <string>
+#include <any>
+#include <iostream>
+
+int main()
+{
+  std::list<std::string> list{"a"};
+  std::list<std::string>::iterator lit = list.begin();
+  // { dg-final { note-test lit {"a"} } }
+
+  std::forward_list<std::string> flist{"b"};
+  std::forward_list<std::string>::iterator flit = flist.begin();
+  // { dg-final { note-test flit {"b"} } }
+
+  std::map<int, int> m{ {1, 2} };
+  auto mit = m.begin();
+  // { dg-final { note-test mit {{first = 1, second = 2}} } }
+
+  std::any a = m;
+  // { dg-final { regexp-test a {std::any containing std::(__debug::)?map with 1 element = {\[1\] = 2}} } }
+
+  std::set<int> s{1, 2};
+  auto sit = s.begin();
+  // { dg-final { note-test sit {1} } }
+
+  std::cout << "\n";
+  return 0;			// Mark SPOT
+}
+// { dg-final { gdb-test SPOT } }
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
index 255d3e7cff1..81e0ce7213f 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc
@@ -23,12 +23,30 @@
 
 namespace std
 {
-  template<typename T, typename U>
-    struct tuple
+  template<typename T>
+    struct _Head_base : T
+    { };
+
+  template<typename T>
+    struct _Head_base<T*>
     {
-      T _M_head_impl;
+      T* _M_head_impl;
     };
 
+  template<unsigned long, typename ...> struct _Tuple_impl;
+
+  template<typename T, typename U>
+    struct _Tuple_impl<0, T, U> : _Tuple_impl<1, U>, _Head_base<T>
+    { };
+
+  template<typename U>
+    struct _Tuple_impl<1, U> : _Head_base<U>
+    { };
+
+  template<typename T, typename U>
+    struct tuple : _Tuple_impl<0, T, U>
+    { };
+
   template<typename T> struct default_delete { };
 
   template<typename T, typename D = default_delete<T>>
@@ -36,7 +54,9 @@ namespace std
     {
       unique_ptr(T* p) { _M_t._M_head_impl = p; }
 
-      tuple<T*, D> _M_t;
+      using __tuple_type = tuple<T*, D>;
+
+      __tuple_type _M_t;
     };
 
   // Old representation of std::optional, before GCC 9
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
index 6cb6a5b9555..71a50988924 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
@@ -60,6 +60,21 @@ struct datum
 
 std::unique_ptr<datum> global;
 
+struct Deleter
+{
+  // Deleter is not an empty class:
+  int deleter_member = -1;
+  // But pointer is an empty class:
+  struct pointer
+  {
+    pointer(const void* = nullptr) { }
+    explicit operator bool() const noexcept { return false; }
+    friend bool operator==(pointer, pointer) noexcept { return true; }
+    friend bool operator!=(pointer, pointer) noexcept { return false; }
+  };
+  void operator()(pointer) const noexcept { }
+};
+
 int
 main()
 {
@@ -137,6 +152,11 @@ main()
   std::unique_ptr<data>& rarrptr = arrptr;
 // { dg-final { regexp-test rarrptr {std::unique_ptr.datum \[\]. = {get\(\) = 0x.*}} } }
 
+  std::unique_ptr<int, Deleter> empty_ptr;
+// { dg-final { note-test empty_ptr {std::unique_ptr<int> = {get() = {<No data fields>}}} } }
+  std::unique_ptr<int, Deleter>& rempty_ptr = empty_ptr;
+// { dg-final { note-test rempty_ptr {std::unique_ptr<int> = {get() = {<No data fields>}}} } }
+
   ExTuple tpl(6,7);
 // { dg-final { note-test tpl {std::tuple containing = {[1] = 6, [2] = 7}} } }
   ExTuple &rtpl = tpl;
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/filesystem-ts.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/filesystem-ts.cc
new file mode 100644
index 00000000000..692d79fa5a6
--- /dev/null
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/filesystem-ts.cc
@@ -0,0 +1,39 @@
+// { dg-options "-g -O0 -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <experimental/filesystem>
+#include <iostream>
+
+int
+main()
+{
+  std::experimental::filesystem::path path0;
+// { dg-final { note-test path0 {experimental::filesystem::path ""} } }
+  std::experimental::filesystem::path path1("filename");
+// { dg-final { note-test path1 {experimental::filesystem::path "filename"} } }
+  std::experimental::filesystem::path path2("/dir/.");
+// { dg-final { note-test path2 {experimental::filesystem::path "/dir/." = {[root-directory] = "/", [1] = "dir", [2] = "."}} } }
+
+  std::cout << "\n";
+  return 0;			// Mark SPOT
+}
+
+// { dg-final { gdb-test SPOT } }
diff --git a/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc b/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
index e1feef99582..0f00a94da42 100644
--- a/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
+++ b/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
@@ -30,7 +30,7 @@ void test01()
 #if _GLIBCXX_USE_C99_STDLIB
 
   long long i = 0;
-  const char* s = 0;
+  const char* s = "";
   char** endptr = 0;
   int base = 0;
 
diff --git a/ltmain.sh b/ltmain.sh
index 79f9ba89af5..70990740b6c 100644
--- a/ltmain.sh
+++ b/ltmain.sh
@@ -3425,8 +3425,8 @@ int setenv (const char *, const char *, int);
 # define PATH_SEPARATOR ':'
 #endif
 
-#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
-  defined (__OS2__)
+#if (defined (_WIN32) && ! defined(__CYGWIN__)) || defined (__MSDOS__) || \
+  defined (__DJGPP__) || defined (__OS2__)
 # define HAVE_DOS_BASED_FILE_SYSTEM
 # define FOPEN_WB "wb"
 # ifndef DIR_SEPARATOR_2
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index b1a9be6f5b2..039f7381af5 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,11 @@
+2020-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2020-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc_release (upload_files): Without -l, pass -m 755 to the mkdir
+	command invoked through ssh.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/maintainer-scripts/gcc_release b/maintainer-scripts/gcc_release
index 74cce1af18d..2456908d716 100755
--- a/maintainer-scripts/gcc_release
+++ b/maintainer-scripts/gcc_release
@@ -398,7 +398,7 @@ upload_files() {
   # Make sure the directory exists on the server.
   if [ $LOCAL -eq 0 ]; then
     ${SSH} -l ${GCC_USERNAME} ${GCC_HOSTNAME} \
-      mkdir -p "${FTP_PATH}/diffs"
+      mkdir -m 755 -p "${FTP_PATH}/diffs"
     UPLOAD_PATH="${GCC_USERNAME}@${GCC_HOSTNAME}:${FTP_PATH}"
   else
     mkdir -p "${FTP_PATH}/diffs" \
