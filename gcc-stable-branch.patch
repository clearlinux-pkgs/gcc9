GCC Administrator (24):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Harald Anlauf (1):
      Fortran - ICE in inline_matmul_assign

Iain Buclaw (5):
      d: Fix ICE in gimplify_var_or_parm_decl, at gimplify.c:2755 (PR100882)
      d: Respect explicit align(N) type alignment (PR100935)
      d: TypeInfo error when using slice copy on Structs (PR100964)
      PR d/90651 (ICE in FuncDeclaration::semantic3, at d/dmd/func.c:1524)
      d: Fix ICE in TypeInfoDeclaration, at dmd/declaration.c (PR100967)

Jonathan Wakely (6):
      libstdc++: Fix find_type helper to work consistently
      libstdc++: Simplify constexpr checks in std::char_traits [PR 91488]
      libstdc++: Reject std::make_shared<T[]> [PR 99006]
      libstdc++: Do not use deduced return type for std::visit [PR 100384]
      libstdc++: Fix filesystem::path constraints for volatile [PR 100630]
      libstdc++: Replace incorrect static assertion in std::reduce [PR95833]

Marius Hillenbrand (1):
      IBM Z: Fix vector intrinsics vec_double and vec_floate

Martin Liska (2):
      contrib: add git-commit-mklog wrapper
      Add mklog.py.

Richard Biener (1):
      Bump BASE-VER to 9.4.1

Uros Bizjak (1):
      i386: Prevent unwanted combine from LZCNT to BSR [PR101175]

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 7ab95a2466e..fdaf498c25f 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,12 @@
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* mklog.py: New file.
+	* test_mklog.py: New file.
+
+2021-06-23  Martin Liska  <mliska@suse.cz>
+
+	* git-commit-mklog.py: New file.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/contrib/git-commit-mklog.py b/contrib/git-commit-mklog.py
new file mode 100755
index 00000000000..9c59fb97809
--- /dev/null
+++ b/contrib/git-commit-mklog.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+#
+# The script is wrapper for git commit-mklog alias where it parses
+# -b/--pr-numbers argument and passes it via environment variable
+# to mklog.py script.
+
+import argparse
+import os
+import subprocess
+
+if __name__ == '__main__':
+    children_args = []
+    myenv = os.environ.copy()
+
+    parser = argparse.ArgumentParser(description='git-commit-mklog wrapped')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    args, unknown_args = parser.parse_known_args()
+
+    myenv['GCC_FORCE_MKLOG'] = '1'
+    mklog_args = []
+    if args.pr_numbers:
+        mklog_args.append(f'-b {",".join(args.pr_numbers)}')
+    if args.fill_up_bug_titles:
+        mklog_args.append('-p')
+
+    if mklog_args:
+        myenv['GCC_MKLOG_ARGS'] = ' '.join(mklog_args)
+
+    commit_args = ' '.join(unknown_args)
+    subprocess.run(f'git commit {commit_args}', shell=True, env=myenv)
diff --git a/contrib/mklog.py b/contrib/mklog.py
new file mode 100755
index 00000000000..674c1dcd78b
--- /dev/null
+++ b/contrib/mklog.py
@@ -0,0 +1,356 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import argparse
+import datetime
+import os
+import re
+import subprocess
+import sys
+from itertools import takewhile
+
+import requests
+
+from unidiff import PatchSet
+
+pr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<pr>PR [a-z+-]+\/[0-9]+)')
+prnum_regex = re.compile(r'PR (?P<comp>[a-z+-]+)/(?P<num>[0-9]+)')
+dr_regex = re.compile(r'(\/(\/|\*)|[Cc*!])\s+(?P<dr>DR [0-9]+)')
+dg_regex = re.compile(r'{\s+dg-(error|warning)')
+pr_filename_regex = re.compile(r'(^|[\W_])[Pp][Rr](?P<pr>\d{4,})')
+identifier_regex = re.compile(r'^([a-zA-Z0-9_#].*)')
+comment_regex = re.compile(r'^\/\*')
+struct_regex = re.compile(r'^(class|struct|union|enum)\s+'
+                          r'(GTY\(.*\)\s+)?([a-zA-Z0-9_]+)')
+macro_regex = re.compile(r'#\s*(define|undef)\s+([a-zA-Z0-9_]+)')
+super_macro_regex = re.compile(r'^DEF[A-Z0-9_]+\s*\(([a-zA-Z0-9_]+)')
+fn_regex = re.compile(r'([a-zA-Z_][^()\s]*)\s*\([^*]')
+template_and_param_regex = re.compile(r'<[^<>]*>')
+md_def_regex = re.compile(r'\(define.*\s+"(.*)"')
+bugzilla_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/bug?id=%s&' \
+               'include_fields=summary,component'
+
+function_extensions = {'.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def', '.md'}
+
+# NB: Makefile.in isn't listed as it's not always generated.
+generated_files = {'aclocal.m4', 'config.h.in', 'configure'}
+
+help_message = """\
+Generate ChangeLog template for PATCH.
+PATCH must be generated using diff(1)'s -up or -cp options
+(or their equivalent in git).
+"""
+
+script_folder = os.path.realpath(__file__)
+root = os.path.dirname(os.path.dirname(script_folder))
+
+firstpr = ''
+
+
+def find_changelog(path):
+    folder = os.path.split(path)[0]
+    while True:
+        if os.path.exists(os.path.join(root, folder, 'ChangeLog')):
+            return folder
+        folder = os.path.dirname(folder)
+        if folder == '':
+            return folder
+    raise AssertionError()
+
+
+def extract_function_name(line):
+    if comment_regex.match(line):
+        return None
+    m = struct_regex.search(line)
+    if m:
+        # Struct declaration
+        return m.group(1) + ' ' + m.group(3)
+    m = macro_regex.search(line)
+    if m:
+        # Macro definition
+        return m.group(2)
+    m = super_macro_regex.search(line)
+    if m:
+        # Supermacro
+        return m.group(1)
+    m = fn_regex.search(line)
+    if m:
+        # Discard template and function parameters.
+        fn = m.group(1)
+        fn = re.sub(template_and_param_regex, '', fn)
+        return fn.rstrip()
+    return None
+
+
+def try_add_function(functions, line):
+    fn = extract_function_name(line)
+    if fn and fn not in functions:
+        functions.append(fn)
+    return bool(fn)
+
+
+def sort_changelog_files(changed_file):
+    return (changed_file.is_added_file, changed_file.is_removed_file)
+
+
+def get_pr_titles(prs):
+    output = []
+    for idx, pr in enumerate(prs):
+        pr_id = pr.split('/')[-1]
+        r = requests.get(bugzilla_url % pr_id)
+        bugs = r.json()['bugs']
+        if len(bugs) == 1:
+            prs[idx] = 'PR %s/%s' % (bugs[0]['component'], pr_id)
+            out = '%s - %s\n' % (prs[idx], bugs[0]['summary'])
+            if out not in output:
+                output.append(out)
+    if output:
+        output.append('')
+    return '\n'.join(output)
+
+
+def generate_changelog(data, no_functions=False, fill_pr_titles=False,
+                       additional_prs=None):
+    changelogs = {}
+    changelog_list = []
+    prs = []
+    out = ''
+    diff = PatchSet(data)
+    global firstpr
+
+    if additional_prs:
+        prs = [pr for pr in additional_prs if pr not in prs]
+    for file in diff:
+        # skip files that can't be parsed
+        if file.path == '/dev/null':
+            continue
+        changelog = find_changelog(file.path)
+        if changelog not in changelogs:
+            changelogs[changelog] = []
+            changelog_list.append(changelog)
+        changelogs[changelog].append(file)
+
+        # Extract PR entries from newly added tests
+        if 'testsuite' in file.path and file.is_added_file:
+            # Only search first ten lines as later lines may
+            # contains commented code which a note that it
+            # has not been tested due to a certain PR or DR.
+            this_file_prs = []
+            for line in list(file)[0][0:10]:
+                m = pr_regex.search(line.value)
+                if m:
+                    pr = m.group('pr')
+                    if pr not in prs:
+                        prs.append(pr)
+                        this_file_prs.append(pr.split('/')[-1])
+                else:
+                    m = dr_regex.search(line.value)
+                    if m:
+                        dr = m.group('dr')
+                        if dr not in prs:
+                            prs.append(dr)
+                            this_file_prs.append(dr.split('/')[-1])
+                    elif dg_regex.search(line.value):
+                        # Found dg-warning/dg-error line
+                        break
+            # PR number in the file name
+            fname = os.path.basename(file.path)
+            m = pr_filename_regex.search(fname)
+            if m:
+                pr = m.group('pr')
+                pr2 = 'PR ' + pr
+                if pr not in this_file_prs and pr2 not in prs:
+                    prs.append(pr2)
+
+    if prs:
+        firstpr = prs[0]
+
+    if fill_pr_titles:
+        out += get_pr_titles(prs)
+
+    # print list of PR entries before ChangeLog entries
+    if prs:
+        if not out:
+            out += '\n'
+        for pr in prs:
+            out += '\t%s\n' % pr
+        out += '\n'
+
+    # sort ChangeLog so that 'testsuite' is at the end
+    for changelog in sorted(changelog_list, key=lambda x: 'testsuite' in x):
+        files = changelogs[changelog]
+        out += '%s:\n' % os.path.join(changelog, 'ChangeLog')
+        out += '\n'
+        # new and deleted files should be at the end
+        for file in sorted(files, key=sort_changelog_files):
+            assert file.path.startswith(changelog)
+            in_tests = 'testsuite' in changelog or 'testsuite' in file.path
+            relative_path = file.path[len(changelog):].lstrip('/')
+            functions = []
+            if file.is_added_file:
+                msg = 'New test' if in_tests else 'New file'
+                out += '\t* %s: %s.\n' % (relative_path, msg)
+            elif file.is_removed_file:
+                out += '\t* %s: Removed.\n' % (relative_path)
+            elif hasattr(file, 'is_rename') and file.is_rename:
+                out += '\t* %s: Moved to...\n' % (relative_path)
+                new_path = file.target_file[2:]
+                # A file can be theoretically moved to a location that
+                # belongs to a different ChangeLog.  Let user fix it.
+                if new_path.startswith(changelog):
+                    new_path = new_path[len(changelog):].lstrip('/')
+                out += '\t* %s: ...here.\n' % (new_path)
+            elif os.path.basename(file.path) in generated_files:
+                out += '\t* %s: Regenerate.\n' % (relative_path)
+            else:
+                if not no_functions:
+                    for hunk in file:
+                        # Do not add function names for testsuite files
+                        extension = os.path.splitext(relative_path)[1]
+                        if not in_tests and extension in function_extensions:
+                            last_fn = None
+                            modified_visited = False
+                            success = False
+                            for line in hunk:
+                                m = identifier_regex.match(line.value)
+                                if line.is_added or line.is_removed:
+                                    # special-case definition in .md files
+                                    m2 = md_def_regex.match(line.value)
+                                    if extension == '.md' and m2:
+                                        fn = m2.group(1)
+                                        if fn not in functions:
+                                            functions.append(fn)
+                                            last_fn = None
+                                            success = True
+
+                                    if not line.value.strip():
+                                        continue
+                                    modified_visited = True
+                                    if m and try_add_function(functions,
+                                                              m.group(1)):
+                                        last_fn = None
+                                        success = True
+                                elif line.is_context:
+                                    if last_fn and modified_visited:
+                                        try_add_function(functions, last_fn)
+                                        last_fn = None
+                                        modified_visited = False
+                                        success = True
+                                    elif m:
+                                        last_fn = m.group(1)
+                                        modified_visited = False
+                            if not success:
+                                try_add_function(functions,
+                                                 hunk.section_header)
+                if functions:
+                    out += '\t* %s (%s):\n' % (relative_path, functions[0])
+                    for fn in functions[1:]:
+                        out += '\t(%s):\n' % fn
+                else:
+                    out += '\t* %s:\n' % relative_path
+        out += '\n'
+    return out
+
+
+def update_copyright(data):
+    current_timestamp = datetime.datetime.now().strftime('%Y-%m-%d')
+    username = subprocess.check_output('git config user.name', shell=True,
+                                       encoding='utf8').strip()
+    email = subprocess.check_output('git config user.email', shell=True,
+                                    encoding='utf8').strip()
+
+    changelogs = set()
+    diff = PatchSet(data)
+
+    for file in diff:
+        changelog = os.path.join(find_changelog(file.path), 'ChangeLog')
+        if changelog not in changelogs:
+            changelogs.add(changelog)
+            with open(changelog) as f:
+                content = f.read()
+            with open(changelog, 'w+') as f:
+                f.write(f'{current_timestamp}  {username}  <{email}>\n\n')
+                f.write('\tUpdate copyright years.\n\n')
+                f.write(content)
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description=help_message)
+    parser.add_argument('input', nargs='?',
+                        help='Patch file (or missing, read standard input)')
+    parser.add_argument('-b', '--pr-numbers', action='store',
+                        type=lambda arg: arg.split(','), nargs='?',
+                        help='Add the specified PRs (comma separated)')
+    parser.add_argument('-s', '--no-functions', action='store_true',
+                        help='Do not generate function names in ChangeLogs')
+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',
+                        help='Download title of mentioned PRs')
+    parser.add_argument('-d', '--directory',
+                        help='Root directory where to search for ChangeLog '
+                        'files')
+    parser.add_argument('-c', '--changelog',
+                        help='Append the ChangeLog to a git commit message '
+                             'file')
+    parser.add_argument('--update-copyright', action='store_true',
+                        help='Update copyright in ChangeLog files')
+    args = parser.parse_args()
+    if args.input == '-':
+        args.input = None
+    if args.directory:
+        root = args.directory
+
+    data = open(args.input) if args.input else sys.stdin
+    if args.update_copyright:
+        update_copyright(data)
+    else:
+        output = generate_changelog(data, args.no_functions,
+                                    args.fill_up_bug_titles, args.pr_numbers)
+        if args.changelog:
+            lines = open(args.changelog).read().split('\n')
+            start = list(takewhile(lambda l: not l.startswith('#'), lines))
+            end = lines[len(start):]
+            with open(args.changelog, 'w') as f:
+                if not start or not start[0]:
+                    # initial commit subject line 'component: [PRnnnnn]'
+                    m = prnum_regex.match(firstpr)
+                    if m:
+                        title = f'{m.group("comp")}: [PR{m.group("num")}]'
+                        start.insert(0, title)
+                if start:
+                    # append empty line
+                    if start[-1] != '':
+                        start.append('')
+                else:
+                    # append 2 empty lines
+                    start = 2 * ['']
+                f.write('\n'.join(start))
+                f.write('\n')
+                f.write(output)
+                f.write('\n'.join(end))
+        else:
+            print(output, end='')
diff --git a/contrib/test_mklog.py b/contrib/test_mklog.py
new file mode 100755
index 00000000000..f5e9ecd577c
--- /dev/null
+++ b/contrib/test_mklog.py
@@ -0,0 +1,487 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2020 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to
+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'
+# and adds a skeleton ChangeLog file to the file. It does not try to be
+# too smart when parsing function names, but it produces a reasonable
+# approximation.
+#
+# Author: Martin Liska <mliska@suse.cz>
+
+import unittest
+
+from mklog import generate_changelog
+
+import unidiff
+
+unidiff_supports_renaming = hasattr(unidiff.PatchedFile(), 'is_rename')
+
+
+PATCH1 = '''\
+diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
+index 567c23380fe..e6209ede9d6 100644
+--- a/gcc/config/riscv/riscv.h
++++ b/gcc/config/riscv/riscv.h
+@@ -920,6 +920,7 @@ extern unsigned riscv_stack_boundary;
+ #define SHIFT_RS1 15
+ #define SHIFT_IMM 20
+ #define IMM_BITS 12
++#define C_S_BITS 5
+ #define C_SxSP_BITS 6
+ 
+ #define IMM_REACH (1LL << IMM_BITS)
+@@ -929,6 +930,10 @@ extern unsigned riscv_stack_boundary;
+ #define SWSP_REACH (4LL << C_SxSP_BITS)
+ #define SDSP_REACH (8LL << C_SxSP_BITS)
+ 
++/* This is the maximum value that can be represented in a compressed load/store
++   offset (an unsigned 5-bit value scaled by 4).  */
++#define CSW_MAX_OFFSET ((4LL << C_S_BITS) - 1) & ~3
++
+ /* Called from RISCV_REORG, this is defined in riscv-sr.c.  */
+ 
+ extern void riscv_remove_unneeded_save_restore_calls (void);
+
+'''
+
+EXPECTED1 = '''\
+gcc/ChangeLog:
+
+	* config/riscv/riscv.h (C_S_BITS):
+	(CSW_MAX_OFFSET):
+
+'''
+
+PATCH2 = '''\
+diff --git a/gcc/targhooks.h b/gcc/targhooks.h
+index 9704d23f1db..b572a36e8cf 100644
+--- a/gcc/targhooks.h
++++ b/gcc/targhooks.h
+@@ -120,7 +120,7 @@ extern bool default_empty_mask_is_expensive (unsigned);
+ extern void *default_init_cost (class loop *);
+ extern unsigned default_add_stmt_cost (class vec_info *, void *, int,
+ 				       enum vect_cost_for_stmt,
+-				       class _stmt_vec_info *, int,
++				       class _stmt_vec_info *, tree, int,
+ 				       enum vect_cost_model_location);
+ extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);
+ extern void default_destroy_cost_data (void *);
+@@ -186,6 +186,7 @@ extern tree default_emutls_var_init (tree, tree, tree);
+ extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);
+ extern bool default_hard_regno_scratch_ok (unsigned int);
+ extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);
++extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);
+ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);
+ extern bool default_target_option_pragma_parse (tree, tree);
+ extern bool default_target_can_inline_p (tree, tree);
+
+'''
+
+EXPECTED2 = '''\
+gcc/ChangeLog:
+
+	* targhooks.h (default_add_stmt_cost):
+	(default_new_address_profitable_p):
+
+'''
+
+PATCH3 = '''\
+diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
+index 2b1e33f94ae..7f47402f9b9 100644
+--- a/libcpp/include/cpplib.h
++++ b/libcpp/include/cpplib.h
+@@ -173,7 +173,7 @@ enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_GNUC11, CLK_GNUC17, CLK_GNUC2X,
+ 	     CLK_STDC2X,
+ 	     CLK_GNUCXX, CLK_CXX98, CLK_GNUCXX11, CLK_CXX11,
+ 	     CLK_GNUCXX14, CLK_CXX14, CLK_GNUCXX17, CLK_CXX17,
+-	     CLK_GNUCXX2A, CLK_CXX2A, CLK_ASM};
++	     CLK_GNUCXX20, CLK_CXX20, CLK_ASM};
+ 
+ /* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */
+ struct GTY(()) cpp_string {
+@@ -484,7 +484,7 @@ struct cpp_options
+   /* Nonzero for C2X decimal floating-point constants.  */
+   unsigned char dfp_constants;
+ 
+-  /* Nonzero for C++2a __VA_OPT__ feature.  */
++  /* Nonzero for C++20 __VA_OPT__ feature.  */
+   unsigned char va_opt;
+ 
+   /* Nonzero for the '::' token.  */
+
+'''
+
+EXPECTED3 = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h (enum c_lang):
+	(struct cpp_options):
+
+'''
+
+EXPECTED3B = '''\
+libcpp/ChangeLog:
+
+	* include/cpplib.h:
+
+'''
+
+PATCH4 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
+index aab79492357..f0df1002488 100644
+--- a/gcc/ipa-icf.c
++++ b/gcc/ipa-icf.c
+@@ -1,5 +1,7 @@
+ 
+ 
++
++
+ /* Interprocedural Identical Code Folding pass
+    Copyright (C) 2014-2020 Free Software Foundation, Inc.
+ 
+diff --git a/gcc/testsuite/gcc.dg/pr32374.c b/gcc/testsuite/gcc.dg/pr32374.c
+deleted file mode 100644
+index de15d559f5b..00000000000
+--- a/gcc/testsuite/gcc.dg/pr32374.c
++++ /dev/null
+@@ -1,20 +0,0 @@
+-/* { dg-do compile } */
+-/* { dg-options "-O2" } */
+-
+-extern int *stderr;
+-
+-void f (int *, const char *, ...);
+-
+-void g (const char *conf_name)
+-{
+-  typedef struct
+-  {
+-    const char *label;
+-    const int value;
+-  } Section;
+-
+-  const Section sections[2] = { {"", 0}, {"", 1} };
+-
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-  f (stderr, "", "", conf_name, 0, sections[0]);
+-}
+diff --git a/gcc/testsuite/gcc.dg/pr40209.c b/gcc/testsuite/gcc.dg/pr40209.c
+index 4e77df5c2e6..c23d69d1f1b 100644
+--- a/gcc/testsuite/gcc.dg/pr40209.c
++++ b/gcc/testsuite/gcc.dg/pr40209.c
+@@ -1,6 +1,8 @@
+ /* { dg-do compile } */
+ /* { dg-options "-O2 -fprofile-use -fopt-info -Wno-missing-profile" } */
+ 
++
++
+ void process(const char *s);
+ 
+ struct BaseHolder {
+diff --git a/gcc/testsuite/gcc.dg/pr50209.c b/gcc/testsuite/gcc.dg/pr50209.c
+new file mode 100644
+index 00000000000..b28b04f6431
+--- /dev/null
++++ b/gcc/testsuite/gcc.dg/pr50209.c
+@@ -0,0 +1,3 @@
++
++
++
+diff --git a/gcc/testsuite/gcc.dg/pr63567-1.c b/gcc/testsuite/gcc.dg/pr63567-1.c
+index 97da171563e..00c5ecc11fa 100644
+--- a/gcc/testsuite/gcc.dg/pr63567-1.c
++++ b/gcc/testsuite/gcc.dg/pr63567-1.c
+@@ -1,3 +1,4 @@
++
+ /* PR c/63567 */
+ /* { dg-do compile } */
+ /* { dg-options "" } */
+diff --git a/gcc/varasm.c b/gcc/varasm.c
+index f062e48071f..fd3c7ca8cf3 100644
+--- a/gcc/varasm.c
++++ b/gcc/varasm.c
+@@ -1,3 +1,5 @@
++
++
+ /* Output variables, constants and external declarations, for GNU compiler.
+    Copyright (C) 1987-2020 Free Software Foundation, Inc.
+ 
+diff --git a/libssp/gets-chk.c b/libssp/gets-chk.c
+index 4ad78c1f77b..6687b368038 100644
+--- a/libssp/gets-chk.c
++++ b/libssp/gets-chk.c
+@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ <http://www.gnu.org/licenses/>.  */
+ 
+ 
++
++
+ #include "config.h"
+ #include <ssp/ssp.h>
+ #include <stdarg.h>
+'''
+
+EXPECTED4 = '''\
+
+	PR 50209
+
+gcc/ChangeLog:
+
+	* ipa-icf.c:
+	* varasm.c:
+
+libssp/ChangeLog:
+
+	* gets-chk.c:
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.dg/pr40209.c:
+	* gcc.dg/pr63567-1.c:
+	* gcc.dg/pr32374.c: Removed.
+	* gcc.dg/pr50209.c: New test.
+
+'''
+
+PATCH5 = '''\
+diff --git a/gcc/testsuite/gcc.target/i386/pr95046-6.c b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+new file mode 100644
+index 00000000000..dcc8999c446
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/i386/pr95046-6.c
+@@ -0,0 +1,44 @@
++/* PR target/95046 */
++/* { dg-do compile { target { ! ia32 } } } */
++/* { dg-options "-O3 -mavx512vl" } */
++
++
++double r[2];
++int s[2];
++unsigned int u[2];
++
++void
++test_float (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = s[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtdq2pd" } } */
++
++void
++test_ufloat (void)
++{
++  for (int i = 0; i < 2; i++)
++    r[i] = u[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvtudq2pd" } } */
++
++void
++test_fix (void)
++{
++  for (int i = 0; i < 2; i++)
++    s[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2dqx" } } */
++
++void
++test_ufix (void)
++{
++  for (int i = 0; i < 2; i++)
++    u[i] = r[i];
++}
++
++/* { dg-final { scan-assembler "\tvcvttpd2udqx" } } */
+-- 
+2.26.2
+
+'''
+
+EXPECTED5 = '''\
+PR target/95046 - Vectorize V2SFmode operations
+
+	PR target/95046
+
+gcc/testsuite/ChangeLog:
+
+	* gcc.target/i386/pr95046-6.c: New test.
+
+'''
+
+PATCH6 = '''\
+diff --git a/gcc/cgraph.h b/gcc/cgraph.h
+index 5ddeb65269b..cfae6e91da9 100644
+--- a/gcc/cgraph.h
++++ b/gcc/cgraph.h
+@@ -937,7 +937,8 @@ struct GTY((tag ("SYMTAB_FUNCTION"))) cgraph_node : public symtab_node
+       split_part (false), indirect_call_target (false), local (false),
+       versionable (false), can_change_signature (false),
+       redefined_extern_inline (false), tm_may_enter_irr (false),
+-      ipcp_clone (false), m_uid (uid), m_summary_id (-1)
++      ipcp_clone (false), declare_variant_alt (false),
++      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)
+   {}
+ 
+   /* Remove the node from cgraph and all inline clones inlined into it.
+
+'''
+
+EXPECTED6 = '''\
+gcc/ChangeLog:
+
+	* cgraph.h (struct cgraph_node):
+
+'''
+
+PATCH7 = '''\
+diff --git a/gcc/testsuite/g++.dg/DRs/dr2237.C b/gcc/testsuite/g++.dg/DRs/dr2237.C
+new file mode 100644
+index 00000000000..f3d6d11e61e
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/DRs/dr2237.C
+@@ -0,0 +1,18 @@
++// DR 2237 - Can a template-id name a constructor?
++
++template<class T>
++struct X {
++  X<T>(); // { dg-error "expected" "" { target c++20 } }
++  X(int); // OK, injected-class-name used
++  ~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
++
++// ill-formed since DR1435
++template<typename T> X<T>::X<T>() {} // { dg-error "names the constructor|as no template constructors" }
++template<typename T> X<T>::~X<T>() {} // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++
++struct Q {
++  // ill-formed since DR1435
++  template<typename T> friend X<T>::X<T>(); // { dg-error "names the constructor|as no template constructors" }
++  template<typename T> friend X<T>::~X<T>(); // { dg-error "template-id not allowed for destructor" "" { target c++20 } }
++};
+'''
+
+EXPECTED7 = '''\
+
+	DR 2237
+
+gcc/testsuite/ChangeLog:
+
+	* g++.dg/DRs/dr2237.C: New test.
+
+'''
+
+PATCH8 = '''\
+diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf2.c
+similarity index 100%
+rename from gcc/ipa-icf.c
+rename to gcc/ipa-icf2.c
+'''
+
+EXPECTED8 = '''\
+gcc/ChangeLog:
+
+	* ipa-icf.c: Moved to...
+	* ipa-icf2.c: ...here.
+
+'''
+
+PATCH9 = '''\
+diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
+index 2a260c1cfbd..7f03fc491c3 100644
+--- a/gcc/config/i386/sse.md
++++ b/gcc/config/i386/sse.md
+@@ -17611,6 +17611,23 @@ (define_insn "avx2_<code>v16qiv16hi2<mask_name>"
+    (set_attr "prefix" "maybe_evex")
+    (set_attr "mode" "OI")])
+ 
++(define_insn_and_split "*avx2_zero_extendv16qiv16hi2_1"
++  [(set (match_operand:V32QI 0 "register_operand" "=v")
++	(vec_select:V32QI
++	  (vec_concat:V64QI
++	    (match_operand:V32QI 1 "nonimmediate_operand" "vm")
++	    (match_operand:V32QI 2 "const0_operand" "C"))
++	  (match_parallel 3 "pmovzx_parallel"
++	    [(match_operand 4 "const_int_operand" "n")])))]
++  "TARGET_AVX2"
++  "#"
++  "&& reload_completed"
++  [(set (match_dup 0) (zero_extend:V16HI (match_dup 1)))]
++{
++  operands[0] = lowpart_subreg (V16HImode, operands[0], V32QImode);
++  operands[1] = lowpart_subreg (V16QImode, operands[1], V32QImode);
++})
++
+ (define_expand "<insn>v16qiv16hi2"
+   [(set (match_operand:V16HI 0 "register_operand")
+ 	(any_extend:V16HI
+'''
+
+EXPECTED9 = '''\
+gcc/ChangeLog:
+
+	* config/i386/sse.md (*avx2_zero_extendv16qiv16hi2_1):
+
+'''
+
+class TestMklog(unittest.TestCase):
+    def test_macro_definition(self):
+        changelog = generate_changelog(PATCH1)
+        assert changelog == EXPECTED1
+
+    def test_changed_argument(self):
+        changelog = generate_changelog(PATCH2)
+        assert changelog == EXPECTED2
+
+    def test_enum_and_struct(self):
+        changelog = generate_changelog(PATCH3)
+        assert changelog == EXPECTED3
+
+    def test_no_function(self):
+        changelog = generate_changelog(PATCH3, True)
+        assert changelog == EXPECTED3B
+
+    def test_sorting(self):
+        changelog = generate_changelog(PATCH4)
+        assert changelog == EXPECTED4
+
+    def test_pr_bugzilla_download(self):
+        changelog = generate_changelog(PATCH5, fill_pr_titles=True)
+        assert changelog == EXPECTED5
+
+    def test_gty_in_struct(self):
+        changelog = generate_changelog(PATCH6, fill_pr_titles=True)
+        assert changelog == EXPECTED6
+
+    def test_dr_detection_in_test_case(self):
+        changelog = generate_changelog(PATCH7)
+        assert changelog == EXPECTED7
+
+    @unittest.skipIf(not unidiff_supports_renaming,
+                     'Newer version of unidiff is needed (0.6.0+)')
+    def test_renaming(self):
+        changelog = generate_changelog(PATCH8)
+        assert changelog == EXPECTED8
+
+    def test_define_macro_parsing(self):
+        changelog = generate_changelog(PATCH9)
+        assert changelog == EXPECTED9
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 8148c559489..ccfb75e5120 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.4.0
+9.4.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 7558c0a369e..adf4d69a829 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,24 @@
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* config/i386/i386.md (bsr_rex64): Add zero-flag setting RTX.
+	(bsr): Ditto.
+	(*bsrhi): Remove.
+	(clz<mode>2): Update RTX pattern for additions.
+
+2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	Backported from master:
+	2021-06-17  Marius Hillenbrand  <mhillen@linux.ibm.com>
+
+	PR target/100871
+	* config/s390/vecintrin.h (vec_doublee): Fix to use
+	  __builtin_s390_vflls.
+	(vec_floate): Fix to use __builtin_s390_vflrd.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 8ae7ea68c16..5d76d36e1c0 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -13451,10 +13451,12 @@
    (set_attr "mode" "<MODE>")])
 
 (define_insn "bsr_rex64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:DI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:DI 0 "register_operand" "=r")
 	(minus:DI (const_int 63)
-		  (clz:DI (match_operand:DI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:DI (match_dup 1))))]
   "TARGET_64BIT"
   "bsr{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13463,10 +13465,12 @@
    (set_attr "mode" "DI")])
 
 (define_insn "bsr"
-  [(set (match_operand:SI 0 "register_operand" "=r")
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SI 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
 	(minus:SI (const_int 31)
-		  (clz:SI (match_operand:SI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
+		  (clz:SI (match_dup 1))))]
   ""
   "bsr{l}\t{%1, %0|%0, %1}"
   [(set_attr "type" "alu1")
@@ -13474,25 +13478,15 @@
    (set_attr "znver1_decode" "vector")
    (set_attr "mode" "SI")])
 
-(define_insn "*bsrhi"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(minus:HI (const_int 15)
-		  (clz:HI (match_operand:HI 1 "nonimmediate_operand" "rm"))))
-   (clobber (reg:CC FLAGS_REG))]
-  ""
-  "bsr{w}\t{%1, %0|%0, %1}"
-  [(set_attr "type" "alu1")
-   (set_attr "prefix_0f" "1")
-   (set_attr "znver1_decode" "vector")
-   (set_attr "mode" "HI")])
-
 (define_expand "clz<mode>2"
   [(parallel
-     [(set (match_operand:SWI48 0 "register_operand")
+     [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ (match_operand:SWI48 1 "nonimmediate_operand" "rm")
+		     (const_int 0)))
+      (set (match_operand:SWI48 0 "register_operand")
 	   (minus:SWI48
 	     (match_dup 2)
-	     (clz:SWI48 (match_operand:SWI48 1 "nonimmediate_operand"))))
-      (clobber (reg:CC FLAGS_REG))])
+	     (clz:SWI48 (match_dup 1))))])
    (parallel
      [(set (match_dup 0) (xor:SWI48 (match_dup 0) (match_dup 2)))
       (clobber (reg:CC FLAGS_REG))])]
diff --git a/gcc/config/s390/vecintrin.h b/gcc/config/s390/vecintrin.h
index d7a4ae64c36..788175e1543 100644
--- a/gcc/config/s390/vecintrin.h
+++ b/gcc/config/s390/vecintrin.h
@@ -109,8 +109,8 @@ __lcbb(const void *ptr, int bndry)
 #define vec_rint(X)   __builtin_s390_vfi((X), 0, 0)
 #define vec_roundc(X) __builtin_s390_vfi((X), 4, 0)
 #define vec_round(X)  __builtin_s390_vfi((X), 4, 4)
-#define vec_doublee(X) __builtin_s390_vfll((X))
-#define vec_floate(X) __builtin_s390_vflr((X), 0, 0)
+#define vec_doublee(X) __builtin_s390_vflls((X))
+#define vec_floate(X) __builtin_s390_vflrd((X), 0, 0)
 #define vec_load_len_r(X,L)				\
   (__vector unsigned char)__builtin_s390_vlrlr((L),(X))
 #define vec_store_len_r(X,Y,L) \
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index b0e68a99a73..809827945f2 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,72 @@
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* d-frontend.cc (getTypeInfoType): Move TypeInfo checks to
+	check_typeinfo_type and call new function.
+	* d-tree.h (check_typeinfo_type): Declare.
+	* typeinfo.cc: Include dmd/scope.h.
+	(create_frontend_tinfo_types): Generate front-end types even if Object
+	is missing.
+	(build_typeinfo): Move TypeInfo checks to check_typeinfo_type and call
+	new function.
+	(check_typeinfo_type): New function.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit (TypeidExp)):
+	Error when TypeInfo doesn't exist.
+	* dmd/func.c (FuncDeclaration::semantic3): Likewise.
+	* dmd/mtype.c (TypeClass::dotExp): Likewise.
+	* typeinfo.cc (object_module): New variable.
+	(make_frontend_typeinfo): Update signature.  Set temporary on
+	generated TypeInfo classes.
+	(create_tinfo_types): Set object_module.  Move generation of front-end
+	typeinfo into ...
+	(create_frontend_tinfo_types): ... New function.
+	(layout_typeinfo): Call create_frontend_tinfo_types.
+	(layout_classinfo): Likewise.
+	(layout_cpp_typeinfo): Likewise.
+	(create_typeinfo): Likewise.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* dmd/expression.c (Expression::checkPostblit): Don't generate
+	TypeInfo when RTTI is disabled.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* dmd/mtype.c (Type::getProperty): Prefer explicit alignment over
+	natural alignment for alignof property.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* d-codegen.cc (build_assign): Construct initializations inside
+	TARGET_EXPR_INITIAL.
+	(compound_expr): Remove intermediate expressions that have no
+	side-effects.
+	(return_expr): Construct returns inside TARGET_EXPR_INITIAL.
+	* expr.cc (ExprVisitor::visit (CallExp *)): Remove useless assignment
+	to TARGET_EXPR_SLOT.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/d/d-codegen.cc b/gcc/d/d-codegen.cc
index 17f624b5a4f..5368b5892db 100644
--- a/gcc/d/d-codegen.cc
+++ b/gcc/d/d-codegen.cc
@@ -1304,6 +1304,7 @@ component_ref (tree object, tree field)
 tree
 build_assign (tree_code code, tree lhs, tree rhs)
 {
+  tree result;
   tree init = stabilize_expr (&lhs);
   init = compound_expr (init, stabilize_expr (&rhs));
 
@@ -1322,19 +1323,27 @@ build_assign (tree_code code, tree lhs, tree rhs)
   if (TREE_CODE (rhs) == TARGET_EXPR)
     {
       /* If CODE is not INIT_EXPR, can't initialize LHS directly,
-	 since that would cause the LHS to be constructed twice.
-	 So we force the TARGET_EXPR to be expanded without a target.  */
+	 since that would cause the LHS to be constructed twice.  */
       if (code != INIT_EXPR)
-	rhs = compound_expr (rhs, TARGET_EXPR_SLOT (rhs));
+	{
+	  init = compound_expr (init, rhs);
+	  result = build_assign (code, lhs, TARGET_EXPR_SLOT (rhs));
+	}
       else
 	{
 	  d_mark_addressable (lhs);
-	  rhs = TARGET_EXPR_INITIAL (rhs);
+	  TARGET_EXPR_INITIAL (rhs) = build_assign (code, lhs,
+						    TARGET_EXPR_INITIAL (rhs));
+	  result = rhs;
 	}
     }
+  else
+    {
+      /* Simple assignment.  */
+      result = fold_build2_loc (input_location, code,
+				TREE_TYPE (lhs), lhs, rhs);
+    }
 
-  tree result = fold_build2_loc (input_location, code,
-				 TREE_TYPE (lhs), lhs, rhs);
   return compound_expr (init, result);
 }
 
@@ -1456,6 +1465,11 @@ compound_expr (tree arg0, tree arg1)
   if (arg0 == NULL_TREE || !TREE_SIDE_EFFECTS (arg0))
     return arg1;
 
+  /* Remove intermediate expressions that have no side-effects.  */
+  while (TREE_CODE (arg0) == COMPOUND_EXPR
+	 && !TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))
+    arg0 = TREE_OPERAND (arg0, 0);
+
   if (TREE_CODE (arg1) == TARGET_EXPR)
     {
       /* If the rhs is a TARGET_EXPR, then build the compound expression
@@ -1476,6 +1490,19 @@ compound_expr (tree arg0, tree arg1)
 tree
 return_expr (tree ret)
 {
+  /* Same as build_assign, the DECL_RESULT assignment replaces the temporary
+     in TARGET_EXPR_SLOT.  */
+  if (ret != NULL_TREE && TREE_CODE (ret) == TARGET_EXPR)
+    {
+      tree exp = TARGET_EXPR_INITIAL (ret);
+      tree init = stabilize_expr (&exp);
+
+      exp = fold_build1_loc (input_location, RETURN_EXPR, void_type_node, exp);
+      TARGET_EXPR_INITIAL (ret) = compound_expr (init, exp);
+
+      return ret;
+    }
+
   return fold_build1_loc (input_location, RETURN_EXPR,
 			  void_type_node, ret);
 }
diff --git a/gcc/d/d-frontend.cc b/gcc/d/d-frontend.cc
index ccd5f50130f..563696bdf9f 100644
--- a/gcc/d/d-frontend.cc
+++ b/gcc/d/d-frontend.cc
@@ -614,39 +614,8 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)
 Type *
 getTypeInfoType (Loc loc, Type *type, Scope *sc)
 {
-  if (!global.params.useTypeInfo)
-    {
-      /* Even when compiling without RTTI we should still be able to evaluate
-	 TypeInfo at compile-time, just not at run-time.  */
-      if (!sc || !(sc->flags & SCOPEctfe))
-	{
-	  static int warned = 0;
-
-	  if (!warned)
-	    {
-	      error_at (make_location_t (loc),
-			"%<object.TypeInfo%> cannot be used with -fno-rtti");
-	      warned = 1;
-	    }
-	}
-    }
-
-  if (Type::dtypeinfo == NULL
-      || (Type::dtypeinfo->storage_class & STCtemp))
-    {
-      /* If TypeInfo has not been declared, warn about each location once.  */
-      static Loc warnloc;
-
-      if (!loc.equals (warnloc))
-	{
-	  error_at (make_location_t (loc),
-		    "%<object.TypeInfo%> could not be found, "
-		    "but is implicitly used");
-	  warnloc = loc;
-	}
-    }
-
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, sc);
   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);
   return type->vtinfo->type;
 }
diff --git a/gcc/d/d-tree.h b/gcc/d/d-tree.h
index 7a54dfbc59e..5d10333fbdc 100644
--- a/gcc/d/d-tree.h
+++ b/gcc/d/d-tree.h
@@ -650,6 +650,7 @@ extern tree layout_typeinfo (TypeInfoDeclaration *);
 extern tree layout_classinfo (ClassDeclaration *);
 extern tree get_typeinfo_decl (TypeInfoDeclaration *);
 extern tree get_classinfo_decl (ClassDeclaration *);
+extern void check_typeinfo_type (const Loc &, Scope *);
 extern tree build_typeinfo (const Loc &, Type *);
 extern void create_typeinfo (Type *, Module *);
 extern void create_tinfo_types (Module *);
diff --git a/gcc/d/dmd/expression.c b/gcc/d/dmd/expression.c
index af762eb3c66..4798409edb9 100644
--- a/gcc/d/dmd/expression.c
+++ b/gcc/d/dmd/expression.c
@@ -2647,8 +2647,11 @@ bool Expression::checkPostblit(Scope *sc, Type *t)
     t = t->baseElemOf();
     if (t->ty == Tstruct)
     {
-        // Bugzilla 11395: Require TypeInfo generation for array concatenation
-        semanticTypeInfo(sc, t);
+        if (global.params.useTypeInfo)
+        {
+            // Bugzilla 11395: Require TypeInfo generation for array concatenation
+            semanticTypeInfo(sc, t);
+        }
 
         StructDeclaration *sd = ((TypeStruct *)t)->sym;
         if (sd->postblit)
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 75794a03285..847a0796792 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -1806,11 +1806,19 @@ public:
         Expression *e;
         if (ea && ta->toBasetype()->ty == Tclass)
         {
-            /* Get the dynamic type, which is .classinfo
-            */
-            ea = semantic(ea, sc);
-            e = new TypeidExp(ea->loc, ea);
-            e->type = Type::typeinfoclass->type;
+            if (!Type::typeinfoclass)
+            {
+                error(exp->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                e = new ErrorExp();
+            }
+            else
+            {
+                /* Get the dynamic type, which is .classinfo
+                */
+                ea = semantic(ea, sc);
+                e = new TypeidExp(ea->loc, ea);
+                e->type = Type::typeinfoclass->type;
+            }
         }
         else if (ta->ty == Terror)
         {
diff --git a/gcc/d/dmd/func.c b/gcc/d/dmd/func.c
index 568decc8cee..04c70cf3b7b 100644
--- a/gcc/d/dmd/func.c
+++ b/gcc/d/dmd/func.c
@@ -1520,6 +1520,18 @@ void FuncDeclaration::semantic3(Scope *sc)
         {
             if (f->linkage == LINKd)
             {
+                // Variadic arguments depend on Typeinfo being defined
+                if (!global.params.useTypeInfo || !Type::dtypeinfo || !Type::typeinfotypelist)
+                {
+                    if (!global.params.useTypeInfo)
+                        error("D-style variadic functions cannot be used with -betterC");
+                    else if (!Type::typeinfotypelist)
+                        error("`object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions");
+                    else
+                        error("`object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions");
+                    fatal();
+                }
+
                 // Declare _arguments[]
                 v_arguments = new VarDeclaration(Loc(), Type::typeinfotypelist->type, Id::_arguments_typeinfo, NULL);
                 v_arguments->storage_class |= STCtemp | STCparameter;
diff --git a/gcc/d/dmd/mtype.c b/gcc/d/dmd/mtype.c
index d0e73967d45..0204860fec3 100644
--- a/gcc/d/dmd/mtype.c
+++ b/gcc/d/dmd/mtype.c
@@ -2059,7 +2059,10 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)
     }
     else if (ident == Id::__xalignof)
     {
-        e = new IntegerExp(loc, alignsize(), Type::tsize_t);
+        unsigned explicitAlignment = alignment();
+        unsigned naturalAlignment = alignsize();
+        unsigned actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);
+        e = new IntegerExp(loc, actualAlignment, Type::tsize_t);
     }
     else if (ident == Id::_init)
     {
@@ -8344,7 +8347,12 @@ L1:
 
         if (ident == Id::classinfo)
         {
-            assert(Type::typeinfoclass);
+            if (!Type::typeinfoclass)
+            {
+                error(e->loc, "`object.TypeInfo_Class` could not be found, but is implicitly used");
+                return new ErrorExp();
+            }
+
             Type *t = Type::typeinfoclass->type;
             if (e->op == TOKtype || e->op == TOKdottype)
             {
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 3a2823d6e46..ff8cd1304a8 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -1837,15 +1837,10 @@ public:
       exp = d_convert (build_ctype (e->type), exp);
 
     /* If this call was found to be a constructor for a temporary with a
-       cleanup, then move the call inside the TARGET_EXPR.  The original
-       initializer is turned into an assignment, to keep its side effect.  */
+       cleanup, then move the call inside the TARGET_EXPR.  */
     if (cleanup != NULL_TREE)
       {
 	tree init = TARGET_EXPR_INITIAL (cleanup);
-	tree slot = TARGET_EXPR_SLOT (cleanup);
-	d_mark_addressable (slot);
-	init = build_assign (INIT_EXPR, slot, init);
-
 	TARGET_EXPR_INITIAL (cleanup) = compound_expr (init, exp);
 	exp = cleanup;
       }
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 0b19bcf7f34..117a5bd1592 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dmd/identifier.h"
 #include "dmd/module.h"
 #include "dmd/mtype.h"
+#include "dmd/scope.h"
 #include "dmd/template.h"
 #include "dmd/target.h"
 
@@ -185,28 +186,36 @@ make_internal_typeinfo (tinfo_kind tk, Identifier *ident, ...)
   va_end (ap);
 }
 
-/* Helper for create_tinfo_types.  Creates a typeinfo class declaration
-   incase one wasn't supplied by reading `object.d'.  */
+/* Reference to the `object` module, where all TypeInfo is defined.  */
+
+static Module *object_module;
+
+/* Helper for create_frontend_tinfo_types.  Creates a typeinfo class
+   declaration incase one wasn't supplied by reading `object.d'.  */
 
 static void
-make_frontend_typeinfo (Module *mod, Identifier *ident,
-			ClassDeclaration *base = NULL)
+make_frontend_typeinfo (Identifier *ident, ClassDeclaration *base = NULL)
 {
   if (!base)
     base = Type::dtypeinfo;
 
+  gcc_assert (object_module);
+
   /* Create object module in order to complete the semantic.  */
-  if (!mod->_scope)
-    mod->importAll (NULL);
+  if (!object_module->_scope)
+    object_module->importAll (NULL);
 
   /* Assignment of global typeinfo variables is managed by the ClassDeclaration
      constructor, so only need to new the declaration here.  */
-  Loc loc = (mod->md) ? mod->md->loc : mod->loc;
+  Loc loc = (object_module->md) ? object_module->md->loc : object_module->loc;
   ClassDeclaration *tinfo = ClassDeclaration::create (loc, ident, NULL, NULL,
 						      true);
-  tinfo->parent = mod;
-  tinfo->semantic (mod->_scope);
+  tinfo->parent = object_module;
+  tinfo->semantic (object_module->_scope);
   tinfo->baseClass = base;
+  /* This is a compiler generated class, and shouldn't be mistaken for being
+     the type declared in the runtime library.  */
+  tinfo->storage_class |= STCtemp;
 }
 
 /* Make sure the required builtin types exist for generating the TypeInfo
@@ -227,69 +236,78 @@ create_tinfo_types (Module *mod)
 			  ptr_type_node, d_uint_type, ptr_type_node,
 			  array_type_node, ptr_type_node, ptr_type_node, NULL);
 
-  /* If there's no Object class defined, then neither can TypeInfo be.  */
-  if (ClassDeclaration::object == NULL)
+  object_module = mod;
+}
+
+/* Same as create_tinfo_types, but builds all front-end TypeInfo variable
+   definitions.  */
+
+static void
+create_frontend_tinfo_types (void)
+{
+  /* If there's no object module, then neither can there be TypeInfo.  */
+  if (object_module == NULL)
     return;
 
   /* Create all frontend TypeInfo classes declarations.  We rely on all
      existing, even if only just as stubs.  */
   if (!Type::dtypeinfo)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo"),
 			    ClassDeclaration::object);
 
   if (!Type::typeinfoclass)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Class"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Class"));
 
   if (!Type::typeinfointerface)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Interface"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Interface"));
 
   if (!Type::typeinfostruct)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Struct"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Struct"));
 
   if (!Type::typeinfopointer)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Pointer"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Pointer"));
 
   if (!Type::typeinfoarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Array"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Array"));
 
   if (!Type::typeinfostaticarray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_StaticArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_StaticArray"));
 
   if (!Type::typeinfoassociativearray)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_AssociativeArray"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_AssociativeArray"));
 
   if (!Type::typeinfoenum)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Enum"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Enum"));
 
   if (!Type::typeinfofunction)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Function"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Function"));
 
   if (!Type::typeinfodelegate)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Delegate"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Delegate"));
 
   if (!Type::typeinfotypelist)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Tuple"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Tuple"));
 
   if (!Type::typeinfoconst)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Const"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Const"));
 
   if (!Type::typeinfoinvariant)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Invariant"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Invariant"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfoshared)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Shared"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Shared"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfowild)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Wild"),
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Wild"),
 			    Type::typeinfoconst);
 
   if (!Type::typeinfovector)
-    make_frontend_typeinfo (mod, Identifier::idPool ("TypeInfo_Vector"));
+    make_frontend_typeinfo (Identifier::idPool ("TypeInfo_Vector"));
 
   if (!ClassDeclaration::cpp_type_info_ptr)
-    make_frontend_typeinfo (mod, Identifier::idPool ("__cpp_type_info_ptr"),
+    make_frontend_typeinfo (Identifier::idPool ("__cpp_type_info_ptr"),
 			    ClassDeclaration::object);
 }
 
@@ -1143,6 +1161,9 @@ public:
 tree
 layout_typeinfo (TypeInfoDeclaration *d)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoVisitor v = TypeInfoVisitor (get_typeinfo_decl (d));
   d->accept (&v);
   return v.result ();
@@ -1154,6 +1175,9 @@ layout_typeinfo (TypeInfoDeclaration *d)
 tree
 layout_classinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   TypeInfoClassDeclaration *d = TypeInfoClassDeclaration::create (cd->type);
   TypeInfoVisitor v = TypeInfoVisitor (get_classinfo_decl (cd));
   d->accept (&v);
@@ -1347,16 +1371,19 @@ get_classinfo_decl (ClassDeclaration *decl)
   return decl->csym;
 }
 
-/* Returns typeinfo reference for TYPE.  */
+/* Performs sanity checks on the `object.TypeInfo' type, raising an error if
+   RTTI is disabled, or the type is missing.  */
 
-tree
-build_typeinfo (const Loc &loc, Type *type)
+void
+check_typeinfo_type (const Loc &loc, Scope *sc)
 {
   if (!global.params.useTypeInfo)
     {
       static int warned = 0;
 
-      if (!warned)
+      /* Even when compiling without RTTI we should still be able to evaluate
+	 TypeInfo at compile-time, just not at run-time.  */
+      if (!warned && (!sc || !(sc->flags & SCOPEctfe)))
 	{
 	  error_at (make_location_t (loc),
 		    "%<object.TypeInfo%> cannot be used with -fno-rtti");
@@ -1364,7 +1391,29 @@ build_typeinfo (const Loc &loc, Type *type)
 	}
     }
 
+  if (Type::dtypeinfo == NULL
+      || (Type::dtypeinfo->storage_class & STCtemp))
+    {
+      /* If TypeInfo has not been declared, warn about each location once.  */
+      static Loc warnloc;
+
+      if (!warnloc.equals (loc))
+	{
+	  error_at (make_location_t (loc),
+		    "%<object.TypeInfo%> could not be found, "
+		    "but is implicitly used");
+	  warnloc = loc;
+	}
+    }
+}
+
+/* Returns typeinfo reference for TYPE.  */
+
+tree
+build_typeinfo (const Loc &loc, Type *type)
+{
   gcc_assert (type->ty != Terror);
+  check_typeinfo_type (loc, NULL);
   create_typeinfo (type, NULL);
   return build_address (get_typeinfo_decl (type->vtinfo));
 }
@@ -1375,6 +1424,9 @@ build_typeinfo (const Loc &loc, Type *type)
 void
 layout_cpp_typeinfo (ClassDeclaration *cd)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   gcc_assert (cd->isCPPclass ());
 
   tree decl = get_cpp_typeinfo_decl (cd);
@@ -1443,6 +1495,9 @@ get_cpp_typeinfo_decl (ClassDeclaration *decl)
 void
 create_typeinfo (Type *type, Module *mod)
 {
+  if (!Type::dtypeinfo)
+    create_frontend_tinfo_types ();
+
   /* Do this since not all Type's are merged.  */
   Type *t = type->merge2 ();
   Identifier *ident;
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index f1d66e38980..98fd3a01286 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,13 @@
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* frontend-passes.c (inline_matmul_assign): Do not inline matmul
+	if the assignment to the resulting array if it is not of canonical
+	type (real/integer/complex/logical).
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index ff71b44b409..7a733cc016c 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -3921,6 +3921,19 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,
   if (m_case == none)
     return 0;
 
+  /* We only handle assignment to numeric or logical variables.  */
+  switch(expr1->ts.type)
+    {
+    case BT_INTEGER:
+    case BT_LOGICAL:
+    case BT_REAL:
+    case BT_COMPLEX:
+      break;
+
+    default:
+      return 0;
+    }
+
   ns = insert_block ();
 
   /* Assign the type of the zero expression for initializing the resulting
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 47eac19a1f6..18d909473eb 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,67 @@
+2021-06-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2021-06-23  Uro≈° Bizjak  <ubizjak@gmail.com>
+
+	PR target/101175
+	* gcc.target/i386/pr101175.c: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100967
+	* gdc.dg/pr100967.d: New test.
+
+2021-06-10  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2019-06-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/90651
+	* gdc.test/fail_compilation/extra-files/minimal/object.d: New file.
+	* gdc.test/fail_compilation/fail19911a.d: New test.
+	* gdc.test/fail_compilation/fail19911b.d: New test.
+	* gdc.test/fail_compilation/fail19911c.d: New test.
+	* gdc.test/fail_compilation/fail19922.d: New test.
+	* gdc.test/fail_compilation/fail19923.d: New test.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100964
+	* gdc.test/compilable/betterCarray.d: Add test cases.
+
+2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-09  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100935
+	* gdc.test/compilable/aggr_alignment.d: Add test cases.
+
+2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-06-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/100882
+	* gdc.dg/pr100882a.d: New test.
+	* gdc.dg/pr100882b.d: New test.
+	* gdc.dg/pr100882c.d: New test.
+	* gdc.dg/pr100882d.d: New test.
+
+2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2021-06-04  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99839
+	* gfortran.dg/inline_matmul_25.f90: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/gcc/testsuite/gcc.target/i386/pr101175.c b/gcc/testsuite/gcc.target/i386/pr101175.c
new file mode 100644
index 00000000000..ed7a08110a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr101175.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mlzcnt" } */
+/* { dg-require-effective-target lzcnt } */
+
+#include "lzcnt-check.h"
+
+static int
+foo (unsigned int v)
+{
+  return v ? __builtin_clz (v) : 32;
+}
+
+/* returns -1 if x == 0 */
+int
+__attribute__ ((noinline, noclone))
+bar (unsigned int x)
+{
+  return 31 - foo (x);
+}
+
+static void
+lzcnt_test ()
+{
+  int r = bar (0);
+
+  if (r != -1)
+    abort ();
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882a.d b/gcc/testsuite/gdc.dg/pr100882a.d
new file mode 100644
index 00000000000..d94baff97ac
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882a.d
@@ -0,0 +1,21 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-additional-options "-fmain" }
+// { dg-do run }
+
+__gshared int counter = 0;
+struct S100882
+{
+    this(int) { counter++; }
+    ~this() { counter++; }
+}
+static S100882 s;
+static this()
+{
+    s = cast(shared) S100882(0);
+    assert(counter == 2);
+}
+
+auto test100882()
+{
+    return cast(shared) S100882(0);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882b.d b/gcc/testsuite/gdc.dg/pr100882b.d
new file mode 100644
index 00000000000..de92ab3bef1
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882b.d
@@ -0,0 +1,35 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct AllocatorList(Factory)
+{
+    Factory factory;
+    auto make(size_t n) { return factory(n); }
+    this(Factory plant)
+    {
+        factory = plant;
+    }
+}
+
+struct Region
+{
+    ~this()
+    {
+    }
+}
+
+auto mmapRegionList()
+{
+    struct Factory
+    {
+        this(size_t )
+        {
+        }
+        auto opCall(size_t )
+        {
+            return Region();
+        }
+    }
+    auto shop = Factory();
+    AllocatorList!Factory(shop);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882c.d b/gcc/testsuite/gdc.dg/pr100882c.d
new file mode 100644
index 00000000000..deaa4b44a16
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882c.d
@@ -0,0 +1,19 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+auto iota(int, int)
+{
+    struct Result
+    {
+        this(int)
+        {
+        }
+    }
+    return Result();
+}
+
+auto iota(int end)
+{
+    int begin;
+    return iota(begin, end);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100882d.d b/gcc/testsuite/gdc.dg/pr100882d.d
new file mode 100644
index 00000000000..f4e6e4d3651
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100882d.d
@@ -0,0 +1,25 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100882
+// { dg-do compile }
+
+struct CowArray
+{
+    this(this)
+    {
+    }
+}
+
+struct Tuple
+{
+    CowArray expand;
+}
+
+auto tuple(CowArray)
+{
+    return Tuple();
+}
+
+auto parseCharTerm()
+{
+    CowArray set;
+    return tuple(set);
+}
diff --git a/gcc/testsuite/gdc.dg/pr100967.d b/gcc/testsuite/gdc.dg/pr100967.d
new file mode 100644
index 00000000000..582ad582676
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr100967.d
@@ -0,0 +1,11 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100967
+// { dg-do compile }
+
+module object; // { dg-error "class object.TypeInfo missing or corrupt object.d" }
+
+extern(C) int main()
+{
+    int[int] aa;
+    aa[0] = 1;  // { dg-error ".object.TypeInfo. could not be found, but is implicitly used" }
+    return 0;
+}
diff --git a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
index 3a80a039e26..5b3542828dd 100644
--- a/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
+++ b/gcc/testsuite/gdc.test/compilable/aggr_alignment.d
@@ -26,3 +26,24 @@ enum payloadOffset = C2.bytes.offsetof;
 static assert(C2.int1.offsetof == payloadOffset + 8);
 static assert(C2.alignof == size_t.sizeof);
 static assert(__traits(classInstanceSize, C2) == payloadOffset + 12);
+
+align(8) struct PaddedStruct
+{
+    bool flag;
+    align(2) S1 s1;
+}
+
+static assert(PaddedStruct.s1.offsetof == 2);
+static assert(PaddedStruct.alignof == 8);
+static assert(PaddedStruct.sizeof == 16);
+
+align(1) struct UglyStruct
+{
+    bool flag;
+    int i;
+    ubyte u;
+}
+
+static assert(UglyStruct.i.offsetof == 4);
+static assert(UglyStruct.alignof == 1);
+static assert(UglyStruct.sizeof == 9);
diff --git a/gcc/testsuite/gdc.test/compilable/betterCarray.d b/gcc/testsuite/gdc.test/compilable/betterCarray.d
index 74c80be3b95..3f48b042bde 100644
--- a/gcc/testsuite/gdc.test/compilable/betterCarray.d
+++ b/gcc/testsuite/gdc.test/compilable/betterCarray.d
@@ -15,3 +15,13 @@ int foo(int[] a, int i)
 {
     return a[i];
 }
+
+/**********************************************/
+// https://issues.dlang.org/show_bug.cgi?id=19234
+void issue19234()
+{
+    static struct A {}
+    A[10] a;
+    A[10] b;
+    b[] = a[];
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
new file mode 100644
index 00000000000..c7060b0d96c
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/extra-files/minimal/object.d
@@ -0,0 +1 @@
+module object;
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
new file mode 100644
index 00000000000..672db305223
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911a.d
@@ -0,0 +1,11 @@
+/*
+REQUIRED_ARGS: -betterC
+TEST_OUTPUT:
+---
+fail_compilation/fail19911a.d(9): Error: function `fail19911a.fun` D-style variadic functions cannot be used with -betterC
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
new file mode 100644
index 00000000000..b4ad22b0896
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911b.d
@@ -0,0 +1,13 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+EXTRA_SOURCES: extra-files/minimal/object.d
+TEST_OUTPUT:
+---
+fail_compilation/fail19911b.d(10): Error: function `fail19911b.fun` `object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
new file mode 100644
index 00000000000..d1e954ed394
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19911c.d
@@ -0,0 +1,17 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19911c.d(15): Error: function `object.fun` `object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions
+---
+*/
+
+module object;
+
+class Object { }
+class TypeInfo_Tuple { }
+
+void fun(...)
+{
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19922.d b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
new file mode 100644
index 00000000000..5c9e2bbe0ab
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19922.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19922.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = typeid(o);
+}
+
diff --git a/gcc/testsuite/gdc.test/fail_compilation/fail19923.d b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
new file mode 100644
index 00000000000..042cf8af11a
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/fail19923.d
@@ -0,0 +1,19 @@
+/* 
+DFLAGS:
+REQUIRED_ARGS:
+TEST_OUTPUT:
+---
+fail_compilation/fail19923.d(17): Error: `object.TypeInfo_Class` could not be found, but is implicitly used
+---
+*/
+
+module object;
+
+class Object {}
+
+void test()
+{
+    Object o;
+    auto ti = o.classinfo;
+}
+
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_25.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
new file mode 100644
index 00000000000..df8ad06c123
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_25.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/99839 - ICE in inline_matmul_assign
+
+program p
+  real :: x(3, 3) = 1.0
+  class(*), allocatable :: z(:, :)
+  z = matmul(x, x)
+end
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index 22d7711bb98..156378b7f0b 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,11 @@
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* testsuite/libitm.c++/libstdc++-pr91488.C: New test.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libitm/testsuite/libitm.c++/libstdc++-pr91488.C b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
new file mode 100644
index 00000000000..e9e82bd1ce2
--- /dev/null
+++ b/libitm/testsuite/libitm.c++/libstdc++-pr91488.C
@@ -0,0 +1,9 @@
+// PR libstdc++/91488 "inlining failed in call to always_inline"
+// { dg-do run }
+// { dg-additional-options "-O1" }
+
+#include <string>
+
+int main() {
+    return std::char_traits<char>::length("");
+}
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 4a898cd27d7..953926f507d 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,70 @@
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95833
+	* include/std/numeric (reduce(Iter, Iter, T, BinaryOp)): Replace
+	incorrect static_assert with ones matching the 'Mandates'
+	conditions in the standard.
+	* testsuite/26_numerics/reduce/95833.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100630
+	* include/bits/fs_path.h (__is_constructible_from): Test
+	construction from a const lvalue, not an rvalue.
+	* include/experimental/bits/fs_path.h (__is_constructible_from):
+	Likewise.
+	* testsuite/27_io/filesystem/path/construct/100630.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/100630.cc:
+	New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100384
+	* include/std/variant (__get_t): New alias template yielding the
+	return type of std::get<N> on a variant.
+	(__visit_result_t): New alias template yielding the result of
+	std::visit.
+	(__do_visit): Use __get_t.
+	(visit): Use __visit_result_t for return type.
+	* testsuite/20_util/variant/100384.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-04-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99006
+	* include/bits/shared_ptr.h (allocate_shared): Assert that _Tp
+	is not an array type.
+	* include/bits/shared_ptr_base.h (__allocate_shared): Likewise.
+	* testsuite/20_util/shared_ptr/creation/99006.cc: New test.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91488
+	* include/bits/char_traits.h (__constant_string_p)
+	(__constant_array_p): Give external linkage.
+
+2021-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/printers.py (find_type): Use tag attribute
+	instead of unqualified() method.
+
 2021-06-01  Release Manager
 
 	* GCC 9.4.0 released.
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index 50bd25eb2df..4c7b84e357f 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -227,7 +227,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_string_p(const _CharT* __s)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
@@ -250,7 +250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  Assumes that _CharT is a built-in character type.
    */
   template<typename _CharT>
-    static _GLIBCXX_ALWAYS_INLINE constexpr bool
+    _GLIBCXX_ALWAYS_INLINE constexpr bool
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
 #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 13eb18c0652..8b801c6787c 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void>
diff --git a/libstdc++-v3/include/bits/shared_ptr.h b/libstdc++-v3/include/bits/shared_ptr.h
index 281600b2901..4ddc52ae723 100644
--- a/libstdc++-v3/include/bits/shared_ptr.h
+++ b/libstdc++-v3/include/bits/shared_ptr.h
@@ -698,6 +698,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline shared_ptr<_Tp>
     allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 			     std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index 0367c2d51a5..8af6e9fb11c 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1822,6 +1822,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline __shared_ptr<_Tp, _Lp>
     __allocate_shared(const _Alloc& __a, _Args&&... __args)
     {
+      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");
+
       return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
 				    std::forward<_Args>(__args)...);
     }
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 33a415645d9..ba12b2f1734 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -125,7 +125,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     template<typename _Source>
       struct __constructible_from<_Source, void>
-      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      : decltype(__is_path_src(std::declval<const _Source&>(), 0))
       { };
 
     template<typename _Tp1, typename _Tp2 = void,
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index 7f80d06cfbc..25fdfaf735f 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -261,9 +261,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
 	   _BinaryOperation __binary_op)
     {
-      using value_type = typename iterator_traits<_InputIterator>::value_type;
+      using __ref = typename iterator_traits<_InputIterator>::reference;
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, __ref>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, _Tp&>);
       static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, _Tp&, _Tp&>);
-      static_assert(is_convertible_v<value_type, _Tp>);
+      static_assert(is_invocable_r_v<_Tp, _BinaryOperation&, __ref, __ref>);
       if constexpr (__is_random_access_iter<_InputIterator>::value)
 	{
 	  while ((__last - __first) >= 4)
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index 321228753cd..99a35cc5915 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -1039,6 +1039,14 @@ namespace __variant
 			      std::index_sequence<__indices...>>
     : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };
 
+  template<size_t _Np, typename _Variant>
+    using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));
+
+  // Return type of std::visit.
+  template<typename _Visitor, typename... _Variants>
+    using __visit_result_t
+      = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;
+
 } // namespace __variant
 } // namespace __detail
 
@@ -1191,7 +1199,8 @@ namespace __variant
 #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
+    visit(_Visitor&&, _Variants&&...);
 
   template<typename... _Types>
     inline enable_if_t<(is_move_constructible_v<_Types> && ...)
@@ -1638,7 +1647,7 @@ namespace __variant
     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       using _Deduced_type = std::invoke_result<_Visitor,
-	decltype(std::get<0>(std::declval<_Variants>()))...>;
+	__detail::__variant::__get_t<0, _Variants>...>;
 
       using _Result_type = typename std::conditional_t<__use_index,
 	__detail::__variant::__variant_idx_cookie,
@@ -1654,14 +1663,14 @@ namespace __variant
     }
 
   template<typename _Visitor, typename... _Variants>
-    constexpr decltype(auto)
+    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
     visit(_Visitor&& __visitor, _Variants&&... __variants)
     {
       if ((__variants.valueless_by_exception() || ...))
 	__throw_bad_variant_access("Unexpected index");
 
-      return __do_visit(std::forward<_Visitor>(__visitor),
-			std::forward<_Variants>(__variants)...);
+      return std::__do_visit(std::forward<_Visitor>(__visitor),
+			     std::forward<_Variants>(__variants)...);
     }
 
 #if __cplusplus > 201703L
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 32b8210414a..0c94a038437 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -85,8 +85,8 @@ except ImportError:
 def find_type(orig, name):
     typ = orig.strip_typedefs()
     while True:
-        # Strip cv-qualifiers.  PR 67440.
-        search = '%s::%s' % (typ.unqualified(), name)
+        # Use Type.tag to ignore cv-qualifiers.  PR 67440.
+        search = '%s::%s' % (typ.tag, name)
         try:
             return gdb.lookup_type(search)
         except RuntimeError:
diff --git a/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
new file mode 100644
index 00000000000..d5f7a5da5e9
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/shared_ptr/creation/99006.cc
@@ -0,0 +1,9 @@
+// FIXME: This should use { target { ! c++20 } }
+// { dg-do compile }
+
+#include <memory>
+
+auto p = std::make_shared<int[]>(2); // { dg-error "here" }
+auto q = std::make_shared<int[2]>(1, 2); // { dg-error "here" }
+
+// { dg-prune-output "static assertion failed" }
diff --git a/libstdc++-v3/testsuite/20_util/variant/100384.cc b/libstdc++-v3/testsuite/20_util/variant/100384.cc
new file mode 100644
index 00000000000..4866aa017ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/100384.cc
@@ -0,0 +1,9 @@
+// { dg-do compile { target c++17 } }
+
+#include <variant>
+
+int visit(int*, std::true_type) { return 0; }
+
+const std::true_type dat;
+
+int i = visit(nullptr, dat);
diff --git a/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
new file mode 100644
index 00000000000..cf4644f53c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/reduce/95833.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+// PR libstdc++/95833 - Incorrect static_assert in std::reduce overload
+
+#include <numeric>
+
+struct A { };
+struct B { };
+
+struct binop
+{
+  template<typename T, typename U>
+    A operator()(T&&, U&&) const { return A{}; }
+};
+
+B b;
+A a = std::reduce(&b, &b + 1, A{}, binop{});
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..eb8473e600e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <filesystem>
+
+void f(bool) { }
+void f(const std::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
new file mode 100644
index 00000000000..b2428ff74cf
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/100630.cc
@@ -0,0 +1,14 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+
+void f(bool) { }
+void f(const std::experimental::filesystem::path&) { }
+
+void
+test_100630()
+{
+  volatile bool b = true;
+  f(b);
+}
